index,project,target,func,for_c,goto_c,if_c,jump_c,switch_c,while_c,ReGVD_1,ReGVD_42,ReGVD_103,CodeBERT_42,CodeBERT_103,CodeBERT_800,RoBERTa_42,RoBERTa_692,RoBERTa_834
3,FFmpeg,0,"int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,

                      AVCodecContext *codec, int size, int big_endian)

{

    int id;

    uint64_t bitrate;



    if (size < 14) {

        avpriv_request_sample(codec, ""wav header size < 14"");

        return AVERROR_INVALIDDATA;

    }



    codec->codec_type  = AVMEDIA_TYPE_AUDIO;

    if (!big_endian) {

        id                 = avio_rl16(pb);

        if (id != 0x0165) {

            codec->channels    = avio_rl16(pb);

            codec->sample_rate = avio_rl32(pb);

            bitrate            = avio_rl32(pb) * 8LL;

            codec->block_align = avio_rl16(pb);

        }

    } else {

        id                 = avio_rb16(pb);

        codec->channels    = avio_rb16(pb);

        codec->sample_rate = avio_rb32(pb);

        bitrate            = avio_rb32(pb) * 8LL;

        codec->block_align = avio_rb16(pb);

    }

    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */

        codec->bits_per_coded_sample ",0,0,4,0,0,0,1,1,1,1,1,0,1,1,1
12,qemu,1,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *s = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int ring_order;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {


            goto out;

        }


        str = g_strdup_printf(""event-channel-%u"", i);

        if (",1,1,3,0,0,0,0,0,0,1,0,0,0,1,0
35,FFmpeg,1,"static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub,

                                int pred_order)

{

    int p, porder, psize;

    int i, part_end;

    int count = 0;



    /* subframe header */

    count += 8;



    /* subframe */

    if (sub->type == FLAC_SUBFRAME_CONSTANT) {

        count += sub->obits;

    } else if (sub->type == FLAC_SUBFRAME_VERBATIM) {

        count += s->frame.blocksize * sub->obits;

    } else {

        /* warm-up samples */

        count += pred_order * sub->obits;



        /* LPC coefficients */

        if (sub->type == FLAC_SUBFRAME_LPC)

            count += 4 + 5 + pred_order * s->options.lpc_coeff_precision;



        /* rice-encoded block */

        count += 2;



        /* partition order */

        porder = sub->rc.porder;

        psize  = s->frame.blocksize >> porder;

        count += 4;



        /* residual */

        i        = pred_order;

        part_end = psize;

        for (p = 0; p < 1 << porder; p++) {

            ",1,0,3,0,0,0,0,0,0,1,0,1,0,0,0
43,qemu,0,"static void ppc_spapr_init(QEMUMachineInitArgs *args)

{

    ram_addr_t ram_size = args->ram_size;

    const char *cpu_model = args->cpu_model;

    const char *kernel_filename = args->kernel_filename;

    const char *kernel_cmdline = args->kernel_cmdline;

    const char *initrd_filename = args->initrd_filename;

    const char *boot_device = args->boot_order;

    PowerPCCPU *cpu;

    CPUPPCState *env;

    PCIHostState *phb;

    int i;

    MemoryRegion *sysmem = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    hwaddr rma_alloc_size;

    uint32_t initrd_base = 0;

    long kernel_size = 0, initrd_size = 0;

    long load_limit, rtas_limit, fw_size;

    bool kernel_le = false;

    char *filename;



    msi_supported = true;



    spapr = g_malloc0(sizeof(*spapr));

    QLIST_INIT(&spapr->phbs);



    cpu_ppc_hypercall = emulate_spapr_hypercall;



    /* Allocate RMA if necessary */

    rma_alloc_size = kvmppc_alloc_rma(""ppc_spapr.rma"", sysmem);



    if (rma_alloc_siz",0,0,1,0,0,0,0,0,0,1,0,1,0,0,0
60,FFmpeg,0,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    float aspect;



    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    s->aspect_ratio_info= get_bits(&s->gb, 4);

    if(!s->mpeg2){

        aspect= mpeg1_aspect[s->aspect_ratio_info];

        if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height);

    }



    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_f",0,0,6,0,0,0,0,0,0,1,0,0,0,0,0
70,qemu,0,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)

{

    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;

    if (drc->awaiting_release) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_allocation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS_OUT_SUCCESS;

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,0,0
83,qemu,1,"static void scsi_read_request(SCSIDiskReq *r)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    if (r->sector_count == (uint32_t)-1) {

        DPRINTF(""Read buf_len=%zd\n"", r->iov.iov_len);

        r->sector_count = 0;

        scsi_req_data(&r->req, r->iov.iov_len);

        return;

    }

    DPRINTF(""Read sector_count=%d\n"", r->sector_count);

    if (r->sector_count == 0) {

        scsi_command_complete(r, GOOD, NO_SENSE);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    n = r->sector_count;

    if (n > SCSI_DMA_BUF_SIZE / 512)

        n = SCSI_DMA_BUF_SIZE / 512;



    r->iov.iov_len = n * 512;

    qemu_iovec_init_external(&r->qiov, &r->iov, 1);

    r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,

                              scsi_read_complete, r);

    if (r->req.aiocb == NULL) {

        scsi_read_complete(r, -EIO);

    }

}
",0,0,4,0,0,0,0,1,0,1,1,0,1,1,1
84,qemu,1,"static void lm32_evr_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    LM32CPU *cpu;

    CPULM32State *env;

    DriveInfo *dinfo;

    MemoryRegion *address_space_mem =  get_system_memory();

    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);

    qemu_irq irq[32];

    ResetInfo *reset_info;

    int i;



    /* memory map */

    hwaddr flash_base  = 0x04000000;

    size_t flash_sector_size       = 256 * 1024;

    size_t flash_size              = 32 * 1024 * 1024;

    hwaddr ram_base    = 0x08000000;

    size_t ram_size                = 64 * 1024 * 1024;

    hwaddr timer0_base = 0x80002000;

    hwaddr uart0_base  = 0x80006000;

    hwaddr timer1_base = 0x8000a000;

    int uart0_irq                  = 0;

    int timer0_irq                 = 1;

    int timer1_irq                 = 3;



    reset_info = g_malloc0(sizeof(ResetInfo));



    if (cpu_model == NULL) {

        cpu_model = ""lm32-full"";

  ",0,0,1,0,0,0,0,0,1,0,0,0,1,1,1
108,qemu,0,"aio_write_f(int argc, char **argv)

{

	char *p;

	int count = 0;

	int nr_iov, i, c;

	int pattern = 0xcd;

	struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx));

	BlockDriverAIOCB *acb;



	while ((c = getopt(argc, argv, ""CqP:"")) != EOF) {

		switch (c) {

		case 'C':

			ctx->Cflag = 1;

			break;

		case 'q':

			ctx->qflag = 1;

			break;

		case 'P':

			pattern = atoi(optarg);

			break;

		default:

			return command_usage(&aio_write_cmd);

		}

	}



	if (optind > argc - 2)

		return command_usage(&aio_write_cmd);



	ctx->offset = cvtnum(argv[optind]);

	if (ctx->offset < 0) {

		printf(""non-numeric length argument -- %s\n"", argv[optind]);

		return 0;

	}

	optind++;



	if (ctx->offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)ctx->offset);

		return 0;

	}



	if (count & 0x1ff) {

		printf(""count %d is not sector aligned\n"",

			count);

		return 0;

	}



	for (i = optind; i < argc; i++) {

	        size_t len;



		len = cvtnum(argv[optind]);

		if (len < 0",1,0,5,0,1,1,0,0,0,0,0,0,0,1,0
121,FFmpeg,1,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",1,0,0,0,0,0,1,1,0,1,1,1,1,0,0
122,qemu,1,"static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,

        const char *desc_file_path)

{

    int ret;

    char access[11];

    char type[11];

    char fname[512];

    const char *p = desc;

    int64_t sectors = 0;

    int64_t flat_offset;

    char extent_path[PATH_MAX];

    BlockDriverState *extent_file;

    Error *local_err = NULL;



    while (*p) {

        /* parse extent line:

         * RW [size in sectors] FLAT ""file-name.vmdk"" OFFSET

         * or

         * RW [size in sectors] SPARSE ""file-name.vmdk""

         */

        flat_offset = -1;

        ret = sscanf(p, ""%10s %"" SCNd64 "" %10s \""%511[^\n\r\""]\"" %"" SCNd64,

                access, &sectors, type, fname, &flat_offset);

        if (ret < 4 || strcmp(access, ""RW"")) {

            goto next_line;

        } else if (!strcmp(type, ""FLAT"")) {

            if (ret != 5 || flat_offset < 0) {

                return -EINVAL;

            }

        } else if (ret != 4) {

            return -EINVAL;

        }



",0,1,4,0,0,1,0,0,0,1,1,1,0,0,1
149,FFmpeg,1,"static void compute_rematrixing_strategy(AC3EncodeContext *s)

{

    int nb_coefs;

    int blk, bnd, i;

    AC3Block *block, *block0;



    s->num_rematrixing_bands = 4;



    if (s->rematrixing & AC3_REMATRIXING_IS_STATIC)

        return;



    nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]);



    for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) {

        block = &s->blocks[blk];

        block->new_rematrixing_strategy = !blk;

        for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) {

            /* calculate calculate sum of squared coeffs for one band in one block */

            int start = ff_ac3_rematrix_band_tab[bnd];

            int end   = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]);

            CoefSumType sum[4] = {0,};

            for (i = start; i < end; i++) {

                CoefType lt = block->mdct_coef[0][i];

                CoefType rt = block->mdct_coef[1][i];

                CoefType md = lt + rt;

                CoefType sd = lt - rt;

                sum[0] += lt",3,0,1,0,0,0,0,0,0,0,0,0,0,0,0
164,qemu,1,"void OPPROTO op_udiv_T1_T0(void)
{
    uint64_t x0;
    uint32_t x1;
    x0 = T0 | ((uint64_t) (env->y) << 32);
    x1 = T1;
    x0 = x0 / x1;
    if (x0 > 0xffffffff) {
	T0 = 0xffffffff;
	T1 = 1;
    } else {
	T0 = x0;
	T1 = 0;
    FORCE_RET();",0,0,1,0,0,0,1,1,1,1,1,1,0,0,0
176,qemu,0,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
178,qemu,0,"int qemu_cpu_self(void *env)

{

    return 1;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
179,qemu,0,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
",0,0,3,0,0,0,0,0,0,0,1,1,0,0,0
185,FFmpeg,0,"static int rv34_decode_mv(RV34DecContext *r, int block_type)

{

    MpegEncContext *s = &r->s;

    GetBitContext *gb = &s->gb;

    int i, j, k, l;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;

    int next_bt;



    memset(r->dmv, 0, sizeof(r->dmv));

    for(i = 0; i < num_mvs[block_type]; i++){

        r->dmv[i][0] = svq3_get_se_golomb(gb);

        r->dmv[i][1] = svq3_get_se_golomb(gb);

    }

    switch(block_type){

    case RV34_MB_TYPE_INTRA:

    case RV34_MB_TYPE_INTRA16x16:

        ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);

        return 0;

    case RV34_MB_SKIP:

        if(s->pict_type == AV_PICTURE_TYPE_P){

            ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride);

            rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0);

            break;

        }

    case RV34_MB_B_DIRECT:

        //surprisingly, it uses motion scheme from next reference fra",1,0,1,0,1,0,0,0,0,1,0,0,0,0,0
200,qemu,1,"static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target,

                             const char *replaces,

                             int64_t speed, uint32_t granularity,

                             int64_t buf_size,

                             BlockdevOnError on_source_error,

                             BlockdevOnError on_target_error,

                             bool unmap,

                             BlockCompletionFunc *cb,

                             void *opaque, Error **errp,

                             const BlockJobDriver *driver,

                             bool is_none_mode, BlockDriverState *base)

{

    MirrorBlockJob *s;




    if (granularity == 0) {

        granularity = bdrv_get_default_bitmap_granularity(target);

    }



    assert ((granularity & (granularity - 1)) == 0);



    if ((on_source_error == BLOCKDEV_ON_ERROR_STOP ||

         on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) &&

        (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) {

",0,0,2,0,0,0,0,0,0,0,0,1,1,1,0
218,qemu,0,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
244,FFmpeg,1,"static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)
{
    uint8_t symbols[256];
    uint8_t bits[256];
    uint16_t codes[256];
    int num_lens, num_codes, num_codes_sum, prefix;
    int i, j, count;
    prefix        = 0;
    count         = 0;
    num_codes_sum = 0;
    num_lens = get_bits(gb, 5);
    for (i = 0; i < num_lens; i++) {
        num_codes      = get_bits(gb, 9);
        num_codes_sum += num_codes;
        if (num_codes_sum > 256) {
            av_log(ctx->avctx, AV_LOG_ERROR,
                   ""Too many VLCs (%d) to be read.\n"", num_codes_sum);
        for (j = 0; j < num_codes; j++) {
            symbols[count] = get_bits(gb, 8);
            bits[count]    = i + 1;
            codes[count]   = prefix++;
            count++;
        if (prefix > (65535 - 256)/2) {
        prefix <<= 1;
    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,
                              codes, 2, 2, symbols, 1, 1, 0);",2,0,2,0,0,0,0,0,0,1,0,1,0,0,0
245,FFmpeg,1,"static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,

                                  CodedBitstreamUnit *unit)

{

    BitstreamContext bc;

    int err;



    err = bitstream_init(&bc, unit->data, 8 * unit->data_size);

    if (err < 0)

        return err;



    switch (unit->type) {

    case HEVC_NAL_VPS:

        {

            H265RawVPS *vps;



            vps = av_mallocz(sizeof(*vps));

            if (!vps)

                return AVERROR(ENOMEM);

            err = cbs_h265_read_vps(ctx, &bc, vps);

            if (err >= 0)

                err = cbs_h265_replace_vps(ctx, vps);

            if (err < 0) {

                av_free(vps);

                return err;

            }



            unit->content = vps;

        }

        break;

    case HEVC_NAL_SPS:

        {

            H265RawSPS *sps;



            sps = av_mallocz(sizeof(*sps));

            if (!sps)

                return AVERROR(ENOMEM);

            err = cbs_h265_read_sps(ctx, &bc, sps);

            if (",0,0,6,0,1,0,1,1,1,1,1,1,0,0,0
246,qemu,1,"static void qpa_audio_fini (void *opaque)

{

    (void) opaque;

}
",0,0,0,0,0,0,1,1,0,0,0,0,1,1,1
248,qemu,1,"static void usbredir_bulk_packet(void *priv, uint32_t id,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,

            ep, len, id);



    aurb = async_find(dev, id);

    if (!aurb) {

        free(data);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!\n"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->data, data, data_l",0,0,5,0,0,0,1,1,1,0,0,0,1,1,1
262,FFmpeg,1,"static av_cold int hevc_init_context(AVCodecContext *avctx)
{
    HEVCContext *s = avctx->priv_data;
    int i;
    s->avctx = avctx;
    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    if (!s->HEVClc)
        goto fail;
    s->HEVClcList[0] = s->HEVClc;
    s->sList[0] = s;
    s->cabac_state = av_malloc(HEVC_CONTEXTS);
    if (!s->cabac_state)
        goto fail;
    s->output_frame = av_frame_alloc();
    if (!s->output_frame)
        goto fail;
    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
        s->DPB[i].frame = av_frame_alloc();
        if (!s->DPB[i].frame)
            goto fail;
        s->DPB[i].tf.f = s->DPB[i].frame;
    }
    s->max_ra = INT_MAX;
    s->md5_ctx = av_md5_alloc();
    if (!s->md5_ctx)
        goto fail;
    ff_bswapdsp_init(&s->bdsp);
    s->context_initialized = 1;
    s->eos = 0;
    return 0;
fail:
    hevc_decode_free(avctx);
    return AVERROR(ENOMEM);
}",1,5,5,0,0,0,1,1,1,1,0,0,1,1,0
265,FFmpeg,1,"static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int n, i, r, g, b;



    if ((length % 3) != 0 || length > 256 * 3)

        return AVERROR_INVALIDDATA;

    /* read the palette */

    n = length / 3;

    for (i = 0; i < n; i++) {

        r = bytestream2_get_byte(&s->gb);

        g = bytestream2_get_byte(&s->gb);

        b = bytestream2_get_byte(&s->gb);

        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;

    }

    for (; i < 256; i++)

        s->palette[i] = (0xFFU << 24);

    s->state |= PNG_PLTE;

    bytestream2_skip(&s->gb, 4);     /* crc */



    return 0;

}
",2,0,1,0,0,0,1,1,1,1,1,1,1,1,1
272,qemu,1,"static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr,

                                    uint64_t value, unsigned size,

                                    MemTxAttrs attrs)

{

    int ret = 0;

    MSIMessage from = {0}, to = {0};



    from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST;

    from.data = (uint32_t) value;



    ret = vtd_interrupt_remap_msi(opaque, &from, &to);

    if (ret) {

        /* TODO: report error */

        VTD_DPRINTF(GENERAL, ""int remap fail for addr 0x%""PRIx64

                    "" data 0x%""PRIx32, from.address, from.data);

        /* Drop this interrupt */

        return MEMTX_ERROR;

    }



    VTD_DPRINTF(IR, ""delivering MSI 0x%""PRIx64"":0x%""PRIx32

                "" for device sid 0x%04x"",

                to.address, to.data, sid);



    if (dma_memory_write(&address_space_memory, to.address,

                         &to.data, size)) {

        VTD_DPRINTF(GENERAL, ""error: fail to write 0x%""PRIx64

                    "" value 0x%""PRIx32, to.add",2,0,2,0,0,0,0,0,0,0,0,0,1,1,1
280,qemu,1,"void st_flush_trace_buffer(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}
",0,0,1,0,0,0,0,0,0,1,1,1,0,0,0
289,qemu,0,"VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *conf,

                              char **serial)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;

    DriveInfo *dinfo;



    if (!conf->bs) {

        error_report(""virtio-blk-pci: drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(conf->bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!*serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(conf->bs);

        if (*dinfo->serial) {

            *serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_",0,0,4,0,0,0,1,1,1,0,0,0,0,0,0
304,qemu,1,"static size_t header_ext_add(char *buf, uint32_t magic, const void *s,

    size_t len, size_t buflen)

{

    QCowExtension *ext_backing_fmt = (QCowExtension*) buf;

    size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7);



    if (buflen < ext_len) {

        return -ENOSPC;

    }



    *ext_backing_fmt = (QCowExtension) {

        .magic  = cpu_to_be32(magic),

        .len    = cpu_to_be32(len),

    };

    memcpy(buf + sizeof(QCowExtension), s, len);



    return ext_len;

}
",0,0,1,0,0,0,1,1,0,0,1,0,0,0,0
305,FFmpeg,1,"static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;



    if (c->fc->nb_streams < 1)

        return 0;

    if (atom.size <= 40)

        return 0;

    st = c->fc->streams[c->fc->nb_streams-1];



    if ((uint64_t)atom.size > (1<<30))

        return AVERROR_INVALIDDATA;



    av_free(st->codec->extradata);

    st->codec->extradata = av_mallocz(atom.size - 40 + FF_INPUT_BUFFER_PADDING_SIZE);

    if (!st->codec->extradata)

        return AVERROR(ENOMEM);

    st->codec->extradata_size = atom.size - 40;

    avio_skip(pb, 40);

    avio_read(pb, st->codec->extradata, atom.size - 40);

    return 0;

}
",0,0,4,0,0,0,0,0,0,1,0,1,0,0,1
321,qemu,0,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
325,qemu,0,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)

{

    uint32_t rgb = 0;



    if (bpp == 32) {

        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;

        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;

        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;

        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;

    }

    if (bpp == 16) {

        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;

        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;

    }

    return rgb;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,0
338,qemu,1,"int net_init_tap(const Netdev *netdev, const char *name,

                 NetClientState *peer, Error **errp)

{

    const NetdevTapOptions *tap;

    int fd, vnet_hdr = 0, i = 0, queues;

    /* for the no-fd, no-helper case */

    const char *script = NULL; /* suppress wrong ""uninit'd use"" gcc warning */

    const char *downscript = NULL;

    Error *err = NULL;

    const char *vhostfdname;

    char ifname[128];



    assert(netdev->type == NET_CLIENT_DRIVER_TAP);

    tap = &netdev->u.tap;

    queues = tap->has_queues ? tap->queues : 1;

    vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL;



    /* QEMU vlans does not support multiqueue tap, in this case peer is set.

     * For -netdev, peer is always NULL. */

    if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) {

        error_setg(errp, ""Multiqueue tap cannot be used with QEMU vlans"");

        return -1;

    }



    if (tap->has_fd) {

        if (tap->has_ifname || tap->has_script || tap->has_downscript ||

       ",0,0,5,0,0,0,0,0,0,0,0,0,1,1,1
369,qemu,1,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",0,0,1,0,0,0,1,1,1,1,0,1,1,1,1
372,FFmpeg,1,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,
                                              int *got_picture_ptr,
                                              AVPacket *avpkt)
{
    int ret;
    *got_picture_ptr = 0;
    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))
        return -1;
    avctx->pkt = avpkt;
    apply_param_change(avctx, avpkt);
    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)
            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,
                                         avpkt);
        else {
            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,
                                       avpkt);
            picture->pkt_dts             = avpkt->dts;
            picture->sample_aspect_ratio = avctx->",0,0,3,0,0,0,1,1,1,1,1,1,1,1,1
373,qemu,1,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
",0,0,2,0,0,0,0,0,0,0,1,1,0,0,0
391,qemu,1,"void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave)

{

    s->codec = slave;

    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];

    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,0,0
399,qemu,0,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)

{



    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )

         || (    ( extractFloatx80Exp( b ) == 0x7FFF )

              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )

       ) {

        float_raise(float_flag_invalid, status);

        return 0;

    }

    return

           ( a.low == b.low )

        && (    ( a.high == b.high )

             || (    ( a.low == 0 )

                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )

           );



}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,1
402,qemu,0,"void json_lexer_init(JSONLexer *lexer, JSONLexerEmitter func)

{

    lexer->emit = func;

    lexer->state = IN_START;

    lexer->token = qstring_new();

    lexer->x = lexer->y = 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
404,qemu,0,"BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque, int type)

{

    struct qemu_paiocb *acb;



    acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque);

    if (!acb)

        return NULL;

    acb->aio_type = type;

    acb->aio_fildes = fd;

    acb->ev_signo = SIGUSR2;

    acb->async_context_id = get_async_context_id();



    if (qiov) {

        acb->aio_iov = qiov->iov;

        acb->aio_niov = qiov->niov;

    }

    acb->aio_nbytes = nb_sectors * 512;

    acb->aio_offset = sector_num * 512;



    acb->next = posix_aio_state->first_aio;

    posix_aio_state->first_aio = acb;



    trace_paio_submit(acb, opaque, sector_num, nb_sectors, type);

    qemu_paio_submit(acb);

    return &acb->common;

}
",0,0,2,0,0,0,0,0,0,1,1,1,1,1,1
436,FFmpeg,1,"static int crypto_open(URLContext *h, const char *uri, int flags)

{

    const char *nested_url;

    int ret;

    CryptoContext *c = h->priv_data;



    if (!av_strstart(uri, ""crypto+"", &nested_url) &&

        !av_strstart(uri, ""crypto:"", &nested_url)) {

        av_log(h, AV_LOG_ERROR, ""Unsupported url %s\n"", uri);

        ret = AVERROR(EINVAL);

        goto err;

    }



    if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) {

        av_log(h, AV_LOG_ERROR, ""Key or IV not set\n"");

        ret = AVERROR(EINVAL);

        goto err;

    }

    if (flags & AVIO_FLAG_WRITE) {

        av_log(h, AV_LOG_ERROR, ""Only decryption is supported currently\n"");

        ret = AVERROR(ENOSYS);

        goto err;

    }

    if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) {

        av_log(h, AV_LOG_ERROR, ""Unable to open input\n"");

        goto err;

    }

    c->aes = av_mallocz(av_aes_size);

    if (!c->aes) {

        ret = AVERROR(ENOMEM);

        goto err;

    }



    av_aes_init(c->",0,5,5,0,0,0,0,0,0,0,0,0,0,1,0
439,FFmpeg,1,"int ff_alloc_entries(AVCodecContext *avctx, int count)

{

    int i;



    if (avctx->active_thread_type & FF_THREAD_SLICE)  {

        SliceThreadContext *p = avctx->internal->thread_ctx;

        p->thread_count  = avctx->thread_count;

        p->entries       = av_mallocz_array(count, sizeof(int));



        if (!p->entries) {

            return AVERROR(ENOMEM);

        }



        p->entries_count  = count;

        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));

        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));



        for (i = 0; i < p->thread_count; i++) {

            pthread_mutex_init(&p->progress_mutex[i], NULL);

            pthread_cond_init(&p->progress_cond[i], NULL);

        }

    }



    return 0;

}
",1,0,2,0,0,0,0,0,0,0,0,0,1,0,1
444,qemu,1,"static int floppy_probe_device(const char *filename)

{

    int fd, ret;

    int prio = 0;

    struct floppy_struct fdparam;

    struct stat st;



    if (strstart(filename, ""/dev/fd"", NULL) &&

        !strstart(filename, ""/dev/fdset/"", NULL)) {

        prio = 50;

    }



    fd = qemu_open(filename, O_RDONLY | O_NONBLOCK);

    if (fd < 0) {

        goto out;

    }

    ret = fstat(fd, &st);

    if (ret == -1 || !S_ISBLK(st.st_mode)) {

        goto outc;

    }



    /* Attempt to detect via a floppy specific ioctl */

    ret = ioctl(fd, FDGETPRM, &fdparam);

    if (ret >= 0)

        prio = 100;



outc:

    qemu_close(fd);

out:

    return prio;

}
",0,2,4,0,0,0,0,0,0,1,0,0,0,0,0
461,qemu,0,"static void sun4uv_init(ram_addr_t RAM_size,

                        const char *boot_devices,

                        const char *kernel_filename, const char *kernel_cmdline,

                        const char *initrd_filename, const char *cpu_model,

                        const struct hwdef *hwdef)

{

    CPUState *env;

    char *filename;

    m48t59_t *nvram;

    int ret, linux_boot;

    unsigned int i;

    ram_addr_t ram_offset, prom_offset;

    long initrd_size, kernel_size;

    PCIBus *pci_bus, *pci_bus2, *pci_bus3;

    QEMUBH *bh;

    qemu_irq *irq;

    int drive_index;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];

    void *fw_cfg;

    ResetData *reset_info;



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    b",0,0,2,0,0,0,1,1,0,0,1,1,1,1,1
474,qemu,0,"static void fpu_init (CPUMIPSState *env, const mips_def_t *def)

{

    int i;



    for (i = 0; i < MIPS_FPU_MAX; i++)

        env->fpus[i].fcr0 = def->CP1_fcr0;



    memcpy(&env->active_fpu, &env->fpus[0], sizeof(env->active_fpu));

    if (env->user_mode_only) {

        if (env->CP0_Config1 & (1 << CP0C1_FP))

            env->hflags |= MIPS_HFLAG_FPU;

#ifdef TARGET_MIPS64

        if (env->active_fpu.fcr0 & (1 << FCR0_F64))

            env->hflags |= MIPS_HFLAG_F64;

#endif

    }

}
",1,0,5,0,0,0,0,0,0,0,0,0,0,0,0
490,FFmpeg,1,"static int bfi_decode_frame(AVCodecContext *avctx, void *data,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *bfi = avctx->priv_data;

    uint8_t *dst = bfi->dst;

    uint8_t *src, *dst_offset, colour1, colour2;

    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;

    uint32_t *pal;

    int i, j, height = avctx->height;



    if (bfi->frame.data[0])

        avctx->release_buffer(avctx, &bfi->frame);



    bfi->frame.reference = 1;



    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        bfi->frame.pict_type = AV_PICTURE_TYPE_I;

        bfi->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log",0,0,4,0,0,0,1,1,1,0,1,1,0,0,0
491,qemu,1,"DeviceState *qdev_device_add(QemuOpts *opts)

{

    ObjectClass *oc;

    DeviceClass *dc;

    const char *driver, *path, *id;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        qerror_report(QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    oc = object_class_by_name(driver);

    if (!oc) {

        const char *typename = find_typename_by_alias(driver);



        if (typename) {

            driver = typename;

            oc = object_class_by_name(driver);

        }

    }



    if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) {

        qerror_report(ERROR_CLASS_GENERIC_ERROR,

                      ""'%s' is not a valid device model name"", driver);

        return NULL;

    }



    if (object_class_is_abstract(oc)) {

        qerror_report(QERR_INVALID_PARAMETER_VALUE, ""driver"",

                      ""non-abstract device type"");

        return NULL;

    }

",0,0,5,0,0,0,0,1,0,1,1,1,0,0,0
501,qemu,0,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)

{

    thread_pool_submit_aio(func, arg, NULL, NULL);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
510,qemu,0,"static void pl061_register_devices(void)

{

    sysbus_register_dev(""pl061"", sizeof(pl061_state),

                        pl061_init_arm);

    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),

                        pl061_init_luminary);

}
",0,0,0,0,0,0,0,0,0,1,1,1,0,0,0
539,qemu,1,"int cpu_exec(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    cc->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about th",3,0,4,0,0,0,1,1,0,1,1,1,0,0,0
547,qemu,0,"static void copy_irb_to_guest(IRB *dest, const IRB *src, PMCW *pmcw)

{

    int i;

    uint16_t stctl = src->scsw.ctrl & SCSW_CTRL_MASK_STCTL;

    uint16_t actl = src->scsw.ctrl & SCSW_CTRL_MASK_ACTL;



    copy_scsw_to_guest(&dest->scsw, &src->scsw);



    for (i = 0; i < ARRAY_SIZE(dest->esw); i++) {

        dest->esw[i] = cpu_to_be32(src->esw[i]);

    }

    for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) {

        dest->ecw[i] = cpu_to_be32(src->ecw[i]);

    }

    /* extended measurements enabled? */

    if ((src->scsw.flags & SCSW_FLAGS_MASK_ESWF) ||

        !(pmcw->flags & PMCW_FLAGS_MASK_TF) ||

        !(pmcw->chars & PMCW_CHARS_MASK_XMWME)) {

        return;

    }

    /* extended measurements pending? */

    if (!(stctl & SCSW_STCTL_STATUS_PEND)) {

        return;

    }

    if ((stctl & SCSW_STCTL_PRIMARY) ||

        (stctl == SCSW_STCTL_SECONDARY) ||

        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {

        for (i = 0; i < ARRAY_SIZE(dest->emw); i++) {

    ",3,0,3,0,0,0,0,0,0,0,0,0,0,0,0
566,FFmpeg,0,"static int process_input_packet(InputStream *ist, const AVPacket *pkt)

{

    int i;

    int got_output;

    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE)

        ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);



    // while we have more to decode or while the decoder did output something on EOF

    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {

        int ret = 0;

    handle_eof:



        ist->last_dts = ist->next_dts;



        if (avpkt.size && avpkt.size != pkt->size &&

            !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) {

            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,",0,1,4,0,0,1,0,0,0,0,0,0,1,1,1
569,qemu,1,"static target_ulong disas_insn(DisasContext *s, CPUState *cpu)

{

    CPUX86State *env = cpu->env_ptr;

    int b, prefixes;

    int shift;

    TCGMemOp ot, aflag, dflag;

    int modrm, reg, rm, mod, op, opreg, val;

    target_ulong next_eip, tval;

    int rex_w, rex_r;

    target_ulong pc_start = s->base.pc_next;



    s->pc_start = s->pc = pc_start;

    prefixes = 0;

    s->override = -1;

    rex_w = -1;

    rex_r = 0;

#ifdef TARGET_X86_64

    s->rex_x = 0;

    s->rex_b = 0;

    x86_64_hregs = 0;

#endif

    s->rip_offset = 0; /* for relative ip address */

    s->vex_l = 0;

    s->vex_v = 0;

    if (sigsetjmp(s->jmpbuf, 0) != 0) {

        gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);

        return s->pc;

    }



 next_byte:

    b = x86_ldub_code(env, s);

    /* Collect prefixes.  */

    switch (b) {

    case 0xf3:

        prefixes |= PREFIX_REPZ;

        goto next_byte;

    case 0xf2:

        prefixes |= PREFIX_REPNZ;

        goto next_byte;

    case 0xf0:

        ",0,2,4,0,1,0,0,1,0,1,1,1,0,0,0
572,qemu,1,"static int iscsi_open(BlockDriverState *bs, const char *filename, int flags)

{

    IscsiLun *iscsilun = bs->opaque;

    struct iscsi_context *iscsi = NULL;

    struct iscsi_url *iscsi_url = NULL;

    struct IscsiTask task;

    char *initiator_name = NULL;

    int ret;



    if ((BDRV_SECTOR_SIZE % 512) != 0) {

        error_report(""iSCSI: Invalid BDRV_SECTOR_SIZE. ""

                     ""BDRV_SECTOR_SIZE(%lld) is not a multiple ""

                     ""of 512"", BDRV_SECTOR_SIZE);

        return -EINVAL;

    }



    iscsi_url = iscsi_parse_full_url(iscsi, filename);

    if (iscsi_url == NULL) {

        error_report(""Failed to parse URL : %s %s"", filename,

                     iscsi_get_error(iscsi));

        ret = -EINVAL;

        goto failed;

    }



    memset(iscsilun, 0, sizeof(IscsiLun));



    initiator_name = parse_initiator_name(iscsi_url->target);



    iscsi = iscsi_create_context(initiator_name);

    if (iscsi == NULL) {

        error_report(""iSCSI: Failed to create iSCSI con",0,1,3,0,0,0,0,0,0,0,0,0,0,1,0
573,qemu,1,"static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt,

                                           const void *pkt_data,

                                           size_t pkt_len)

{

    struct virtio_net_hdr *vhdr;

    bool isip4, isip6, istcp, isudp;

    uint8_t *data;

    int len;



    if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) {

        return;

    }



    vhdr = vmxnet_rx_pkt_get_vhdr(pkt);

    if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) {

        return;

    }



    vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp);

    if (!(isip4 || isip6) || !(istcp || isudp)) {

        return;

    }



    vmxnet3_dump_virt_hdr(vhdr);



    /* Validate packet len: csum_start + scum_offset + length of csum field */

    if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) {

        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, ""

                  ""cannot calculate checksum"",

                  len, vhdr->csum_start, vhdr->csum_o",0,0,4,0,0,0,0,1,0,0,0,0,0,0,0
574,qemu,1,"CommandInfoList *qmp_query_commands(Error **errp)

{

    CommandInfoList *list = NULL;



    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);



    return list;

}
",1,0,0,0,0,0,1,1,1,1,0,0,1,1,0
585,FFmpeg,1,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *div_blocks,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shi",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
599,qemu,0,"static int write_f(int argc, char **argv)

{

    struct timeval t1, t2;

    int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;

    int c, cnt;

    char *buf;

    int64_t offset;

    int count;

    /* Some compilers get confused and warn if this is not initialized.  */

    int total = 0;

    int pattern = 0xcd;



    while ((c = getopt(argc, argv, ""bCpP:q"")) != EOF) {

        switch (c) {

        case 'b':

            bflag = 1;

            break;

        case 'C':

            Cflag = 1;

            break;

        case 'p':

            pflag = 1;

            break;

        case 'P':

            pattern = parse_pattern(optarg);

            if (pattern < 0) {

                return 0;

            }

            break;

        case 'q':

            qflag = 1;

            break;

        default:

            return command_usage(&write_cmd);

        }

    }



    if (optind != argc - 2) {

        return command_usage(&write_cmd);

    }



    if (bflag && pflag) {

        printf(""-b",0,0,3,0,1,1,1,1,1,1,1,1,1,0,1
657,FFmpeg,1,"static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)

{

    int compno;

    int x, y;

    int *image_line;

    int frame_index;

    const int numcomps  = image->numcomps;

    uint16_t *frame_ptr = (uint16_t *)frame->data[0];



    for (compno = 0; compno < numcomps; ++compno) {

        if (image->comps[compno].w > frame->linesize[0] / numcomps) {

            av_log(avctx, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image\n"");

            return 0;

        }

    }



    for (compno = 0; compno < numcomps; ++compno) {

        for (y = 0; y < avctx->height; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            frame_index = y * (frame->linesize[0] / 2) + compno;

            for (x = 0; x < avctx->width; ++x) {

                image_line[x] = frame_ptr[frame_index] >> 4;

                frame_index += numcomps;

            }

            for (; x < image->comps[compno].w; ++x) {

    ",6,0,1,0,0,0,0,0,0,0,0,0,1,1,1
666,FFmpeg,0,"static void build_feed_streams(void)

{

    FFStream *stream, *feed;

    int i;



    /* gather all streams */

    for(stream = first_stream; stream != NULL; stream = stream->next) {

        feed = stream->feed;

        if (feed) {

            if (!stream->is_feed) {

                /* we handle a stream coming from a feed */

                for(i=0;i<stream->nb_streams;i++)

                    stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]);

            }

        }

    }



    /* gather all streams */

    for(stream = first_stream; stream != NULL; stream = stream->next) {

        feed = stream->feed;

        if (feed) {

            if (stream->is_feed) {

                for(i=0;i<stream->nb_streams;i++)

                    stream->feed_streams[i] = i;

            }

        }

    }



    /* create feed files if needed */

    for(feed = first_feed; feed != NULL; feed = feed->next_feed) {

        int fd;



        if (url_exist(feed->feed_filename)) {

            /*",5,0,5,0,0,0,0,1,1,1,0,0,1,0,0
669,qemu,1,"static void do_interrupt64(CPUX86State *env, int intno, int is_int,

                           int error_code, target_ulong next_eip, int is_hw)

{

    SegmentCache *dt;

    target_ulong ptr;

    int type, dpl, selector, cpl, ist;

    int has_error_code, new_stack;

    uint32_t e1, e2, e3, ss;

    target_ulong old_eip, esp, offset;



    has_error_code = 0;

    if (!is_int && !is_hw) {

        has_error_code = exception_has_error_code(intno);

    }

    if (is_int) {

        old_eip = next_eip;

    } else {

        old_eip = env->eip;

    }



    dt = &env->idt;

    if (intno * 16 + 15 > dt->limit) {

        raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2);

    }

    ptr = dt->base + intno * 16;

    e1 = cpu_ldl_kernel(env, ptr);

    e2 = cpu_ldl_kernel(env, ptr + 4);

    e3 = cpu_ldl_kernel(env, ptr + 8);

    /* check gate type */

    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;

    switch (type) {

    case 14: /* 386 interrupt gate */

    case 15: /* 386 trap gate */

        break",0,0,3,0,1,0,0,0,0,0,0,0,0,0,0
674,FFmpeg,1,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
",2,0,0,0,0,0,1,1,1,0,1,1,1,1,1
677,FFmpeg,0,"static inline void codeblock(DiracContext *s, SubBand *b,

                             GetBitContext *gb, DiracArith *c,

                             int left, int right, int top, int bottom,

                             int blockcnt_one, int is_arith)

{

    int x, y, zero_block;

    int qoffset, qfactor;

    IDWTELEM *buf;



    /* check for any coded coefficients in this codeblock */

    if (!blockcnt_one) {

        if (is_arith)

            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);

        else

            zero_block = get_bits1(gb);



        if (zero_block)

            return;

    }



    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {

        if (is_arith)

            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);

        else

            b->quant += dirac_get_se_golomb(gb);

    }



    b->quant = FFMIN(b->quant, MAX_QUANT);



    qfactor = qscale_tab[b->quant];

    /* TODO: context pointer? */

    if (!s->num_refs)

        qo",0,0,6,0,0,0,0,0,0,1,1,0,1,1,1
683,FFmpeg,1,"static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){

    FFV1Context *f = avctx->priv_data;

    CABACContext * const c= &f->c;

    AVFrame *pict = data;

    const int width= f->width;

    const int height= f->height;

    AVFrame * const p= &f->picture;

    int used_count= 0;



    if(avctx->strict_std_compliance >= 0){

        av_log(avctx, AV_LOG_ERROR, ""this codec is under development, files encoded with it wont be decodeable with future versions!!!\n""

               ""use vstrict=-1 to use it anyway\n"");

        return -1;

    }

        

    ff_init_cabac_encoder(c, buf, buf_size);

    ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64);

    c->lps_state[2] = 1;

    c->lps_state[3] = 0;

    

    *p = *pict;

    p->pict_type= FF_I_TYPE;

    

    if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){

        put_cabac_bypass(c, 1);

        p->key_frame= 1;

        write_header(f);

        clear_sta",0,0,2,0,0,0,0,1,0,0,0,0,0,0,0
686,qemu,1,"void do_POWER_maskg (void)

{

    uint32_t ret;



    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {

        ret = -1;

    } else {

        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^

            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);

        if ((uint32_t)T0 > (uint32_t)T1)

            ret = ~ret;

    }

    T0 = ret;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
707,qemu,1,"static void qed_aio_read_data(void *opaque, int ret,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, acb, ret, offset, len);



    if (ret < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (ret == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (ret != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

             ",0,1,3,0,0,0,1,1,1,1,1,0,0,1,0
710,qemu,1,"int qcow2_update_header(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    QCowHeader *header;

    char *buf;

    size_t buflen = s->cluster_size;

    int ret;

    uint64_t total_size;

    uint32_t refcount_table_clusters;

    size_t header_length;

    Qcow2UnknownHeaderExtension *uext;



    buf = qemu_blockalign(bs, buflen);



    /* Header structure */

    header = (QCowHeader*) buf;



    if (buflen < sizeof(*header)) {

        ret = -ENOSPC;

        goto fail;

    }



    header_length = sizeof(*header) + s->unknown_header_fields_size;

    total_size = bs->total_sectors * BDRV_SECTOR_SIZE;

    refcount_table_clusters = s->refcount_table_size >> (s->cluster_bits - 3);



    *header = (QCowHeader) {

        /* Version 2 fields */

        .magic                  = cpu_to_be32(QCOW_MAGIC),

        .version                = cpu_to_be32(s->qcow_version),

        .backing_file_offset    = 0,

        .backing_file_size      = 0,

        .cluster_bits           = cpu_to_be32",0,1,1,0,0,0,0,0,0,1,1,1,0,0,0
729,qemu,1,"void tcp_start_incoming_migration(const char *host_port, Error **errp)

{

    int s;



    s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp);

    if (s < 0) {

        return;

    }



    qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL,

                         (void *)(intptr_t)s);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
740,qemu,1,"static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset,

                                       sPAPRPHBState *sphb)

{

    ResourceProps rp;

    bool is_bridge = false;

    int pci_status, err;

    char *buf = NULL;

    uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev);

    uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3);

    uint32_t max_msi, max_msix;



    if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) ==

        PCI_HEADER_TYPE_BRIDGE) {

        is_bridge = true;

    }



    /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */

    _FDT(fdt_setprop_cell(fdt, offset, ""vendor-id"",

                          pci_default_read_config(dev, PCI_VENDOR_ID, 2)));

    _FDT(fdt_setprop_cell(fdt, offset, ""device-id"",

                          pci_default_read_config(dev, PCI_DEVICE_ID, 2)));

    _FDT(fdt_setprop_cell(fdt, offset, ""revision-id"",

                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));

    _FDT(fdt_setprop_ce",0,0,1,0,0,0,1,0,1,1,0,1,0,0,0
748,FFmpeg,1,"static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)

{

    MLPHeaderInfo mh;

    int substr, ret;



    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)

        return ret;



    if (mh.group1_bits == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown bits per sample\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group2_bits > mh.group1_bits) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel group 2 cannot have more bits per sample than group 1.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {

        av_log(m->avctx, AV_LOG_ERROR,

               ""Channel groups with differing sample rates are not currently supported.\n"");

        return AVERROR_INVALIDDATA;




    if (mh.group1_samplerate == 0) {

        av_log(m->avctx, AV_LOG_ERROR, ""invalid/unknown sampling rate\n"");

        return AVERROR_INVALIDDATA;


    if (mh.group1_samplerate > MAX_SAMPLERATE) {

    ",0,0,7,0,0,0,0,0,0,0,0,0,0,0,0
767,FFmpeg,1,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",1,0,2,0,0,0,1,1,1,0,1,1,0,0,0
781,qemu,1,"static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num,

                        int nb_sectors, QEMUIOVector *qiov)

{

    SheepdogAIOCB *acb;

    int ret;



    if (bs->growable && sector_num + nb_sectors > bs->total_sectors) {

        ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE);

        if (ret < 0) {

            return ret;

        }

        bs->total_sectors = sector_num + nb_sectors;

    }



    acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors);

    acb->aio_done_func = sd_write_done;

    acb->aiocb_type = AIOCB_WRITE_UDATA;



    ret = sd_co_rw_vector(acb);

    if (ret <= 0) {

        qemu_aio_release(acb);

        return ret;

    }



    qemu_coroutine_yield();



    return acb->ret;

}
",0,0,3,0,0,0,0,1,0,1,1,1,1,0,1
794,qemu,0,"static void sdl_send_mouse_event(int dx, int dy, int x, int y, int state)

{

    static uint32_t bmap[INPUT_BUTTON__MAX] = {

        [INPUT_BUTTON_LEFT]       = SDL_BUTTON(SDL_BUTTON_LEFT),

        [INPUT_BUTTON_MIDDLE]     = SDL_BUTTON(SDL_BUTTON_MIDDLE),

        [INPUT_BUTTON_RIGHT]      = SDL_BUTTON(SDL_BUTTON_RIGHT),

        [INPUT_BUTTON_WHEEL_UP]   = SDL_BUTTON(SDL_BUTTON_WHEELUP),

        [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN),

    };

    static uint32_t prev_state;



    if (prev_state != state) {

        qemu_input_update_buttons(dcl->con, bmap, prev_state, state);

        prev_state = state;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x,

                             real_screen->w);

        qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y,

                             real_screen->h);

    } else {

        if (guest_cursor) {

            x -= guest_x;

            y -= guest_y;

            guest_x += x;

   ",0,0,3,0,0,0,0,0,0,0,0,0,0,1,1
797,qemu,0,"static void device_initfn(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop;



    if (qdev_hotplug) {

        dev->hotplugged = 1;

        qdev_hot_added = true;

    }



    dev->instance_id_alias = -1;

    dev->state = DEV_STATE_CREATED;



    qdev_prop_set_defaults(dev, qdev_get_props(dev));

    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {

        qdev_property_add_legacy(dev, prop, NULL);

        qdev_property_add_static(dev, prop, NULL);

    }



    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);

}
",1,0,1,0,0,0,1,0,0,0,0,0,0,0,0
837,qemu,1,"static void scsi_write_data(SCSIRequest *req)

{

    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);

    uint32_t n;



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    /* The request is used as the AIO opaque value, so add a ref.  */

    scsi_req_ref(&r->req);

    if (r->req.cmd.mode != SCSI_XFER_TO_DEV) {

        DPRINTF(""Data transfer direction invalid\n"");

        scsi_write_complete(r, -EINVAL);

        return;

    }



    if (!r->req.sg && !r->qiov.size) {

        /* Called for the first time.  Ask the driver to send us more data.  */

        r->started = true;

        scsi_write_complete(r, 0);

        return;

    }

    if (s->tray_open) {

        scsi_write_complete(r, -ENOMEDIUM);

        return;

    }



    if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 ||

        r->req.cmd.buf[0] == VERIFY_16) {

        if (r->req.sg) {

            scsi_d",0,0,5,0,0,0,0,0,0,0,0,0,0,0,0
848,qemu,1,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
",0,0,4,0,0,0,0,1,0,1,0,1,1,1,0
855,qemu,1,"void bios_linker_loader_alloc(GArray *linker,

                              const char *file,

                              uint32_t alloc_align,

                              bool alloc_fseg)

{

    BiosLinkerLoaderEntry entry;



    assert(!(alloc_align & (alloc_align - 1)));



    memset(&entry, 0, sizeof entry);

    strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE);

    entry.alloc.align = cpu_to_le32(alloc_align);

    entry.alloc.zone = cpu_to_le32(alloc_fseg ?

                                    BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG :

                                    BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH);



    /* Alloc entries must come first, so prepend them */

    g_array_prepend_vals(linker, &entry, sizeof entry);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
860,qemu,1,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->bl.request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) {

            bs->bl.max_pdiscard =

                iscsilun->bl.max_unmap * iscsilun->block_size;

        }

        bs->bl.pdiscard_alignment =

            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;

    } else {

        bs->bl.pdiscard_alignment = iscsilun->block_siz",1,0,4,0,0,0,0,0,0,0,1,1,0,0,1
883,qemu,0,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",1,0,1,0,0,0,0,1,0,1,1,1,1,0,1
886,qemu,0,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
899,qemu,0,"static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    uint32_t new_vid;

    SheepdogInode *inode;

    unsigned int datalen;



    dprintf(""sn_info: name %s id_str %s s: name %s vm_state_size %"" PRId64 "" ""

            ""is_snapshot %d\n"", sn_info->name, sn_info->id_str,

            s->name, sn_info->vm_state_size, s->is_snapshot);



    if (s->is_snapshot) {

        error_report(""You can't create a snapshot of a snapshot VDI, ""

                     ""%s (%"" PRIu32 "")."", s->name, s->inode.vdi_id);



        return -EINVAL;

    }



    dprintf(""%s %s\n"", sn_info->name, sn_info->id_str);



    s->inode.vm_state_size = sn_info->vm_state_size;

    s->inode.vm_clock_nsec = sn_info->vm_clock_nsec;

    /* It appears that inode.tag does not require a NUL terminator,

     * which means this use of strncpy is ok.

     */

    strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag));

    /* we don't need to update e",0,0,1,0,0,0,0,0,0,0,0,0,0,1,0
906,qemu,0,"static int vnc_display_listen(VncDisplay *vd,

                              SocketAddress **saddr,

                              size_t nsaddr,

                              SocketAddress **wsaddr,

                              size_t nwsaddr,

                              Error **errp)

{

    size_t i;



    for (i = 0; i < nsaddr; i++) {

        if (vnc_display_listen_addr(vd, saddr[i],

                                    ""vnc-listen"",

                                    &vd->lsock,

                                    &vd->lsock_tag,

                                    &vd->nlsock,

                                    errp) < 0) {

            return -1;

        }

    }

    for (i = 0; i < nwsaddr; i++) {

        if (vnc_display_listen_addr(vd, wsaddr[i],

                                    ""vnc-ws-listen"",

                                    &vd->lwebsock,

                                    &vd->lwebsock_tag,

                                    &vd->nlwebsock,

                        ",2,0,2,0,0,0,0,1,0,0,0,0,1,0,0
913,qemu,0,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
921,qemu,1,"MigrationState *exec_start_outgoing_migration(const char *command,

                                             int64_t bandwidth_limit,

                                             int async)

{

    FdMigrationState *s;

    FILE *f;



    s = qemu_mallocz(sizeof(*s));

    if (s == NULL) {

        dprintf(""Unable to allocate FdMigrationState\n"");

        goto err;

    }



    f = popen(command, ""w"");

    if (f == NULL) {

        dprintf(""Unable to popen exec target\n"");

        goto err_after_alloc;

    }



    s->fd = fileno(f);

    if (s->fd == -1) {

        dprintf(""Unable to retrieve file descriptor for popen'd handle\n"");

        goto err_after_open;

    }



    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {

        dprintf(""Unable to set nonblocking mode on file descriptor\n"");

        goto err_after_open;

    }



    s->opaque = qemu_popen(f, ""w"");




    s->get_error = file_errno;

    s->write = file_write;

    s->mig_state.cancel = migrate_fd_cancel;

    s->mig_state.get_s",1,4,4,0,0,0,0,1,0,0,0,0,1,1,0
924,qemu,1,"static void register_core_rtas(void)

{

    spapr_rtas_register(""display-character"", rtas_display_character);

    spapr_rtas_register(""get-time-of-day"", rtas_get_time_of_day);

    spapr_rtas_register(""power-off"", rtas_power_off);




}",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
937,qemu,1,"static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr,

                              target_ulong opcode, target_ulong *args)

{

    target_ulong liobn = args[0];

    target_ulong ioba = args[1];

    target_ulong tce = args[2];

    VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn);

    VIOsPAPR_RTCE *rtce;



    if (!dev) {

        hcall_dprintf(""LIOBN 0x"" TARGET_FMT_lx "" does not exist\n"", liobn);

        return H_PARAMETER;

    }



    ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1);



#ifdef DEBUG_TCE

    fprintf(stderr, ""spapr_vio_put_tce on %s  ioba 0x"" TARGET_FMT_lx

            ""  TCE 0x"" TARGET_FMT_lx ""\n"", dev->qdev.id, ioba, tce);

#endif



    if (ioba >= dev->rtce_window_size) {

        hcall_dprintf(""Out-of-bounds IOBA 0x"" TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT);

    rtce->tce = tce;



    return H_SUCCESS;

}
",0,0,4,0,0,0,0,1,0,1,1,0,0,0,1
941,qemu,1,"static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque,

                                  const char *name, Error **errp)

{

    NvmeCtrl *s = NVME(obj);



    visit_type_int32(v, &s->conf.bootindex, name, errp);

}
",0,0,0,0,0,0,0,0,1,0,1,1,0,0,0
944,FFmpeg,1,"ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb,

                    AVStream *st, RMStream *ast, int len, AVPacket *pkt,

                    int *seq, int flags, int64_t timestamp)

{

    RMDemuxContext *rm = s->priv_data;

    int ret;



    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

        rm->current_stream= st->id;

        ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp);

        if(ret)

            return ret < 0 ? ret : -1; //got partial frame or error

    } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

        if ((ast->deint_id == DEINT_ID_GENR) ||

            (ast->deint_id == DEINT_ID_INT4) ||

            (ast->deint_id == DEINT_ID_SIPR)) {

            int x;

            int sps = ast->sub_packet_size;

            int cfs = ast->coded_framesize;

            int h = ast->sub_packet_h;

            int y = ast->sub_packet_cnt;

            int w = ast->audio_framesize;



            if (flags & 2)

                y = ast->sub_packet",0,0,5,0,0,0,1,1,1,1,1,1,0,0,0
946,qemu,1,"Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
961,qemu,1,"static void vscsi_process_login(VSCSIState *s, vscsi_req *req)

{

    union viosrp_iu *iu = &req->iu;

    struct srp_login_rsp *rsp = &iu->srp.login_rsp;

    uint64_t tag = iu->srp.rsp.tag;



    trace_spapr_vscsi__process_login();



    /* TODO handle case that requested size is wrong and

     * buffer format is wrong

     */

    memset(iu, 0, sizeof(struct srp_login_rsp));

    rsp->opcode = SRP_LOGIN_RSP;

    /* Don't advertise quite as many request as we support to

     * keep room for management stuff etc...

     */

    rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2);

    rsp->tag = tag;

    rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu));

    rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu));

    /* direct and indirect */

    rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT);



    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);

}
",2,0,0,0,0,0,0,0,0,0,0,0,1,1,0
963,qemu,1,"void cpu_tick_set_count(CPUTimer *timer, uint64_t count)

{

    uint64_t real_count = count & ~timer->disabled_mask;

    uint64_t disabled_bit = count & timer->disabled_mask;



    int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) -

                    cpu_to_timer_ticks(real_count, timer->frequency);



    TIMER_DPRINTF(""%s set_count count=0x%016lx (%s) p=%p\n"",

                  timer->name, real_count,

                  timer->disabled?""disabled"":""enabled"", timer);



    timer->disabled = disabled_bit ? 1 : 0;

    timer->clock_offset = vm_clock_offset;

}
",0,0,0,0,0,0,0,1,1,1,1,0,1,1,1
971,qemu,1,"void commit_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, BlockDriverState *top, int64_t speed,

                  BlockdevOnError on_error, const char *backing_file_str,

                  const char *filter_node_name, Error **errp)

{

    CommitBlockJob *s;

    BlockReopenQueue *reopen_queue = NULL;

    int orig_overlay_flags;

    int orig_base_flags;

    BlockDriverState *iter;

    BlockDriverState *overlay_bs;

    BlockDriverState *commit_top_bs = NULL;

    Error *local_err = NULL;

    int ret;



    assert(top != bs);

    if (top == base) {

        error_setg(errp, ""Invalid files for merge: top and base are the same"");

        return;




    overlay_bs = bdrv_find_overlay(bs, top);



    if (overlay_bs == NULL) {

        error_setg(errp, ""Could not find overlay image for %s:"", top->filename);

        return;




    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,

                         speed, BLOCK_JOB_DEFAULT, NULL, N",2,0,2,0,0,0,1,1,0,0,0,0,1,1,1
982,qemu,0,"int bdrv_is_removable(BlockDriverState *bs)

{

    return bs->removable;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
1035,FFmpeg,1,"static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{


    return 0;

}",0,0,0,0,0,0,0,1,1,1,1,1,1,0,1
1038,qemu,1,"void qmp_blockdev_add(BlockdevOptions *options, Error **errp)

{

    QmpOutputVisitor *ov = qmp_output_visitor_new();

    QObject *obj;

    QDict *qdict;

    Error *local_err = NULL;



    /* Require an ID in the top level */

    if (!options->has_id) {

        error_setg(errp, ""Block device needs an ID"");

        goto fail;

    }



    /* TODO Sort it out in raw-posix and drive_init: Reject aio=native with

     * cache.direct=false instead of silently switching to aio=threads, except

     * if called from drive_init.

     *

     * For now, simply forbidding the combination for all drivers will do. */

    if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) {

        bool direct = options->cache->has_direct && options->cache->direct;

        if (!options->has_cache && !direct) {

            error_setg(errp, ""aio=native requires cache.direct=true"");

            goto fail;

        }

    }



    visit_type_BlockdevOptions(qmp_output_get_visitor(ov),

                        ",2,2,4,0,1,0,0,0,0,0,0,0,1,1,0
1040,qemu,1,"void do_divwuo (void)

{

    if (likely((uint32_t)T1 != 0)) {

        xer_ov = 0;

        T0 = (uint32_t)T0 / (uint32_t)T1;

    } else {

        xer_so = 1;

        xer_ov = 1;

        T0 = 0;

    }

}
",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
1046,qemu,1,"static void kvmclock_pre_save(void *opaque)

{

    KVMClockState *s = opaque;

    struct kvm_clock_data data;

    int ret;



    if (s->clock_valid) {

        return;

    }

    ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data);

    if (ret < 0) {

        fprintf(stderr, ""KVM_GET_CLOCK failed: %s\n"", strerror(ret));

        data.clock = 0;

    }

    s->clock = data.clock;

    /*

     * If the VM is stopped, declare the clock state valid to avoid re-reading

     * it on next vmsave (which would return a different value). Will be reset

     * when the VM is continued.

     */

    s->clock_valid = !runstate_is_running();

}
",0,0,3,0,0,0,0,0,0,0,1,0,0,0,0
1056,qemu,1,"static void handle_satn(ESPState *s)

{

    uint8_t buf[32];

    int len;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn;

        return;

    }

    len = get_cmd(s, buf);

    if (len)

        do_cmd(s, buf);

}
",0,0,2,0,0,0,1,1,1,1,1,1,0,0,0
1059,FFmpeg,1,"static int check_checksum(ByteIOContext *bc){

    unsigned long checksum= get_checksum(bc);

//    return checksum != get_be32(bc);



    av_log(NULL, AV_LOG_ERROR, ""%08X %08X\n"", checksum, (int)get_be32(bc));



    return 0;

}
",0,0,0,0,0,0,1,0,0,0,0,0,1,1,1
1060,qemu,0,"int ide_init_drive(IDEState *s, BlockBackend *blk, IDEDriveKind kind,

                   const char *version, const char *serial, const char *model,

                   uint64_t wwn,

                   uint32_t cylinders, uint32_t heads, uint32_t secs,

                   int chs_trans)

{

    uint64_t nb_sectors;



    s->blk = blk;

    s->drive_kind = kind;



    blk_get_geometry(blk, &nb_sectors);

    s->cylinders = cylinders;

    s->heads = heads;

    s->sectors = secs;

    s->chs_trans = chs_trans;

    s->nb_sectors = nb_sectors;

    s->wwn = wwn;

    /* The SMART values should be preserved across power cycles

       but they aren't.  */

    s->smart_enabled = 1;

    s->smart_autosave = 1;

    s->smart_errors = 0;

    s->smart_selftest_count = 0;

    if (kind == IDE_CD) {

        blk_set_dev_ops(blk, &ide_cd_block_ops, s);

        blk_set_guest_block_size(blk, 2048);

    } else {

        if (!blk_is_inserted(s->blk)) {

            error_report(""Device needs media, but drive is emp",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
1089,qemu,1,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
1107,qemu,0,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)

{

    uint32_t val;

    val = gic_dist_readb(opaque, offset);

    val |= gic_dist_readb(opaque, offset + 1) << 8;

    return val;

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
1108,qemu,0,"static void test_qemu_strtoull_overflow(void)

{

    const char *str = ""99999999999999999999999999999999999999999999"";

    char f = 'X';

    const char *endptr = &f;

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, -ERANGE);

    g_assert_cmpint(res, ==, ULLONG_MAX);

    g_assert(endptr == str + strlen(str));

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1119,qemu,0,"PXA2xxState *pxa255_init(unsigned int sdram_size)

{

    PXA2xxState *s;

    int iomemtype, i;

    DriveInfo *dinfo;



    s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState));



    s->env = cpu_init(""pxa255"");

    if (!s->env) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }

    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];



    /* SDRAM & Internal Memory Storage */

    cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size,

                    qemu_ram_alloc(NULL, ""pxa255.sdram"",

                                   sdram_size) | IO_MEM_RAM);

    cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE,

                    qemu_ram_alloc(NULL, ""pxa255.internal"",

                                   PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM);



    s->pic = pxa2xx_pic_init(0x40d00000, s->env);



    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);



    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);



    s->g",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
1121,qemu,0,"int usb_device_delete_addr(int busnr, int addr)

{

    USBBus *bus;

    USBPort *port;

    USBDevice *dev;



    bus = usb_bus_find(busnr);

    if (!bus)

        return -1;



    TAILQ_FOREACH(port, &bus->used, next) {

        if (port->dev->addr == addr)

            break;

    }

    if (!port)

        return -1;



    dev = port->dev;

    TAILQ_REMOVE(&bus->used, port, next);

    bus->nused--;



    usb_attach(port, NULL);

    dev->info->handle_destroy(dev);



    TAILQ_INSERT_TAIL(&bus->free, port, next);

    bus->nfree++;

    return 0;

}
",0,0,3,0,0,0,1,0,0,0,1,1,0,0,1
1122,qemu,0,"static void qmp_output_type_number(Visitor *v, const char *name, double *obj,

                                   Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qmp_output_add(qov, name, qfloat_from_double(*obj));

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
1130,qemu,1,"static int aio_write_f(BlockBackend *blk, int argc, char **argv)

{

    int nr_iov, c;

    int pattern = 0xcd;

    struct aio_ctx *ctx = g_new0(struct aio_ctx, 1);



    ctx->blk = blk;

    while ((c = getopt(argc, argv, ""CqP:z"")) != -1) {

        switch (c) {

        case 'C':

            ctx->Cflag = 1;

            break;

        case 'q':

            ctx->qflag = 1;

            break;

        case 'P':

            pattern = parse_pattern(optarg);

            if (pattern < 0) {


                return 0;

            }

            break;

        case 'z':

            ctx->zflag = 1;

            break;

        default:


            return qemuio_command_usage(&aio_write_cmd);

        }

    }



    if (optind > argc - 2) {


        return qemuio_command_usage(&aio_write_cmd);

    }



    if (ctx->zflag && optind != argc - 2) {

        printf(""-z supports only a single length parameter\n"");


        return 0;

    }



    if (ctx->zflag && ctx->Pflag) {

        printf(""-z and -P",0,0,4,0,1,1,0,1,0,1,1,1,0,1,1
1136,qemu,1,"static int alloc_refcount_block(BlockDriverState *bs,

    int64_t cluster_index, uint16_t **refcount_block)

{

    BDRVQcowState *s = bs->opaque;

    unsigned int refcount_table_index;

    int ret;



    BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC);



    /* Find the refcount block for the given cluster */

    refcount_table_index = cluster_index >> s->refcount_block_bits;



    if (refcount_table_index < s->refcount_table_size) {



        uint64_t refcount_block_offset =

            s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;



        /* If it's already there, we're done */

        if (refcount_block_offset) {

            if (offset_into_cluster(s, refcount_block_offset)) {

                qcow2_signal_corruption(bs, true, -1, -1, ""Refblock offset %#""

                                        PRIx64 "" unaligned (reftable index: ""

                                        ""%#x)"", refcount_block_offset,

                                        refcount_table_index);

            ",0,0,3,0,0,0,1,1,1,1,1,1,0,0,0
1137,FFmpeg,1,"static int alac_decode_frame(AVCodecContext *avctx,

                             void *outbuffer, int *outputsize,

                             const uint8_t *inbuffer, int input_buffer_size)

{

    ALACContext *alac = avctx->priv_data;



    int channels;

    unsigned int outputsamples;

    int hassize;

    int readsamplesize;

    int wasted_bytes;

    int isnotcompressed;

    uint8_t interlacing_shift;

    uint8_t interlacing_leftweight;



    /* short-circuit null buffers */

    if (!inbuffer || !input_buffer_size)

        return input_buffer_size;



    /* initialize from the extradata */

    if (!alac->context_initialized) {

        if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) {

            av_log(avctx, AV_LOG_ERROR, ""alac: expected %d extradata bytes\n"",

                ALAC_EXTRADATA_SIZE);

            return input_buffer_size;

        }

        if (alac_set_info(alac)) {

            av_log(avctx, AV_LOG_ERROR, ""alac: set_info failed\n"");

            return input_buf",0,0,5,0,0,0,1,1,1,1,1,1,0,0,0
1145,FFmpeg,0,"static int getopt(int argc, char *argv[], char *opts)

{

    static int sp = 1;

    int c;

    char *cp;



    if (sp == 1)

        if (optind >= argc ||

            argv[optind][0] != '-' || argv[optind][1] == '\0')

            return EOF;

        else if (!strcmp(argv[optind], ""--"")) {

            optind++;

            return EOF;

        }

    optopt = c = argv[optind][sp];

    if (c == ':' || (cp = strchr(opts, c)) == NULL) {

        fprintf(stderr, "": illegal option -- %c\n"", c);

        if (argv[optind][++sp] == '\0') {

            optind++;

            sp = 1;

        }

        return '?';

    }

    if (*++cp == ':') {

        if (argv[optind][sp+1] != '\0')

            optarg = &argv[optind++][sp+1];

        else if(++optind >= argc) {

            fprintf(stderr, "": option requires an argument -- %c\n"", c);

            sp = 1;

            return '?';

        } else

            optarg = argv[optind++];

        sp = 1;

    } else {

        if (argv[optind][++sp] == '\0') ",0,0,9,0,0,0,1,0,0,0,1,0,1,1,1
1167,qemu,0,"static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr,

                                    uint32_t val)

{

    SLAVIO_TIMERState *s = opaque;

    uint32_t saddr;

    int reload = 0;



    DPRINTF(""write "" TARGET_FMT_plx "" %08x\n"", addr, val);

    saddr = (addr & TIMER_MAXADDR) >> 2;

    switch (saddr) {

    case TIMER_LIMIT:

        if (slavio_timer_is_user(s)) {

            // set user counter MSW, reset counter

            qemu_irq_lower(s->irq);

            s->limit = TIMER_MAX_COUNT64;

            DPRINTF(""processor %d user timer reset\n"", s->slave_index);

            ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1);

        } else {

            // set limit, reset counter

            qemu_irq_lower(s->irq);

            s->limit = val & TIMER_MAX_COUNT32;

            if (!s->limit)

                s->limit = TIMER_MAX_COUNT32;

            ptimer_set_limit(s->timer, s->limit >> 9, 1);

        }

        break;

    case TIMER_COUNTER:

        if (slavio_",0,0,3,0,1,0,0,0,0,0,0,0,1,1,1
1194,qemu,0,"void qemu_cpu_kick(void *env)

{

    return;

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
1215,qemu,0,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
1227,qemu,0,"void qmp_block_stream(const char *device, bool has_base,

                      const char *base, Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    Error *local_err = NULL;



    bs = bdrv_find(device);

    if (!bs) {

        error_set(errp, QERR_DEVICE_NOT_FOUND, device);

        return;

    }



    if (base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_set(errp, QERR_BASE_NOT_FOUND, base);

            return;

        }

    }



    stream_start(bs, base_bs, base, block_stream_cb, bs, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(errp, local_err);

        return;

    }



    /* Grab a reference so hotplug does not delete the BlockDriverState from

     * underneath us.

     */

    drive_get_ref(drive_get_by_blockdev(bs));



    trace_qmp_block_stream(bs, bs->job);

}
",0,0,4,0,0,0,1,1,1,1,1,1,0,1,0
1277,qemu,1,"static void mptsas_scsi_init(PCIDevice *dev, Error **errp)

{

    DeviceState *d = DEVICE(dev);

    MPTSASState *s = MPT_SAS(dev);



    dev->config[PCI_LATENCY_TIMER] = 0;

    dev->config[PCI_INTERRUPT_PIN] = 0x01;



    memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s,

                          ""mptsas-mmio"", 0x4000);

    memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s,

                          ""mptsas-io"", 256);

    memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s,

                          ""mptsas-diag"", 0x10000);



    if (s->msi != ON_OFF_AUTO_OFF &&

        msi_init(dev, 0, 1, true, false) >= 0) {

        /* TODO check for errors */

        s->msi_in_use = true;

    }



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io);

    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY |

                                 PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io);

    pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY",0,0,1,0,0,0,0,1,0,0,1,0,1,1,1
1290,qemu,0,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
",0,0,0,0,0,0,0,1,1,1,0,1,1,1,0
1307,FFmpeg,1,"FFTContext *av_fft_init(int nbits, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}
",0,0,1,0,0,0,1,0,0,0,1,0,1,0,1
1308,qemu,1,"static void gen_set_CF_bit31(TCGv var)

{

    TCGv tmp = new_tmp();

    tcg_gen_shri_i32(tmp, var, 31);

    gen_set_CF(tmp);

    dead_tmp(tmp);

}
",0,0,0,0,0,0,0,0,0,0,1,1,0,1,0
1318,FFmpeg,1,"static int get_siz(Jpeg2000DecoderContext *s)
{
    int i;
    int ncomponents;
    uint32_t log2_chroma_wh = 0;
    const enum AVPixelFormat *possible_fmts = NULL;
    int possible_fmts_nb = 0;
    if (bytestream2_get_bytes_left(&s->g) < 36) {
        av_log(s->avctx, AV_LOG_ERROR, ""Insufficient space for SIZ\n"");
    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz
    s->width          = bytestream2_get_be32u(&s->g); // Width
    s->height         = bytestream2_get_be32u(&s->g); // Height
    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz
    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz
    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz
    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz
    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz
    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz
    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz
    if (s->image_offset_x || s->image_offset_y) {
        avpriv_request_sam",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
1335,qemu,1,"static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp)

{

    CommitBlockJob *s = container_of(job, CommitBlockJob, common);



    if (speed < 0) {

        error_setg(errp, QERR_INVALID_PARAMETER, ""speed"");

        return;

    }

    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);

}
",0,0,1,0,0,0,1,0,1,1,1,1,1,0,0
1338,FFmpeg,1,"static void sd_1d97_int(int *p, int i0, int i1)

{

    int i;



    if (i1 <= i0 + 1) {

        if (i0 == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, i0, i1);

    i0++; i1++;



    for (i = i0/2 - 2; i < i1/2 + 1; i++)

        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2 + 1; i++)

        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2; i++)

        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2; i < i1/2; i++)

        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

}
",4,0,2,0,0,0,0,0,0,0,0,0,1,1,1
1341,FFmpeg,1,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",1,0,0,0,0,0,0,0,0,0,1,0,1,1,0
1351,qemu,0,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",0,0,2,0,0,1,0,0,0,1,0,0,1,1,0
1360,qemu,0,"static void virtio_9p_device_unrealize(DeviceState *dev, Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    V9fsVirtioState *v = VIRTIO_9P(dev);

    V9fsState *s = &v->state;



    virtio_cleanup(vdev);

    v9fs_device_unrealize_common(s, errp);

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,1,1
1373,FFmpeg,1,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",0,0,3,0,0,0,1,1,0,0,0,1,1,1,1
1377,FFmpeg,1,"static int opus_decode_frame(OpusStreamContext *s, const uint8_t *data, int size)

{

    int samples    = s->packet.frame_duration;

    int redundancy = 0;

    int redundancy_size, redundancy_pos;

    int ret, i, consumed;

    int delayed_samples = s->delayed_samples;



    ret = opus_rc_init(&s->rc, data, size);

    if (ret < 0)

        return ret;



    /* decode the silk frame */

    if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) {

        if (!swr_is_initialized(s->swr)) {

            ret = opus_init_resample(s);

            if (ret < 0)

                return ret;

        }



        samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output,

                                            FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND),

                                            s->packet.stereo + 1,

                                            silk_frame_duration_ms[s->packet.config]);

        if (samples < 0) {

            av_log(s->avctx, AV_",0,0,5,0,0,0,1,1,0,1,0,0,0,1,1
1381,qemu,1,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",0,0,1,0,0,0,1,1,1,1,1,1,1,0,0
1404,FFmpeg,1,"static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode)

{

    int   band, result=0, numSubbands, lastTonal, numBands;



    if (codingMode == JOINT_STEREO && channelNum == 1) {

        if (get_bits(gb,2) != 3) {

            av_log(NULL,AV_LOG_ERROR,""JS mono Sound Unit id != 3.\n"");

            return -1;

        }

    } else {

        if (get_bits(gb,6) != 0x28) {

            av_log(NULL,AV_LOG_ERROR,""Sound Unit id != 0x28.\n"");

            return -1;

        }

    }



    /* number of coded QMF bands */

    pSnd->bandsCoded = get_bits(gb,2);



    result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded);

    if (result) return result;



    pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded);

    if (pSnd->numComponents == -1) return -1;



    numSubbands = decodeSpectrum (gb, pSnd->spectrum);



    /* Merge the decoded spectrum and tonal compo",0,0,5,0,0,0,1,1,1,1,1,1,0,0,0
1420,qemu,1,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
",0,0,1,0,0,0,1,1,1,0,0,1,1,1,0
1426,FFmpeg,0,"static void vp8_idct_dc_add4uv_c(uint8_t *dst, int16_t block[4][16], ptrdiff_t stride)

{

    vp8_idct_dc_add_c(dst+stride*0+0, block[0], stride);

    vp8_idct_dc_add_c(dst+stride*0+4, block[1], stride);

    vp8_idct_dc_add_c(dst+stride*4+0, block[2], stride);

    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
1434,qemu,1,"static void integratorcp_init(QEMUMachineInitArgs *args)

{

    ram_addr_t ram_size = args->ram_size;

    const char *cpu_model = args->cpu_model;

    const char *kernel_filename = args->kernel_filename;

    const char *kernel_cmdline = args->kernel_cmdline;

    const char *initrd_filename = args->initrd_filename;

    ARMCPU *cpu;

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    MemoryRegion *ram_alias = g_new(MemoryRegion, 1);

    qemu_irq pic[32];

    DeviceState *dev;

    int i;



    if (!cpu_model) {

        cpu_model = ""arm926"";

    }

    cpu = cpu_arm_init(cpu_model);

    if (!cpu) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }



    memory_region_init_ram(ram, NULL, ""integrator.ram"", ram_size);

    vmstate_register_ram_global(ram);

    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */

    /* ??? RAM should repeat to fill physical memory space.  */

    /",0,0,2,0,0,0,0,1,1,1,1,1,0,0,0
1435,qemu,1,"static void set_vlan(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);

    NetClientState **ptr = &peers_ptr->ncs[0];

    Error *local_err = NULL;

    int32_t id;

    NetClientState *hubport;



    if (dev->realized) {

        qdev_prop_set_after_realize(dev, name, errp);





    visit_type_int32(v, &id, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);



    if (id == -1) {

        *ptr = NULL;









    hubport = net_hub_port_find(id);

    if (!hubport) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE,

                  name, prop->info->name);



    *ptr = hubport;
",0,0,4,0,0,0,0,0,0,0,1,1,0,0,0
1439,FFmpeg,1,"static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
1457,qemu,1,"static void fd_chr_update_read_handler(CharDriverState *chr)

{

    FDCharDriver *s = chr->opaque;



    if (s->fd_in_tag) {

        g_source_remove(s->fd_in_tag);

        s->fd_in_tag = 0;

    }



    if (s->fd_in) {

        s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr);

    }

}
",0,0,2,0,0,0,1,1,1,1,1,1,1,0,1
1469,FFmpeg,1,"static int probe_file(WriterContext *wctx, const char *filename)

{

    AVFormatContext *fmt_ctx;

    int ret, i;

    int section_id;



    do_read_frames = do_show_frames || do_count_frames;

    do_read_packets = do_show_packets || do_count_packets;



    ret = open_input_file(&fmt_ctx, filename);

    if (ret < 0)

        return ret;



#define CHECK_END if (ret < 0) goto end



    nb_streams_frames  = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames));

    nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets));

    selected_streams   = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams));



    for (i = 0; i < fmt_ctx->nb_streams; i++) {

        if (stream_specifier) {

            ret = avformat_match_stream_specifier(fmt_ctx,

                                                  fmt_ctx->streams[i],

                                                  stream_specifier);

            CHECK_END;

            else

                selected_streams[i] = ret;

   ",2,1,6,0,0,0,1,1,1,1,1,1,0,0,1
1473,qemu,1,"static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr,

                                          target_phys_addr_t end_addr)

{

    KVMState *s = kvm_state;

    unsigned long size, allocated_size = 0;

    KVMDirtyLog d;

    KVMSlot *mem;

    int ret = 0;



    d.dirty_bitmap = NULL;

    while (start_addr < end_addr) {

        mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr);

        if (mem == NULL) {

            break;

        }



        size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8;

        if (!d.dirty_bitmap) {

            d.dirty_bitmap = qemu_malloc(size);

        } else if (size > allocated_size) {

            d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size);

        }

        allocated_size = size;

        memset(d.dirty_bitmap, 0, allocated_size);



        d.slot = mem->slot;



        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {

            DPRINTF(""ioctl failed %d\n"", errno);

            ret = -1;

       ",0,0,4,0,0,1,1,1,1,1,1,1,0,1,1
1476,FFmpeg,1,"static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],

                   int dst_stride[3], int src_stride[3], int width,

                   int height, uint8_t *qp_store, int qp_stride)

{

    int x, y, i, j;

    const int count = 1<<p->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? p->hsub : 0);

        int h = height >> (is_chroma ? p->vsub : 0);

        int stride = p->temp_stride[i];

        int block = BLOCK >> (is_chroma ? p->hsub : 0);



        if (!src[i] || !dst[i])

            continue;

        for (y = 0; y < h; y++) {

            int index = block + block * stride + y * stride;



            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );

            for (x = 0; x < block; x++) {

                p->src[i][index     - x - 1] = p->src[i][index +     x    ];

                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];

            }

        }

        for (y = 0; y < block; ",4,0,1,0,0,0,0,1,0,1,0,0,1,0,1
1487,qemu,0,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
1497,qemu,0,"static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba,

                                target_ulong tce)

{

    IOMMUTLBEntry entry;

    hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift);

    unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift;



    if (index >= tcet->nb_table) {

        hcall_dprintf(""spapr_vio_put_tce on out-of-bounds IOBA 0x""

                      TARGET_FMT_lx ""\n"", ioba);

        return H_PARAMETER;

    }



    tcet->table[index] = tce;



    entry.target_as = &address_space_memory,

    entry.iova = ioba & page_mask;

    entry.translated_addr = tce & page_mask;

    entry.addr_mask = ~page_mask;

    entry.perm = spapr_tce_iommu_access_flags(tce);

    memory_region_notify_iommu(&tcet->iommu, entry);



    return H_SUCCESS;

}
",0,0,4,0,0,0,0,0,0,0,0,0,0,1,0
1500,qemu,0,"static target_ulong h_enter(CPUState *env, sPAPREnvironment *spapr,

                            target_ulong opcode, target_ulong *args)

{

    target_ulong flags = args[0];

    target_ulong pte_index = args[1];

    target_ulong pteh = args[2];

    target_ulong ptel = args[3];

    target_ulong i;

    uint8_t *hpte;



    /* only handle 4k and 16M pages for now */

    if (pteh & HPTE_V_LARGE) {

#if 0 /* We don't support 64k pages yet */

        if ((ptel & 0xf000) == 0x1000) {

            /* 64k page */

        } else

#endif

        if ((ptel & 0xff000) == 0) {

            /* 16M page */

            /* lowest AVA bit must be 0 for 16M pages */

            if (pteh & 0x80) {

                return H_PARAMETER;

            }

        } else {

            return H_PARAMETER;

        }

    }



    /* FIXME: bounds check the pa? */



    /* Check WIMG */

    if ((ptel & HPTE_R_WIMG) != HPTE_R_M) {

        return H_PARAMETER;

    }

    pteh &= ~0x60ULL;



    if ((pte_index * HASH_PTE_S",0,0,8,0,0,0,1,0,1,1,0,1,1,1,1
1507,qemu,1,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,

                                    TCGv arg2, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, t1;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, arg1, arg2);



    if (compute_ca) {

        gen_op_arith_compute_ca(ctx, t0, arg1, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, t1);

        gen_op_arith_compute_ca",0,0,6,0,0,0,1,1,1,1,0,1,0,0,1
1508,FFmpeg,1,"static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t*)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_end = end - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%m",0,0,0,0,0,1,1,1,1,1,0,0,0,0,1
1519,qemu,1,"int inet_dgram_opts(QemuOpts *opts)

{

    struct addrinfo ai, *peer = NULL, *local = NULL;

    const char *addr;

    const char *port;

    char uaddr[INET6_ADDRSTRLEN+1];

    char uport[33];

    int sock = -1, rc;



    /* lookup peer addr */

    memset(&ai,0, sizeof(ai));

    ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG;

    ai.ai_family = PF_UNSPEC;

    ai.ai_socktype = SOCK_DGRAM;



    addr = qemu_opt_get(opts, ""host"");

    port = qemu_opt_get(opts, ""port"");

    if (addr == NULL || strlen(addr) == 0) {

        addr = ""localhost"";

    }

    if (port == NULL || strlen(port) == 0) {

        fprintf(stderr, ""inet_dgram: port not specified\n"");

        return -1;

    }



    if (qemu_opt_get_bool(opts, ""ipv4"", 0))

        ai.ai_family = PF_INET;

    if (qemu_opt_get_bool(opts, ""ipv6"", 0))

        ai.ai_family = PF_INET6;



    if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) {

        fprintf(stderr,""getaddrinfo(%s,%s): %s\n"", addr, port,

                gai_strerror(rc));

	retur",0,0,6,0,0,0,1,1,0,0,0,0,0,0,0
1525,FFmpeg,0,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
",0,0,1,0,0,0,0,1,0,1,0,0,0,0,1
1533,qemu,1,"static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64)

{

    TCGReg datalo, datahi, addrlo, rbase;

    TCGReg addrhi __attribute__((unused));

    TCGMemOpIdx oi;

    TCGMemOp opc, s_bits;

#ifdef CONFIG_SOFTMMU

    int mem_index;

    tcg_insn_unit *label_ptr;

#endif



    datalo = *args++;

    datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0);

    addrlo = *args++;

    addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0);

    oi = *args++;

    opc = get_memop(oi);

    s_bits = opc & MO_SIZE;



#ifdef CONFIG_SOFTMMU

    mem_index = get_mmuidx(oi);

    addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, true);



    /* Load a pointer into the current opcode w/conditional branch-link. */

    label_ptr = s->code_ptr;

    tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK);



    rbase = TCG_REG_R3;

#else  /* !CONFIG_SOFTMMU */

    rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0;

    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {

  ",0,0,4,0,0,0,1,1,1,1,1,1,0,0,0
1540,FFmpeg,0,"int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl,

                                   GetBitContext *gb)

{

    int i;

    MMCO *mmco = sl->mmco;

    int nb_mmco = 0;



    if (h->nal_unit_type == NAL_IDR_SLICE) { // FIXME fields

        skip_bits1(gb); // broken_link

        if (get_bits1(gb)) {

            mmco[0].opcode   = MMCO_LONG;

            mmco[0].long_arg = 0;

            nb_mmco          = 1;

        }

        sl->explicit_ref_marking = 1;

    } else {

        sl->explicit_ref_marking = get_bits1(gb);

        if (sl->explicit_ref_marking) {

            for (i = 0; i < MAX_MMCO_COUNT; i++) {

                MMCOOpcode opcode = get_ue_golomb_31(gb);



                mmco[i].opcode = opcode;

                if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) {

                    mmco[i].short_pic_num =

                        (sl->curr_pic_num - get_ue_golomb(gb) - 1) &

                            (sl->max_pic_num - 1);

#if 0

           ",1,0,5,0,0,0,1,1,1,0,1,0,1,0,1
1557,qemu,0," void cpu_sh4_invalidate_tlb(CPUSH4State *s)

{

    int i;



    /* UTLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }

    /* ITLB */

    for (i = 0; i < UTLB_SIZE; i++) {

        tlb_t * entry = &s->utlb[i];

        entry->v = 0;

    }



    tlb_flush(s, 1);

}
",2,0,0,0,0,0,0,0,0,0,0,0,1,0,1
1573,qemu,0,"uint16_t net_checksum_finish(uint32_t sum)

{

    while (sum>>16)

	sum = (sum & 0xFFFF)+(sum >> 16);

    return ~sum;

}
",0,0,0,0,0,1,0,0,0,0,1,1,1,1,1
1616,qemu,0,"static void pci_init_mask_bridge(PCIDevice *d)

{

    /* PCI_PRIMARY_BUS, PCI_SECONDARY_BUS, PCI_SUBORDINATE_BUS and

       PCI_SEC_LETENCY_TIMER */

    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);



    /* base and limit */

    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;

    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;

    pci_set_word(d->wmask + PCI_MEMORY_BASE,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,

                 PCI_MEMORY_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,

                 PCI_PREF_RANGE_MASK & 0xffff);

    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,

                 PCI_PREF_RANGE_MASK & 0xffff);



    /* PCI_PREF_BASE_UPPER32 and PCI_PREF_LIMIT_UPPER32 */

    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);



    /* Supported memory and i/o types */

    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;

    d->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16;

    pci_word_test_",0,0,0,0,0,0,0,0,0,0,0,0,1,1,0
1621,qemu,0,"static TranslationBlock *tb_alloc(target_ulong pc)

{

    TranslationBlock *tb;

    TBContext *ctx;



    assert_tb_locked();



    tb = tcg_tb_alloc(&tcg_ctx);

    if (unlikely(tb == NULL)) {

        return NULL;

    }

    ctx = &tcg_ctx.tb_ctx;

    if (unlikely(ctx->nb_tbs == ctx->tbs_size)) {

        ctx->tbs_size *= 2;

        ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size);

    }

    ctx->tbs[ctx->nb_tbs++] = tb;

    tb->pc = pc;

    tb->cflags = 0;

    tb->invalid = false;

    return tb;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
1626,qemu,0,"static void gpollfds_from_select(void)

{

    int fd;

    for (fd = 0; fd <= nfds; fd++) {

        int events = 0;

        if (FD_ISSET(fd, &rfds)) {

            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;

        }

        if (FD_ISSET(fd, &wfds)) {

            events |= G_IO_OUT | G_IO_ERR;

        }

        if (FD_ISSET(fd, &xfds)) {

            events |= G_IO_PRI;

        }

        if (events) {

            GPollFD pfd = {

                .fd = fd,

                .events = events,

            };

            g_array_append_val(gpollfds, pfd);

        }

    }

}
",1,0,4,0,0,0,1,1,1,1,0,1,1,1,1
1628,FFmpeg,0,"static int decode_frame(AVCodecContext *avctx,

                        void *data, int *got_frame, AVPacket *avpkt)

{

    TiffContext *const s = avctx->priv_data;

    AVFrame *const p = data;

    ThreadFrame frame = { .f = data };

    unsigned off;

    int le, ret, plane, planes;

    int i, j, entries, stride;

    unsigned soff, ssize;

    uint8_t *dst;

    GetByteContext stripsizes;

    GetByteContext stripdata;



    bytestream2_init(&s->gb, avpkt->data, avpkt->size);



    // parse image header

    if ((ret = ff_tdecode_header(&s->gb, &le, &off))) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid TIFF header\n"");

        return ret;

    } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {

        av_log(avctx, AV_LOG_ERROR, ""IFD offset is greater than image size\n"");

        return AVERROR_INVALIDDATA;

    }

    s->le          = le;

    // TIFF_BPP is not a required tag and defaults to 1

    s->bppcount    = s->bpp = 1;

    s->photometric = TIFF_PHOTOMETRIC_NONE;

    s->compr",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
1657,FFmpeg,0,"int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,

                                              int *got_picture_ptr,

                                              AVPacket *avpkt)

{

    int ret;



    *got_picture_ptr = 0;

    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))

        return -1;



    avctx->pkt = avpkt;

    apply_param_change(avctx, avpkt);



    avcodec_get_frame_defaults(picture);



    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {

        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)

            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,

                                         avpkt);

        else {

            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,

                                       avpkt);

            picture->pkt_dts          ",0,0,3,0,0,0,0,0,0,1,1,1,1,1,1
1672,qemu,1,"static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun,

                                      MegasasCmd *cmd)

{

    struct mfi_pd_info *info = cmd->iov_buf;

    size_t dcmd_size = sizeof(struct mfi_pd_info);

    uint64_t pd_size;

    uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF);

    uint8_t cmdbuf[6];

    SCSIRequest *req;

    size_t len, resid;



    if (!cmd->iov_buf) {

        cmd->iov_buf = g_malloc0(dcmd_size);

        info = cmd->iov_buf;

        info->inquiry_data[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */

        info->vpd_page83[0] = 0x7f;

        megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data));

        req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd);

        if (!req) {

            trace_megasas_dcmd_req_alloc_failed(cmd->index,

                                                ""PD get info std inquiry"");

            g_free(cmd->iov_buf);

            cmd->iov_buf = NULL;

            return MFI_STAT_FLASH_ALLOC_FAIL;

        }

        ",0,0,2,0,0,0,0,0,0,1,0,0,1,1,1
1710,qemu,0,"static void gen_isel(DisasContext *ctx)

{

    int l1, l2;

    uint32_t bi = rC(ctx->opcode);

    uint32_t mask;

    TCGv_i32 t0;



    l1 = gen_new_label();

    l2 = gen_new_label();



    mask = 0x08 >> (bi & 0x03);

    t0 = tcg_temp_new_i32();

    tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask);

    tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1);

    if (rA(ctx->opcode) == 0)

        tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0);

    else

        tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]);

    gen_set_label(l2);

    tcg_temp_free_i32(t0);

}
",0,0,1,0,0,0,0,1,0,0,0,0,1,1,1
1712,qemu,0,"static void stream_process_mem2s(struct Stream *s,

                                 StreamSlave *tx_dev)

{

    uint32_t prev_d;

    unsigned char txbuf[16 * 1024];

    unsigned int txlen;

    uint32_t app[6];



    if (!stream_running(s) || stream_idle(s)) {

        return;

    }



    while (1) {

        stream_desc_load(s, s->regs[R_CURDESC]);



        if (s->desc.status & SDESC_STATUS_COMPLETE) {

            s->regs[R_DMASR] |= DMASR_HALTED;

            break;

        }



        if (stream_desc_sof(&s->desc)) {

            s->pos = 0;

            memcpy(app, s->desc.app, sizeof app);

        }



        txlen = s->desc.control & SDESC_CTRL_LEN_MASK;

        if ((txlen + s->pos) > sizeof txbuf) {

            hw_error(""%s: too small internal txbuf! %d\n"", __func__,

                     txlen + s->pos);

        }



        cpu_physical_memory_read(s->desc.buffer_address,

                                 txbuf + s->pos, txlen);

        s->pos += txlen;



        if (stream_desc_eo",0,0,5,0,0,1,1,1,1,1,1,0,0,0,0
1713,FFmpeg,0,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
",0,0,2,0,1,0,0,0,0,1,0,1,0,0,1
1721,qemu,1,"static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci)

{

    read_local_name_rp params;

    params.status = HCI_SUCCESS;

    memset(params.name, 0, sizeof(params.name));

    if (hci->device.lmp_name)

        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));



    bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,1
1726,qemu,1,"static bool vnc_should_update(VncState *vs)

{

    switch (vs->update) {

    case VNC_STATE_UPDATE_NONE:

        break;

    case VNC_STATE_UPDATE_INCREMENTAL:

        /* Only allow incremental updates if the output buffer

         * is empty, or if audio capture is enabled.

         */

        if (!vs->output.offset || vs->audio_cap) {

            return true;

        }

        break;

    case VNC_STATE_UPDATE_FORCE:

        return true;

    }

    return false;

}
",0,0,3,0,1,0,1,1,1,0,0,0,1,0,1
1736,qemu,1,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,1,1
1760,qemu,0,"static void test_migrate(void)

{

    char *uri = g_strdup_printf(""unix:%s/migsocket"", tmpfs);

    QTestState *global = global_qtest, *from, *to;

    unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d;

    gchar *cmd;

    QDict *rsp;



    char *bootpath = g_strdup_printf(""%s/bootsect"", tmpfs);

    FILE *bootfile = fopen(bootpath, ""wb"");



    got_stop = false;

    g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1);

    fclose(bootfile);



    cmd = g_strdup_printf(""-machine accel=kvm:tcg -m 150M""

                          "" -name pcsource,debug-threads=on""

                          "" -serial file:%s/src_serial""

                          "" -drive file=%s,format=raw"",

                          tmpfs, bootpath);

    from = qtest_start(cmd);

    g_free(cmd);



    cmd = g_strdup_printf(""-machine accel=kvm:tcg -m 150M""

                          "" -name pcdest,debug-threads=on""

                          "" -serial file:%s/dest_serial""

                          "" -drive fil",1,0,0,0,0,0,0,0,0,1,1,1,1,1,1
1770,qemu,0,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!tso_enable) {

        goto func_exit;

    }



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:

    return rc;

}
",0,1,1,0,0,0,0,0,0,1,0,0,0,0,0
1783,qemu,1,"static int scsi_req_length(SCSIRequest *req, uint8_t *cmd)

{

    switch (cmd[0] >> 5) {

    case 0:

        req->cmd.xfer = cmd[4];

        req->cmd.len = 6;

        /* length 0 means 256 blocks */

        if (req->cmd.xfer == 0)

            req->cmd.xfer = 256;

        break;

    case 1:

    case 2:

        req->cmd.xfer = cmd[8] | (cmd[7] << 8);

        req->cmd.len = 10;

        break;

    case 4:

        req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24);

        req->cmd.len = 16;

        break;

    case 5:

        req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24);

        req->cmd.len = 12;

        break;

    default:

        trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, cmd[0]);

        return -1;

    }



    switch(cmd[0]) {

    case TEST_UNIT_READY:

    case START_STOP:

    case SEEK_6:

    case WRITE_FILEMARKS:

    case SPACE:

    case RESERVE:

    case RELEASE:

    case ERASE:

    case ALLOW_MEDIUM_REM",0,0,1,0,2,0,1,1,1,1,1,1,0,0,0
1791,FFmpeg,1,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
",0,0,2,0,0,0,0,0,0,1,0,0,0,0,0
1802,qemu,1,"int kvmppc_reset_htab(int shift_hint)

{

    uint32_t shift = shift_hint;



    if (!kvm_enabled()) {

        /* Full emulation, tell caller to allocate htab itself */

        return 0;

    }

    if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) {

        int ret;

        ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift);

        if (ret == -ENOTTY) {

            /* At least some versions of PR KVM advertise the

             * capability, but don't implement the ioctl().  Oops.

             * Return 0 so that we allocate the htab in qemu, as is

             * correct for PR. */

            return 0;

        } else if (ret < 0) {

            return ret;

        }

        return shift;

    }



    /* We have a kernel that predates the htab reset calls.  For PR

     * KVM, we need to allocate the htab ourselves, for an HV KVM of

     * this era, it has allocated a 16MB fixed size hash table already. */

    if (kvmppc_is_pr(kvm_state)) {

        /* PR - tell caller to ",2,0,10,0,0,0,1,1,0,1,1,1,0,0,0
1804,FFmpeg,1,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    unsigned int offset, w, h, y, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_pixel = AV_RL16(buf+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.\n"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c\n"");



    buf += offset;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

",3,0,6,0,0,0,0,0,0,1,1,0,0,0,0
1817,qemu,1,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",0,0,2,0,0,0,1,1,1,0,0,0,0,0,0
1822,qemu,1,"POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(oc);

    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(oc);



    dc->fw_name = ""PowerPC,POWER9"";

    dc->desc = ""POWER9"";

    dc->props = powerpc_servercpu_properties;

    pcc->pvr_match = ppc_pvr_match_power9;

    pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07;

    pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 |

                         PCR_COMPAT_2_05;

    pcc->init_proc = init_proc_POWER9;

    pcc->check_pow = check_pow_nocheck;

    cc->has_work = cpu_has_work_POWER9;

    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |

                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |

                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |

                       PPC_FLOAT_FRSQRTES |

                       PPC_FLOAT_STFIWX |

                       PPC_FLOAT_EXT |

                       PPC_CAC",0,0,0,0,0,0,0,1,1,1,1,0,1,1,1
1878,FFmpeg,1,"static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!s->pb->eof_reached) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", klv.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_k",1,0,4,0,0,1,0,0,0,0,0,1,0,0,0
1883,FFmpeg,1,"static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
    opj_image_cmptparm_t cmptparm[4] = {{0}};
    opj_image_t *img;
    int i;
    int sub_dx[4];
    int sub_dy[4];
    int numcomps;
    OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN;
    sub_dx[0] = sub_dx[3] = 1;
    sub_dy[0] = sub_dy[3] = 1;
    sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w;
    sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h;
    numcomps = desc->nb_components;
    switch (avctx->pix_fmt) {
    case AV_PIX_FMT_GRAY8:
    case AV_PIX_FMT_YA8:
    case AV_PIX_FMT_GRAY16:
    case AV_PIX_FMT_YA16:
        color_space = CLRSPC_GRAY;
        break;
    case AV_PIX_FMT_RGB24:
    case AV_PIX_FMT_RGBA:
    case AV_PIX_FMT_RGB48:
    case AV_PIX_FMT_RGBA64:
    case AV_PIX_FMT_GBR24P:
    case AV_PIX_FMT_GBRP9:
    case AV_PIX_FMT_GBRP10:
    case AV_PIX_FMT_GBRP12:
    case AV_PIX_FMT_GBRP14:
    case AV_PIX_FMT_GBRP16:
    c",0,0,0,0,1,0,0,0,1,1,1,1,0,0,0
1894,qemu,0,"static int xen_platform_initfn(PCIDevice *dev)

{

    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);

    uint8_t *pci_conf;



    pci_conf = d->pci_dev.config;



    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);



    pci_config_set_prog_interface(pci_conf, 0);



    pci_conf[PCI_INTERRUPT_PIN] = 1;



    pci_register_bar(&d->pci_dev, 0, 0x100,

            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);



    /* reserve 16MB mmio address for share memory*/

    pci_register_bar(&d->pci_dev, 1, 0x1000000,

            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);



    platform_fixed_ioport_init(d);



    return 0;

}
",6,0,0,0,0,0,0,1,1,1,0,1,0,0,0
1896,qemu,0,"static int proxy_symlink(FsContext *fs_ctx, const char *oldpath,

                         V9fsPath *dir_path, const char *name, FsCred *credp)

{

    int retval;

    V9fsString fullname, target;



    v9fs_string_init(&fullname);

    v9fs_string_init(&target);



    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    v9fs_string_sprintf(&target, ""%s"", oldpath);



    retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, ""ssdd"",

                          &target, &fullname, credp->fc_uid, credp->fc_gid);

    v9fs_string_free(&fullname);

    v9fs_string_free(&target);

    if (retval < 0) {

        errno = -retval;

        retval = -1;

    }

    return retval;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,1
1900,qemu,0,"static int vfio_enable_intx(VFIODevice *vdev)

{

    VFIOIRQSetFD irq_set_fd = {

        .irq_set = {

            .argsz = sizeof(irq_set_fd),

            .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER,

            .index = VFIO_PCI_INTX_IRQ_INDEX,

            .start = 0,

            .count = 1,

        },

    };

    uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);

    int ret;



    if (vdev->intx.disabled || !pin) {

        return 0;

    }



    vfio_disable_interrupts(vdev);



    vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */

    ret = event_notifier_init(&vdev->intx.interrupt, 0);

    if (ret) {

        error_report(""vfio: Error: event_notifier_init failed\n"");

        return ret;

    }



    irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt);

    qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev);



    if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) {

        error_report(""vfio: Error: Failed to set",0,0,6,0,0,0,0,0,0,0,0,0,1,0,0
1902,qemu,0,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    /* mvc and memmove do not behave the same when areas overlap! */

    } else if ((dest < src) || (src + l < dest)) {

        memmove(g2h(dest), g2h(src), l + 1);",0,0,6,0,0,0,0,0,0,0,0,0,1,1,1
1905,qemu,0,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
",0,0,2,0,1,0,0,0,0,0,0,0,0,0,0
1909,qemu,0,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)

{

    tcet->bypass = bypass;

}
",0,0,0,0,0,0,0,1,0,1,1,0,0,0,0
1917,qemu,0,"void qemu_system_wakeup_request(WakeupReason reason)

{

    if (!is_suspended) {

        return;

    }

    if (!(wakeup_reason_mask & (1 << reason))) {

        return;

    }

    runstate_set(RUN_STATE_RUNNING);

    monitor_protocol_event(QEVENT_WAKEUP, NULL);

    notifier_list_notify(&wakeup_notifiers, &reason);

    reset_requested = 1;

    qemu_notify_event();

    is_suspended = false;

}
",0,0,6,0,0,0,0,0,0,0,1,1,0,0,0
1937,FFmpeg,1,"static int rtsp_listen(AVFormatContext *s)

{

    RTSPState *rt = s->priv_data;

    char proto[128], host[128], path[512], auth[128];

    char uri[500];

    int port;

    int default_port = RTSP_DEFAULT_PORT;

    char tcpname[500];

    const char *lower_proto = ""tcp"";

    unsigned char rbuf[4096];

    unsigned char method[10];

    int rbuflen = 0;

    int ret;

    enum RTSPMethod methodcode;



    if (!rt->protocols) {

        rt->protocols = ffurl_get_protocols(NULL, NULL);

        if (!rt->protocols)

            return AVERROR(ENOMEM);

    }



    /* extract hostname and port */

    av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host),

                 &port, path, sizeof(path), s->filename);



    /* ff_url_join. No authorization by now (NULL) */

    ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host,

                port, ""%s"", path);



    if (!strcmp(proto, ""rtsps"")) {

        lower_proto  = ""tls"";

        default_port = RTSPS_DEFAULT_P",0,0,3,0,0,0,0,1,1,0,0,0,0,0,1
1945,FFmpeg,1,"int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb,

                            VLC *vlc, const float *level_table,

                            const uint16_t *run_table, int version,

                            WMACoef *ptr, int offset, int num_coefs,

                            int block_len, int frame_len_bits,

                            int coef_nb_bits)

{

    int code, level, sign;

    const uint32_t *ilvl = (const uint32_t *) level_table;

    uint32_t *iptr = (uint32_t *) ptr;

    const unsigned int coef_mask = block_len - 1;

    for (; offset < num_coefs; offset++) {

        code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX);

        if (code > 1) {

            /** normal code */

            offset                  += run_table[code];

            sign                     = get_bits1(gb) - 1;

            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;

        } else if (code == 1) {

            /** EOB */

            break;

        } else {

            /** esca",1,0,2,0,0,0,1,1,0,1,0,1,0,0,0
1946,FFmpeg,0,"int avfilter_graph_parse(AVFilterGraph *graph, const char *filters,

                         AVFilterInOut *open_inputs,

                         AVFilterInOut *open_outputs, AVClass *log_ctx)

{

    int index = 0, ret;

    char chr = 0;



    AVFilterInOut *curr_inputs = NULL;



    do {

        AVFilterContext *filter;

        filters += strspn(filters, WHITESPACES);



        if ((ret = parse_inputs(&filters, &curr_inputs, &open_outputs, log_ctx)) < 0)

            goto fail;



        if ((ret = parse_filter(&filter, &filters, graph, index, log_ctx)) < 0)

            goto fail;



        if (filter->input_count == 1 && !curr_inputs && !index) {

            /* First input can be omitted if it is ""[in]"" */

            const char *tmp = ""[in]"";

            if ((ret = parse_inputs(&tmp, &curr_inputs, &open_outputs, log_ctx)) < 0)

                goto fail;

        }



        if ((ret = link_filter_inouts(filter, &curr_inputs, &open_inputs, log_ctx)) < 0)

            goto fail;



        i",0,4,5,0,0,0,0,1,1,1,1,1,0,0,0
1981,qemu,0,"static int virtio_net_device_exit(DeviceState *qdev)

{

    VirtIONet *n = VIRTIO_NET(qdev);

    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);

    int i;



    /* This will stop vhost backend if appropriate. */

    virtio_net_set_status(vdev, 0);



    unregister_savevm(qdev, ""virtio-net"", n);



    if (n->netclient_name) {

        g_free(n->netclient_name);

        n->netclient_name = NULL;

    }

    if (n->netclient_type) {

        g_free(n->netclient_type);

        n->netclient_type = NULL;

    }



    g_free(n->mac_table.macs);

    g_free(n->vlans);



    for (i = 0; i < n->max_queues; i++) {

        VirtIONetQueue *q = &n->vqs[i];

        NetClientState *nc = qemu_get_subqueue(n->nic, i);



        qemu_purge_queued_packets(nc);



        if (q->tx_timer) {

            timer_del(q->tx_timer);

            timer_free(q->tx_timer);

        } else {

            qemu_bh_delete(q->tx_bh);

        }

    }



    g_free(n->vqs);

    qemu_del_nic(n->nic);

    virtio_cleanup(vdev);



    ",1,0,3,0,0,0,0,0,0,1,0,1,0,0,0
1983,qemu,0,"static inline void gen_neon_widen(TCGv dest, TCGv src, int size, int u)

{

    if (u) {

        switch (size) {

        case 0: gen_helper_neon_widen_u8(dest, src); break;

        case 1: gen_helper_neon_widen_u16(dest, src); break;

        case 2: tcg_gen_extu_i32_i64(dest, src); break;

        default: abort();

        }

    } else {

        switch (size) {

        case 0: gen_helper_neon_widen_s8(dest, src); break;

        case 1: gen_helper_neon_widen_s16(dest, src); break;

        case 2: tcg_gen_ext_i32_i64(dest, src); break;

        default: abort();

        }

    }

    dead_tmp(src);

}
",0,0,1,0,2,0,0,0,0,0,0,0,1,0,1
1990,qemu,0,"static int sd_create_branch(BDRVSheepdogState *s)

{

    int ret, fd;

    uint32_t vid;

    char *buf;



    dprintf(""%"" PRIx32 "" is snapshot.\n"", s->inode.vdi_id);



    buf = g_malloc(SD_INODE_SIZE);



    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,

                       s->addr, s->port);

    if (ret) {

        goto out;

    }



    dprintf(""%"" PRIx32 "" is created.\n"", vid);



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        error_report(""failed to connect"");

        ret = fd;

        goto out;

    }



    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,

                      SD_INODE_SIZE, 0, s->cache_enabled);



    closesocket(fd);



    if (ret < 0) {

        goto out;

    }



    memcpy(&s->inode, buf, sizeof(s->inode));



    s->is_snapshot = false;

    ret = 0;

    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);



out:

    g_free(buf);



    return ret;

}
",0,3,3,0,0,0,0,0,0,0,0,0,0,0,0
1994,qemu,1,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
1998,FFmpeg,1,"av_cold int swri_rematrix_init(SwrContext *s){

    int i, j;

    int nb_in  = av_get_channel_layout_nb_channels(s->in_ch_layout);

    int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout);



    s->mix_any_f = NULL;



    if (!s->rematrix_custom) {

        int r = auto_matrix(s);

        if (r)

            return r;

    }

    if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){

        s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int));

        s->native_one    = av_mallocz(sizeof(int));

        if (!s->native_matrix || !s->native_one)

            return AVERROR(ENOMEM);

        for (i = 0; i < nb_out; i++) {

            double rem = 0;



            for (j = 0; j < nb_in; j++) {

                double target = s->matrix[i][j] * 32768 + rem;

                ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target);

                rem += target - ((int*)s->native_matrix)[i * nb_in + j];

            }

        }

        *((int*)s->native_one) = 32768;

        s->mix_1_1_f = (mix_1_",2,0,4,0,0,0,0,0,0,1,1,0,1,1,1
2009,qemu,1,"void s390_machine_reset(void)

{

    S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0));



    qemu_devices_reset();

    s390_cmma_reset();

    s390_crypto_reset();



    /* all cpus are stopped - configure and start the ipl cpu only */

    s390_ipl_prepare_cpu(ipl_cpu);

    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
2010,FFmpeg,1,"static int fic_decode_block(FICContext *ctx, GetBitContext *gb,

                            uint8_t *dst, int stride, int16_t *block)

{

    int i, num_coeff;



    /* Is it a skip block? */

    if (get_bits1(gb)) {

        /* This is a P-frame. */

        ctx->frame->key_frame = 0;

        ctx->frame->pict_type = AV_PICTURE_TYPE_P;



        return 0;

    }



    memset(block, 0, sizeof(*block) * 64);



    num_coeff = get_bits(gb, 7);

    if (num_coeff > 64)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < num_coeff; i++)

        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *

                                     ctx->qmat[ff_zigzag_direct[i]];



    fic_idct_put(dst, stride, block);



    return 0;

}
",1,0,2,0,0,0,0,0,0,0,0,0,1,1,1
2027,FFmpeg,1,"void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets)

{

    RTSPState *rt = s->priv_data;

    int i;



    for (i = 0; i < rt->nb_rtsp_streams; i++) {

        RTSPStream *rtsp_st = rt->rtsp_streams[i];

        if (!rtsp_st)

            continue;

        if (rtsp_st->transport_priv) {

            if (s->oformat) {

                AVFormatContext *rtpctx = rtsp_st->transport_priv;

                av_write_trailer(rtpctx);

                if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) {

                    uint8_t *ptr;

                    if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets)

                        ff_rtsp_tcp_write_packet(s, rtsp_st);

                    avio_close_dyn_buf(rtpctx->pb, &ptr);

                    av_free(ptr);

                } else {

                    avio_close(rtpctx->pb);

                }

                avformat_free_context(rtpctx);

            } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC)

                ff_rdt_par",3,0,6,0,0,0,0,0,0,1,0,0,1,1,1
2047,qemu,0,"static void do_token_in(USBDevice *s, USBPacket *p)

{

    int request, value, index;



    assert(p->ep->nr == 0);



    request = (s->setup_buf[0] << 8) | s->setup_buf[1];

    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];

    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];

 

    switch(s->setup_state) {

    case SETUP_STATE_ACK:

        if (!(s->setup_buf[0] & USB_DIR_IN)) {

            usb_device_handle_control(s, p, request, value, index,

                                      s->setup_len, s->data_buf);

            if (p->status == USB_RET_ASYNC) {

                return;

            }

            s->setup_state = SETUP_STATE_IDLE;

            p->actual_length = 0;

        }

        break;



    case SETUP_STATE_DATA:

        if (s->setup_buf[0] & USB_DIR_IN) {

            int len = s->setup_len - s->setup_index;

            if (len > p->iov.size) {

                len = p->iov.size;

            }

            usb_packet_copy(p, s->data_buf + s->setup_index, len);

      ",0,0,4,0,1,0,0,0,0,0,0,0,0,0,0
2049,FFmpeg,0,"static int get_video_buffer(AVFrame *frame, int align)

{

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);

    int ret, i;



    if (!desc)

        return AVERROR(EINVAL);



    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)

        return ret;



    if (!frame->linesize[0]) {

        ret = av_image_fill_linesizes(frame->linesize, frame->format,

                                      frame->width);

        if (ret < 0)

            return ret;



        for (i = 0; i < 4 && frame->linesize[i]; i++)

            frame->linesize[i] = FFALIGN(frame->linesize[i], align);

    }



    for (i = 0; i < 4 && frame->linesize[i]; i++) {

        int h = FFALIGN(frame->height, 32);

        if (i == 1 || i == 2)

            h = -((-h) >> desc->log2_chroma_h);



        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);

        if (!frame->buf[i])

            goto fail;



        frame->data[i] = frame->buf[i]->data;

    }

    if (desc->flags & P",4,1,7,0,0,0,0,0,0,1,0,0,0,1,0
2053,qemu,0,"static int kvm_get_msrs(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    struct kvm_msr_entry *msrs = cpu->kvm_msr_buf->entries;

    int ret, i;

    uint64_t mtrr_top_bits;



    kvm_msr_buf_reset(cpu);



    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0);

    kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0);

    kvm_msr_entry_add(cpu, MSR_PAT, 0);

    if (has_msr_star) {

        kvm_msr_entry_add(cpu, MSR_STAR, 0);

    }

    if (has_msr_hsave_pa) {

        kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0);

    }

    if (has_msr_tsc_aux) {

        kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0);

    }

    if (has_msr_tsc_adjust) {

        kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0);

    }

    if (has_msr_tsc_deadline) {

        kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0);

    }

    if (has_msr_misc_enable) {

        kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0);

    }

    if (has_msr_smbase) {

        kvm_msr_entry_add(cpu, MSR_IA32_",0,0,7,0,0,0,1,0,1,0,0,0,1,0,1
2063,qemu,0,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
",0,0,1,0,0,0,0,0,0,1,1,1,0,0,1
2083,FFmpeg,0,"av_cold int ffv1_init_slice_contexts(FFV1Context *f)

{

    int i;



    f->slice_count = f->num_h_slices * f->num_v_slices;

    if (f->slice_count <= 0) {

        av_log(f->avctx, AV_LOG_ERROR, ""Invalid number of slices\n"");

        return AVERROR(EINVAL);

    }



    for (i = 0; i < f->slice_count; i++) {

        FFV1Context *fs = av_mallocz(sizeof(*fs));

        int sx          = i % f->num_h_slices;

        int sy          = i / f->num_h_slices;

        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;

        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;

        int sys         = f->avctx->height *  sy      / f->num_v_slices;

        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;

        f->slice_context[i] = fs;

        memcpy(fs, f, sizeof(*fs));

        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));



        fs->slice_width  = sxe - sxs;

        fs->slice_height = sye - sys;

        fs->slice_x      = sxs;

        fs->slice_y   ",1,0,1,0,0,0,0,1,0,1,1,1,0,0,0
2084,qemu,0,"static void omap_pwt_write(void *opaque, target_phys_addr_t addr,

                           uint64_t value, unsigned size)

{

    struct omap_pwt_s *s = (struct omap_pwt_s *) opaque;

    int offset = addr & OMAP_MPUI_REG_MASK;



    if (size != 1) {

        return omap_badwidth_write8(opaque, addr, value);

    }



    switch (offset) {

    case 0x00:	/* FRC */

        s->frc = value & 0x3f;

        break;

    case 0x04:	/* VRC */

        if ((value ^ s->vrc) & 1) {

            if (value & 1)

                printf(""%s: %iHz buzz on\n"", __FUNCTION__, (int)

                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */

                                ((omap_clk_getrate(s->clk) >> 3) /

                                 /* Pre-multiplexer divider */

                                 ((s->gcr & 2) ? 1 : 154) /

                                 /* Octave multiplexer */

                                 (2 << (value & 3)) *

                                 /* 101/107 divider */

    ",0,0,3,0,1,0,1,1,1,1,0,1,1,1,1
2093,FFmpeg,0,"static void predictor_decode_mono(APEContext *ctx, int count)

{

    APEPredictor *p = &ctx->predictor;

    int32_t *decoded0 = ctx->decoded[0];

    int32_t predictionA, currentA, A, sign;



    currentA = p->lastA[0];



    while (count--) {

        A = *decoded0;



        p->buf[YDELAYA] = currentA;

        p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1];



        predictionA = p->buf[YDELAYA    ] * p->coeffsA[0][0] +

                      p->buf[YDELAYA - 1] * p->coeffsA[0][1] +

                      p->buf[YDELAYA - 2] * p->coeffsA[0][2] +

                      p->buf[YDELAYA - 3] * p->coeffsA[0][3];



        currentA = A + (predictionA >> 10);



        p->buf[YADAPTCOEFFSA]     = APESIGN(p->buf[YDELAYA    ]);

        p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]);



        sign = APESIGN(A);

        p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA    ] * sign;

        p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign;

        p->coeffsA[0][2] += p->buf[YADAPTCOEFF",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
2110,FFmpeg,0,"static void print_report(AVFormatContext **output_files,

                         AVOutputStream **ost_table, int nb_ostreams,

                         int is_last_report)

{

    char buf[1024];

    AVOutputStream *ost;

    AVFormatContext *oc;

    int64_t total_size;

    AVCodecContext *enc;

    int frame_number, vid, i;

    double bitrate, ti1, pts;

    static int64_t last_time = -1;

    static int qp_histogram[52];



    if (!is_last_report) {

        int64_t cur_time;

        /* display the report every 0.5 seconds */

        cur_time = av_gettime();

        if (last_time == -1) {

            last_time = cur_time;

            return;

        }

        if ((cur_time - last_time) < 500000)

            return;

        last_time = cur_time;

    }





    oc = output_files[0];



    total_size = avio_size(oc->pb);

    if(total_size<0) // FIXME improve avio_size() so it works with non seekable output too

        total_size= avio_tell(oc->pb);



    buf[0] = '\0';

    ti1 = 1e10;

  ",0,0,4,0,0,0,1,1,1,1,1,1,1,1,1
2115,FFmpeg,1,"static av_always_inline void rv40_strong_loop_filter(uint8_t *src,

                                                     const int step,

                                                     const int stride,

                                                     const int alpha,

                                                     const int lims,

                                                     const int dmode,

                                                     const int chroma)

{

    int i;



    for(i = 0; i < 4; i++, src += stride){

        int sflag, p0, q0, p1, q1;

        int t = src[0*step] - src[-1*step];



        if (!t)

            continue;



        sflag = (alpha * FFABS(t)) >> 7;

        if (sflag > 1)

            continue;



        p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] +

              26*src[ 0*step] + 25*src[ 1*step] +

              rv40_dither_l[dmode + i]) >> 7;



        q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] +

              2",1,0,2,0,0,0,1,1,0,1,1,1,1,1,1
2124,qemu,1,"DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)

{

    DeviceClass *dc;

    const char *driver, *path;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        error_setg(errp, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    dc = qdev_get_device_class(&driver, errp);

    if (!dc) {

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path, errp);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            error_setg(errp, ""Device '%s' can't go on %s bus"",

                       driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus || qbus_is",0,0,7,0,0,0,1,1,1,1,1,1,1,1,1
2130,FFmpeg,1,"static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,

                              int buf_size, int buf_size2)

{

    RVDecContext *rv = avctx->priv_data;

    MpegEncContext *s = &rv->m;

    int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret;



    active_bits_size = buf_size * 8;

    init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8);

    if (s->codec_id == AV_CODEC_ID_RV10)

        mb_count = rv10_decode_picture_header(s);

    else

        mb_count = rv20_decode_picture_header(rv);

    if (mb_count < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""HEADER ERROR\n"");

        return AVERROR_INVALIDDATA;

    }



    if (s->mb_x >= s->mb_width ||

        s->mb_y >= s->mb_height) {

        av_log(s->avctx, AV_LOG_ERROR, ""POS ERROR %d %d\n"", s->mb_x, s->mb_y);

        return AVERROR_INVALIDDATA;

    }

    mb_pos = s->mb_y * s->mb_width + s->mb_x;

    left   = s->mb_width * s->mb_height - mb_pos;

    if (mb_count > left) {

        av_log(s->avctx, AV_LOG_E",0,0,4,0,0,0,1,1,1,1,1,1,0,0,0
2133,qemu,1,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
",0,0,2,0,0,0,1,1,1,1,1,1,0,0,1
2142,FFmpeg,1,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
2148,qemu,1,"void hmp_info_block_jobs(Monitor *mon, const QDict *qdict)
{
    BlockJobInfoList *list;
    Error *err = NULL;
    list = qmp_query_block_jobs(&err);
    assert(!err);
    if (!list) {
        monitor_printf(mon, ""No active jobs\n"");
        return;
    }
    while (list) {
        if (strcmp(list->value->type, ""stream"") == 0) {
            monitor_printf(mon, ""Streaming device %s: Completed %"" PRId64
                           "" of %"" PRId64 "" bytes, speed limit %"" PRId64
                           "" bytes/s\n"",
                           list->value->device,
                           list->value->offset,
                           list->value->len,
                           list->value->speed);
        } else {
            monitor_printf(mon, ""Type %s, device %s: Completed %"" PRId64
                           "" of %"" PRId64 "" bytes, speed limit %"" PRId64
                           "" bytes/s\n"",
                           list->value->type,
                           list->value->device,
                 ",0,0,2,0,0,1,1,1,1,1,1,1,1,1,0
2157,FFmpeg,0,"static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame)

{

    AVFilterContext *ctx = inlink->dst;

    TrimContext       *s = ctx->priv;

    int64_t start_sample, end_sample = frame->nb_samples;

    int64_t pts;

    int drop;



    /* drop everything if EOF has already been returned */

    if (s->eof) {

        av_frame_free(&frame);

        return 0;

    }



    if (frame->pts != AV_NOPTS_VALUE)

        pts = av_rescale_q(frame->pts, inlink->time_base,

                           (AVRational){ 1, inlink->sample_rate });

    else

        pts = s->next_pts;

    s->next_pts = pts + frame->nb_samples;



    /* check if at least a part of the frame is after the start time */

    if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) {

        start_sample = 0;

    } else {

        drop = 1;

        start_sample = frame->nb_samples;



        if (s->start_sample >= 0 &&

            s->nb_samples + frame->nb_samples > s->start_sample) {

            drop         = 0;

        ",0,0,4,0,0,0,0,0,0,1,0,1,1,1,1
2182,qemu,0,"static void tcg_reg_alloc_call(TCGContext *s, int nb_oargs, int nb_iargs,

                               const TCGArg * const args, uint16_t dead_args,

                               uint8_t sync_args)

{

    int flags, nb_regs, i;

    TCGReg reg;

    TCGArg arg;

    TCGTemp *ts;

    intptr_t stack_offset;

    size_t call_stack_size;

    tcg_insn_unit *func_addr;

    int allocate_args;

    TCGRegSet allocated_regs;



    func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];

    flags = args[nb_oargs + nb_iargs + 1];



    nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);

    if (nb_regs > nb_iargs) {

        nb_regs = nb_iargs;

    }



    /* assign stack slots first */

    call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);

    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & 

        ~(TCG_TARGET_STACK_ALIGN - 1);

    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);

    if (allocate_args) {

        /* XXX: if more than TCG_STAT",0,0,3,0,0,0,0,0,0,0,0,0,1,1,0
2187,qemu,0,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
",0,0,1,0,0,1,0,0,0,0,0,0,1,1,1
2188,FFmpeg,0,"static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config)

{

    static int hinted = 0;

    int ret = 0;

    AVDictionaryEntry *e;

    const AVOption *o = NULL;

    const char *option = NULL;

    const char *codec_name = NULL;

    char buff[1024];

    AVCodecContext *ctx;

    AVDictionary **dict;

    enum AVCodecID guessed_codec_id;



    switch (type) {

    case AV_OPT_FLAG_VIDEO_PARAM:

        ctx = config->dummy_vctx;

        dict = &config->video_opts;

        guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ?

                           config->guessed_video_codec_id : AV_CODEC_ID_H264;

        break;

    case AV_OPT_FLAG_AUDIO_PARAM:

        ctx = config->dummy_actx;

        dict = &config->audio_opts;

        guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ?

                           config->guessed_audio_codec_id : AV_CODEC_ID_AAC;

        break;

    default:

        av_assert0(0);

    }


",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
2190,qemu,0,"static int decode_opc(MoxieCPU *cpu, DisasContext *ctx)

{

    CPUMoxieState *env = &cpu->env;



    /* Local cache for the instruction opcode.  */

    int opcode;

    /* Set the default instruction length.  */

    int length = 2;



    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {

        tcg_gen_debug_insn_start(ctx->pc);

    }



    /* Examine the 16-bit opcode.  */

    opcode = ctx->opcode;



    /* Decode instruction.  */

    if (opcode & (1 << 15)) {

        if (opcode & (1 << 14)) {

            /* This is a Form 3 instruction.  */

            int inst = (opcode >> 10 & 0xf);



#define BRANCH(cond)                                                         \

    do {                                                                     \

        int l1 = gen_new_label();                                            \

        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \

        gen_goto_tb(env, ctx, 1, ctx->pc+2);                            ",0,1,3,0,0,0,1,1,1,0,1,0,0,1,0
2195,qemu,0,"static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)

{

    int rex;



    if (opc & P_GS) {

        tcg_out8(s, 0x65);

    }

    if (opc & P_DATA16) {

        /* We should never be asking for both 16 and 64-bit operation.  */

        assert((opc & P_REXW) == 0);

        tcg_out8(s, 0x66);

    }

    if (opc & P_ADDR32) {

        tcg_out8(s, 0x67);

    }



    rex = 0;

    rex |= (opc & P_REXW) ? 0x8 : 0x0;  /* REX.W */

    rex |= (r & 8) >> 1;                /* REX.R */

    rex |= (x & 8) >> 2;                /* REX.X */

    rex |= (rm & 8) >> 3;               /* REX.B */



    /* P_REXB_{R,RM} indicates that the given register is the low byte.

       For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do,

       as otherwise the encoding indicates %[abcd]h.  Note that the values

       that are ORed in merely indicate that the REX byte must be present;

       those bits get discarded in output.  */

    rex |= opc & (r >= 4 ? P_REXB_R : 0);

    rex |= opc & ",1,0,3,0,0,0,0,0,1,0,0,0,0,1,0
2213,qemu,1,"qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset,

                            uint64_t bytes, QEMUIOVector *qiov)

{

    BDRVQcow2State *s = bs->opaque;

    QEMUIOVector hd_qiov;

    struct iovec iov;

    z_stream strm;

    int ret, out_len;

    uint8_t *buf, *out_buf;

    uint64_t cluster_offset;



    if (bytes == 0) {

        /* align end of file to a sector boundary to ease reading with

           sector based I/Os */

        cluster_offset = bdrv_getlength(bs->file->bs);

        return bdrv_truncate(bs->file, cluster_offset, PREALLOC_MODE_OFF, NULL);

    }



    buf = qemu_blockalign(bs, s->cluster_size);

    if (bytes != s->cluster_size) {

        if (bytes > s->cluster_size ||

            offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS)

        {

            qemu_vfree(buf);

            return -EINVAL;

        }

        /* Zero-pad last write if image size is not cluster aligned */

        memset(buf + bytes, 0, s->cluster_size - bytes);

    }

    qemu",0,0,3,0,0,0,1,1,1,1,1,0,1,1,1
2229,qemu,1,"static void gen_mfrom(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

#endif

}
",0,0,3,0,0,0,0,0,1,0,0,0,1,1,0
2246,FFmpeg,0,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",0,0,0,0,0,0,0,0,0,1,1,1,0,0,0
2265,qemu,0,"static gboolean ga_channel_open(GAChannel *c, const gchar *path,

                                GAChannelMethod method, int fd)

{

    int ret;

    c->method = method;



    switch (c->method) {

    case GA_CHANNEL_VIRTIO_SERIAL: {

        assert(fd < 0);

        fd = qemu_open(path, O_RDWR | O_NONBLOCK

#ifndef CONFIG_SOLARIS

                           | O_ASYNC

#endif

                           );

        if (fd == -1) {

            g_critical(""error opening channel: %s"", strerror(errno));

            return false;

        }

#ifdef CONFIG_SOLARIS

        ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI);

        if (ret == -1) {

            g_critical(""error setting event mask for channel: %s"",

                       strerror(errno));

            close(fd);

            return false;

        }

#endif

        ret = ga_channel_client_add(c, fd);

        if (ret) {

            g_critical(""error adding channel to main loop"");

            close(fd);

            return false;

  ",1,0,7,0,1,0,0,1,1,0,1,1,0,0,0
2280,qemu,0,"static int ram_save_block(QEMUFile *f)

{

    RAMBlock *block = last_block;

    ram_addr_t offset = last_offset;

    int bytes_sent = -1;

    MemoryRegion *mr;



    if (!block)

        block = QLIST_FIRST(&ram_list.blocks);



    do {

        mr = block->mr;

        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,

                                    DIRTY_MEMORY_MIGRATION)) {

            uint8_t *p;

            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;



            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,

                                      DIRTY_MEMORY_MIGRATION);



            p = memory_region_get_ram_ptr(mr) + offset;



            if (is_dup_page(p)) {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);

                qemu_put_byte(f, *p);

                bytes_sent = 1;

            } else {

                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);

                qemu_put_buffer(f, p, TA",0,0,3,0,0,0,1,1,1,0,0,0,1,1,1
2297,qemu,0,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,0,1
2298,FFmpeg,0,"yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *buf1, const uint16_t *ubuf0,

                     const uint16_t *ubuf1, const uint16_t *vbuf0,

                     const uint16_t *vbuf1, const uint16_t *abuf0,

                     const uint16_t *abuf1, uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target)

{

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;



        output_pixels(i * 4, Y1, U, Y2, V);

    }

}
",1,0,0,0,0,0,0,0,0,1,0,0,1,1,0
2300,FFmpeg,0,"static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,

                                              int linesize,

                                              int block_w, int block_h,

                                              int src_x, int src_y,

                                              int w, int h,

                                              emu_edge_core_func *core_fn)

{

    int start_y, start_x, end_y, end_x, src_y_add = 0;



    if (src_y >= h) {

        src_y_add = h - 1 - src_y;

        src_y     = h - 1;

    } else if (src_y <= -block_h) {

        src_y_add = 1 - block_h - src_y;

        src_y     = 1 - block_h;

    }

    if (src_x >= w) {

        src   += w - 1 - src_x;

        src_x  = w - 1;

    } else if (src_x <= -block_w) {

        src   += 1 - block_w - src_x;

        src_x  = 1 - block_w;

    }



    start_y = FFMAX(0, -src_y);

    start_x = FFMAX(0, -src_x);

    end_y   = FFMIN(block_h, h-src_y);

    end_x   = FFMIN(block_w, w-s",0,0,4,0,0,0,1,1,1,1,1,1,1,1,0
2325,FFmpeg,1,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
2328,qemu,1,"static void quorum_vote(QuorumAIOCB *acb)

{

    bool quorum = true;

    int i, j, ret;

    QuorumVoteValue hash;

    BDRVQuorumState *s = acb->common.bs->opaque;

    QuorumVoteVersion *winner;



    if (quorum_has_too_much_io_failed(acb)) {

        return;

    }



    /* get the index of the first successful read */

    for (i = 0; i < s->num_children; i++) {

        if (!acb->qcrs[i].ret) {

            break;

        }

    }



    assert(i < s->num_children);



    /* compare this read with all other successful reads stopping at quorum

     * failure

     */

    for (j = i + 1; j < s->num_children; j++) {

        if (acb->qcrs[j].ret) {

            continue;

        }

        quorum = quorum_compare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov);

        if (!quorum) {

            break;

       }

    }



    /* Every successful read agrees */

    if (quorum) {

        quorum_copy_qiov(acb->qiov, &acb->qcrs[i].qiov);

        return;

    }



    /* compute hashes for each succes",3,0,5,0,0,0,0,1,1,1,1,1,0,1,1
2329,qemu,1,"static void stellaris_init(const char *kernel_filename, const char *cpu_model,

                           stellaris_board_info *board)

{

    static const int uart_irq[] = {5, 6, 33, 34};

    static const int timer_irq[] = {19, 21, 23, 35};

    static const uint32_t gpio_addr[7] =

      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,

        0x40024000, 0x40025000, 0x40026000};

    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};



    qemu_irq *pic;

    DeviceState *gpio_dev[7];

    qemu_irq gpio_in[7][8];

    qemu_irq gpio_out[7][8];

    qemu_irq adc;

    int sram_size;

    int flash_size;

    I2CBus *i2c;

    DeviceState *dev;

    int i;

    int j;



    MemoryRegion *sram = g_new(MemoryRegion, 1);

    MemoryRegion *flash = g_new(MemoryRegion, 1);

    MemoryRegion *system_memory = get_system_memory();



    flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024;

    sram_size = ((board->dc0 >> 18) + 1) * 1024;



    /* Flash programming is done via the SCU, so pretend it is",0,0,0,0,0,0,1,1,1,1,0,0,0,0,0
2334,qemu,1,"void cpu_exec_init(CPUState *env)

{

    CPUState **penv;

    int cpu_index;



    if (!code_gen_ptr) {

        code_gen_ptr = code_gen_buffer;

        page_init();

        io_mem_init();

    }

    env->next_cpu = NULL;

    penv = &first_cpu;

    cpu_index = 0;

    while (*penv != NULL) {

        penv = (CPUState **)&(*penv)->next_cpu;

        cpu_index++;

    }

    env->cpu_index = cpu_index;


    *penv = env;

}",0,0,1,0,0,1,0,0,0,1,1,1,1,1,1
2348,FFmpeg,1,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	long width, long height,

	long lumStride, long chromStride, long dstStride)

{

	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0
2349,qemu,1,"static inline bool handler_is_async(const mon_cmd_t *cmd)

{

    return cmd->flags & MONITOR_CMD_ASYNC;

}
",0,0,0,0,0,0,1,1,0,0,1,0,0,0,0
2358,FFmpeg,1,"static int vqa_decode_init(AVCodecContext *avctx)

{

    VqaContext *s = (VqaContext *)avctx->priv_data;

    unsigned char *vqa_header;

    int i, j, codebook_index;;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    avctx->has_b_frames = 0;

    dsputil_init(&s->dsp, avctx);



    /* make sure the extradata made it */

    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  VQA video: expected extradata size of %d\n"", VQA_HEADER_SIZE);





    /* load up the VQA parameters from the header */

    vqa_header = (unsigned char *)s->avctx->extradata;

    s->vqa_version = vqa_header[0];

    s->width = LE_16(&vqa_header[6]);

    s->height = LE_16(&vqa_header[8]);





    s->vector_width = vqa_header[10];

    s->vector_height = vqa_header[11];

    s->partial_count = s->partial_countdown = vqa_header[13];



    /* the vector dimensions have to meet very stringent requirements */

    if ((s->vector_width != 4) ||

        ((s->vector_height != 2) ",0,0,2,0,0,0,0,1,1,1,0,1,1,1,1
2365,FFmpeg,0,"static int open_output_file(OptionsContext *o, const char *filename)

{

    AVFormatContext *oc;

    int i, j, err;

    AVOutputFormat *file_oformat;

    OutputFile *of;

    OutputStream *ost;

    InputStream  *ist;

    AVDictionary *unused_opts = NULL;

    AVDictionaryEntry *e = NULL;



    if (configure_complex_filters() < 0) {

        av_log(NULL, AV_LOG_FATAL, ""Error configuring filters.\n"");

        exit_program(1);

    }



    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {

        o->stop_time = INT64_MAX;

        av_log(NULL, AV_LOG_WARNING, ""-t and -to cannot be used together; using -t.\n"");

    }



    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {

        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;

        if (o->stop_time <= start_time) {

            av_log(NULL, AV_LOG_WARNING, ""-to value smaller than -ss; ignoring -to.\n"");

            o->stop_time = INT64_MAX;

        } else {

            o->recording_ti",1,0,4,0,0,0,0,0,0,0,0,0,1,1,1
2395,qemu,1,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,

                                   unsigned int imms, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int len;



    assert(immn < 2 && imms < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1",0,0,0,0,0,0,0,0,0,1,1,0,1,1,1
2400,FFmpeg,1,"static int add_candidate_ref(HEVCContext *s, RefPicList *list,

                             int poc, int ref_flag)

{

    HEVCFrame *ref = find_ref_idx(s, poc);



    if (ref == s->ref)

        return AVERROR_INVALIDDATA;



    if (!ref) {

        ref = generate_missing_ref(s, poc);

        if (!ref)

            return AVERROR(ENOMEM);

    }



    list->list[list->nb_refs] = ref->poc;

    list->ref[list->nb_refs]  = ref;

    list->nb_refs++;



    mark_ref(ref, ref_flag);

    return 0;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,1,1
2415,qemu,1,"static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)

{

    if (r < 0 || r > 15) {

        fprintf(stderr, ""wrong register write $p%d\n"", r);

    }

    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {

        return;

    } else if (r == PR_SRS) {

        tcg_gen_andi_tl(cpu_PR[r], tn, 3);

    } else {

        if (r == PR_PID) {

            gen_helper_tlb_flush_pid(cpu_env, tn);

        }

        if (dc->tb_flags & S_FLAG && r == PR_SPC) {

            gen_helper_spc_write(cpu_env, tn);

        } else if (r == PR_CCS) {

            dc->cpustate_changed = 1;

        }

        tcg_gen_mov_tl(cpu_PR[r], tn);

    }

}
",0,0,6,0,0,0,0,1,1,0,1,1,1,1,1
2424,FFmpeg,1,"static int vorbis_parse_id_hdr(vorbis_context *vc){

    GetBitContext *gb=&vc->gb;

    uint_fast8_t bl0, bl1;



    if ((get_bits(gb, 8)!='v') || (get_bits(gb, 8)!='o') ||

    (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') ||

    (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) {

        av_log(vc->avccontext, AV_LOG_ERROR, "" Vorbis id header packet corrupt (no vorbis signature). \n"");

        return 1;

    }



    vc->version=get_bits_long(gb, 32);    //FIXME check 0

    vc->audio_channels=get_bits(gb, 8);   //FIXME check >0

    vc->audio_samplerate=get_bits_long(gb, 32);   //FIXME check >0

    vc->bitrate_maximum=get_bits_long(gb, 32);

    vc->bitrate_nominal=get_bits_long(gb, 32);

    vc->bitrate_minimum=get_bits_long(gb, 32);

    bl0=get_bits(gb, 4);

    bl1=get_bits(gb, 4);

    vc->blocksize[0]=(1<<bl0);

    vc->blocksize[1]=(1<<bl1);

    if (bl0>13 || bl0<6 || bl1>13 || bl1<6 || bl1<bl0) {

        av_log(vc->avccontext, AV_LOG_ERROR, "" Vorbis id header packet corrupt (illegal bloc",0,0,2,0,0,0,0,0,1,0,0,0,0,0,0
2429,FFmpeg,0,"void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2,

                                         src - (stride * 2) +

                                         sizeof(uint8_t), stride, dst, stride);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,1
2451,qemu,1,"static int net_vhost_user_init(NetClientState *peer, const char *device,

                               const char *name, CharDriverState *chr,

                               int queues)

{

    NetClientState *nc;

    VhostUserState *s;

    int i;



    for (i = 0; i < queues; i++) {

        nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name);



        snprintf(nc->info_str, sizeof(nc->info_str), ""vhost-user%d to %s"",

                 i, chr->label);



        nc->queue_index = i;



        s = DO_UPCAST(VhostUserState, nc, nc);

        s->chr = chr;

    }



    qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name);



    return 0;

}
",1,0,0,0,0,0,1,1,1,1,1,1,1,0,0
2466,FFmpeg,0,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
",0,0,2,0,0,0,0,0,0,0,1,0,0,0,0
2471,qemu,0,"static void scsi_read_data(SCSIDevice *d, uint32_t tag)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);

    SCSIDiskReq *r;



    r = scsi_find_request(s, tag);

    if (!r) {

        BADF(""Bad read tag 0x%x\n"", tag);

        /* ??? This is the wrong error.  */

        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    scsi_read_request(r);

}
",0,0,1,0,0,0,0,1,1,1,1,1,1,1,1
2502,FFmpeg,0,"static void opt_output_file(void *optctx, const char *filename)

{

    OptionsContext *o = optctx;

    AVFormatContext *oc;

    int i, err;

    AVOutputFormat *file_oformat;

    OutputStream *ost;

    InputStream  *ist;



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    oc = avformat_alloc_context();

    if (!oc) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }



    if (last_asked_format) {

        file_oformat = av_guess_format(last_asked_format, NULL, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Requested output format '%s' is not a suitable output format\n"", last_asked_format);

            exit_program(1);

        }

        last_asked_format = NULL;

    } else {

        file_oformat = av_guess_format(NULL, filename, NULL);

        if (!file_oformat) {

            fprintf(stderr, ""Unable to find a suitable output format for '%s'\n"",

                    filename);

            exit_program(1);

        }

    }



",16,0,5,0,0,0,0,0,0,0,0,0,0,1,0
2523,qemu,0,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
",0,0,0,0,0,0,0,0,0,0,1,1,0,1,1
2534,FFmpeg,0,"static int read_gab2_sub(AVStream *st, AVPacket *pkt)

{

    if (pkt->size >= 7 &&

        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {

        uint8_t desc[256];

        int score      = AVPROBE_SCORE_EXTENSION, ret;

        AVIStream *ast = st->priv_data;

        AVInputFormat *sub_demuxer;

        AVRational time_base;

        AVIOContext *pb = avio_alloc_context(pkt->data + 7,

                                             pkt->size - 7,

                                             0, NULL, NULL, NULL, NULL);

        AVProbeData pd;

        unsigned int desc_len = avio_rl32(pb);



        if (desc_len > pb->buf_end - pb->buf_ptr)

            goto error;



        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));

        avio_skip(pb, desc_len - ret);

        if (*desc)

            av_dict_set(&st->metadata, ""title"", desc, 0);



        avio_rl16(pb);   /* flags? */

        avio_rl32(pb);   /* data size */



        pd = (AVProbeData) { .buf      = pb->buf_ptr,

 ",0,1,3,0,0,0,0,0,0,0,0,0,0,0,0
2535,qemu,0,"bool machine_iommu(MachineState *machine)

{

    return machine->iommu;

}
",0,0,0,0,0,0,0,1,0,1,1,1,1,0,1
2538,qemu,0,"static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)

{

    uint32_t rd;

    TCGv tmp, tmp2;



    /* M profile cores use memory mapped registers instead of cp15.  */

    if (arm_feature(env, ARM_FEATURE_M))

	return 1;



    if ((insn & (1 << 25)) == 0) {

        if (insn & (1 << 20)) {

            /* mrrc */

            return 1;

        }

        /* mcrr.  Used for block cache operations, so implement as no-op.  */

        return 0;

    }

    if ((insn & (1 << 4)) == 0) {

        /* cdp */

        return 1;

    }

    if (IS_USER(s) && !cp15_user_ok(insn)) {

        return 1;

    }

    if ((insn & 0x0fff0fff) == 0x0e070f90

        || (insn & 0x0fff0fff) == 0x0e070f58) {

        /* Wait for interrupt.  */

        gen_set_pc_im(s->pc);

        s->is_jmp = DISAS_WFI;

        return 0;

    }

    rd = (insn >> 12) & 0xf;



    if (cp15_tls_load_store(env, s, insn, rd))

        return 0;



    tmp2 = tcg_const_i32(insn);

    if (insn & ARM_CP_RW_BIT) {

        ",0,0,8,0,0,0,0,0,0,0,0,0,0,1,1
2564,qemu,0,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
",0,0,0,0,0,0,1,1,0,0,0,1,0,1,1
2583,qemu,0,"USBDevice *usb_host_device_open(const char *devname)

{

    int fd = -1, ret;

    USBHostDevice *dev = NULL;

    struct usbdevfs_connectinfo ci;

    char buf[1024];

    int bus_num, addr;

    char product_name[PRODUCT_NAME_SZ];



    dev = qemu_mallocz(sizeof(USBHostDevice));

    if (!dev)

        goto fail;



#ifdef DEBUG_ISOCH

    printf(""usb_host_device_open %s\n"", devname);

#endif

    if (usb_host_find_device(&bus_num, &addr,

                             product_name, sizeof(product_name),

                             devname) < 0)

        return NULL;



    snprintf(buf, sizeof(buf), USBDEVFS_PATH ""/%03d/%03d"",

             bus_num, addr);

    fd = open(buf, O_RDWR | O_NONBLOCK);

    if (fd < 0) {

        perror(buf);

        return NULL;

    }



    /* read the device description */

    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));

    if (dev->descr_len <= 0) {

        perror(""usb_host_device_open: reading device data failed"");

        goto fail;

    }



#ifde",0,2,7,0,0,0,0,0,0,0,0,0,0,1,0
2594,qemu,0,"uint64_t helper_frsp(CPUPPCState *env, uint64_t arg)

{

    CPU_DoubleU farg;

    float32 f32;



    farg.ll = arg;



    if (unlikely(float64_is_signaling_nan(farg.d))) {

        /* sNaN square root */

        fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

    }

    f32 = float64_to_float32(farg.d, &env->fp_status);

    farg.d = float32_to_float64(f32, &env->fp_status);



    return farg.ll;

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
2602,qemu,0,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,0
2604,qemu,0,"void bdrv_round_to_clusters(BlockDriverState *bs,

                            int64_t sector_num, int nb_sectors,

                            int64_t *cluster_sector_num,

                            int *cluster_nb_sectors)

{

    BlockDriverInfo bdi;



    if (bdrv_get_info(bs, &bdi) < 0 || bdi.cluster_size == 0) {

        *cluster_sector_num = sector_num;

        *cluster_nb_sectors = nb_sectors;

    } else {

        int64_t c = bdi.cluster_size / BDRV_SECTOR_SIZE;

        *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, c);

        *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num +

                                            nb_sectors, c);

    }

}
",0,0,1,0,0,0,1,1,1,1,1,1,0,0,0
2620,qemu,1,"void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length)

{

    CPUArchState *env;



    int mmu_idx;



    assert_cpu_is_self(cpu);



    env = cpu->env_ptr;

    for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) {

        unsigned int i;



        for (i = 0; i < CPU_TLB_SIZE; i++) {

            tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i],

                                  start1, length);

        }



        for (i = 0; i < CPU_VTLB_SIZE; i++) {

            tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i],

                                  start1, length);

        }

    }

}
",3,0,0,0,0,0,1,1,1,1,1,1,0,0,0
2622,qemu,1,"blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,
                   QEMUIOVector *qiov, int flags)
{
    BDRVBlkdebugState *s = bs->opaque;
    BlkdebugRule *rule = NULL;
    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {
        uint64_t inject_offset = rule->options.inject.offset;
        if (inject_offset == -1 ||
            (inject_offset >= offset && inject_offset < offset + bytes))
        {
            break;
    if (rule && rule->options.inject.error) {
        return inject_error(bs, rule);
    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);",0,0,2,0,0,0,1,1,1,0,0,0,1,1,0
2624,qemu,1,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
",0,0,0,0,0,0,1,1,1,1,0,1,0,0,1
2628,qemu,0,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,

                                  tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);

    if (arg != (arg & 0xfff))

        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));

    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |

              INSN_IMM13(arg & 0x3ff));

#else

    tcg_out_ld_raw(s, ret, arg);

#endif

}
",0,0,4,0,0,0,0,0,0,0,0,0,0,1,1
2632,qemu,0,"int xen_config_dev_blk(DriveInfo *disk)

{

    char fe[256], be[256];

    int vdev = 202 * 256 + 16 * disk->unit;

    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;

    const char *devtype = cdrom ? ""cdrom"" : ""disk"";

    const char *mode    = cdrom ? ""r""     : ""w"";



    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),

	     ""xvd%c"", 'a' + disk->unit);

    xen_be_printf(NULL, 1, ""config disk %d [%s]: %s\n"",

                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);

    xen_config_dev_dirs(""vbd"", ""qdisk"", vdev, fe, be, sizeof(fe));



    /* frontend */

    xenstore_write_int(fe, ""virtual-device"",  vdev);

    xenstore_write_str(fe, ""device-type"",     devtype);



    /* backend */

    xenstore_write_str(be, ""dev"",             disk->bdrv->device_name);

    xenstore_write_str(be, ""type"",            ""file"");

    xenstore_write_str(be, ""params"",          disk->bdrv->filename);

    xenstore_write_str(be, ""mode"",            mode);



    /* common stuff */

    ",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0
2634,qemu,0,"static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu,

                                                  TranslationBlock *tb,

                                                  int search_pc)

{

    CPUState *cs = CPU(cpu);

    struct DisasContext ctx, *dc = &ctx;

    uint16_t *gen_opc_end;

    uint32_t pc_start;

    int j, k;

    uint32_t next_page_start;

    int num_insns;

    int max_insns;



    pc_start = tb->pc;

    dc->tb = tb;



    gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE;

    dc->is_jmp = DISAS_NEXT;

    dc->ppc = pc_start;

    dc->pc = pc_start;

    dc->flags = cpu->env.cpucfgr;

    dc->mem_idx = cpu_mmu_index(&cpu->env);

    dc->synced_flags = dc->tb_flags = tb->flags;

    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);

    dc->singlestep_enabled = cs->singlestep_enabled;

    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {

        qemu_log(""-----------------------------------------\n"");

        log_cpu_state(CPU(cpu), 0);

    }



    next_page_start = (p",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
2649,qemu,1,"static void pci_ivshmem_realize(PCIDevice *dev, Error **errp)

{

    IVShmemState *s = IVSHMEM(dev);

    Error *err = NULL;

    uint8_t *pci_conf;

    uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY |

        PCI_BASE_ADDRESS_MEM_PREFETCH;



    if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) {

        error_setg(errp,

                   ""You must specify either 'shm', 'chardev' or 'x-memdev'"");

        return;

    }



    if (s->hostmem) {

        MemoryRegion *mr;



        if (s->sizearg) {

            g_warning(""size argument ignored with hostmem"");

        }



        mr = host_memory_backend_get_memory(s->hostmem, &error_abort);

        s->ivshmem_size = memory_region_size(mr);

    } else if (s->sizearg == NULL) {

        s->ivshmem_size = 4 << 20; /* 4 MB default */

    } else {

        char *end;

        int64_t size = qemu_strtosz(s->sizearg, &end);

        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {

            error_setg(errp, ""Invalid size %s"", s->sizearg);
",0,0,6,0,0,0,0,1,0,0,0,0,1,1,1
2656,qemu,1,"int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info)

{

    fprintf_function fprintf_fn = info->fprintf_func;

    void *stream = info->stream;

    int rc;

    uint8_t insn[4];

    const Lm32OpcodeInfo *opc_info;

    uint32_t op;

    const char *args_fmt;



    rc = info->read_memory_func(memaddr, insn, 4, info);

    if (rc != 0) {

        info->memory_error_func(rc, memaddr, info);

        return -1;

    }



    fprintf_fn(stream, ""%02x %02x %02x %02x    "",

            insn[0], insn[1], insn[2], insn[3]);



    op = bfd_getb32(insn);

    opc_info = find_opcode_info(op);

    if (opc_info) {

        fprintf_fn(stream, ""%-8s "", opc_info->name);

        args_fmt = opc_info->args_fmt;

        while (args_fmt && *args_fmt) {

            if (*args_fmt == '%') {

                switch (*(++args_fmt)) {

                case '0': {

                    uint8_t r0;

                    const char *r0_name;

                    r0 = (op >> 21) & 0x1f;

                    r0_name = f",0,0,3,0,1,1,1,1,1,1,1,1,0,0,0
2665,FFmpeg,0,"static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,

                   uint8_t *properties)

{

    int compno;



    if (s->buf_end - s->buf < 2)

        return AVERROR(EINVAL);



    compno = bytestream_get_byte(&s->buf);



    c      += compno;

    c->csty = bytestream_get_byte(&s->buf);

    get_cox(s, c);



    properties[compno] |= HAD_COC;

    return 0;

}
",0,0,1,0,0,0,1,1,0,1,1,1,1,1,1
2673,qemu,1,"static void curses_setup(void)

{

    int i, colour_default[8] = {

        COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN,

        COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE,

    };



    /* input as raw as possible, let everything be interpreted

     * by the guest system */

    initscr(); noecho(); intrflush(stdscr, FALSE);

    nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE);

    start_color(); raw(); scrollok(stdscr, FALSE);



    for (i = 0; i < 64; i ++)

        init_pair(i, colour_default[i & 7], colour_default[i >> 3]);

}
",1,0,0,0,0,0,1,1,1,1,1,1,0,1,1
2677,FFmpeg,1,"static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int i;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""pxor %%mm2, %%mm2		\n\t"" // 2*xalpha

			""movd %5, %%mm6			\n\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""movq %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	\n\t""

			""movd %4, %%mm6			\",0,0,7,0,0,0,1,1,1,1,1,1,0,1,0
2680,qemu,1,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",0,0,1,0,0,0,0,1,0,0,0,0,0,1,0
2704,FFmpeg,1,"static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,

                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,

                              const uint8_t *buf, int len, uint16_t seq,

                              int flags)

{

    uint8_t nal;

    uint8_t type;

    int result = 0;



    if (!len) {

        av_log(ctx, AV_LOG_ERROR, ""Empty H264 RTP packet\n"");

        return AVERROR_INVALIDDATA;

    }

    nal  = buf[0];

    type = nal & 0x1f;



    assert(data);

    assert(buf);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (type >= 1 && type <= 23)

        type = 1;

    switch (type) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(pkt, len + sizeof(start_sequence));

        memcpy(pkt->data, start_sequence, sizeof(start_sequence));

        memcpy(pkt->data + sizeof(start_sequence), buf, len);

        COUNT_NAL_TYPE(data, nal)",0,0,3,0,1,0,0,0,0,1,0,0,1,1,1
2737,qemu,0,"void bdrv_refresh_filename(BlockDriverState *bs)

{

    BlockDriver *drv = bs->drv;

    QDict *opts;



    if (!drv) {

        return;

    }



    /* This BDS's file name will most probably depend on its file's name, so

     * refresh that first */

    if (bs->file) {

        bdrv_refresh_filename(bs->file->bs);

    }



    if (drv->bdrv_refresh_filename) {

        /* Obsolete information is of no use here, so drop the old file name

         * information before refreshing it */

        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

        }



        drv->bdrv_refresh_filename(bs);

    } else if (bs->file) {

        /* Try to reconstruct valid information from the underlying file */

        bool has_open_options;



        bs->exact_filename[0] = '\0';

        if (bs->full_open_options) {

            QDECREF(bs->full_open_options);

            bs->full_open_options = NULL;

   ",3,0,6,0,0,0,1,1,1,1,1,1,1,1,1
2762,qemu,0,"static inline bool cpu_handle_exception(CPUState *cpu, int *ret)

{

    if (cpu->exception_index >= 0) {

        if (cpu->exception_index >= EXCP_INTERRUPT) {

            /* exit request from the cpu execution loop */

            *ret = cpu->exception_index;

            if (*ret == EXCP_DEBUG) {

                cpu_handle_debug_exception(cpu);

            }

            cpu->exception_index = -1;

            return true;

        } else {

#if defined(CONFIG_USER_ONLY)

            /* if user mode only, we simulate a fake exception

               which will be handled outside the cpu execution

               loop */

#if defined(TARGET_I386)

            CPUClass *cc = CPU_GET_CLASS(cpu);

            cc->do_interrupt(cpu);

#endif

            *ret = cpu->exception_index;

            cpu->exception_index = -1;

            return true;

#else

            if (replay_exception()) {

                CPUClass *cc = CPU_GET_CLASS(cpu);

                qemu_mutex_lock_iothread();

                cc->",0,0,8,0,0,0,1,1,1,0,0,0,0,0,0
2793,FFmpeg,0,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)

{

#if HAVE_INLINE_ASM

    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {

        if (ctx->cid_table->bit_depth == 8)

            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;

    }

#endif /* HAVE_INLINE_ASM */

}
",0,0,4,0,0,0,1,0,0,1,0,0,1,1,1
2806,qemu,0,"uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2)

{

    CPU_DoubleU farg1, farg2;



    farg1.ll = arg1;

    farg2.ll = arg2;



    if (unlikely(float64_is_infinity(farg1.d) &&

                 float64_is_infinity(farg2.d))) {

        /* Division of infinity by infinity */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI);

    } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) {

        /* Division of zero by zero */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ);

    } else {

        if (unlikely(float64_is_signaling_nan(farg1.d) ||

                     float64_is_signaling_nan(farg2.d))) {

            /* sNaN division */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

        }

        farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status);

    }



    return farg1.ll;

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
2817,qemu,0,"static void test_io_channel_ipv4(bool async)

{

    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    SocketAddress *connect_addr = g_new0(SocketAddress, 1);



    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    listen_addr->u.inet = g_new0(InetSocketAddress, 1);

    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");

    listen_addr->u.inet->port = NULL; /* Auto-select */



    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);



    qapi_free_SocketAddress(listen_addr);

    qapi_free_SocketAddress(connect_addr);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,0
2818,qemu,0,"static void gen_loongson_multimedia(DisasContext *ctx, int rd, int rs, int rt)

{

    const char *opn = ""loongson_cp2"";

    uint32_t opc, shift_max;

    TCGv_i64 t0, t1;



    opc = MASK_LMI(ctx->opcode);

    switch (opc) {

    case OPC_ADD_CP2:

    case OPC_SUB_CP2:

    case OPC_DADD_CP2:

    case OPC_DSUB_CP2:

        t0 = tcg_temp_local_new_i64();

        t1 = tcg_temp_local_new_i64();

        break;

    default:

        t0 = tcg_temp_new_i64();

        t1 = tcg_temp_new_i64();

        break;

    }



    gen_load_fpr64(ctx, t0, rs);

    gen_load_fpr64(ctx, t1, rt);



#define LMI_HELPER(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break

#define LMI_HELPER_1(UP, LO) \

    case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break

#define LMI_DIRECT(UP, LO, OP) \

    case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break



    switch (opc) {

    LMI_HELPER(PADDSH, paddsh);

    LMI_HELPER(PADDUSH, paddush);

    LMI_HELPER(PADDH, paddh);

    LMI_HELPE",0,0,1,0,2,0,0,0,0,0,0,0,0,0,1
2820,qemu,0,"static void v9fs_stat(void *opaque)

{

    int32_t fid;

    V9fsStat v9stat;

    ssize_t err = 0;

    size_t offset = 7;

    struct stat stbuf;

    V9fsFidState *fidp;

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;



    pdu_unmarshal(pdu, offset, ""d"", &fid);

    trace_v9fs_stat(pdu->tag, pdu->id, fid);



    fidp = get_fid(pdu, fid);

    if (fidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }

    err = v9fs_co_lstat(pdu, &fidp->path, &stbuf);

    if (err < 0) {

        goto out;

    }

    err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat);

    if (err < 0) {

        goto out;

    }

    offset += pdu_marshal(pdu, offset, ""wS"", 0, &v9stat);

    err = offset;

    trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode,

                           v9stat.atime, v9stat.mtime, v9stat.length);

    v9fs_stat_free(&v9stat);

out:

    put_fid(pdu, fidp);

out_nofid:

    complete_pdu(s, pdu, err);

}
",0,3,3,0,0,0,1,1,1,1,1,1,0,0,0
2832,qemu,1,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)

{

    uint64_t tmp = op1;

    op1 = (uint32_t)(op1 + op2);

    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {

        arith_excp(env, GETPC(), EXC_M_IOV, 0);

    }

    return op1;

}
",0,0,1,0,0,0,0,0,1,0,0,0,0,0,1
2846,qemu,1,"static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *group,

                                   RockerTlv **group_tlvs)

{

    OfDpaGroup *l2_group;

    RockerTlv **tlvs;

    int err;

    int i;



    if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] ||

        !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) {

        return -ROCKER_EINVAL;

    }



    group->l2_flood.group_count =

        rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]);



    tlvs = g_malloc0((group->l2_flood.group_count + 1) *

                     sizeof(RockerTlv *));

    if (!tlvs) {

        return -ROCKER_ENOMEM;

    }



    g_free(group->l2_flood.group_ids);

    group->l2_flood.group_ids =

        g_malloc0(group->l2_flood.group_count * sizeof(uint32_t));

    if (!group->l2_flood.group_ids) {

        err = -ROCKER_ENOMEM;

        goto err_out;

    }



    rocker_tlv_parse_nested(tlvs, group->l2_flood.group_count,

                            group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]);



    for (i = ",1,1,3,0,0,0,1,1,1,1,0,0,1,0,0
2857,FFmpeg,1,"int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {

    const uint64_t fuzz_tag = FUZZ_TAG;

    FuzzDataBuffer buffer;

    const uint8_t *last = data;

    const uint8_t *end = data + size;

    uint32_t it = 0;



    if (!c)

        c = AVCodecInitialize(FFMPEG_CODEC);  // Done once.



    AVCodecContext* ctx = avcodec_alloc_context3(NULL);

    if (!ctx)

        error(""Failed memory allocation"");



    ctx->max_pixels = 4096 * 4096; //To reduce false positive OOM and hangs



    int res = avcodec_open2(ctx, c, NULL);

    if (res < 0)

        return res;



    FDBCreate(&buffer);

    int got_frame;

    AVFrame *frame = av_frame_alloc();

    if (!frame)

        error(""Failed memory allocation"");



    // Read very simple container

    AVPacket avpkt;

    while (data < end && it < maxiteration) {

        // Search for the TAG

        while (data + sizeof(fuzz_tag) < end) {

            if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag)

                br",0,0,5,0,0,2,1,0,1,1,1,1,1,1,0
2880,qemu,0,"void op_cp1_64bitmode(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR))) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
2884,qemu,0,"void disas_a64_insn(CPUARMState *env, DisasContext *s)

{

    uint32_t insn;



    insn = arm_ldl_code(env, s->pc, s->bswap_code);

    s->insn = insn;

    s->pc += 4;



    switch ((insn >> 24) & 0x1f) {

    default:

        unallocated_encoding(s);

        break;

    }



    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {

        /* go through the main loop for single step */

        s->is_jmp = DISAS_JUMP;

    }

}
",0,0,1,0,1,0,0,1,0,1,1,0,0,0,0
2895,qemu,0,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(t0, t0);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(t0, cpu_regs[reg]);

        break;

    }

}
",0,1,1,0,1,0,0,0,0,0,0,0,1,0,0
2903,qemu,0,"static int hdev_open(BlockDriverState *bs, const char *filename, int flags)

{

    BDRVRawState *s = bs->opaque;

    int access_flags, create_flags;

    DWORD overlapped;

    char device_name[64];



    if (strstart(filename, ""/dev/cdrom"", NULL)) {

        if (find_cdrom(device_name, sizeof(device_name)) < 0)

            return -ENOENT;

        filename = device_name;

    } else {

        /* transform drive letters into device name */

        if (((filename[0] >= 'a' && filename[0] <= 'z') ||

             (filename[0] >= 'A' && filename[0] <= 'Z')) &&

            filename[1] == ':' && filename[2] == '\0') {

            snprintf(device_name, sizeof(device_name), ""\\\\.\\%c:"", filename[0]);

            filename = device_name;

        }

    }

    s->type = find_device_type(bs, filename);

    

    if ((flags & BDRV_O_ACCESS) == O_RDWR) {

        access_flags = GENERIC_READ | GENERIC_WRITE;

    } else {

        access_flags = GENERIC_READ;

    }

    create_flags = OPEN_EXISTING;



#ifdef ",0,0,5,0,0,0,1,1,1,0,1,0,1,1,1
2911,qemu,0,"static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg)

{

    S390CPU *cpu = S390_CPU(cs);

    SigpInfo *si = arg.host_ptr;



    if (!s390_has_feat(S390_FEAT_VECTOR)) {

        set_sigp_status(si, SIGP_STAT_INVALID_ORDER);

        return;

    }



    /* cpu has to be stopped */

    if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) {

        set_sigp_status(si, SIGP_STAT_INCORRECT_STATE);

        return;

    }



    /* parameter must be aligned to 1024-byte boundary */

    if (si->param & 0x3ff) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }



    cpu_synchronize_state(cs);



    if (kvm_s390_store_adtl_status(cpu, si->param)) {

        set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER);

        return;

    }

    si->cc = SIGP_CC_ORDER_CODE_ACCEPTED;

}
",0,0,4,0,0,0,1,1,1,1,0,0,0,0,0
2913,qemu,0,"static int cpu_gdb_write_register(CPUState *env, uint8_t *mem_buf, int n)

{

    target_ulong tmp;



    tmp = ldtul_p(mem_buf);



    if (n < 32) {

        env->active_tc.gpr[n] = tmp;

        return sizeof(target_ulong);

    }

    if (env->CP0_Config1 & (1 << CP0C1_FP)

            && n >= 38 && n < 73) {

        if (n < 70) {

            if (env->CP0_Status & (1 << CP0St_FR))

              env->active_fpu.fpr[n - 38].d = tmp;

            else

              env->active_fpu.fpr[n - 38].w[FP_ENDIAN_IDX] = tmp;

        }

        switch (n) {

        case 70:

            env->active_fpu.fcr31 = tmp & 0xFF83FFFF;

            /* set rounding mode */

            RESTORE_ROUNDING_MODE;

#ifndef CONFIG_SOFTFLOAT

            /* no floating point exception for native float */

            SET_FP_ENABLE(env->active_fpu.fcr31, 0);

#endif

            break;

        case 71: env->active_fpu.fcr0 = tmp; break;

        }

        return sizeof(target_ulong);

    }

    switch (n) {

    case 32: env-",0,0,6,0,2,0,0,0,0,1,0,0,1,1,1
2914,qemu,0,"QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)

{

    QEMUBH *bh;

    bh = g_malloc0(sizeof(QEMUBH));

    bh->ctx = ctx;

    bh->cb = cb;

    bh->opaque = opaque;

    qemu_mutex_lock(&ctx->bh_lock);

    bh->next = ctx->first_bh;

    /* Make sure that the members are ready before putting bh into list */

    smp_wmb();

    ctx->first_bh = bh;

    qemu_mutex_unlock(&ctx->bh_lock);

    return bh;

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
2929,FFmpeg,0,"static void audiogen(void *data, enum AVSampleFormat sample_fmt,

                     int channels, int sample_rate, int nb_samples)

{

    int i, ch, k;

    double v, f, a, ampa;

    double tabf1[SWR_CH_MAX];

    double tabf2[SWR_CH_MAX];

    double taba[SWR_CH_MAX];

    unsigned static rnd;



#define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v);

#define uint_rand(x) (x = x * 1664525 + 1013904223)

#define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1)

    k = 0;



    /* 1 second of single freq sinus at 1000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

        a += M_PI * 1000.0 * 2.0 / sample_rate;

    }



    /* 1 second of varying frequency between 100 and 10000 Hz */

    a = 0;

    for (i = 0; i < 1 * sample_rate && k < nb_samples; i++, k++) {

        v = sin(a) * 0.30;

        for (ch = 0; ch < channels; ch++)

            PUT_SAMPLE

 ",4,0,0,0,0,0,0,1,1,0,1,1,0,0,0
2946,FFmpeg,1,"static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab)

{

    CURSORINFO ci = {0};



#define CURSOR_ERROR(str)                 \

    if (!gdigrab->cursor_error_printed) {       \

        WIN32_API_ERROR(str);             \

        gdigrab->cursor_error_printed = 1;      \

    }



    ci.cbSize = sizeof(ci);



    if (GetCursorInfo(&ci)) {

        HCURSOR icon = CopyCursor(ci.hCursor);

        ICONINFO info;

        POINT pos;

        RECT clip_rect = gdigrab->clip_rect;

        HWND hwnd = gdigrab->hwnd;

        info.hbmMask = NULL;

        info.hbmColor = NULL;



        if (ci.flags != CURSOR_SHOWING)

            return;



        if (!icon) {

            /* Use the standard arrow cursor as a fallback.

             * You'll probably only hit this in Wine, which can't fetch

             * the current system cursor. */

            icon = CopyCursor(LoadCursor(NULL, IDC_ARROW));

        }



        if (!GetIconInfo(icon, &info)) {

            CURSOR_ERROR(""Could ",0,0,5,0,0,0,0,0,0,0,0,0,0,0,0
2950,qemu,1,"static void machine_initfn(Object *obj)

{

    MachineState *ms = MACHINE(obj);



    ms->kernel_irqchip_allowed = true;

    ms->kvm_shadow_mem = -1;

    ms->dump_guest_core = true;




    object_property_add_str(obj, ""accel"",

                            machine_get_accel, machine_set_accel, NULL);

    object_property_set_description(obj, ""accel"",

                                    ""Accelerator list"",

                                    NULL);

    object_property_add_bool(obj, ""kernel-irqchip"",

                             NULL,

                             machine_set_kernel_irqchip,

                             NULL);

    object_property_set_description(obj, ""kernel-irqchip"",

                                    ""Use KVM in-kernel irqchip"",

                                    NULL);

    object_property_add(obj, ""kvm-shadow-mem"", ""int"",

                        machine_get_kvm_shadow_mem,

                        machine_set_kvm_shadow_mem,

                        NULL, NULL, NULL);

    ob",0,0,0,0,0,0,0,0,0,1,1,0,0,0,0
2958,qemu,1,"void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->peer);



    /* remove from list, if necessary */

    if (bs->device_name[0] != '\0') {

        QTAILQ_REMOVE(&bdrv_states, bs, list);

    }



    bdrv_close(bs);

    if (bs->file != NULL) {

        bdrv_delete(bs->file);

    }



    assert(bs != bs_snapshots);

    qemu_free(bs);

}
",0,0,2,0,0,0,0,0,0,1,0,0,0,0,0
2967,qemu,1,"static void hmp_migrate_status_cb(void *opaque)

{

    MigrationStatus *status = opaque;

    MigrationInfo *info;



    info = qmp_query_migrate(NULL);

    if (!info->has_status || strcmp(info->status, ""active"") == 0) {

        if (info->has_disk) {

            int progress;



            if (info->disk->remaining) {

                progress = info->disk->transferred * 100 / info->disk->total;

            } else {

                progress = 100;

            }



            monitor_printf(status->mon, ""Completed %d %%\r"", progress);

            monitor_flush(status->mon);

        }



        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);

    } else {

        if (status->is_block_migration) {

            monitor_printf(status->mon, ""\n"");

        }

        monitor_resume(status->mon);

        timer_del(status->timer);

        g_free(status);

    }



    qapi_free_MigrationInfo(info);

}
",0,0,4,0,0,0,1,1,1,1,1,1,0,0,0
2996,qemu,0,"int kvm_arch_on_sigbus(int code, void *addr)

{

#ifdef KVM_CAP_MCE

    if ((first_cpu->mcg_cap & MCG_SER_P) && addr && code == BUS_MCEERR_AO) {

        void *vaddr;

        ram_addr_t ram_addr;

        target_phys_addr_t paddr;



        /* Hope we are lucky for AO MCE */

        vaddr = addr;

        if (qemu_ram_addr_from_host(vaddr, &ram_addr) ||

            !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, ram_addr,

                                               &paddr)) {

            fprintf(stderr, ""Hardware memory error for memory used by ""

                    ""QEMU itself instead of guest system!: %p\n"", addr);

            return 0;

        }

        kvm_mce_inj_srao_memscrub2(first_cpu, paddr);

    } else

#endif /* KVM_CAP_MCE */

    {

        if (code == BUS_MCEERR_AO) {

            return 0;

        } else if (code == BUS_MCEERR_AR) {

            hardware_memory_error();

        } else {

            return 1;

        }

    }

    return 0;

}
",1,0,6,0,0,0,0,0,1,0,0,0,0,0,0
3001,qemu,1,"coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes)

{

    IscsiLun *iscsilun = bs->opaque;

    struct IscsiTask iTask;

    struct unmap_list list;

    int r = 0;



    if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) {

        return -ENOTSUP;

    }



    if (!iscsilun->lbp.lbpu) {

        /* UNMAP is not supported by the target */

        return 0;

    }



    list.lba = offset / iscsilun->block_size;

    list.num = bytes / iscsilun->block_size;



    iscsi_co_init_iscsitask(iscsilun, &iTask);

    qemu_mutex_lock(&iscsilun->mutex);

retry:

    if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1,

                         iscsi_co_generic_cb, &iTask) == NULL) {

        r = -ENOMEM;

        goto out_unlock;

    }



    while (!iTask.complete) {

        iscsi_set_events(iscsilun);

        qemu_mutex_unlock(&iscsilun->mutex);

        qemu_coroutine_yield();

        qemu_mutex_lock(&iscsilun->mutex);

    }



    if (iTask.task != NUL",0,1,4,0,0,1,0,0,0,1,0,0,0,0,0
3003,qemu,1,"int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw,

                              int mmu_idx)

{

    MIPSCPU *cpu = MIPS_CPU(cs);

    CPUMIPSState *env = &cpu->env;

#if !defined(CONFIG_USER_ONLY)

    hwaddr physical;

    int prot;

    int access_type;

#endif

    int ret = 0;



#if 0

    log_cpu_state(cs, 0);

#endif

    qemu_log_mask(CPU_LOG_MMU,

              ""%s pc "" TARGET_FMT_lx "" ad %"" VADDR_PRIx "" rw %d mmu_idx %d\n"",

              __func__, env->active_tc.PC, address, rw, mmu_idx);



    /* data access */

#if !defined(CONFIG_USER_ONLY)

    /* XXX: put correct access by using cpu_restore_state()

       correctly */

    access_type = ACCESS_INT;

    ret = get_physical_address(env, &physical, &prot,

                               address, rw, access_type);

    qemu_log_mask(CPU_LOG_MMU,

             ""%s address=%"" VADDR_PRIx "" ret %d physical "" TARGET_FMT_plx

             "" prot %d\n"",

             __func__, address, ret, physical, prot);

    if (ret == TLBRET_MAT",0,0,6,0,0,0,0,1,0,1,0,1,0,1,0
3020,qemu,0,"static ModuleTypeList *find_type(module_init_type type)

{

    ModuleTypeList *l;



    init_types();



    l = &init_type_list[type];



    return l;

}
",0,0,0,0,0,0,0,0,0,0,0,1,1,0,1
3040,qemu,0,"static int qemu_suspend_requested(void)

{

    int r = suspend_requested;

    suspend_requested = 0;

    return r;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3054,FFmpeg,0,"int opt_cpuflags(const char *opt, const char *arg)

{

#define CPUFLAG_MMX2     (AV_CPU_FLAG_MMX      | AV_CPU_FLAG_MMX2)

#define CPUFLAG_3DNOW    (AV_CPU_FLAG_3DNOW    | AV_CPU_FLAG_MMX)

#define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW)

#define CPUFLAG_SSE      (AV_CPU_FLAG_SSE      | CPUFLAG_MMX2)

#define CPUFLAG_SSE2     (AV_CPU_FLAG_SSE2     | CPUFLAG_SSE)

#define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2)

#define CPUFLAG_SSE3     (AV_CPU_FLAG_SSE3     | CPUFLAG_SSE2)

#define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3)

#define CPUFLAG_SSSE3    (AV_CPU_FLAG_SSSE3    | CPUFLAG_SSE3)

#define CPUFLAG_SSE4     (AV_CPU_FLAG_SSE4     | CPUFLAG_SSSE3)

#define CPUFLAG_SSE42    (AV_CPU_FLAG_SSE42    | CPUFLAG_SSE4)

#define CPUFLAG_AVX      (AV_CPU_FLAG_AVX      | CPUFLAG_SSE42)

#define CPUFLAG_XOP      (AV_CPU_FLAG_XOP      | CPUFLAG_AVX)

#define CPUFLAG_FMA4     (AV_CPU_FLAG_FMA4     | CPUFLAG_AVX)

    static const AVOption cpuflags_opts[] = {

        { ""flags""  ",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3065,FFmpeg,0,"void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0);

}
",0,0,1,0,0,0,0,0,0,0,1,0,1,1,1
3070,qemu,1,"static void serial_tx_done(void *opaque)

{

    SerialState *s = opaque;



    if (s->tx_burst < 0) {

        uint16_t divider;



        if (s->divider)

          divider = s->divider;

        else

          divider = 1;



        /* We assume 10 bits/char, OK for this purpose. */

        s->tx_burst = THROTTLE_TX_INTERVAL * 1000 /

            (1000000 * 10 / (s->baudbase / divider));

    }

    s->thr_ipending = 1;

    s->lsr |= UART_LSR_THRE;

    s->lsr |= UART_LSR_TEMT;

    serial_update_irq(s);

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,0,0
3076,qemu,1,"void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)

{

    QXLDevSurfaceCreate surface;



    memset(&surface, 0, sizeof(surface));



    dprint(1, ""%s/%d: %dx%d\n"", __func__, ssd->qxl.id,

           surface_width(ssd->ds), surface_height(ssd->ds));



    surface.format     = SPICE_SURFACE_FMT_32_xRGB;

    surface.width      = surface_width(ssd->ds);

    surface.height     = surface_height(ssd->ds);

    surface.stride     = -surface.width * 4;

    surface.mouse_mode = true;

    surface.flags      = 0;

    surface.type       = 0;

    surface.mem        = (uintptr_t)ssd->buf;

    surface.group_id   = MEMSLOT_GROUP_HOST;



    qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC);

}
",1,0,0,0,0,0,0,0,0,0,0,0,1,1,1
3082,qemu,1,"static void init_proc_750fx (CPUPPCState *env)

{

    gen_spr_ne_601(env);

    gen_spr_7xx(env);

    /* XXX : not implemented */

    spr_register(env, SPR_L2CR, ""L2CR"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, NULL,

                 0x00000000);

    /* Time base */

    gen_tbl(env);

    /* Thermal management */

    gen_spr_thrm(env);

    /* XXX : not implemented */

    spr_register(env, SPR_750_THRM4, ""THRM4"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(env, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_ge",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3098,qemu,1,"void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...))

{

    stream_printf(stream, ""Trace file \""%s\"" %s.\n"",

                  trace_file_name, trace_file_enabled ? ""on"" : ""off"");

}
",0,0,0,0,0,0,1,1,1,1,0,1,0,1,1
3117,FFmpeg,0,"static int mkv_write_header(AVFormatContext *s)

{

    MatroskaMuxContext *mkv = s->priv_data;

    AVIOContext *pb = s->pb;

    ebml_master ebml_header;

    AVDictionaryEntry *tag;

    int ret, i, version = 2;

    int64_t creation_time;



    if (!strcmp(s->oformat->name, ""webm""))

        mkv->mode = MODE_WEBM;

    else

        mkv->mode = MODE_MATROSKAv2;



    if (mkv->mode != MODE_WEBM ||

        av_dict_get(s->metadata, ""stereo_mode"", NULL, 0) ||

        av_dict_get(s->metadata, ""alpha_mode"", NULL, 0))

        version = 4;



    if (s->nb_streams > MAX_TRACKS) {

        av_log(s, AV_LOG_ERROR,

               ""At most %d streams are supported for muxing in Matroska\n"",

               MAX_TRACKS);

        return AVERROR(EINVAL);

    }



    for (i = 0; i < s->nb_streams; i++) {

        if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK ||

            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 |",3,0,4,0,0,0,1,1,1,1,0,0,0,0,0
3130,qemu,1,"e1000_can_receive(void *opaque)

{

    E1000State *s = opaque;



    return (!(s->mac_reg[RCTL] & E1000_RCTL_EN) ||

            s->mac_reg[RDH] != s->mac_reg[RDT]);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
3153,FFmpeg,0,"av_cold void ff_sws_init_swScale_mmx(SwsContext *c)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_INLINE_ASM

    if (cpu_flags & AV_CPU_FLAG_MMX)

        sws_init_swScale_MMX(c);

#if HAVE_MMXEXT_INLINE

    if (cpu_flags & AV_CPU_FLAG_MMXEXT)

        sws_init_swScale_MMX2(c);

#endif

#endif /* HAVE_INLINE_ASM */



#if HAVE_YASM

#define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \

    if (c->srcBpc == 8) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale8to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 9) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale9to19_ ## filtersize ## _ ## opt1; \

    } else if (c->srcBpc == 10) { \

        hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \

                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; ",0,0,10,0,0,0,1,0,1,0,0,1,0,0,0
3158,FFmpeg,1,"static unsigned tget(const uint8_t **p, int type, int le)

{

    switch (type) {

    case TIFF_BYTE:

        return *(*p)++;

    case TIFF_SHORT:

        return tget_short(p, le);

    case TIFF_LONG:

        return tget_long(p, le);

    default:

        return UINT_MAX;

    }

}
",0,0,0,0,1,0,0,0,0,1,1,1,0,0,0
3160,FFmpeg,1,"static int decode_hq_slice(AVCodecContext *avctx, void *arg)

{

    int i, quant, level, orientation, quant_idx;

    uint8_t quants[MAX_DWT_LEVELS][4];

    DiracContext *s = avctx->priv_data;

    DiracSlice *slice = arg;

    GetBitContext *gb = &slice->gb;



    skip_bits_long(gb, 8*s->highquality.prefix_bytes);

    quant_idx = get_bits(gb, 8);



    /* Slice quantization (slice_quantizers() in the specs) */

    for (level = 0; level < s->wavelet_depth; level++) {

        for (orientation = !!level; orientation < 4; orientation++) {

            quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0);

            quants[level][orientation] = quant;

        }

    }



    /* Luma + 2 Chroma planes */

    for (i = 0; i < 3; i++) {

        int64_t length = s->highquality.size_scaler * get_bits(gb, 8);

        int64_t bits_left = 8 * length;

        int64_t bits_end = get_bits_count(gb) + bits_left;



        if (bits_end >= INT_MAX) {

            av_log(s->avctx, AV_LOG_ERROR, ""end",3,0,1,0,0,0,1,1,1,1,0,0,0,0,1
3161,FFmpeg,1,"static av_cold int amr_wb_encode_init(AVCodecContext *avctx)

{

    AMRWBContext *s = avctx->priv_data;



    if (avctx->sample_rate != 16000) {

        av_log(avctx, AV_LOG_ERROR, ""Only 16000Hz sample rate supported\n"");

        return AVERROR(ENOSYS);

    }



    if (avctx->channels != 1) {

        av_log(avctx, AV_LOG_ERROR, ""Only mono supported\n"");

        return AVERROR(ENOSYS);

    }



    s->mode            = get_wb_bitrate_mode(avctx->bit_rate, avctx);

    s->last_bitrate    = avctx->bit_rate;



    avctx->frame_size  = 320;

    avctx->coded_frame = avcodec_alloc_frame();





    s->state     = E_IF_init();



    return 0;

}",0,0,2,0,0,0,0,1,0,0,0,1,1,1,0
3162,qemu,1,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3176,FFmpeg,1,"void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove)

{

    int i;



    s->dts    =

    s->pts    = AV_NOPTS_VALUE;

    s->pos    = -1;

    s->offset = 0;

    for (i = 0; i < AV_PARSER_PTS_NB; i++) {

        if (s->cur_offset + off >= s->cur_frame_offset[i] &&

            (s->frame_offset < s->cur_frame_offset[i] ||

             (!s->frame_offset && !s->next_frame_offset)) && // first field/frame

            // check disabled since MPEG-TS does not send complete PES packets

            /*s->next_frame_offset + off <*/  s->cur_frame_end[i]){



            s->dts    = s->cur_frame_dts[i];

            s->pts    = s->cur_frame_pts[i];

            s->pos    = s->cur_frame_pos[i];

            s->offset = s->next_frame_offset - s->cur_frame_offset[i];

            if (remove)

                s->cur_frame_offset[i] = INT64_MAX;

            if (s->cur_offset + off < s->cur_frame_end[i])

                break;

        }

    }

}
",1,0,3,0,0,0,0,0,0,0,0,0,1,0,0
3179,qemu,1,"static void simple_whitespace(void)

{

    int i;

    struct {

        const char *encoded;

        LiteralQObject decoded;

    } test_cases[] = {

        {

            .encoded = "" [ 43 , 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' }, [ ], 42 ]"",

            .decoded = QLIT_QLIST(((LiteralQObject[]){

                        QLIT_QINT(43),

                        QLIT_QDICT(((LiteralQDictEntry[]){

                                    { ""h"", QLIT_QSTR(""b"") },

                                    { }})),

                        QLIT_QLIST(((LiteralQObject[]){

                                    { }})),

                        QLIT_QINT(42),

                        { }

                    })),

        },

        {

            .encoded = "" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], ",0,0,0,0,0,0,0,0,1,1,0,1,1,1,1
3180,qemu,1,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",1,0,3,0,0,0,0,1,0,1,0,0,0,0,0
3182,qemu,1,"static void gen_lswi(DisasContext *ctx)

{

    TCGv t0;

    TCGv_i32 t1, t2;

    int nb = NB(ctx->opcode);

    int start = rD(ctx->opcode);

    int ra = rA(ctx->opcode);

    int nr;



    if (nb == 0)

        nb = 32;

    nr = (nb + 3) / 4;

    if (unlikely(lsw_reg_in_range(start, nr, ra))) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

        return;

    }

    gen_set_access_type(ctx, ACCESS_INT);

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    t0 = tcg_temp_new();

    gen_addr_register(ctx, t0);

    t1 = tcg_const_i32(nb);

    t2 = tcg_const_i32(start);

    gen_helper_lsw(cpu_env, t0, t1, t2);

    tcg_temp_free(t0);

    tcg_temp_free_i32(t1);

    tcg_temp_free_i32(t2);

}
",0,0,2,0,0,0,0,1,0,0,0,0,0,0,0
3183,FFmpeg,0,"static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf,

                        float **out_samples)

{

    ATRAC3Context *q = avctx->priv_data;

    int ret, i;

    uint8_t *ptr1;



    if (q->coding_mode == JOINT_STEREO) {

        /* channel coupling mode */

        /* decode Sound Unit 1 */

        init_get_bits(&q->gb, databuf, avctx->block_align * 8);



        ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0,

                                        JOINT_STEREO);

        if (ret != 0)

            return ret;



        /* Framedata of the su2 in the joint-stereo mode is encoded in

         * reverse byte order so we need to swap it first. */

        if (databuf == q->decoded_bytes_buffer) {

            uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1;

            ptr1          = q->decoded_bytes_buffer;

            for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--)

                FFSWAP(uint8_t, *ptr1, *ptr2);

        } el",1,0,3,0,0,0,1,1,1,1,0,1,1,0,0
3184,qemu,1,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
",0,0,4,0,0,0,0,0,0,1,0,1,0,1,0
3205,qemu,1,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	strcpy(term_cmd_buf, term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_printf(""\n"");

    term_print_cmdline(term_cmd_buf);

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
",0,0,2,0,0,0,0,1,0,0,0,0,1,1,1
3211,FFmpeg,0,"static int decode_cabac_mb_cbp_luma( H264Context *h) {

    int cbp_b, cbp_a, ctx, cbp = 0;



    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;

    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;



    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);

    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;

    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;

    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);

    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;

    return cbp;

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,1,1
3227,FFmpeg,1,"void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *q)

{

    QSVFrame *cur;

    AVPacket pkt;

    int ret = 0;

    mfxVideoParam param = { { 0 } };



    if (q->reinit_pending) {

        close_decoder(q);

    } else if (q->engine_ready) {

        ret = MFXVideoDECODE_GetVideoParam(q->session, &param);

        if (ret < 0) {

            av_log(avctx, AV_LOG_ERROR, ""MFX decode get param error %d\n"", ret);

        }



        ret = MFXVideoDECODE_Reset(q->session, &param);

        if (ret < 0) {

            av_log(avctx, AV_LOG_ERROR, ""MFX decode reset error %d\n"", ret);

        }



        /* Free all frames*/

        cur = q->work_frames;

        while (cur) {

            q->work_frames = cur->next;

            av_frame_free(&cur->frame);

            av_freep(&cur);

            cur = q->work_frames;

        }

    }



    /* Reset output surfaces */

    av_fifo_reset(q->async_fifo);



    /* Reset input packets fifo */

    while (av_fifo_size(q->pkt_fifo)) {

        av_fifo",0,0,9,0,0,2,0,0,0,1,1,1,1,1,1
3228,qemu,1,"target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
",0,0,2,0,0,0,0,0,0,1,0,1,0,0,0
3236,qemu,1,"static void xhci_reset(DeviceState *dev)

{

    XHCIState *xhci = XHCI(dev);

    int i;



    trace_usb_xhci_reset();

    if (!(xhci->usbsts & USBSTS_HCH)) {

        DPRINTF(""xhci: reset while running!\n"");

    }



    xhci->usbcmd = 0;

    xhci->usbsts = USBSTS_HCH;

    xhci->dnctrl = 0;

    xhci->crcr_low = 0;

    xhci->crcr_high = 0;

    xhci->dcbaap_low = 0;

    xhci->dcbaap_high = 0;

    xhci->config = 0;



    for (i = 0; i < xhci->numslots; i++) {

        xhci_disable_slot(xhci, i+1);

    }



    for (i = 0; i < xhci->numports; i++) {

        xhci_port_update(xhci->ports + i, 0);

    }



    for (i = 0; i < xhci->numintrs; i++) {

        xhci->intr[i].iman = 0;

        xhci->intr[i].imod = 0;

        xhci->intr[i].erstsz = 0;

        xhci->intr[i].erstba_low = 0;

        xhci->intr[i].erstba_high = 0;

        xhci->intr[i].erdp_low = 0;

        xhci->intr[i].erdp_high = 0;

        xhci->intr[i].msix_used = 0;



        xhci->intr[i].er_ep_idx = 0;

        xhci->intr[i].er",3,0,1,0,0,1,1,1,1,0,1,1,1,1,0
3237,qemu,1,"int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def)

{

    int i, ret;



    ret = -1;

    *def = NULL;

    for (i = 0; ppc_defs[i].name != NULL; i++) {

        if ((pvr & ppc_defs[i].pvr_mask) ==

            (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) {

            *def = &ppc_defs[i];

            ret = 0;

            break;

        }

    }



    return ret;

}
",1,0,1,0,0,0,1,1,1,1,1,0,0,0,1
3256,qemu,0,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,1,0
3266,qemu,0,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
",1,0,1,0,0,0,0,0,0,0,0,0,1,1,1
3274,FFmpeg,0,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",3,0,0,0,0,0,0,0,0,0,0,0,1,1,1
3278,qemu,1,"static void nvme_instance_init(Object *obj)

{

    object_property_add(obj, ""bootindex"", ""int32"",

                        nvme_get_bootindex,

                        nvme_set_bootindex, NULL, NULL, NULL);

    object_property_set_int(obj, -1, ""bootindex"", NULL);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
3279,qemu,1,"static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,

                          Error **errp)

{

    BDRVBlkverifyState *s = bs->opaque;

    QemuOpts *opts;

    Error *local_err = NULL;

    int ret;



    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(opts, options, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto fail;




    /* Open the raw file */

    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-raw""), options, ""raw"",

                               bs, &child_file, false, &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        goto fail;




    /* Open the test file */

    s->test_file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options,

                                   ""test"", bs, &child_format, false,

                                   &local_err);

    if (local_err) {

        ret = -EINVAL;

  ",1,2,5,0,0,0,1,1,1,0,1,1,0,1,1
3288,qemu,1,"static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi,

                             int s_bits, int tlb_offset)

{

    TCGReg base = TCG_AREG0;



    /* Should generate something like the following:

     * pre-v7:

     *   shr    tmp, addr_reg, #TARGET_PAGE_BITS                  (1)

     *   add    r2, env, #off & 0xff00

     *   and    r0, tmp, #(CPU_TLB_SIZE - 1)                      (2)

     *   add    r2, r2, r0, lsl #CPU_TLB_ENTRY_BITS               (3)

     *   ldr    r0, [r2, #off & 0xff]!                            (4)

     *   tst    addr_reg, #s_mask

     *   cmpeq  r0, tmp, lsl #TARGET_PAGE_BITS                    (5)

     *

     * v7 (not implemented yet):

     *   ubfx   r2, addr_reg, #TARGET_PAGE_BITS, #CPU_TLB_BITS    (1)

     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask

     *   movw   r0, #off

     *   add    r2, env, r2, lsl #CPU_TLB_ENTRY_BITS              (2)

     *   bic    tmp, addr_reg, tmp

     *   ldr    r0, [r2, r0]!                              ",0,0,0,0,0,0,0,1,1,1,1,1,0,0,0
3290,FFmpeg,0,"static void qdm2_decode_super_block(QDM2Context *q)

{

    GetBitContext gb;

    QDM2SubPacket header, *packet;

    int i, packet_bytes, sub_packet_size, sub_packets_D;

    unsigned int next_index = 0;



    memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1));

    memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid));

    memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2));



    q->sub_packets_B = 0;

    sub_packets_D    = 0;



    average_quantized_coeffs(q); // average elements in quantized_coeffs[max_ch][10][8]



    init_get_bits(&gb, q->compressed_data, q->compressed_size * 8);

    qdm2_decode_sub_packet_header(&gb, &header);



    if (header.type < 2 || header.type >= 8) {

        q->has_errors = 1;

        av_log(NULL, AV_LOG_ERROR, ""bad superblock type\n"");

        return;

    }



    q->superblocktype_2_3 = (header.type == 2 || header.type == 3);

    packet_bytes          = (q->compressed_size - get_bits_count(&gb) / 8);



    init_get_bits(&gb, ",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
3293,FFmpeg,1,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3320,qemu,1,"MigrationState *migrate_get_current(void)

{

    static MigrationState current_migration = {

        .state = MIG_STATE_NONE,

        .bandwidth_limit = MAX_THROTTLE,

        .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE,

        .mbps = -1,

    };



    return &current_migration;

}
",0,0,0,0,0,0,0,0,0,1,1,1,0,0,0
3322,qemu,1,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",2,0,5,0,0,1,1,1,1,1,0,1,0,0,0
3327,qemu,1,"static int qcow2_change_backing_file(BlockDriverState *bs,

    const char *backing_file, const char *backing_fmt)

{

    return qcow2_update_ext_header(bs, backing_file, backing_fmt);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,1,0
3330,FFmpeg,0,"static void av_always_inline filter_mb_edgech( uint8_t *pix, int stride, const int16_t bS[4], unsigned int qp, H264Context *h ) {

    const int qp_bd_offset = 6 * (h->sps.bit_depth_luma - 8);

    const unsigned int index_a = qp - qp_bd_offset + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp - qp_bd_offset + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_v_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_v_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
3333,qemu,0,"static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size,

                          const char *boot_device,

                          DisplayState *ds, const char *kernel_filename,

                          const char *kernel_cmdline,

                          const char *initrd_filename, const char *cpu_model)

{

    CPUState *env, *envs[MAX_CPUS];

    unsigned int i;

    void *iounits[MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi;

    qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq,

        *espdma_irq, *ledma_irq;

    qemu_irq *esp_reset, *le_reset;

    ram_addr_t ram_offset, prom_offset, tcx_offset;

    unsigned long kernel_size;

    int ret;

    char buf[1024];

    int drive_index;

    void *fw_cfg;



    /* init CPUs */

    if (!cpu_model)

        cpu_model = hwdef->default_cpu_model;



    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""qemu: Unable to find Sparc CPU definiti",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
3348,qemu,0,"static int qemu_rdma_block_for_wrid(RDMAContext *rdma, int wrid_requested)

{

    int num_cq_events = 0, ret = 0;

    struct ibv_cq *cq;

    void *cq_ctx;

    uint64_t wr_id = RDMA_WRID_NONE, wr_id_in;



    if (ibv_req_notify_cq(rdma->cq, 0)) {

        return -1;

    }

    /* poll cq first */

    while (wr_id != wrid_requested) {

        ret = qemu_rdma_poll(rdma, &wr_id_in);

        if (ret < 0) {

            return ret;

        }



        wr_id = wr_id_in & RDMA_WRID_TYPE_MASK;



        if (wr_id == RDMA_WRID_NONE) {

            break;

        }

        if (wr_id != wrid_requested) {

            DDDPRINTF(""A Wanted wrid %s (%d) but got %s (%"" PRIu64 "")\n"",

                print_wrid(wrid_requested),

                wrid_requested, print_wrid(wr_id), wr_id);

        }

    }



    if (wr_id == wrid_requested) {

        return 0;

    }



    while (1) {

        /*

         * Coroutine doesn't start until process_incoming_migration()

         * so don't yield unless we know we'r",1,0,6,0,0,2,0,0,0,0,0,0,0,0,0
3375,FFmpeg,1,"static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t *)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    __asm__ volatile(""pxor    %%mm7,%%mm7    \n\t"":::""memory"");

    __asm__ volatile(""pcmpeqd %%mm6,%%mm6    \n\t"":::""memory"");

    mm_end = end - 3;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            PACK_RGB32

            :""=m""(*d)

",0,0,0,0,0,1,1,1,1,1,1,1,0,0,0
3392,qemu,1,"static int mux_chr_can_read(void *opaque)

{

    CharDriverState *chr = opaque;

    MuxDriver *d = chr->opaque;



    if ((d->prod - d->cons) < MUX_BUFFER_SIZE)

        return 1;

    if (d->chr_can_read[chr->focus])

        return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]);

    return 0;

}
",0,0,2,0,0,0,1,1,1,1,1,1,1,1,1
3394,qemu,1,"static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s)

{

    return s->iq_tail == 0;

}
",0,0,0,0,0,0,1,1,1,1,0,0,0,0,0
3397,FFmpeg,1,"static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,

                                     const uint8_t *src_in[4],

                                     int srcW, int xInc, const int16_t *hChrFilter,

                                     const int16_t *hChrFilterPos, int hChrFilterSize,

                                     uint8_t *formatConvBuffer, uint32_t *pal)

{

    const uint8_t *src1 = src_in[1], *src2 = src_in[2];

    if (c->chrToYV12) {

        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);

        c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal);

        src1= formatConvBuffer;

        src2= buf2;

    } else if (c->readChrPlanar) {

        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);

        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);

        src1= formatConvBuffer;

        src2= buf2;

    }



    if (!c->hcscale_fast) {

        c->hcScale(c, ds",7,0,3,0,0,0,1,1,1,1,0,0,1,1,1
3398,qemu,1,"static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,
        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)
{
    BlockDriverState *bs = child->bs;
    /* Perform I/O through a temporary buffer so that users who scribble over
     * their read buffer while the operation is in progress do not end up
     * modifying the image file.  This is critical for zero-copy guest I/O
     * where anything might happen inside guest memory.
     */
    void *bounce_buffer;
    BlockDriver *drv = bs->drv;
    struct iovec iov;
    QEMUIOVector local_qiov;
    int64_t cluster_offset;
    int64_t cluster_bytes;
    size_t skip_bytes;
    int ret;
    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,
                                    BDRV_REQUEST_MAX_BYTES);
    unsigned int progress = 0;
    /* FIXME We cannot require callers to have write permissions when all they
     * are doing is a read request. If we did things right, write permissions
     * would be obtained anyway, but internally by the co",2,0,1,0,0,1,1,1,1,1,1,1,1,1,1
3399,qemu,1,"static void virtio_scsi_device_unrealize(DeviceState *dev, Error **errp)
{
    virtio_scsi_common_unrealize(dev, errp);
}",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3401,qemu,1,"static int protocol_client_init(VncState *vs, uint8_t *data, size_t len)

{

    char buf[1024];

    VncShareMode mode;

    int size;



    mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE;

    switch (vs->vd->share_policy) {

    case VNC_SHARE_POLICY_IGNORE:

        /*

         * Ignore the shared flag.  Nothing to do here.

         *

         * Doesn't conform to the rfb spec but is traditional qemu

         * behavior, thus left here as option for compatibility

         * reasons.

         */

        break;

    case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE:

        /*

         * Policy: Allow clients ask for exclusive access.

         *

         * Implementation: When a client asks for exclusive access,

         * disconnect all others. Shared connects are allowed as long

         * as no exclusive connection exists.

         *

         * This is how the rfb spec suggests to handle the shared flag.

         */

        if (mode == VNC_SHARE_MODE_EXCLUSIVE) {

            Vnc",4,0,1,0,1,0,1,1,1,1,1,1,1,0,0
3416,FFmpeg,0,"static void avc_luma_hv_qrt_and_aver_dst_4x4_msa(const uint8_t *src_x,

                                                 const uint8_t *src_y,

                                                 int32_t src_stride,

                                                 uint8_t *dst,

                                                 int32_t dst_stride)

{

    v16i8 src_hz0, src_hz1, src_hz2, src_hz3;

    v16u8 dst0, dst1, dst2, dst3;

    v16i8 src_vt0, src_vt1, src_vt2, src_vt3, src_vt4;

    v16i8 src_vt5, src_vt6, src_vt7, src_vt8;

    v16i8 mask0, mask1, mask2;

    v8i16 hz_out0, hz_out1, vert_out0, vert_out1;

    v8i16 res0, res1;

    v16u8 res;



    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);

    LD_SB5(src_y, src_stride, src_vt0, src_vt1, src_vt2, src_vt3, src_vt4);

    src_y += (5 * src_stride);



    src_vt0 = (v16i8) __msa_insve_w((v4i32) src_vt0, 1, (v4i32) src_vt1);

    src_vt1 = (v16i8) __msa_insve_w((v4i32) src_vt1, 1, (v4i32) src_vt2);

    src_vt2 = (v16i8) __msa_insve_w((v4i32) s",0,0,0,0,0,0,1,1,0,1,1,1,0,0,0
3440,qemu,0,"static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *bs,

                         int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

                         BlockDriverCompletionFunc *cb, void *opaque)

{

    BDRVRawState *s = bs->opaque;

    return paio_submit(bs, s->hfile, sector_num, qiov, nb_sectors,

                       cb, opaque, QEMU_AIO_READ);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
3449,qemu,0,"static void tcx_blit_writel(void *opaque, hwaddr addr,

                            uint64_t val, unsigned size)

{

    TCXState *s = opaque;

    uint32_t adsr, len;

    int i;



    if (!(addr & 4)) {

        s->tmpblit = val;

    } else {

        addr = (addr >> 3) & 0xfffff;

        adsr = val & 0xffffff;

        len = ((val >> 24) & 0x1f) + 1;

        if (adsr == 0xffffff) {

            memset(&s->vram[addr], s->tmpblit, len);

            if (s->depth == 24) {

                val = s->tmpblit & 0xffffff;

                val = cpu_to_be32(val);

                for (i = 0; i < len; i++) {

                    s->vram24[addr + i] = val;

                }

            }

        } else {

            memcpy(&s->vram[addr], &s->vram[adsr], len);

            if (s->depth == 24) {

                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);

            }

        }

        memory_region_set_dirty(&s->vram_mem, addr, len);

    }

}
",1,0,4,0,0,0,0,0,0,1,0,1,0,0,0
3452,FFmpeg,0,"static void avc_loopfilter_cb_or_cr_intra_edge_ver_msa(uint8_t *data_cb_or_cr,

                                                       uint8_t alpha_in,

                                                       uint8_t beta_in,

                                                       uint32_t img_width)

{

    uint16_t out0, out1, out2, out3;

    v8i16 tmp1;

    v16u8 alpha, beta, is_less_than;

    v8i16 p0_or_q0, q0_or_p0;

    v16u8 p1_or_q1_org, p0_or_q0_org, q0_or_p0_org, q1_or_p1_org;

    v16i8 zero = { 0 };

    v16u8 p0_asub_q0, p1_asub_p0, q1_asub_q0;

    v16u8 is_less_than_alpha, is_less_than_beta;

    v8i16 p1_org_r, p0_org_r, q0_org_r, q1_org_r;



    {

        v16u8 row0, row1, row2, row3, row4, row5, row6, row7;



        LOAD_8VECS_UB((data_cb_or_cr - 2), img_width,

                      row0, row1, row2, row3, row4, row5, row6, row7);



        TRANSPOSE8x4_B_UB(row0, row1, row2, row3, row4, row5, row6, row7,

                          p1_or_q1_org, p0_or_q0_org,

                     ",0,0,0,0,0,0,1,0,0,0,1,1,1,1,1
3456,FFmpeg,1,"int ff_h261_handle_packet(AVFormatContext *ctx, PayloadContext *data,

                          AVStream *st, AVPacket *pkt, uint32_t *timestamp,

                          const uint8_t *buf, int len, uint16_t seq, int flags)

{

    int sbit, ebit, gobn, mbap, quant;

    int res;



    //av_log(ctx, AV_LOG_DEBUG, ""got h261 RTP packet with time: %u\n"", timestamp);



    /* drop data of previous packets in case of non-continuous (loss) packet stream */

    if (data->buf && data->timestamp != *timestamp) {

        h261_free_dyn_buffer(&data->buf);

    }



    /* sanity check for size of input packet */

    if (len < 5 /* 4 bytes header and 1 byte payload at least */) {

        av_log(ctx, AV_LOG_ERROR, ""Too short H.261 RTP packet\n"");

        return AVERROR_INVALIDDATA;

    }



    /*

      decode the H.261 payload header according to section 4.1 of RFC 4587:

      (uses 4 bytes between RTP header and H.261 stream per packet)



         0                   1                   2                 ",0,0,2,0,0,0,0,0,0,0,1,0,1,0,1
3460,FFmpeg,1,"static int vdpau_mpeg_start_frame(AVCodecContext *avctx,

                                  const uint8_t *buffer, uint32_t size)

{

    MpegEncContext * const s = avctx->priv_data;

    Picture *pic             = s->current_picture_ptr;

    struct vdpau_picture_context *pic_ctx = pic->hwaccel_picture_private;

    VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;

    VdpVideoSurface ref;

    int i;



    /* fill VdpPictureInfoMPEG1Or2 struct */

    info->forward_reference  = VDP_INVALID_HANDLE;

    info->backward_reference = VDP_INVALID_HANDLE;



    switch (s->pict_type) {

    case AV_PICTURE_TYPE_B:

        ref = ff_vdpau_get_surface_id(&s->next_picture.f);

        assert(ref != VDP_INVALID_HANDLE);

        info->backward_reference = ref;

        /* fall through to forward prediction */

    case AV_PICTURE_TYPE_P:

        ref = ff_vdpau_get_surface_id(&s->last_picture.f);

        info->forward_reference  = ref;

    }



    info->slice_count                = 0;

    info->picture_structu",2,0,0,0,1,0,1,1,1,1,1,1,1,0,1
3476,FFmpeg,1,"void h263_decode_init_vlc(MpegEncContext *s)

{

    static int done = 0;



    if (!done) {

        done = 1;



        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, 

                 intra_MCBPC_bits, 1, 1,

                 intra_MCBPC_code, 1, 1);

        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, 

                 inter_MCBPC_bits, 1, 1,

                 inter_MCBPC_code, 1, 1);

        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,

                 &cbpy_tab[0][1], 2, 1,

                 &cbpy_tab[0][0], 2, 1);

        init_vlc(&mv_vlc, MV_VLC_BITS, 33,

                 &mvtab[0][1], 2, 1,

                 &mvtab[0][0], 2, 1);

        init_rl(&rl_inter);

        init_rl(&rl_intra);

        init_rl(&rvlc_rl_inter);

        init_rl(&rvlc_rl_intra);

        init_rl(&rl_intra_aic);

        init_vlc_rl(&rl_inter);

        init_vlc_rl(&rl_intra);

        init_vlc_rl(&rvlc_rl_inter);

        init_vlc_rl(&rvlc_rl_intra);

        init_vlc_rl(&rl_intra_aic);

        init_vlc(&dc_lu",0,0,1,0,0,0,1,1,1,1,0,0,0,0,1
3484,qemu,1,"static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset,

                             unsigned size)

{

    icp_pit_state *s = (icp_pit_state *)opaque;

    int n;



    /* ??? Don't know the PrimeCell ID for this device.  */

    n = offset >> 8;

    if (n > 3) {

        hw_error(""sp804_read: Bad timer %d\n"", n);

    }



    return arm_timer_read(s->timer[n], offset & 0xff);

}
",0,0,1,0,0,0,1,1,1,1,1,1,1,1,0
3499,FFmpeg,1,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    

    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    skip_bits(&s->gb, 4);

    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        s->has_b_frames =",1,0,5,0,0,0,1,1,1,1,1,1,1,0,0
3502,FFmpeg,1,"void ff_rfps_calculate(AVFormatContext *ic)
{
    int i, j;
    for (i = 0; i<ic->nb_streams; i++) {
        AVStream *st = ic->streams[i];
        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)
        // the check for tb_unreliable() is not completely correct, since this is not about handling
        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
        // ipmovie.c produces.
        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)
            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);
        if (st->info->duration_count>1 && !st->r_frame_rate.num
            && tb_unreliable(st->codec)) {
            int num = 0;
            double best_error= 0.01;
            for (j=0; j<MAX_STD_TIMEBASES; j++) {
                int k;
                if(st->info->codec_in",2,0,4,0,0,0,0,1,0,1,1,0,0,0,0
3513,qemu,0,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3517,FFmpeg,0,"static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,

                                       int *mb_type)

{

    int b8_stride = 2;

    int b4_stride = h->b_stride;

    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;

    int mb_type_col[2];

    const int16_t (*l1mv0)[2], (*l1mv1)[2];

    const int8_t *l1ref0, *l1ref1;

    const int is_b8x8 = IS_8X8(*mb_type);

    unsigned int sub_mb_type = MB_TYPE_L0L1;

    int i8, i4;

    int ref[2];

    int mv[2];

    int list;



    assert(sl->ref_list[1][0].reference & 3);



    await_reference_mb_row(h, sl->ref_list[1][0].parent,

                           sl->mb_y + !!IS_INTERLACED(*mb_type));



#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \

                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)



    /* ref = min(neighbors) */

    for (list = 0; list < 2; list++) {

        int left_ref     = sl->ref_cache[list][scan8[0] - 1];

        int top_ref      = sl->ref_cache[list][scan8[0] ",1,0,0,0,0,0,0,0,0,0,0,0,1,0,0
3521,qemu,0,"static void gem_write(void *opaque, target_phys_addr_t offset, uint64_t val,

        unsigned size)

{

    GemState *s = (GemState *)opaque;

    uint32_t readonly;



    DB_PRINT(""offset: 0x%04x write: 0x%08x "", offset, (unsigned)val);

    offset >>= 2;



    /* Squash bits which are read only in write value */

    val &= ~(s->regs_ro[offset]);

    /* Preserve (only) bits which are read only in register */

    readonly = s->regs[offset];

    readonly &= s->regs_ro[offset];



    /* Squash bits which are write 1 to clear */

    val &= ~(s->regs_w1c[offset] & val);



    /* Copy register write to backing store */

    s->regs[offset] = val | readonly;



    /* Handle register write side effects */

    switch (offset) {

    case GEM_NWCTRL:

        if (val & GEM_NWCTRL_TXSTART) {

            gem_transmit(s);

        }

        if (!(val & GEM_NWCTRL_TXENA)) {

            /* Reset to start of Q when transmit disabled. */

            s->tx_desc_addr = s->regs[GEM_TXQBASE];

        }

        ",0,0,2,0,1,0,0,0,0,0,0,0,1,1,0
3540,qemu,1,"void cpu_loop(CPUMIPSState *env)

{

    target_siginfo_t info;

    int trapnr, ret;

    unsigned int syscall_num;



    for(;;) {

        trapnr = cpu_mips_exec(env);

        switch(trapnr) {

        case EXCP_SYSCALL:

            syscall_num = env->active_tc.gpr[2] - 4000;

            env->active_tc.PC += 4;

            if (syscall_num >= sizeof(mips_syscall_args)) {

                ret = -ENOSYS;

            } else {

                int nb_args;

                abi_ulong sp_reg;

                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;



                nb_args = mips_syscall_args[syscall_num];

                sp_reg = env->active_tc.gpr[29];

                switch (nb_args) {

                /* these arguments are taken from the stack */

                /* FIXME - what to do if get_user() fails? */

                case 8: get_user_ual(arg8, sp_reg + 28);

                case 7: get_user_ual(arg7, sp_reg + 24);

                case 6: get_user_ual(arg6, sp_reg + 20);

        ",1,0,1,0,2,0,1,1,1,1,1,1,0,0,1
3551,FFmpeg,1,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
",0,0,1,0,0,0,1,1,1,1,1,1,0,0,1
3555,qemu,1,"static void bonito_ldma_writel(void *opaque, hwaddr addr,
                               uint64_t val, unsigned size)
{
    PCIBonitoState *s = opaque;
    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
3561,FFmpeg,1,"static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,

                                  Jpeg2000CodingStyle *codsty,

                                  Jpeg2000ResLevel *rlevel, int precno,

                                  int layno, uint8_t *expn, int numgbits)

{

    int bandno, cblkno, ret, nb_code_blocks;

    int cwsno;



    if (layno < rlevel->band[0].prec[precno].decoded_layers)

        return 0;

    rlevel->band[0].prec[precno].decoded_layers = layno + 1;



    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {

        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {

            s->g = tile->tile_part[++(*tp_index)].tpg;

        }

    }



    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)

        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);



    if (!(ret = get_bits(s, 1))) {

        jpeg2000_flush(s);

        return 0;

    } else if (ret < 0)

        return ret;



    for (bandno = 0; bandno < r",1,0,6,0,0,0,0,0,0,1,1,1,1,0,0
3582,qemu,1,"static void curses_refresh(DisplayChangeListener *dcl)

{

    int chr, nextchr, keysym, keycode, keycode_alt;



    curses_winch_check();



    if (invalidate) {

        clear();

        refresh();

        curses_calc_pad();

        graphic_hw_invalidate(NULL);

        invalidate = 0;

    }



    graphic_hw_text_update(NULL, screen);



    nextchr = ERR;

    while (1) {

        /* while there are any pending key strokes to process */

        if (nextchr == ERR)

            chr = getch();

        else {

            chr = nextchr;

            nextchr = ERR;

        }



        if (chr == ERR)

            break;



#ifdef KEY_RESIZE

        /* this shouldn't occur when we use a custom SIGWINCH handler */

        if (chr == KEY_RESIZE) {

            clear();

            refresh();

            curses_calc_pad();

            curses_update(dcl, 0, 0, width, height);

            continue;

        }

#endif



        keycode = curses2keycode[chr];

        keycode_alt = 0;



        /* a",0,0,6,0,0,1,1,1,0,1,1,1,0,0,0
3596,FFmpeg,1,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",0,0,1,0,0,0,0,1,1,1,1,1,1,1,1
3598,qemu,1,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",0,0,0,0,0,0,0,0,1,0,0,0,1,1,1
3602,qemu,1,"static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom,

                               Error **errp)

{

    int size;

    char *path;

    void *ptr;

    char name[32];

    const VMStateDescription *vmsd;



    if (!pdev->romfile)

        return;

    if (strlen(pdev->romfile) == 0)

        return;



    if (!pdev->rom_bar) {

        /*

         * Load rom via fw_cfg instead of creating a rom bar,

         * for 0.11 compatibility.

         */

        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);



        /*

         * Hot-plugged devices can't use the option ROM

         * if the rom bar is disabled.

         */

        if (DEVICE(pdev)->hotplugged) {

            error_setg(errp, ""Hot-plugged device without ROM bar""

                       "" can't have an option ROM"");

            return;

        }



        if (class == 0x0300) {

            rom_add_vga(pdev->romfile);

        } else {

            rom_add_option(pdev->romfile, -1);

        }

        ret",1,0,6,0,0,0,1,1,1,1,1,0,1,0,1
3610,FFmpeg,1,"static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s)

{

    AVStream       *video_st    = s->streams[0];

    AVCodecParameters *video_par = s->streams[0]->codecpar;

    AVCodecParameters *audio_par = s->streams[1]->codecpar;

    int audio_rate = audio_par->sample_rate;

    // TODO: should be avg_frame_rate

    int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num);

    int audio_kbitrate = audio_par->bit_rate / 1000;

    int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate);



    avio_wb32(pb, 0x94); /* size */

    ffio_wfourcc(pb, ""uuid"");

    ffio_wfourcc(pb, ""PROF"");



    avio_wb32(pb, 0x21d24fce); /* 96 bit UUID */

    avio_wb32(pb, 0xbb88695c);

    avio_wb32(pb, 0xfac9c740);



    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x3);  /* 3 sections ? */



    avio_wb32(pb, 0x14); /* size */

    ffio_wfourcc(pb, ""FPRF"");

    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x0);  /* ? */

    avio_wb32(pb, 0x0);  /*",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3611,qemu,1,"static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb,  PCIDevice *pdev)

{

    char *path = NULL, *buf = NULL, *host = NULL;



    /* Get the PCI VFIO host id */

    host = object_property_get_str(OBJECT(pdev), ""host"", NULL);

    if (!host) {

        goto err_out;

    }



    /* Construct the path of the file that will give us the DT location */

    path = g_strdup_printf(""/sys/bus/pci/devices/%s/devspec"", host);

    g_free(host);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    g_free(path);



    /* Construct and read from host device tree the loc-code */

    path = g_strdup_printf(""/proc/device-tree%s/ibm,loc-code"", buf);

    g_free(buf);

    if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) {

        goto err_out;

    }

    return buf;



err_out:

    g_free(path);

    return NULL;

}
",0,3,3,0,0,0,0,0,0,0,1,0,0,1,1
3621,FFmpeg,1,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)

{

    //FIXME Optimize (just quickly writen not opti..)

    int i;

    for (i=0; i<dstW; i++)

    {

        int val=1<<18;

        int j;

        for (j=0; j<lumFilterSize; j++)

            val += lumSrc[j][i] * lumFilter[j];



        dest[i]= av_clip_uint8(val>>19);

    }



    if (!uDest)

        return;



    if (dstFormat == PIX_FMT_NV12)

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(u>>19);

            uDest[2*i+1]= av_cl",4,0,2,0,0,0,1,1,0,1,0,0,1,1,1
3634,qemu,1,"static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)

{

    uint32_t qid;



    if (addr & ((1 << 2) - 1)) {

        return;

    }



    if (((addr - 0x1000) >> 2) & 1) {

        uint16_t new_head = val & 0xffff;

        int start_sqs;

        NvmeCQueue *cq;



        qid = (addr - (0x1000 + (1 << 2))) >> 3;

        if (nvme_check_cqid(n, qid)) {

            return;

        }



        cq = n->cq[qid];

        if (new_head >= cq->size) {

            return;

        }



        start_sqs = nvme_cq_full(cq) ? 1 : 0;

        cq->head = new_head;

        if (start_sqs) {

            NvmeSQueue *sq;

            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {

                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

            }

            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

        }



        if (cq->tail != cq->head) {

            nvme_isr_notify(n, cq);

        }

    } else {

        uint16_t new_tail = val & 0xffff;

 ",0,0,7,0,0,0,1,1,1,1,1,1,0,0,1
3658,FFmpeg,0,"static av_cold void build_modpred(Indeo3DecodeContext *s)

{

  int i, j;



  s->ModPred = av_malloc(8 * 128);



  for (i=0; i < 128; ++i) {

    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));

    s->ModPred[i+1*128] = i ==   7 ?  20 :

                          i == 119 ||

                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));

    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));

    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));

    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));

    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));

    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));

    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));

  }



  s->corrector_type = av_malloc(24 * 256);



  for (i=0; i < 24; ++i) {

    for (j=0; j < 256; ++j) {

      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :

                                   j < 248",3,0,0,0,0,0,0,0,0,0,0,1,1,0,0
3681,qemu,1,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",0,0,0,0,0,0,0,0,0,0,0,1,1,0,0
3691,qemu,1,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
",0,0,4,0,0,0,1,1,1,1,0,0,1,0,1
3714,FFmpeg,1,"static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)

{

    int16_t icoef;

    int recent = s->cdlms[ich][ilms].recent;

    int16_t range = 1 << (s->bits_per_sample - 1);

    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample



    if (input > pred) {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] +=

                s->cdlms[ich][ilms].lms_updates[icoef + recent];

    } else {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] -=

                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?

    }

    s->cdlms[ich][ilms].recent--;

    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);



    if (input > pred)

        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];

    else if (input < pred)

        s->cdlms[ich][ilms].lms_updates[recent] = -s->update",2,0,3,0,0,0,1,1,1,1,1,1,0,0,0
3721,FFmpeg,1,"static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index,

                         const char *filt_name, const char *args, AVClass *log_ctx)

{

    AVFilter *filt;

    char inst_name[30];

    char tmp_args[256];

    int ret;



    snprintf(inst_name, sizeof(inst_name), ""Parsed filter %d %s"", index, filt_name);



    filt = avfilter_get_by_name(filt_name);



    if (!filt) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""No such filter: '%s'\n"", filt_name);

        return AVERROR(EINVAL);

    }



    ret = avfilter_open(filt_ctx, filt, inst_name);

    if (!*filt_ctx) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Error creating filter '%s'\n"", filt_name);

        return ret;

    }



    if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) {

        avfilter_free(*filt_ctx);

        return ret;

    }



    if (!strcmp(filt_name, ""scale"") && !strstr(args, ""flags"")) {

        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",

                 ar",0,0,4,0,0,0,0,0,0,0,1,1,0,0,0
3722,FFmpeg,1,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
",3,0,2,0,0,0,0,0,0,0,1,0,1,1,0
3731,qemu,1,"static void ppc_spapr_init(ram_addr_t ram_size,
                           const char *boot_device,
                           const char *kernel_filename,
                           const char *kernel_cmdline,
                           const char *initrd_filename,
                           const char *cpu_model)
{
    PowerPCCPU *cpu;
    CPUPPCState *env;
    int i;
    MemoryRegion *sysmem = get_system_memory();
    MemoryRegion *ram = g_new(MemoryRegion, 1);
    target_phys_addr_t rma_alloc_size, rma_size;
    uint32_t initrd_base = 0;
    long kernel_size = 0, initrd_size = 0;
    long load_limit, rtas_limit, fw_size;
    long pteg_shift = 17;
    char *filename;
    spapr = g_malloc0(sizeof(*spapr));
    QLIST_INIT(&spapr->phbs);
    cpu_ppc_hypercall = emulate_spapr_hypercall;
    /* Allocate RMA if necessary */
    rma_alloc_size = kvmppc_alloc_rma(""ppc_spapr.rma"", sysmem);
    if (rma_alloc_size == -1) {
        hw_error(""qemu: Unable to create RMA\n"");
        exit(1);
    }
    if (rma_alloc_size",0,0,3,0,0,0,0,0,0,0,0,0,0,1,0
3743,FFmpeg,0,"static av_cold int sonic_encode_init(AVCodecContext *avctx)

{

    SonicContext *s = avctx->priv_data;

    PutBitContext pb;

    int i, version = 0;



    if (avctx->channels > MAX_CHANNELS)

    {

        av_log(avctx, AV_LOG_ERROR, ""Only mono and stereo streams are supported by now\n"");

        return AVERROR(EINVAL); /* only stereo or mono for now */

    }



    if (avctx->channels == 2)

        s->decorrelation = MID_SIDE;

    else

        s->decorrelation = 3;



    if (avctx->codec->id == AV_CODEC_ID_SONIC_LS)

    {

        s->lossless = 1;

        s->num_taps = 32;

        s->downsampling = 1;

        s->quantization = 0.0;

    }

    else

    {

        s->num_taps = 128;

        s->downsampling = 2;

        s->quantization = 1.0;

    }



    // max tap 2048

    if ((s->num_taps < 32) || (s->num_taps > 1024) ||

        ((s->num_taps>>5)<<5 != s->num_taps))

    {

        av_log(avctx, AV_LOG_ERROR, ""Invalid number of taps\n"");

        return AVERROR_INVALIDDATA;

    }



  ",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
3748,FFmpeg,0,"int ff_h264_check_intra_pred_mode(H264Context *h, int mode, int is_chroma)

{

    static const int8_t top[7]  = { LEFT_DC_PRED8x8, 1, -1, -1 };

    static const int8_t left[7] = { TOP_DC_PRED8x8, -1, 2, -1, DC_128_PRED8x8 };



    if (mode > 6U) {

        av_log(h->avctx, AV_LOG_ERROR,

               ""out of range intra chroma pred mode at %d %d\n"",

               h->mb_x, h->mb_y);

        return -1;

    }



    if (!(h->top_samples_available & 0x8000)) {

        mode = top[mode];

        if (mode < 0) {

            av_log(h->avctx, AV_LOG_ERROR,

                   ""top block unavailable for requested intra mode at %d %d\n"",

                   h->mb_x, h->mb_y);

            return -1;

        }

    }



    if ((h->left_samples_available & 0x8080) != 0x8080) {

        mode = left[mode];

        if (is_chroma && (h->left_samples_available & 0x8080)) {

            // mad cow disease mode, aka MBAFF + constrained_intra_pred

            mode = ALZHEIMER_DC_L0T_PRED8x8 +

                   (",1,0,5,0,0,0,0,0,0,0,0,0,1,0,0
3755,qemu,0,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
",0,0,7,0,1,0,0,0,0,0,0,0,0,0,0
3763,qemu,0,"static void block_job_completed_txn_abort(BlockJob *job)

{

    AioContext *ctx;

    BlockJobTxn *txn = job->txn;

    BlockJob *other_job, *next;



    if (txn->aborting) {

        /*

         * We are cancelled by another job, which will handle everything.

         */

        return;

    }

    txn->aborting = true;

    /* We are the first failed job. Cancel other jobs. */

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        ctx = blk_get_aio_context(other_job->blk);

        aio_context_acquire(ctx);

    }

    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {

        if (other_job == job || other_job->completed) {

            /* Other jobs are ""effectively"" cancelled by us, set the status for

             * them; this job, however, may or may not be cancelled, depending

             * on the caller, so leave it. */

            if (other_job != job) {

                block_job_cancel_async(other_job);

            }

            continue;

        }

        block_job_cancel_sync(o",1,0,3,0,0,0,0,0,0,0,0,0,1,0,1
3766,qemu,0,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)

{

    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
3770,qemu,0,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
3778,qemu,0,"static void dec_bit(DisasContext *dc)

{

    TCGv t0, t1;

    unsigned int op;

    int mem_index = cpu_mmu_index(dc->env);



    op = dc->ir & ((1 << 9) - 1);

    switch (op) {

        case 0x21:

            /* src.  */

            t0 = tcg_temp_new();



            LOG_DIS(""src r%d r%d\n"", dc->rd, dc->ra);

            tcg_gen_andi_tl(t0, cpu_R[dc->ra], 1);

            if (dc->rd) {

                t1 = tcg_temp_new();

                read_carry(dc, t1);

                tcg_gen_shli_tl(t1, t1, 31);



                tcg_gen_shri_tl(cpu_R[dc->rd], cpu_R[dc->ra], 1);

                tcg_gen_or_tl(cpu_R[dc->rd], cpu_R[dc->rd], t1);

                tcg_temp_free(t1);

            }



            /* Update carry.  */

            write_carry(dc, t0);

            tcg_temp_free(t0);

            break;



        case 0x1:

        case 0x41:

            /* srl.  */

            t0 = tcg_temp_new();

            LOG_DIS(""srl r%d r%d\n"", dc->rd, dc->ra);



            /* Update carry.  */

      ",0,0,1,0,1,0,0,0,0,0,0,0,0,0,0
3795,qemu,0,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
3811,qemu,0,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool pre, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= pre << 24;

    insn |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);

}
",0,0,0,0,0,0,0,0,1,0,0,0,1,0,1
3815,qemu,0,"static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, void *opaque,

                                   const char *name, Error **errp)

{

    X86CPU *cpu = X86_CPU(obj);

    const int64_t min = 0;

    const int64_t max = INT_MAX;

    int64_t value;



    visit_type_int(v, &value, name, errp);

    if (error_is_set(errp)) {

        return;

    }

    if (value < min || value > max) {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE, """",

                  name ? name : ""null"", value, min, max);

        return;

    }



    cpu->env.tsc_khz = value / 1000;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
3824,qemu,1,"static int cow_create(const char *filename, QemuOpts *opts, Error **errp)

{

    struct cow_header_v2 cow_header;

    struct stat st;

    int64_t image_sectors = 0;

    char *image_filename = NULL;

    Error *local_err = NULL;

    int ret;

    BlockDriverState *cow_bs;



    /* Read out options */

    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;

    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);



    ret = bdrv_create_file(filename, opts, &local_err);

    if (ret < 0) {

        error_propagate(errp, local_err);

        goto exit;

    }



    cow_bs = NULL;

    ret = bdrv_open(&cow_bs, filename, NULL, NULL,

                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);

    if (ret < 0) {

        error_propagate(errp, local_err);

        goto exit;

    }



    memset(&cow_header, 0, sizeof(cow_header));

    cow_header.magic = cpu_to_be32(COW_MAGIC);

    cow_header.version = cpu_to_be32(COW_VERSION);

    if (image_filename) {

        /",0,2,3,0,0,0,1,1,1,1,0,1,1,1,1
3832,FFmpeg,0,"static av_cold int check_format(AVCodecContext *avctx)

{

    AVCodecParserContext *parser;

    uint8_t *pout;

    int psize;

    int index;

    H264Context *h;

    int ret = -1;



    /* init parser & parse file */

    parser = av_parser_init(avctx->codec->id);

    if (!parser) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");

        goto final;

    }

    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;

    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);

    if (index < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");

        goto release_parser;

    }



    /* check if support */

    h = parser->priv_data;

    switch (h->sps.bit_depth_luma) {

    case 8:

        if (!CHROMA444(h) && !CHROMA422(h)) {

            // only this will H.264 decoder switch to hwaccel

            ret = 0;

            break;

        }

    default:

        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");

    }



release_parser:

 ",1,2,3,0,1,0,0,0,0,0,0,0,1,1,1
3834,qemu,0,"static unsigned int dec_move_mr(DisasContext *dc)

{

	int memsize = memsize_zz(dc);

	int insn_len;

	DIS(fprintf (logfile, ""move.%c [$r%u%s, $r%u\n"",

		    memsize_char(memsize),

		    dc->op1, dc->postinc ? ""+]"" : ""]"",

		    dc->op2));



	if (memsize == 4) {

		insn_len = dec_prep_move_m(dc, 0, 4, cpu_R[dc->op2]);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_update_cc_op(dc, CC_OP_MOVE, 4);

		cris_update_cc_x(dc);

		cris_update_result(dc, cpu_R[dc->op2]);

	}

	else {

		TCGv t0;



		t0 = tcg_temp_new(TCG_TYPE_TL);

		insn_len = dec_prep_move_m(dc, 0, memsize, t0);

		cris_cc_mask(dc, CC_MASK_NZ);

		cris_alu(dc, CC_OP_MOVE,

			    cpu_R[dc->op2], cpu_R[dc->op2], t0, memsize);

		tcg_temp_free(t0);

	}

	do_postinc(dc, memsize);

	return insn_len;

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
3838,qemu,0,"static int rtc_initfn(ISADevice *dev)

{

    RTCState *s = DO_UPCAST(RTCState, dev, dev);

    int base = 0x70;

    int isairq = 8;



    isa_init_irq(dev, &s->irq, isairq);



    s->cmos_data[RTC_REG_A] = 0x26;

    s->cmos_data[RTC_REG_B] = 0x02;

    s->cmos_data[RTC_REG_C] = 0x00;

    s->cmos_data[RTC_REG_D] = 0x80;



    rtc_set_date_from_host(s);



    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);

#ifdef TARGET_I386

    if (rtc_td_hack)

        s->coalesced_timer =

            qemu_new_timer(rtc_clock, rtc_coalesced_timer, s);

#endif

    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);

    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);



    s->next_second_time =

        qemu_get_clock(rtc_clock) + (get_ticks_per_sec() * 99) / 100;

    qemu_mod_timer(s->second_timer2, s->next_second_time);



    register_ioport_write(base, 2, 1, cmos_ioport_write, s);

    register_ioport_read(base, 2, 1, cmos_ioport_read, s);



    regis",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
3845,qemu,0,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *n = opaque;

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,1
3901,FFmpeg,0,"static int read_packet(AVFormatContext *s1, AVPacket *pkt)

{

    VideoDemuxData *s = s1->priv_data;

    char filename_bytes[1024];

    char *filename = filename_bytes;

    int i;

    int size[3]={0}, ret[3]={0};

    AVIOContext *f[3] = {NULL};

    AVCodecContext *codec= s1->streams[0]->codec;



    if (!s->is_pipe) {

        /* loop over input */

        if (s->loop && s->img_number > s->img_last) {

            s->img_number = s->img_first;

        }

        if (s->img_number > s->img_last)

            return AVERROR_EOF;

        if (s->use_glob) {

#if HAVE_GLOB

            filename = s->globstate.gl_pathv[s->img_number];

#endif

        } else {

        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),

                                  s->path, s->img_number)<0 && s->img_number > 1)

            return AVERROR(EIO);

        }

        for(i=0; i<3; i++){

            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,

                           &s1->interrupt_callback, NULL",1,0,8,0,0,0,1,1,1,1,1,1,0,0,0
3913,FFmpeg,1,"static int smacker_read_header(AVFormatContext *s)
{
    AVIOContext *pb = s->pb;
    SmackerContext *smk = s->priv_data;
    AVStream *st, *ast[7];
    int i, ret;
    int tbase;
    /* read and check header */
    smk->magic = avio_rl32(pb);
    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))
    smk->width = avio_rl32(pb);
    smk->height = avio_rl32(pb);
    smk->frames = avio_rl32(pb);
    smk->pts_inc = (int32_t)avio_rl32(pb);
    smk->flags = avio_rl32(pb);
    if(smk->flags & SMACKER_FLAG_RING_FRAME)
        smk->frames++;
    for(i = 0; i < 7; i++)
        smk->audio[i] = avio_rl32(pb);
    smk->treesize = avio_rl32(pb);
    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)
        av_log(s, AV_LOG_ERROR, ""treesize too large\n"");
//FIXME remove extradata ""rebuilding""
    smk->mmap_size = avio_rl32(pb);
    smk->mclr_size = avio_rl32(pb);
    smk->full_size = avio_rl32(pb);
    smk->type_size = avio_rl32(",1,0,3,0,0,0,1,1,1,1,1,0,0,0,0
3920,qemu,0,"static int coroutine_fn raw_co_discard(BlockDriverState *bs,

                                       int64_t sector_num, int nb_sectors)

{

    return bdrv_co_discard(bs->file->bs, sector_num, nb_sectors);

}
",0,0,0,0,0,0,1,1,1,0,0,0,0,0,1
3924,qemu,0,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
3926,qemu,0,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
3933,qemu,0,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = opinv;

        }

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
",1,0,2,0,0,0,0,0,0,0,0,0,1,0,0
3946,qemu,0,"static int twl92230_init(i2c_slave *i2c)

{

    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);



    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);

    /* Three output pins plus one interrupt pin.  */

    qdev_init_gpio_out(&i2c->qdev, s->out, 4);

    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);

    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];



    menelaus_reset(&s->i2c);



    return 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
3956,FFmpeg,1,"static int mov_write_packet(AVFormatContext *s, AVPacket *pkt)

{

    MOVContext *mov = s->priv_data;

    ByteIOContext *pb = s->pb;

    MOVTrack *trk = &mov->tracks[pkt->stream_index];

    AVCodecContext *enc = trk->enc;

    unsigned int samplesInChunk = 0;

    int size= pkt->size;



    if (url_is_streamed(s->pb)) return 0; /* Can't handle that */

    if (!size) return 0; /* Discard 0 sized packets */



    if (enc->codec_id == CODEC_ID_AMR_NB) {

        /* We must find out how many AMR blocks there are in one packet */

        static uint16_t packed_size[16] =

            {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0};

        int len = 0;



        while (len < size && samplesInChunk < 100) {

            len += packed_size[(pkt->data[len] >> 3) & 0x0F];

            samplesInChunk++;

        }

        if(samplesInChunk > 1){

            av_log(s, AV_LOG_ERROR, ""fatal error, input is not a single packet, implement a AVParser for it\n"");

            return -1;

        }

    } ",1,0,4,0,0,1,0,0,0,1,1,1,1,1,1
3960,qemu,1,"static void gen_st_cond (DisasContext *ctx, uint32_t opc, int rt,

                         int base, int16_t offset)

{

    const char *opn = ""st_cond"";

    TCGv t0, t1;



    t0 = tcg_temp_local_new();



    gen_base_offset_addr(ctx, t0, base, offset);

    /* Don't do NOP if destination is zero: we must perform the actual

       memory access. */



    t1 = tcg_temp_local_new();

    gen_load_gpr(t1, rt);

    switch (opc) {

#if defined(TARGET_MIPS64)

    case OPC_SCD:

        save_cpu_state(ctx, 0);

        op_st_scd(t1, t0, rt, ctx);

        opn = ""scd"";

        break;

#endif

    case OPC_SC:

        save_cpu_state(ctx, 1);

        op_st_sc(t1, t0, rt, ctx);

        opn = ""sc"";

        break;

    }

    (void)opn; /* avoid a compiler warning */

    MIPS_DEBUG(""%s %s, %d(%s)"", opn, regnames[rt], offset, regnames[base]);

    tcg_temp_free(t1);

    tcg_temp_free(t0);

}
",1,0,3,0,1,0,0,0,0,0,0,0,1,1,1
3970,qemu,1,"static int32_t bmdma_prepare_buf(IDEDMA *dma, int is_write)

{

    BMDMAState *bm = DO_UPCAST(BMDMAState, dma, dma);

    IDEState *s = bmdma_active_if(bm);

    PCIDevice *pci_dev = PCI_DEVICE(bm->pci_dev);

    struct {

        uint32_t addr;

        uint32_t size;

    } prd;

    int l, len;



    pci_dma_sglist_init(&s->sg, pci_dev,

                        s->nsector / (BMDMA_PAGE_SIZE / 512) + 1);

    s->io_buffer_size = 0;

    for(;;) {

        if (bm->cur_prd_len == 0) {

            /* end of table (with a fail safe of one page) */

            if (bm->cur_prd_last ||

                (bm->cur_addr - bm->addr) >= BMDMA_PAGE_SIZE) {

                return s->io_buffer_size;

            }

            pci_dma_read(pci_dev, bm->cur_addr, &prd, 8);

            bm->cur_addr += 8;

            prd.addr = le32_to_cpu(prd.addr);

            prd.size = le32_to_cpu(prd.size);

            len = prd.size & 0xfffe;

            if (len == 0)

                len = 0x10000;

            bm->cur_prd_le",1,0,4,0,0,0,1,1,1,1,1,1,0,0,1
3971,FFmpeg,0,"static int apply_window_and_mdct(vorbis_enc_context *venc,

                                 float *audio, int samples)

{

    int channel;

    const float * win = venc->win[0];

    int window_len = 1 << (venc->log2_blocksize[0] - 1);

    float n = (float)(1 << venc->log2_blocksize[0]) / 4.0;

    AVFloatDSPContext *fdsp = venc->fdsp;



    if (!venc->have_saved && !samples)

        return 0;



    if (venc->have_saved) {

        for (channel = 0; channel < venc->channels; channel++)

            memcpy(venc->samples + channel * window_len * 2,

                   venc->saved + channel * window_len, sizeof(float) * window_len);

    } else {

        for (channel = 0; channel < venc->channels; channel++)

            memset(venc->samples + channel * window_len * 2, 0,

                   sizeof(float) * window_len);

    }



    if (samples) {

        for (channel = 0; channel < venc->channels; channel++) {

            float *offset = venc->samples + channel * window_len * 2 + window_len;



      ",3,0,3,0,0,0,1,1,1,1,1,0,0,0,0
3977,qemu,1,"static inline int popcountl(unsigned long l)

{

    return BITS_PER_LONG == 32 ? ctpop32(l) : ctpop64(l);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
3984,FFmpeg,1,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
",0,0,4,0,0,1,0,0,0,1,1,0,0,0,0
3988,qemu,1,"static inline void ide_dma_submit_check(IDEState *s,

          BlockDriverCompletionFunc *dma_cb)

{

    if (s->bus->dma->aiocb)

	return;

    dma_cb(s, -1);

}
",0,0,1,0,0,0,1,1,1,1,1,1,0,1,1
4006,qemu,1,"static BlockStats *bdrv_query_bds_stats(const BlockDriverState *bs,

                                 bool query_backing)

{

    BlockStats *s = NULL;



    s = g_malloc0(sizeof(*s));

    s->stats = g_malloc0(sizeof(*s->stats));



    if (!bs) {

        return s;

    }



    if (bdrv_get_node_name(bs)[0]) {

        s->has_node_name = true;

        s->node_name = g_strdup(bdrv_get_node_name(bs));

    }



    s->stats->wr_highest_offset = stat64_get(&bs->wr_highest_offset);



    if (bs->file) {

        s->has_parent = true;

        s->parent = bdrv_query_bds_stats(bs->file->bs, query_backing);

    }



    if (query_backing && bs->backing) {

        s->has_backing = true;

        s->backing = bdrv_query_bds_stats(bs->backing->bs, query_backing);

    }



    return s;

}
",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
4009,FFmpeg,1,"static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,

                                    const uint8_t *src, const uint8_t *src_end,

                                    int width, int esc_count)

{

    int i = 0;

    int count;

    uint8_t zero_run = 0;

    const uint8_t *src_start = src;

    uint8_t mask1 = -(esc_count < 2);

    uint8_t mask2 = -(esc_count < 3);

    uint8_t *end = dst + (width - 2);



    avpriv_request_sample(l->avctx, ""zero_run_line"");

    return AVERROR_PATCHWELCOME;



output_zeros:

    if (l->zeros_rem) {

        count = FFMIN(l->zeros_rem, width - i);

        if (end - dst < count) {

            av_log(l->avctx, AV_LOG_ERROR, ""Too many zeros remaining.\n"");

            return AVERROR_INVALIDDATA;

        }



        memset(dst, 0, count);

        l->zeros_rem -= count;

        dst += count;

    }



    while (dst < end) {

        i = 0;

        while (!zero_run && dst + i < end) {

            i++;

            if (i+2 >= src_end - src)

       ",0,0,3,0,0,2,1,0,0,1,1,1,0,1,0
4017,qemu,1,"static int ram_init_all(RAMState **rsp)

{

    Error *local_err = NULL;



    if (ram_state_init(rsp)) {

        return -1;

    }



    if (migrate_use_xbzrle()) {

        XBZRLE_cache_lock();

        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);

        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),

                                  TARGET_PAGE_SIZE, &local_err);

        if (!XBZRLE.cache) {

            XBZRLE_cache_unlock();

            error_report_err(local_err);

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }

        XBZRLE_cache_unlock();



        /* We prefer not to abort if there is no memory */

        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);

        if (!XBZRLE.encoded_buf) {

            error_report(""Error allocating encoded_buf"");

            g_free(*rsp);

            *rsp = NULL;

            return -1;

        }



        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);

        if (!XBZRLE.current_bu",0,0,5,0,0,0,0,0,0,0,1,0,0,0,0
4025,FFmpeg,0,"static void av_always_inline filter_mb_edgecv( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = beta_table[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]]+1;

        tc[1] = tc0_table[index_a][bS[1]]+1;

        tc[2] = tc0_table[index_a][bS[2]]+1;

        tc[3] = tc0_table[index_a][bS[3]]+1;

        h->h264dsp.h264_h_loop_filter_chroma(pix, stride, alpha, beta, tc);

    } else {

        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,1,1
4029,FFmpeg,1,"static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,

                                      int w, int h)

{

    ImageContext *img;

    HuffReader *hg;

    int i, j, ret, x, y, width;



    img       = &s->image[role];

    img->role = role;



    if (!img->frame) {

        img->frame = av_frame_alloc();

        if (!img->frame)

            return AVERROR(ENOMEM);

    }



    img->frame->format = AV_PIX_FMT_ARGB;

    img->frame->width  = w;

    img->frame->height = h;



    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {

        ThreadFrame pt = { .f = img->frame };

        ret = ff_thread_get_buffer(s->avctx, &pt, 0);

    } else

        ret = av_frame_get_buffer(img->frame, 1);

    if (ret < 0)

        return ret;



    if (get_bits1(&s->gb)) {

        img->color_cache_bits = get_bits(&s->gb, 4);

        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {

            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d\n"",

            ",1,0,6,0,0,0,0,0,0,0,0,0,1,0,1
4041,FFmpeg,1,"void ff_mspel_motion(MpegEncContext *s,

                               uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,

                               uint8_t **ref_picture, op_pixels_func (*pix_op)[4],

                               int motion_x, int motion_y, int h)

{

    Wmv2Context * const w= (Wmv2Context*)s;

    uint8_t *ptr;

    int dxy, offset, mx, my, src_x, src_y, v_edge_pos, linesize, uvlinesize;

    int emu=0;



    dxy = ((motion_y & 1) << 1) | (motion_x & 1);

    dxy = 2*dxy + w->hshift;

    src_x = s->mb_x * 16 + (motion_x >> 1);

    src_y = s->mb_y * 16 + (motion_y >> 1);



    /* WARNING: do no forget half pels */

    v_edge_pos = s->v_edge_pos;

    src_x = av_clip(src_x, -16, s->width);

    src_y = av_clip(src_y, -16, s->height);



    if(src_x<=-16 || src_x >= s->width)

        dxy &= ~3;

    if(src_y<=-16 || src_y >= s->height)

        dxy &= ~4;



    linesize   = s->linesize;

    uvlinesize = s->uvlinesize;

    ptr = ref_picture[0] + (src_y * linesize) + src_x;
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
4062,FFmpeg,1,"static int svq1_encode_plane(SVQ1Context *s, int plane,

                             unsigned char *src_plane,

                             unsigned char *ref_plane,

                             unsigned char *decoded_plane,

                             int width, int height, int src_stride, int stride)

{

    const AVFrame *f = s->avctx->coded_frame;

    int x, y;

    int i;

    int block_width, block_height;

    int level;

    int threshold[6];

    uint8_t *src     = s->scratchbuf + stride * 16;

    const int lambda = (f->quality * f->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    threshold[5] = QUALITY_THRESHOLD;

    for (level = 4; level >= 0; level--)

        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    block_height = (height + 15) / 16;



    if (f->pict_type == AV_PICTURE_TYPE_P) {

        s->m.avctx                         = s->avctx;

  ",1,0,1,0,0,0,1,1,1,1,1,0,0,1,1
4064,FFmpeg,1,"static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,

                             int is_extradata)

{

    MMALDecodeContext *ctx = avctx->priv_data;

    AVBufferRef *buf = NULL;

    int size = 0;

    uint8_t *data = (uint8_t *)"""";

    uint8_t *start;

    int ret = 0;



    if (avpkt->size) {

        if (avpkt->buf) {

            buf = av_buffer_ref(avpkt->buf);

            size = avpkt->size;

            data = avpkt->data;

        } else {

            buf = av_buffer_alloc(avpkt->size);

            if (buf) {

                memcpy(buf->data, avpkt->data, avpkt->size);

                size = buf->size;

                data = buf->data;

            }

        }

        if (!buf) {

            ret = AVERROR(ENOMEM);

            goto done;

        }

        if (!is_extradata)

            ctx->packets_sent++;

    } else {

        if (!ctx->packets_sent) {

            // Short-cut the flush logic to avoid upsetting MMAL.

            ctx->eos_sent = 1;

            ctx",0,1,6,0,0,0,1,1,1,1,1,1,0,0,0
4070,FFmpeg,1,"static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)

{

    AVBitStreamFilterContext *bsfc = ost->bitstream_filters;

    AVCodecContext          *avctx = ost->st->codec;

    int ret;



    if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||

        (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))

        pkt->pts = pkt->dts = AV_NOPTS_VALUE;



    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) {

        int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);

        if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt->dts) {

            av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, ""Audio timestamp %""PRId64"" < %""PRId64"" invalid, cliping\n"", pkt->dts, max);

            pkt->pts = pkt->dts = max;





    /*

     * Audio encoders may split the packets --  #frames in != #packets out.

     * But there is no reordering, so we can limit the num",1,0,3,0,0,0,0,0,0,1,0,0,0,1,0
4080,qemu,1,"void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)

{

    CachedL2Table *entry;



    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);

    if (entry) {

        qed_unref_l2_cache_entry(entry);

        qed_unref_l2_cache_entry(l2_table);

        return;

    }



    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {

        entry = QTAILQ_FIRST(&l2_cache->entries);

        QTAILQ_REMOVE(&l2_cache->entries, entry, node);

        l2_cache->n_entries--;

        qed_unref_l2_cache_entry(entry);

    }



    l2_cache->n_entries++;

    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);

}
",0,0,2,0,0,0,0,0,1,1,1,0,0,0,0
4091,FFmpeg,1,"av_cold void ff_pixblockdsp_init_x86(PixblockDSPContext *c,

                                     AVCodecContext *avctx,

                                     unsigned high_bit_depth)

{

    int cpu_flags = av_get_cpu_flags();



    if (EXTERNAL_MMX(cpu_flags)) {

        if (!high_bit_depth)

            c->get_pixels = ff_get_pixels_mmx;


        c->diff_pixels = ff_diff_pixels_mmx;

    }



    if (EXTERNAL_SSE2(cpu_flags)) {

        if (!high_bit_depth)

            c->get_pixels = ff_get_pixels_sse2;


        c->diff_pixels = ff_diff_pixels_sse2;

    }

}",0,0,8,0,0,0,1,1,1,1,1,1,0,1,0
4093,qemu,1,"static USBDevice *usb_net_init(const char *cmdline)

{

    USBDevice *dev;

    QemuOpts *opts;

    int idx;



    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);

    if (!opts) {



    qemu_opt_set(opts, ""type"", ""nic"");

    qemu_opt_set(opts, ""model"", ""usb"");



    idx = net_client_init(NULL, opts, 0);

    if (idx == -1) {





    dev = usb_create(NULL /* FIXME */, ""usb-net"");




    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);

    qdev_init_nofail(&dev->qdev);

    return dev;
",0,0,2,0,0,0,0,0,0,0,0,1,0,0,0
4095,FFmpeg,1,"static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt,

                              int dump_payload, AVRational time_base)

{

    HEXDUMP_PRINT(""stream #%d:\n"", pkt->stream_index);

    HEXDUMP_PRINT(""  keyframe=%d\n"", (pkt->flags & AV_PKT_FLAG_KEY) != 0);

    HEXDUMP_PRINT(""  duration=%0.3f\n"", pkt->duration * av_q2d(time_base));

    /* DTS is _always_ valid after av_read_frame() */

    HEXDUMP_PRINT(""  dts="");

    if (pkt->dts == AV_NOPTS_VALUE)

        HEXDUMP_PRINT(""N/A"");

    else

        HEXDUMP_PRINT(""%0.3f"", pkt->dts * av_q2d(time_base));

    /* PTS may not be known if B-frames are present. */

    HEXDUMP_PRINT(""  pts="");

    if (pkt->pts == AV_NOPTS_VALUE)

        HEXDUMP_PRINT(""N/A"");

    else

        HEXDUMP_PRINT(""%0.3f"", pkt->pts * av_q2d(time_base));

    HEXDUMP_PRINT(""\n"");

    HEXDUMP_PRINT(""  size=%d\n"", pkt->size);

    if (dump_payload)

        av_hex_dump(f, pkt->data, pkt->size);

}
",0,0,3,0,0,0,0,1,1,1,1,1,0,1,1
4104,qemu,0,"static void handle_mousewheel(SDL_Event *ev)

{

    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);

    SDL_MouseWheelEvent *wev = &ev->wheel;

    InputButton btn;



    if (wev->y > 0) {

        btn = INPUT_BUTTON_WHEEL_UP;

    } else if (wev->y < 0) {

        btn = INPUT_BUTTON_WHEEL_DOWN;

    } else {

        return;

    }



    qemu_input_queue_btn(scon->dcl.con, btn, true);

    qemu_input_event_sync();

    qemu_input_queue_btn(scon->dcl.con, btn, false);

    qemu_input_event_sync();

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
4141,qemu,1,"static void init_virtio_dev(TestServer *s)

{

    QPCIBus *bus;

    QVirtioPCIDevice *dev;

    uint32_t features;



    bus = qpci_init_pc(NULL);

    g_assert_nonnull(bus);



    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);

    g_assert_nonnull(dev);



    qvirtio_pci_device_enable(dev);

    qvirtio_reset(&dev->vdev);

    qvirtio_set_acknowledge(&dev->vdev);

    qvirtio_set_driver(&dev->vdev);



    features = qvirtio_get_features(&dev->vdev);

    features = features & VIRTIO_NET_F_MAC;

    qvirtio_set_features(&dev->vdev, features);



    qvirtio_set_driver_ok(&dev->vdev);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
4159,FFmpeg,1,"int av_packet_split_side_data(AVPacket *pkt){

    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){

        int i;

        unsigned int size;

        uint8_t *p;



        p = pkt->data + pkt->size - 8 - 5;

        for (i=1; ; i++){

            size = AV_RB32(p);

            if (size>INT_MAX || p - pkt->data < size)

                return 0;

            if (p[4]&128)

                break;

            p-= size+5;

        }



        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));

        if (!pkt->side_data)

            return AVERROR(ENOMEM);



        p= pkt->data + pkt->size - 8 - 5;

        for (i=0; ; i++){

            size= AV_RB32(p);

            av_assert0(size<=INT_MAX && p - pkt->data >= size);

            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);

            pkt->side_data[i].size = size;

            pkt->side_data[i].type = p[4]&127;

            if (!pkt->side_data[i].data)

  ",2,0,5,0,0,0,0,1,0,1,1,1,1,1,1
4165,qemu,1,"static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);

    scsi_req_cancel(s->req);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4166,qemu,1,"ram_addr_t ppc405_set_bootinfo (CPUState *env, ppc4xx_bd_info_t *bd,

                                uint32_t flags)

{

    ram_addr_t bdloc;

    int i, n;



    /* We put the bd structure at the top of memory */

    if (bd->bi_memsize >= 0x01000000UL)

        bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t);

    else

        bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t);

    stl_phys(bdloc + 0x00, bd->bi_memstart);

    stl_phys(bdloc + 0x04, bd->bi_memsize);

    stl_phys(bdloc + 0x08, bd->bi_flashstart);

    stl_phys(bdloc + 0x0C, bd->bi_flashsize);

    stl_phys(bdloc + 0x10, bd->bi_flashoffset);

    stl_phys(bdloc + 0x14, bd->bi_sramstart);

    stl_phys(bdloc + 0x18, bd->bi_sramsize);

    stl_phys(bdloc + 0x1C, bd->bi_bootflags);

    stl_phys(bdloc + 0x20, bd->bi_ipaddr);

    for (i = 0; i < 6; i++)

        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);

    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);

    stl_phys(bdloc + 0x2C, bd->bi_intfreq);

    stl_phys(bdloc + 0x30, ",1,0,1,0,0,0,1,1,1,0,1,0,1,0,0
4173,qemu,0,"bool virtio_ipl_disk_is_valid(void)

{

    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
4178,qemu,0,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
4196,FFmpeg,0,"dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,

                    enum dshowDeviceType devtype, IBaseFilter **pfilter)

{

    struct dshow_ctx *ctx = avctx->priv_data;

    IBaseFilter *device_filter = NULL;

    IEnumMoniker *classenum = NULL;

    IMoniker *m = NULL;

    const char *device_name = ctx->device_name[devtype];

    int skip = (devtype == VideoDevice) ? ctx->video_device_number

                                        : ctx->audio_device_number;

    int r;



    const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory,

                                   &CLSID_AudioInputDeviceCategory };

    const char *devtypename = (devtype == VideoDevice) ? ""video"" : ""audio"";



    r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype],

                                             (IEnumMoniker **) &classenum, 0);

    if (r != S_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Could not enumerate %s devices.\n"",

               devtypename);

        return AV",0,0,1,0,0,0,0,0,0,1,0,0,1,1,1
4198,FFmpeg,0,"static int do_decode(AVCodecContext *avctx, AVPacket *pkt)

{

    int got_frame;

    int ret;



    av_assert0(!avctx->internal->buffer_frame->buf[0]);



    if (!pkt)

        pkt = avctx->internal->buffer_pkt;



    // This is the lesser evil. The field is for compatibility with legacy users

    // of the legacy API, and users using the new API should not be forced to

    // even know about this field.

    avctx->refcounted_frames = 1;



    // Some codecs (at least wma lossless) will crash when feeding drain packets

    // after EOF was signaled.

    if (avctx->internal->draining_done)

        return AVERROR_EOF;



    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {

        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,

                                    &got_frame, pkt);

        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))

            ret = pkt->size;

    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {

        ret = avcodec_decode_audio4(avctx, avc",0,0,5,0,0,0,0,0,0,1,0,0,0,0,0
4209,qemu,0,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
",1,0,2,0,0,0,0,0,0,0,0,0,1,1,1
4211,qemu,0,"static void vfio_bar_write(void *opaque, hwaddr addr,

                           uint64_t data, unsigned size)

{

    VFIOBAR *bar = opaque;

    union {

        uint8_t byte;

        uint16_t word;

        uint32_t dword;

        uint64_t qword;

    } buf;



    switch (size) {

    case 1:

        buf.byte = data;

        break;

    case 2:

        buf.word = cpu_to_le16(data);

        break;

    case 4:

        buf.dword = cpu_to_le32(data);

        break;

    default:

        hw_error(""vfio: unsupported write size, %d bytes\n"", size);

        break;

    }



    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {

        error_report(""%s(,0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d) failed: %m"",

                     __func__, addr, data, size);

    }



    DPRINTF(""%s(BAR%d+0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d)\n"",

            __func__, bar->nr, addr, data, size);



    /*

     * A read or write to a BAR always signals an INTx EOI.  This will

     * do nothing if not pending (",0,0,2,0,1,0,1,1,0,1,1,1,0,0,0
4213,qemu,0,"static void mcf5208evb_init(QEMUMachineInitArgs *args)

{

    ram_addr_t ram_size = args->ram_size;

    const char *cpu_model = args->cpu_model;

    const char *kernel_filename = args->kernel_filename;

    CPUM68KState *env;

    int kernel_size;

    uint64_t elf_entry;

    target_phys_addr_t entry;

    qemu_irq *pic;

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    MemoryRegion *sram = g_new(MemoryRegion, 1);



    if (!cpu_model)

        cpu_model = ""m5208"";

    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find m68k CPU definition\n"");

        exit(1);

    }



    /* Initialize CPU registers.  */

    env->vbr = 0;

    /* TODO: Configure BARs.  */



    /* DRAM at 0x40000000 */

    memory_region_init_ram(ram, ""mcf5208.ram"", ram_size);

    vmstate_register_ram_global(ram);

    memory_region_add_subregion(address_space_mem, 0x40000000, ram);



    /* Internal SRAM.  */

    memory_region_init",0,0,2,0,0,0,0,0,1,0,1,0,0,0,0
4217,qemu,0,"static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)

{

    QObject *token;

    const char *val;



    if (ap == NULL) {

        return NULL;

    }



    token = parser_context_pop_token(ctxt);

    assert(token && token_get_type(token) == JSON_ESCAPE);

    val = token_get_value(token);



    if (!strcmp(val, ""%p"")) {

        return va_arg(*ap, QObject *);

    } else if (!strcmp(val, ""%i"")) {

        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%ld"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long)));

    } else if (!strcmp(val, ""%lld"") ||

               !strcmp(val, ""%I64d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long long)));

    } else if (!strcmp(val, ""%s"")) {

        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));

    } else if (!strcmp(val, ""%f"")) {

        return QOBJECT(qfloat_from_double(va_arg(*ap, doub",0,0,8,0,0,0,0,0,0,0,1,0,1,1,1
4218,qemu,0,"static inline uint64_t ldq_phys_internal(hwaddr addr,

                                         enum device_endian endian)

{

    uint8_t *ptr;

    uint64_t val;

    MemoryRegionSection *section;



    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);



    if (!(memory_region_is_ram(section->mr) ||

          memory_region_is_romd(section->mr))) {

        /* I/O case */

        addr = memory_region_section_addr(section, addr);



        /* XXX This is broken when device endian != cpu endian.

               Fix and add ""endian"" variable check */

#ifdef TARGET_WORDS_BIGENDIAN

        val = io_mem_read(section->mr, addr, 4) << 32;

        val |= io_mem_read(section->mr, addr + 4, 4);

#else

        val = io_mem_read(section->mr, addr, 4);

        val |= io_mem_read(section->mr, addr + 4, 4) << 32;

#endif

    } else {

        /* RAM case */

        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)

                                & TARGET_PAGE_MASK",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
4221,qemu,0,"void main_loop_wait(int nonblocking)

{

    fd_set rfds, wfds, xfds;

    int ret, nfds;

    struct timeval tv;

    int timeout;



    if (nonblocking)

        timeout = 0;

    else {

        timeout = qemu_calculate_timeout();

        qemu_bh_update_timeout(&timeout);

    }



    os_host_main_loop_wait(&timeout);



    tv.tv_sec = timeout / 1000;

    tv.tv_usec = (timeout % 1000) * 1000;



    /* poll any events */

    /* XXX: separate device handlers from system ones */

    nfds = -1;

    FD_ZERO(&rfds);

    FD_ZERO(&wfds);

    FD_ZERO(&xfds);

    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);

    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);



    qemu_mutex_unlock_iothread();

    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);

    qemu_mutex_lock_iothread();



    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);

    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));



    qemu_run_all_timers();



    /* Check bottom-halves last in case any of the earlier events triggered

   ",0,0,1,0,0,0,1,1,0,1,1,0,1,1,1
4253,qemu,1,"void bdrv_invalidate_cache_all(Error **errp)

{

    BlockDriverState *bs;

    Error *local_err = NULL;

    BdrvNextIterator *it = NULL;



    while ((it = bdrv_next(it, &bs)) != NULL) {

        AioContext *aio_context = bdrv_get_aio_context(bs);



        aio_context_acquire(aio_context);

        bdrv_invalidate_cache(bs, &local_err);

        aio_context_release(aio_context);

        if (local_err) {

            error_propagate(errp, local_err);

            return;

        }

    }

}
",0,0,1,0,0,1,1,0,0,1,1,0,1,1,1
4255,FFmpeg,1,"static int parse_adaptation_sets(AVFormatContext *s)

{

    WebMDashMuxContext *w = s->priv_data;

    char *p = w->adaptation_sets;

    char *q;

    enum { new_set, parsed_id, parsing_streams } state;

    if (!w->adaptation_sets) {

        av_log(s, AV_LOG_ERROR, ""The 'adaptation_sets' option must be set.\n"");

        return AVERROR(EINVAL);

    }

    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on

    state = new_set;

    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {

        if (*p == ' ')

            continue;

        else if (state == new_set && !strncmp(p, ""id="", 3)) {

            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));

            if (mem == NULL)

                return AVERROR(ENOMEM);

            w->as = mem;

            ++w->nb_as;

            w->as[w->nb_as - 1].nb_streams = 0;

            w->as[w->nb_as - 1].streams = NULL;

            p += 3; // consume ""id=""

            q = w->as[w->nb_as - 1].id;

            while (*p != ',')",0,0,4,0,0,2,0,0,0,0,0,0,0,0,0
4256,qemu,1,"static QObject *parse_keyword(JSONParserContext *ctxt)

{

    QObject *token, *ret;

    JSONParserContext saved_ctxt = parser_context_save(ctxt);



    token = parser_context_pop_token(ctxt);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));



    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    return ret;



out: 

    parser_context_restore(ctxt, saved_ctxt);



    return NULL;

}",0,3,4,0,0,0,1,1,0,1,1,0,1,0,0
4260,FFmpeg,0,"static int aac_encode_frame(AVCodecContext *avctx,

                            uint8_t *frame, int buf_size, void *data)

{

    AACEncContext *s = avctx->priv_data;

    int16_t *samples = s->samples, *samples2, *la;

    ChannelElement *cpe;

    int i, j, chans, tag, start_ch;

    const uint8_t *chan_map = aac_chan_configs[avctx->channels-1];

    int chan_el_counter[4];

    FFPsyWindowInfo windows[AAC_MAX_CHANNELS];



    if (s->last_frame)

        return 0;

    if (data) {

        if (!s->psypp) {

            memcpy(s->samples + 1024 * avctx->channels, data,

                   1024 * avctx->channels * sizeof(s->samples[0]));

        } else {

            start_ch = 0;

            samples2 = s->samples + 1024 * avctx->channels;

            for (i = 0; i < chan_map[0]; i++) {

                tag = chan_map[i+1];

                chans = tag == TYPE_CPE ? 2 : 1;

                ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch,

                                  samples2 + start_ch, start",1,0,3,0,0,0,1,1,1,1,0,1,1,1,1
4306,FFmpeg,0,"static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic,

                                const uint8_t *src, int src_size)

{

    GetByteContext gb;

    GetBitContext  gb2;

    int nslices, slice, slice_height, ref_slice_height;

    int cur_y, next_y;

    uint32_t off, slice_size;

    uint8_t *Y, *U, *V;

    int ret;



    bytestream2_init(&gb, src, src_size);

    nslices = bytestream2_get_le16(&gb);

    off = FFALIGN(nslices * 4 + 2, 16);

    if (src_size < off) {

        av_log(avctx, AV_LOG_ERROR, ""no slice data\n"");

        return AVERROR_INVALIDDATA;

    }



    if (!nslices || avctx->height % nslices) {

        avpriv_request_sample(avctx, ""%d slices for %dx%d"", nslices,

                              avctx->width, avctx->height);

        return AVERROR_PATCHWELCOME;

    }



    ref_slice_height = avctx->height / nslices;

    if ((avctx->width & 1) || (avctx->height & 1)) {

        avpriv_request_sample(avctx, ""Frame dimensions %dx%d"",

                              avc",1,0,3,0,0,0,0,0,0,0,0,0,0,1,0
4307,FFmpeg,0,"static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr,

                         GetBitContext *gb, SBRData *ch_data)

{

    int i;

    unsigned bs_pointer = 0;

    // frameLengthFlag ? 15 : 16; 960 sample length frames unsupported; this value is numTimeSlots

    int abs_bord_trail = 16;

    int num_rel_lead, num_rel_trail;

    unsigned bs_num_env_old = ch_data->bs_num_env;



    ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env];

    ch_data->bs_amp_res = sbr->bs_amp_res_header;

    ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old];



    switch (ch_data->bs_frame_class = get_bits(gb, 2)) {

    case FIXFIX:

        ch_data->bs_num_env                 = 1 << get_bits(gb, 2);

        num_rel_lead                        = ch_data->bs_num_env - 1;

        if (ch_data->bs_num_env == 1)

            ch_data->bs_amp_res = 0;



        if (ch_data->bs_num_env > 4) {

            av_log(ac->avccontext, AV_LOG_ERROR,

                   ""Invalid bitstream, too ",0,0,2,0,1,0,0,1,0,1,0,1,1,0,1
4315,qemu,0,"static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *async, uint32_t *int_mask)

{

    int len = 0, max_len, err, ret;

    uint8_t pid;



    max_len = ((td->token >> 21) + 1) & 0x7ff;

    pid = td->token & 0xff;



    ret = async->packet.result;



    if (td->ctrl & TD_CTRL_IOS)

        td->ctrl &= ~TD_CTRL_ACTIVE;



    if (ret < 0)

        goto out;



    len = async->packet.result;

    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);



    /* The NAK bit may have been set by a previous frame, so clear it

       here.  The docs are somewhat unclear, but win2k relies on this

       behavior.  */

    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);

    if (td->ctrl & TD_CTRL_IOC)

        *int_mask |= 0x01;



    if (pid == USB_TOKEN_IN) {

        if (len > max_len) {

            ret = USB_RET_BABBLE;

            goto out;

        }



        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {

            *int_mask |= 0x02;

            /* short packet: do not update QH */

",0,2,6,0,0,0,0,0,0,0,0,0,0,0,0
4337,qemu,0,"static void cpu_x86_dump_state(FILE *f)

{

    int eflags;

    char cc_op_name[32];

    eflags = cc_table[CC_OP].compute_all();

    eflags |= (DF & DF_MASK);

    if ((unsigned)env->cc_op < CC_OP_NB)

        strcpy(cc_op_name, cc_op_str[env->cc_op]);

    else

        snprintf(cc_op_name, sizeof(cc_op_name), ""[%d]"", env->cc_op);

    fprintf(f, 

            ""EAX=%08x EBX=%08X ECX=%08x EDX=%08x\n""

            ""ESI=%08x EDI=%08X EBP=%08x ESP=%08x\n""

            ""CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\n""

            ""EIP=%08x\n"",

            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], 

            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], 

            env->cc_src, env->cc_dst, cc_op_name,

            eflags & DF_MASK ? 'D' : '-',

            eflags & CC_O ? 'O' : '-',

            eflags & CC_S ? 'S' : '-',

            eflags & CC_Z ? 'Z' : '-',

            eflags & CC_A ? 'A' : '-',

            eflags & CC_P ? 'P' : '-',

       ",0,0,1,0,0,0,0,1,1,0,1,0,0,1,0
4341,FFmpeg,0,"static int gif_read_image(GifState *s)

{

    int left, top, width, height, bits_per_pixel, code_size, flags;

    int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i;

    uint8_t *ptr, *spal, *palette, *ptr1;



    left = bytestream_get_le16(&s->bytestream);

    top = bytestream_get_le16(&s->bytestream);

    width = bytestream_get_le16(&s->bytestream);

    height = bytestream_get_le16(&s->bytestream);

    flags = bytestream_get_byte(&s->bytestream);

    is_interleaved = flags & 0x40;

    has_local_palette = flags & 0x80;

    bits_per_pixel = (flags & 0x07) + 1;



    av_dlog(s->avctx, ""image x=%d y=%d w=%d h=%d\n"", left, top, width, height);



    if (has_local_palette) {

        bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel));

        palette = s->local_palette;

    } else {

        palette = s->global_palette;

        bits_per_pixel = s->bits_per_pixel;

    }



    /* verify that all the image is inside the screen dimensions */

    if (l",0,0,4,0,0,0,1,1,1,1,1,1,0,0,0
4344,FFmpeg,0,"static int alac_encode_frame(AVCodecContext *avctx, uint8_t *frame,

                             int buf_size, void *data)

{

    AlacEncodeContext *s = avctx->priv_data;

    PutBitContext *pb = &s->pbctx;

    int i, out_bytes, verbatim_flag = 0;



    if (avctx->frame_size > DEFAULT_FRAME_SIZE) {

        av_log(avctx, AV_LOG_ERROR, ""input frame size exceeded\n"");

        return -1;

    }



    if (buf_size < 2 * s->max_coded_frame_size) {

        av_log(avctx, AV_LOG_ERROR, ""buffer size is too small\n"");

        return -1;

    }



verbatim:

    init_put_bits(pb, frame, buf_size);



    if (s->compression_level == 0 || verbatim_flag) {

        // Verbatim mode

        const int16_t *samples = data;

        write_frame_header(s, 1);

        for (i = 0; i < avctx->frame_size * avctx->channels; i++) {

            put_sbits(pb, 16, *samples++);

        }

    } else {

        init_sample_buffers(s, data);

        write_frame_header(s, 0);

        write_compressed_frame(s);

    }



    pu",1,0,3,0,0,0,0,0,0,0,0,0,1,0,1
4360,qemu,1,"static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, r;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &d->pam_regions[i+1]);

    }

    smram = d->dev.config[I440FX_SMRAM];

    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&d->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
",1,0,0,0,0,0,1,0,0,1,1,1,0,0,0
4362,qemu,1,"static int vmdk_open_vmdk4(BlockDriverState *bs,

                           BlockDriverState *file,

                           int flags)

{

    int ret;

    uint32_t magic;

    uint32_t l1_size, l1_entry_sectors;

    VMDK4Header header;

    VmdkExtent *extent;

    int64_t l1_backup_offset = 0;



    ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header));

    if (ret < 0) {

        return ret;

    }

    if (header.capacity == 0) {

        int64_t desc_offset = le64_to_cpu(header.desc_offset);

        if (desc_offset) {

            return vmdk_open_desc_file(bs, flags, desc_offset << 9);

        }

    }



    if (le64_to_cpu(header.gd_offset) == VMDK4_GD_AT_END) {

        /*

         * The footer takes precedence over the header, so read it in. The

         * footer starts at offset -1024 from the end: One sector for the

         * footer, and another one for the end-of-stream marker.

         */

        struct {

            struct {

                uint64_t val;

           ",2,0,4,0,0,0,1,1,1,0,0,1,0,0,0
4385,qemu,1,"static void control_to_network(RDMAControlHeader *control)

{

    control->type = htonl(control->type);

    control->len = htonl(control->len);

    control->repeat = htonl(control->repeat);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
4389,qemu,0,"static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
",0,0,0,0,0,0,0,1,0,0,0,0,0,1,1
4411,FFmpeg,0,"static int poll_filter(OutputStream *ost)

{

    OutputFile    *of = output_files[ost->file_index];

    AVFrame *filtered_frame = NULL;

    int frame_size, ret;



    if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) {

        return AVERROR(ENOMEM);

    } else

        avcodec_get_frame_defaults(ost->filtered_frame);

    filtered_frame = ost->filtered_frame;



    if (ost->enc->type == AVMEDIA_TYPE_AUDIO &&

        !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE))

        ret = av_buffersink_get_samples(ost->filter->filter, filtered_frame,

                                         ost->st->codec->frame_size);

    else

        ret = av_buffersink_get_frame(ost->filter->filter, filtered_frame);



    if (ret < 0)

        return ret;



    if (filtered_frame->pts != AV_NOPTS_VALUE) {

        filtered_frame->pts = av_rescale_q(filtered_frame->pts,

                                           ost->filter->filter->inputs[0]->time_base,

                            ",0,0,4,0,0,0,0,1,0,0,0,0,0,0,0
4440,qemu,0,"void *memory_region_get_ram_ptr(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;

    }



    assert(mr->terminates);



    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);

}
",0,0,1,0,0,0,0,1,0,1,1,1,1,0,0
4479,FFmpeg,0,"void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)

{

    afq->avctx             = avctx;

    afq->next_pts          = AV_NOPTS_VALUE;

    afq->remaining_delay   = avctx->delay;

    afq->remaining_samples = avctx->delay;

    afq->frame_queue       = NULL;

}
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
4488,qemu,0,"void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)

{

    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4519,FFmpeg,1,"static inline void RENAME(rgb24tobgr15)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint8_t *s = src;

    const uint8_t *end;

    const uint8_t *mm_end;

    uint16_t *d = (uint16_t *)dst;

    end = s + src_size;

    __asm__ volatile(PREFETCH""    %0""::""m""(*src):""memory"");

    __asm__ volatile(

        ""movq          %0, %%mm7    \n\t""

        ""movq          %1, %%mm6    \n\t""

        ::""m""(red_15mask),""m""(green_15mask));

    mm_end = end - 11;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movd          %1, %%mm0    \n\t""

            ""movd         3%1, %%mm3    \n\t""

            ""punpckldq    6%1, %%mm0    \n\t""

            ""punpckldq    9%1, %%mm3    \n\t""

            ""movq       %%mm0, %%mm1    \n\t""

            ""movq       %%mm0, %%mm2    \n\t""

            ""movq       %%mm3, %%mm4    \n\t""

            ""movq       %%mm3, %%mm5    \n\t""

            ""psrlq         $3, %%mm0    \n\t""

            ""psrlq       ",0,0,0,0,0,1,0,0,0,1,1,1,0,0,0
4521,qemu,1,"static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion,

                                void *opaque)

{

    GtkDisplayState *s = opaque;

    int x, y;

    int mx, my;

    int fbh, fbw;

    int ww, wh;



    fbw = surface_width(s->ds) * s->scale_x;

    fbh = surface_height(s->ds) * s->scale_y;



    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);



    mx = my = 0;

    if (ww > fbw) {

        mx = (ww - fbw) / 2;

    }

    if (wh > fbh) {

        my = (wh - fbh) / 2;

    }



    x = (motion->x - mx) / s->scale_x;

    y = (motion->y - my) / s->scale_y;



    if (x < 0 || y < 0 ||

        x >= surface_width(s->ds) ||

        y >= surface_height(s->ds)) {

        return TRUE;

    }



    if (qemu_input_is_absolute()) {

        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x,

                             surface_width(s->ds));

        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y,

                             surface_height(s->ds));

    ",0,0,4,0,0,0,0,0,1,0,0,0,1,1,1
4524,FFmpeg,0,"int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,

                         int level)

{

    VDPAUHWContext *hwctx = avctx->hwaccel_context;

    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;

    VdpVideoSurfaceQueryCapabilities *surface_query_caps;

    VdpDecoderQueryCapabilities *decoder_query_caps;

    VdpDecoderCreate *create;

    void *func;

    VdpStatus status;

    VdpBool supported;

    uint32_t max_level, max_mb, max_width, max_height;

    VdpChromaType type;

    uint32_t width;

    uint32_t height;



    vdctx->width            = UINT32_MAX;

    vdctx->height           = UINT32_MAX;



    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))

        return AVERROR(ENOSYS);



    if (hwctx) {

        hwctx->reset            = 0;



        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {

            vdctx->decoder = hwctx->context.decoder;

            vdctx->render  = hwctx->context.render;

            vdctx->device  = VDP_INV",0,0,3,0,0,0,1,1,0,0,0,0,0,0,0
4539,FFmpeg,1,"static int estimate_qp(MpegEncContext *s, int dry_run){

    if (s->next_lambda){

        s->current_picture_ptr->f.quality =

        s->current_picture.f.quality = s->next_lambda;

        if(!dry_run) s->next_lambda= 0;

    } else if (!s->fixed_qscale) {

        s->current_picture_ptr->f.quality =

        s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run);

        if (s->current_picture.f.quality < 0)

            return -1;

    }



    if(s->adaptive_quant){

        switch(s->codec_id){

        case AV_CODEC_ID_MPEG4:

            if (CONFIG_MPEG4_ENCODER)

                ff_clean_mpeg4_qscales(s);

            break;

        case AV_CODEC_ID_H263:

        case AV_CODEC_ID_H263P:

        case AV_CODEC_ID_FLV1:

            if (CONFIG_H263_ENCODER)

                ff_clean_h263_qscales(s);

            break;

        default:

            ff_init_qscale_tab(s);

        }



        s->lambda= s->lambda_table[0];

        //FIXME broken

    }else

        s->lambda = s->curr",0,0,7,0,1,0,1,1,1,1,1,1,0,0,0
4540,qemu,0,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
4551,qemu,0,"static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev)

{

#ifdef CONFIG_KVM

    struct kvm_irqfd irqfd = {

        .fd = event_notifier_get_fd(&vdev->intx.interrupt),

        .gsi = vdev->intx.route.irq,

        .flags = KVM_IRQFD_FLAG_RESAMPLE,

    };

    struct vfio_irq_set *irq_set;

    int ret, argsz;

    int32_t *pfd;



    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||

        vdev->intx.route.mode != PCI_INTX_ENABLED ||

        !kvm_resamplefds_enabled()) {

        return;

    }



    /* Get to a known interrupt state */

    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);

    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);

    vdev->intx.pending = false;

    pci_irq_deassert(&vdev->pdev);



    /* Get an eventfd for resample/unmask */

    if (event_notifier_init(&vdev->intx.unmask, 0)) {

        error_report(""vfio: Error: event_notifier_init failed eoi"");

        goto fail;

    }



    /* KVM triggers it, VFIO listens for it */

    irqfd.resamplefd =",0,1,6,0,0,0,0,1,1,1,0,1,1,0,1
4555,qemu,0,"static inline void gen_evfsnabs(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);

#else

    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);

    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
",0,0,3,0,0,0,0,1,0,1,1,0,1,0,0
4556,qemu,0,"static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,

                                unsigned size)

{

    IMXTimerGState *s = (IMXTimerGState *)opaque;



    DPRINTF(""g-read(offset=%x)"", offset >> 2);

    switch (offset >> 2) {

    case 0: /* Control Register */

        DPRINTF("" cr = %x\n"", s->cr);

        return s->cr;



    case 1: /* prescaler */

        DPRINTF("" pr = %x\n"", s->pr);

        return s->pr;



    case 2: /* Status Register */

        DPRINTF("" sr = %x\n"", s->sr);

        return s->sr;



    case 3: /* Interrupt Register */

        DPRINTF("" ir = %x\n"", s->ir);

        return s->ir;



    case 4: /* Output Compare Register 1 */

        DPRINTF("" ocr1 = %x\n"", s->ocr1);

        return s->ocr1;





    case 9: /* cnt */

        imx_timerg_update_counts(s);

        DPRINTF("" cnt = %x\n"", s->cnt);

        return s->cnt;

    }



    IPRINTF(""imx_timerg_read: Bad offset %x\n"",

            (int)offset >> 2);

    return 0;

}
",0,0,0,0,1,0,0,0,0,0,0,0,1,1,1
4563,qemu,0,"static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,

                         Error **errp)

{

    BDRVBlkdebugState *s = bs->opaque;

    QemuOpts *opts;

    Error *local_err = NULL;

    int ret;



    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);

    qemu_opts_absorb_qdict(opts, options, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        ret = -EINVAL;

        goto out;

    }



    /* Read rules from config file or command line options */

    s->config_file = g_strdup(qemu_opt_get(opts, ""config""));

    ret = read_config(s, s->config_file, options, errp);

    if (ret) {

        goto out;

    }



    /* Set initial state */

    s->state = 1;



    /* Open the image file */

    bs->file = bdrv_open_child(qemu_opt_get(opts, ""x-image""), options, ""image"",

                               bs, &child_file, false, &local_err);

    if (local_err) {

        ret = -EINVAL;

        error_propagate(errp, local_err);

        got",0,2,3,0,0,0,1,1,1,1,0,1,0,0,0
4569,qemu,0,"static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
",0,0,0,0,0,0,0,0,0,1,1,1,1,1,1
4570,qemu,0,"static uint64_t exynos4210_fimd_read(void *opaque, target_phys_addr_t offset,

                                  unsigned size)

{

    Exynos4210fimdState *s = (Exynos4210fimdState *)opaque;

    int w, i;

    uint32_t ret = 0;



    DPRINT_L2(""read offset 0x%08x\n"", offset);



    switch (offset) {

    case FIMD_VIDCON0 ... FIMD_VIDCON3:

        return s->vidcon[(offset - FIMD_VIDCON0) >> 2];

    case FIMD_VIDTCON_START ... FIMD_VIDTCON_END:

        return s->vidtcon[(offset - FIMD_VIDTCON_START) >> 2];

    case FIMD_WINCON_START ... FIMD_WINCON_END:

        return s->window[(offset - FIMD_WINCON_START) >> 2].wincon;

    case FIMD_SHADOWCON:

        return s->shadowcon;

    case FIMD_WINCHMAP:

        return s->winchmap;

    case FIMD_VIDOSD_START ... FIMD_VIDOSD_END:

        w = (offset - FIMD_VIDOSD_START) >> 4;

        i = ((offset - FIMD_VIDOSD_START) & 0xF) >> 2;

        switch (i) {

        case 0:

            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<

            ",0,0,0,0,2,0,0,0,1,0,0,0,1,1,1
4571,qemu,0,"float64 HELPER(ucf64_absd)(float64 a)

{

    return float64_abs(a);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
4607,qemu,0,"static CharDriverState *qemu_chr_open_null(const char *id,

                                           ChardevBackend *backend,

                                           ChardevReturn *ret,

                                           Error **errp)

{

    CharDriverState *chr;

    ChardevCommon *common = backend->u.null;



    chr = qemu_chr_alloc(common, errp);

    if (!chr) {

        return NULL;

    }

    chr->chr_write = null_chr_write;

    chr->explicit_be_open = true;

    return chr;

}
",0,0,1,0,0,0,0,0,1,1,0,0,1,1,1
4609,qemu,0,"static int packet_enqueue(CompareState *s, int mode)

{

    ConnectionKey key;

    Packet *pkt = NULL;

    Connection *conn;



    if (mode == PRIMARY_IN) {

        pkt = packet_new(s->pri_rs.buf,

                         s->pri_rs.packet_len,

                         s->pri_rs.vnet_hdr_len);

    } else {

        pkt = packet_new(s->sec_rs.buf,

                         s->sec_rs.packet_len,

                         s->sec_rs.vnet_hdr_len);

    }



    if (parse_packet_early(pkt)) {

        packet_destroy(pkt, NULL);

        pkt = NULL;

        return -1;

    }

    fill_connection_key(pkt, &key);



    conn = connection_get(s->connection_track_table,

                          &key,

                          &s->conn_list);



    if (!conn->processing) {

        g_queue_push_tail(&s->conn_list, conn);

        conn->processing = true;

    }



    if (mode == PRIMARY_IN) {

        if (!colo_insert_packet(&conn->primary_list, pkt)) {

            error_report(""colo compare primary queue ",0,0,5,0,0,0,0,0,0,0,0,0,0,0,1
4610,FFmpeg,0,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)

{

    int i;

    for(i=0; i<4 && tags[i]; i++){

        enum CodecID id= codec_get_id(tags[i], tag);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
4611,qemu,0,"static void ide_atapi_identify(IDEState *s)

{

    uint16_t *p;



    if (s->identify_set) {

	memcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data));

	return;

    }



    memset(s->io_buffer, 0, 512);

    p = (uint16_t *)s->io_buffer;

    /* Removable CDROM, 50us response, 12 byte packets */

    put_le16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0));

    padstr((char *)(p + 10), s->drive_serial_str, 20); /* serial number */

    put_le16(p + 20, 3); /* buffer type */

    put_le16(p + 21, 512); /* cache size in sectors */

    put_le16(p + 22, 4); /* ecc bytes */

    padstr((char *)(p + 23), s->version, 8); /* firmware version */

    padstr((char *)(p + 27), ""QEMU DVD-ROM"", 40); /* model */

    put_le16(p + 48, 1); /* dword I/O (XXX: should not be set on CDROM) */

#ifdef USE_DMA_CDROM

    put_le16(p + 49, 1 << 9 | 1 << 8); /* DMA and LBA supported */

    put_le16(p + 53, 7); /* words 64-70, 54-58, 88 valid */

    put_le16(p + 62, 7);  /* single word dma0-2 supported ",0,0,6,0,0,0,0,0,0,0,0,0,1,1,1
4615,qemu,0,"static int kvm_put_xsave(CPUState *env)

{

#ifdef KVM_CAP_XSAVE

    int i, r;

    struct kvm_xsave* xsave;

    uint16_t cwd, swd, twd, fop;



    if (!kvm_has_xsave())

        return kvm_put_fpu(env);



    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));

    memset(xsave, 0, sizeof(struct kvm_xsave));

    cwd = swd = twd = fop = 0;

    swd = env->fpus & ~(7 << 11);

    swd |= (env->fpstt & 7) << 11;

    cwd = env->fpuc;

    for (i = 0; i < 8; ++i)

        twd |= (!env->fptags[i]) << i;

    xsave->region[0] = (uint32_t)(swd << 16) + cwd;

    xsave->region[1] = (uint32_t)(fop << 16) + twd;

    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,

            sizeof env->fpregs);

    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,

            sizeof env->xmm_regs);

    xsave->region[XSAVE_MXCSR] = env->mxcsr;

    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;

    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,

            sizeof env->ymmh_regs);

    r",1,0,2,0,0,0,1,1,1,1,1,1,1,1,1
4639,FFmpeg,1,"static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,

	int numLines, int levelFix)

{

	int i;

	if(levelFix)

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax \n\t""

						""movl %%eax, temp0\n\t""

						""pushl %0 \n\t""

						""pushl %1 \n\t""

						""leal (%2,%2), %%eax	\n\t""

						""leal (%3,%3), %%ebx	\n\t""

						""movq packedYOffset, %%mm2	\n\t""

						""movq packedYScale, %%mm3	\n\t""

						""pxor %%mm4, %%mm4	\n\t""



#define SCALED_CPY					\

						""movq (%0), %%mm0	\n\t""\

						""movq (%0,%2), %%mm1	\n\t""\

						""psubusb %%mm2, %%mm0	\n\t""\

						""psubusb %%mm2, %%mm1	\n\t""\

						""movq %%mm0, %%mm5	\n\t""\

						""punpcklbw %%mm4, %%mm0 \n\t""\

						""punpckhbw %%mm4, %%mm5 \n\t""\

						""psllw $7, %%mm0	\n\t""\

						""psllw $7, %%mm5	\n\t""\

						""pmulhw %%mm3, %%mm0	\n\t""\

						""pmulhw %%mm3, %%mm5	\n\t""\

						""packuswb %%mm5, %%mm0	\n\t""\

						""movq %%mm0, (%1)	\n\t""\

						""movq %%mm1, %%mm5	\n\t""\

						""punpcklbw %%mm4, %%mm1 \n\t""\

			",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
4645,qemu,1,"build_tpm2(GArray *table_data, BIOSLinker *linker)

{

    Acpi20TPM2 *tpm2_ptr;



    tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr);



    tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT);

    tpm2_ptr->control_area_address = cpu_to_le64(0);

    tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO);



    build_header(linker, table_data,

                 (void *)tpm2_ptr, ""TPM2"", sizeof(*tpm2_ptr), 4, NULL, NULL);

}
",1,0,0,0,0,0,0,0,0,0,1,1,1,1,0
4668,FFmpeg,1,"int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush)

{

    do {

        int nb_output = 0;

        int min_poc   = INT_MAX;

        int i, min_idx, ret;



        if (s->sh.no_output_of_prior_pics_flag == 1) {

            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {

                HEVCFrame *frame = &s->DPB[i];

                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&

                        frame->sequence == s->seq_output) {

                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);

                }

            }

        }



        for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {

            HEVCFrame *frame = &s->DPB[i];

            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&

                frame->sequence == s->seq_output) {

                nb_output++;

                if (frame->poc < min_poc) {

                    min_poc = frame->poc;

                    min_idx = i;

                }

            }

        }



",2,0,4,0,0,0,1,1,1,1,1,1,0,0,1
4681,FFmpeg,0,"static int mpegaudio_parse(AVCodecParserContext *s1,

                           AVCodecContext *avctx,

                           uint8_t **poutbuf, int *poutbuf_size, 

                           const uint8_t *buf, int buf_size)

{

    MpegAudioParseContext *s = s1->priv_data;

    int len, ret;

    uint32_t header;

    const uint8_t *buf_ptr;



    *poutbuf = NULL;

    *poutbuf_size = 0;

    buf_ptr = buf;

    while (buf_size > 0) {

	len = s->inbuf_ptr - s->inbuf;

	if (s->frame_size == 0) {

            /* special case for next header for first frame in free

               format case (XXX: find a simpler method) */

            if (s->free_format_next_header != 0) {

                s->inbuf[0] = s->free_format_next_header >> 24;

                s->inbuf[1] = s->free_format_next_header >> 16;

                s->inbuf[2] = s->free_format_next_header >> 8;

                s->inbuf[3] = s->free_format_next_header;

                s->inbuf_ptr = s->inbuf + 4;

                s->free_format_ne",9,0,2,0,0,1,1,1,1,1,0,0,0,1,1
4685,FFmpeg,0,"JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)

{

    int ret = 0;

    JNIEnv *env = NULL;



    *attached = 0;



    pthread_mutex_lock(&lock);

    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {



        av_log(log_ctx, AV_LOG_INFO, ""Retrieving current Java virtual machine using Android JniInvocation wrapper\n"");

        if (check_jni_invocation(log_ctx) == 0) {

            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libdvm.so"", log_ctx)) != NULL ||

                (java_vm = get_java_vm(""libart.so"", log_ctx)) != NULL) {

                av_log(log_ctx, AV_LOG_INFO, ""Found Java virtual machine using Android JniInvocation wrapper\n"");

            }

        }

    }

    pthread_mutex_unlock(&lock);



    if (!java_vm) {

        av_log(log_ctx, AV_LOG_ERROR, ""Could not retrieve a Java virtual machine\n"");

        return NULL;

    }



    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);

   ",0,0,4,0,0,0,1,0,0,0,1,0,0,0,0
4697,qemu,1,"static int perform_cow(BlockDriverState *bs, QCowL2Meta *m)

{

    BDRVQcow2State *s = bs->opaque;

    Qcow2COWRegion *start = &m->cow_start;

    Qcow2COWRegion *end = &m->cow_end;

    unsigned buffer_size;

    unsigned data_bytes = end->offset - (start->offset + start->nb_bytes);

    bool merge_reads;

    uint8_t *start_buffer, *end_buffer;

    QEMUIOVector qiov;

    int ret;



    assert(start->nb_bytes <= UINT_MAX - end->nb_bytes);

    assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes);

    assert(start->offset + start->nb_bytes <= end->offset);

    assert(!m->data_qiov || m->data_qiov->size == data_bytes);



    if (start->nb_bytes == 0 && end->nb_bytes == 0) {

        return 0;

    }



    /* If we have to read both the start and end COW regions and the

     * middle region is not too large then perform just one read

     * operation */

    merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384;

    if (merge_reads) {

        buffer_size = start->nb_byte",2,0,2,0,0,0,0,0,0,0,1,0,0,1,1
4698,FFmpeg,0,"void sws_rgb2rgb_init(int flags)

{

#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX

    if (flags & SWS_CPU_CAPS_SSE2)

        rgb2rgb_init_SSE2();

    else if (flags & SWS_CPU_CAPS_MMX2)

        rgb2rgb_init_MMX2();

    else if (flags & SWS_CPU_CAPS_3DNOW)

        rgb2rgb_init_3DNOW();

    else if (flags & SWS_CPU_CAPS_MMX)

        rgb2rgb_init_MMX();

    else

#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */

        rgb2rgb_init_C();

}
",0,0,6,0,0,0,0,1,0,0,0,0,0,0,0
4718,FFmpeg,0,"static double tget_double(GetByteContext *gb, int le)

{

    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};

    return i.f64;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4760,qemu,1,"static void init_proc_power5plus(CPUPPCState *env)

{

    gen_spr_ne_601(env);

    gen_spr_7xx(env);

    /* Time base */

    gen_tbl(env);

    /* Hardware implementation registers */

    /* XXX : not implemented */

    spr_register(env, SPR_HID0, ""HID0"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_clear,

                 0x60000000);

    /* XXX : not implemented */

    spr_register(env, SPR_HID1, ""HID1"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_750FX_HID2, ""HID2"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 0x00000000);

    /* XXX : not implemented */

    spr_register(env, SPR_970_HID5, ""HID5"",

                 SPR_NOACCESS, SPR_NOACCESS,

                 &spr_read_generic, &spr_write_generic,

                 POWERPC97",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
4761,FFmpeg,1,"static int64_t get_bit_rate(AVCodecContext *ctx)

{

    int64_t bit_rate;

    int bits_per_sample;



    switch (ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

    case AVMEDIA_TYPE_DATA:

    case AVMEDIA_TYPE_SUBTITLE:

    case AVMEDIA_TYPE_ATTACHMENT:

        bit_rate = ctx->bit_rate;

        break;

    case AVMEDIA_TYPE_AUDIO:

        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);

        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;

        break;

    default:

        bit_rate = 0;

        break;

    }

    return bit_rate;

}
",0,0,0,0,1,0,1,1,1,1,1,1,0,0,0
4762,FFmpeg,0,"static int mkv_write_codecprivate(AVFormatContext *s, AVIOContext *pb,

                                  AVCodecParameters *par,

                                  int native_id, int qt_id)

{

    AVIOContext *dyn_cp;

    uint8_t *codecpriv;

    int ret, codecpriv_size;



    ret = avio_open_dyn_buf(&dyn_cp);

    if (ret < 0)

        return ret;



    if (native_id) {

        ret = mkv_write_native_codecprivate(s, par, dyn_cp);

    } else if (par->codec_type == AVMEDIA_TYPE_VIDEO) {

        if (qt_id) {

            if (!par->codec_tag)

                par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags,

                                                    par->codec_id);

            if (   ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id

                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)

            ) {

                int i;

                avio_wb32(dyn_cp, 0x5a + par->extradata_siz",0,0,6,0,0,0,0,0,0,0,0,0,1,1,0
4766,FFmpeg,1,"void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){

    int i, dc = (block[0] + 15) >> 5;

    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;



    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += line_size;

    }

}
",1,0,0,0,0,0,1,1,1,1,0,0,1,1,1
4768,qemu,1,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
4769,FFmpeg,1,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
",0,0,2,0,0,0,1,1,1,1,1,1,1,0,0
4770,qemu,1,"void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s)

{

    if (!s->started) {

        return;

    }

    s->started = false;

    trace_virtio_blk_data_plane_stop(s);



    /* Stop thread or cancel pending thread creation BH */

    if (s->start_bh) {

        qemu_bh_delete(s->start_bh);

        s->start_bh = NULL;

    } else {

        event_poll_notify(&s->event_poll);

        qemu_thread_join(&s->thread);

    }



    ioq_cleanup(&s->ioqueue);



    s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, false);



    event_poll_cleanup(&s->event_poll);



    /* Clean up guest notifier (irq) */

    s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, false);



    vring_teardown(&s->vring);

}
",0,0,5,0,0,0,1,1,1,1,1,1,0,1,1
4781,FFmpeg,1,"static int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov,

                              MOVTrack *track, AVStream *st)

{

    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,

                                      track->timescale, AV_ROUND_UP);

    int version = duration < INT32_MAX ? 0 : 1;

    int flags   = MOV_TKHD_FLAG_IN_MOVIE;

    int rotation = 0;

    int group   = 0;



    uint32_t *display_matrix = NULL;

    int      display_matrix_size, i;



    if (st) {

        if (mov->per_stream_grouping)

            group = st->index;

        else

            group = st->codecpar->codec_type;



        display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX,

                                                            &display_matrix_size);

        if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix))

            display_matrix = NULL;

    }



    if (track->flags & MOV_TRACK_ENABLED)

        flags |= MOV_TKHD_FLAG_",0,0,4,0,0,0,1,0,0,1,1,1,0,0,0
4798,FFmpeg,1,"static int vobsub_read_seek(AVFormatContext *s, int stream_index,

                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)

{

    MpegDemuxContext *vobsub = s->priv_data;



    /* Rescale requested timestamps based on the first stream (timebase is the

     * same for all subtitles stream within a .idx/.sub). Rescaling is done just

     * like in avformat_seek_file(). */

    if (stream_index == -1 && s->nb_streams != 1) {

        int i, ret = 0;

        AVRational time_base = s->streams[0]->time_base;

        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);

        min_ts = av_rescale_rnd(min_ts, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);

        max_ts = av_rescale_rnd(max_ts, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);

        for (i = 0; i < ",3,0,1,0,0,0,1,1,1,1,1,1,0,0,0
4800,FFmpeg,0,"static av_cold int aac_encode_init(AVCodecContext *avctx)

{

    AACContext *s = avctx->priv_data;

    int ret = AVERROR(EINVAL);

    AACENC_InfoStruct info = { 0 };

    CHANNEL_MODE mode;

    AACENC_ERROR err;

    int aot = FF_PROFILE_AAC_LOW + 1;

    int sce = 0, cpe = 0;



    if ((err = aacEncOpen(&s->handle, 0, avctx->channels)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to open the encoder: %s\n"",

               aac_get_error(err));

        goto error;

    }



    if (avctx->profile != FF_PROFILE_UNKNOWN)

        aot = avctx->profile + 1;



    if ((err = aacEncoder_SetParam(s->handle, AACENC_AOT, aot)) != AACENC_OK) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to set the AOT %d: %s\n"",

               aot, aac_get_error(err));

        goto error;

    }



    if (aot == FF_PROFILE_AAC_ELD + 1 && s->eld_sbr) {

        if ((err = aacEncoder_SetParam(s->handle, AACENC_SBR_MODE,

                                       1)) != AACENC_OK) {

            av_log(avctx, AV_LO",0,2,5,0,0,0,0,1,0,1,0,0,1,1,1
4801,FFmpeg,1,"static int vorbis_floor1_decode(vorbis_context *vc,

                                vorbis_floor_data *vfu, float *vec)

{

    vorbis_floor1 *vf = &vfu->t1;

    GetBitContext *gb = &vc->gb;

    uint16_t range_v[4] = { 256, 128, 86, 64 };

    unsigned range = range_v[vf->multiplier - 1];

    uint16_t floor1_Y[258];

    uint16_t floor1_Y_final[258];

    int floor1_flag[258];

    unsigned class, cdim, cbits, csub, cval, offset, i, j;

    int book, adx, ady, dy, off, predicted, err;





    if (!get_bits1(gb)) // silence

        return 1;



// Read values (or differences) for the floor's points



    floor1_Y[0] = get_bits(gb, ilog(range - 1));

    floor1_Y[1] = get_bits(gb, ilog(range - 1));



    av_dlog(NULL, ""floor 0 Y %d floor 1 Y %d \n"", floor1_Y[0], floor1_Y[1]);



    offset = 2;

    for (i = 0; i < vf->partitions; ++i) {

        class = vf->partition_class[i];

        cdim   = vf->class_dimensions[class];

        cbits  = vf->class_subclasses[class];

        csub = (1 << cbits) - 1;",1,0,1,0,0,0,0,0,0,0,1,0,0,1,1
4815,qemu,1,"static void colo_process_checkpoint(MigrationState *s)
{
    QIOChannelBuffer *bioc;
    QEMUFile *fb = NULL;
    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);
    Error *local_err = NULL;
    int ret;
    failover_init_state();
    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);
    if (!s->rp_state.from_dst_file) {
        error_report(""Open QEMUFile from_dst_file failed"");
    /*
     * Wait for Secondary finish loading VM states and enter COLO
     * restore.
     */
    colo_receive_check_message(s->rp_state.from_dst_file,
                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);
    if (local_err) {
    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);
    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));
    object_unref(OBJECT(bioc));
    qemu_mutex_lock_iothread();
    vm_start();
    qemu_mutex_unlock_iothread();
    trace_colo_vm_state_change(""stop"", ""run"");
    while (s->state == MIGRATION_STATUS_COLO) {
        current_time = qemu",1,0,2,0,0,1,1,1,1,1,1,1,0,1,1
4835,qemu,0,"static void pc_init1(QEMUMachineInitArgs *args,

                     int pci_enabled,

                     int kvmclock_enabled)

{

    MemoryRegion *system_memory = get_system_memory();

    MemoryRegion *system_io = get_system_io();

    int i;

    ram_addr_t below_4g_mem_size, above_4g_mem_size;

    PCIBus *pci_bus;

    ISABus *isa_bus;

    PCII440FXState *i440fx_state;

    int piix3_devfn = -1;

    qemu_irq *cpu_irq;

    qemu_irq *gsi;

    qemu_irq *i8259;

    qemu_irq *smi_irq;

    GSIState *gsi_state;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BusState *idebus[MAX_IDE_BUS];

    ISADevice *rtc_state;

    ISADevice *floppy;

    MemoryRegion *ram_memory;

    MemoryRegion *pci_memory;

    MemoryRegion *rom_memory;

    DeviceState *icc_bridge;

    FWCfgState *fw_cfg = NULL;

    PcGuestInfo *guest_info;



    if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {

        fprintf(stderr, ""xen hardware virtual machine initialisation failed\n"");

        exit(1);

    }



    ic",0,0,1,0,0,0,0,0,0,0,0,0,1,0,1
4842,qemu,0,"uint32_t wm8750_adc_dat(void *opaque)

{

    WM8750State *s = (WM8750State *) opaque;

    uint32_t *data;



    if (s->idx_in >= sizeof(s->data_in))

        wm8750_in_load(s);



    data = (uint32_t *) &s->data_in[s->idx_in];

    s->req_in -= 4;

    s->idx_in += 4;

    return *data;

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,0
4849,qemu,0,"static QmpInputVisitor *to_qiv(Visitor *v)

{

    return container_of(v, QmpInputVisitor, visitor);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
4873,FFmpeg,0,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *s = s1->priv_data;

    AVFrame *frame = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(pkt);

    if ((res = mmap_read_frame(s1, pkt)) < 0) {

        return res;

    }



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    if (frame && s->interlaced) {

        frame->interlaced_frame = 1;

        frame->top_field_first = s->top_field_first;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    return pkt->size;

}
",0,0,6,0,0,0,0,0,0,0,0,1,0,1,1
4874,qemu,1,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = bonito_pcihost_initfn;

    dc->no_user = 1;

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
4879,FFmpeg,0,"static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)

{

    uint32_t v, spf;

    MPADecodeHeader c;

    int vbrtag_size = 0;

    MP3DecContext *mp3 = s->priv_data;



    ffio_init_checksum(s->pb, ff_crcA001_update, 0);



    v = avio_rb32(s->pb);

    if(ff_mpa_check_header(v) < 0)

      return -1;



    if (avpriv_mpegaudio_decode_header(&c, v) == 0)

        vbrtag_size = c.frame_size;

    if(c.layer != 3)

        return -1;



    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */



    mp3->frames = 0;

    mp3->size   = 0;



    mp3_parse_info_tag(s, st, &c, spf);

    mp3_parse_vbri_tag(s, st, base);



    if (!mp3->frames && !mp3->size)

        return -1;



    /* Skip the vbr tag frame */

    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);



    if (mp3->frames)

        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},

                                    st->time_base);

    if (mp3->size && mp3->frames && !mp3->is_cbr)

    ",0,0,6,0,0,0,1,1,1,1,1,1,0,0,0
4892,qemu,0,"void memory_region_iommu_replay_all(MemoryRegion *mr)

{

    IOMMUNotifier *notifier;



    IOMMU_NOTIFIER_FOREACH(notifier, mr) {

        memory_region_iommu_replay(mr, notifier, false);

    }

}
",0,0,4,0,0,0,0,0,0,0,0,1,0,0,0
4893,qemu,0,"static int usb_uhci_piix3_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);

    return usb_uhci_common_initfn(s);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
4896,FFmpeg,0,"static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)

{

    MpegTSWrite *ts = s->priv_data;

    uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr;

    int val, stream_type, i;



    q = data;

    put16(&q, 0xe000 | service->pcr_pid);



    program_info_length_ptr = q;

    q += 2; /* patched after */



    /* put program info here */



    val = 0xf000 | (q - program_info_length_ptr - 2);

    program_info_length_ptr[0] = val >> 8;

    program_info_length_ptr[1] = val;



    for(i = 0; i < s->nb_streams; i++) {

        AVStream *st = s->streams[i];

        MpegTSWriteStream *ts_st = st->priv_data;

        AVDictionaryEntry *lang = av_dict_get(st->metadata, ""language"", NULL,0);

        switch(st->codec->codec_id) {

        case AV_CODEC_ID_MPEG1VIDEO:

        case AV_CODEC_ID_MPEG2VIDEO:

            stream_type = STREAM_TYPE_VIDEO_MPEG2;

            break;

        case AV_CODEC_ID_MPEG4:

            stream_type = STREAM_TYPE_VIDEO_MPEG4;

            bre",1,0,0,0,1,0,0,0,0,0,0,0,1,1,1
4899,qemu,0,"static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
",0,0,0,0,0,0,0,1,1,1,1,0,0,1,1
4924,qemu,0,"static void gen_trap (DisasContext *ctx, uint32_t opc,

                      int rs, int rt, int16_t imm)

{

    int cond;

    TCGv t0 = tcg_temp_new();

    TCGv t1 = tcg_temp_new();



    cond = 0;

    /* Load needed operands */

    switch (opc) {

    case OPC_TEQ:

    case OPC_TGE:

    case OPC_TGEU:

    case OPC_TLT:

    case OPC_TLTU:

    case OPC_TNE:

        /* Compare two registers */

        if (rs != rt) {

            gen_load_gpr(t0, rs);

            gen_load_gpr(t1, rt);

            cond = 1;

        }

        break;

    case OPC_TEQI:

    case OPC_TGEI:

    case OPC_TGEIU:

    case OPC_TLTI:

    case OPC_TLTIU:

    case OPC_TNEI:

        /* Compare register to immediate */

        if (rs != 0 || imm != 0) {

            gen_load_gpr(t0, rs);

            tcg_gen_movi_tl(t1, (int32_t)imm);

            cond = 1;

        }

        break;

    }

    if (cond == 0) {

        switch (opc) {

        case OPC_TEQ:   /* rs == rs */

        case OPC_TEQI:  /* r0 == 0  */

",0,0,3,0,2,0,1,1,1,1,1,0,0,1,1
4961,qemu,0,"static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,

                                 unsigned size)

{

    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;

    uint32_t ret;

    int bank;

    if (offset >= 0x200)

        return 0;



    bank = pxa2xx_gpio_regs[offset].bank;

    switch (pxa2xx_gpio_regs[offset].reg) {

    case GPDR:		/* GPIO Pin-Direction registers */

        return s->dir[bank];



    case GPSR:		/* GPIO Pin-Output Set registers */

        qemu_log_mask(LOG_GUEST_ERROR,

                      ""pxa2xx GPIO: read from write only register GPSR\n"");

        return 0;



    case GPCR:		/* GPIO Pin-Output Clear registers */

        qemu_log_mask(LOG_GUEST_ERROR,

                      ""pxa2xx GPIO: read from write only register GPCR\n"");

        return 0;



    case GRER:		/* GPIO Rising-Edge Detect Enable registers */

        return s->rising[bank];



    case GFER:		/* GPIO Falling-Edge Detect Enable registers */

        return s->falling[bank];



    case GAFR_L:	/* ",0,0,1,0,1,0,0,0,0,0,0,0,1,0,1
4995,FFmpeg,1,"static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    /* 4-color block encoding: each 4x4 block is a different color */
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    /* report success */
    return 0;",1,0,1,0,0,0,0,0,0,1,0,0,1,0,0
5035,qemu,0,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)

{

    MigrationState *s = opaque;

    if (qemu_file_get_error(s->file)) {

        goto out;

    }



    s->xfer_limit = new_rate;



out:

    return s->xfer_limit;

}
",0,1,1,0,0,0,0,0,0,0,1,0,0,0,0
5044,FFmpeg,0,"static void reverse_matrixing(float *su1, float *su2, int *prev_code,

                              int *curr_code)

{

    int i, nsample, band;

    float mc1_l, mc1_r, mc2_l, mc2_r;



    for (i = 0, band = 0; band < 4 * 256; band += 256, i++) {

        int s1 = prev_code[i];

        int s2 = curr_code[i];

        nsample = 0;



        if (s1 != s2) {

            /* Selector value changed, interpolation needed. */

            mc1_l = matrix_coeffs[s1 * 2    ];

            mc1_r = matrix_coeffs[s1 * 2 + 1];

            mc2_l = matrix_coeffs[s2 * 2    ];

            mc2_r = matrix_coeffs[s2 * 2 + 1];



            /* Interpolation is done over the first eight samples. */

            for (; nsample < 8; nsample++) {

                float c1 = su1[band + nsample];

                float c2 = su2[band + nsample];

                c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +

                     c2 * INTERPOLATE(mc1_r, mc2_r, nsample);

                su1[band + nsample] = c2;

               ",2,0,1,0,0,0,0,0,0,0,0,0,0,0,0
5054,qemu,0,"static void scsi_disk_reset(DeviceState *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);

    uint64_t nb_sectors;



    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));



    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    nb_sectors /= s->qdev.blocksize / 512;

    if (nb_sectors) {

        nb_sectors--;

    }

    s->qdev.max_lba = nb_sectors;

    /* reset tray statuses */

    s->tray_locked = 0;

    s->tray_open = 0;

}
",0,0,1,0,0,0,1,0,1,1,1,1,0,0,0
5060,FFmpeg,1,"static int read_part_of_packet(AVFormatContext *s, int64_t *pts,

                               int *len, int *strid, int read_packet) {

    AVIOContext *pb = s->pb;

    PVAContext *pvactx = s->priv_data;

    int syncword, streamid, reserved, flags, length, pts_flag;

    int64_t pva_pts = AV_NOPTS_VALUE, startpos;

    int ret;



recover:

    startpos = avio_tell(pb);



    syncword = avio_rb16(pb);

    streamid = avio_r8(pb);

    avio_r8(pb);               /* counter not used */

    reserved = avio_r8(pb);

    flags    = avio_r8(pb);

    length   = avio_rb16(pb);



    pts_flag = flags & 0x10;



    if (syncword != PVA_MAGIC) {

        pva_log(s, AV_LOG_ERROR, ""invalid syncword\n"");

        return AVERROR(EIO);

    }

    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {

        pva_log(s, AV_LOG_ERROR, ""invalid streamid\n"");

        return AVERROR(EIO);

    }

    if (reserved != 0x55) {

        pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");

   ",0,0,3,0,0,0,1,1,1,1,1,1,1,1,1
5071,FFmpeg,1,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
",2,0,0,0,0,0,1,1,1,1,0,1,1,1,0
5093,qemu,0,"static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,

                              uint16_t index, uint16_t num)

{

    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);



    if (index >= VIRTIO_PCI_QUEUE_MAX) {

        return -EINVAL;

    }



    /* Current code in virtio.c relies on 4K alignment. */

    if (addr && (align != 4096)) {

        return -EINVAL;

    }



    if (!vdev) {

        return -EINVAL;

    }



    virtio_queue_set_addr(vdev, index, addr);

    if (!addr) {

        virtio_queue_set_vector(vdev, index, 0);

    } else {

        /* Fail if we don't have a big enough queue. */

        /* TODO: Add interface to handle vring.num changing */

        if (virtio_queue_get_num(vdev, index) > num) {

            return -EINVAL;

        }

        virtio_queue_set_vector(vdev, index, index);

    }

    /* tell notify handler in case of config change */

    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;

    return 0;

}
",0,0,5,0,0,0,0,0,0,0,0,0,1,1,1
5099,qemu,0,"static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)

{

    rtl8139_do_receive(opaque, buf, size, 1);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
5102,qemu,0,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)

{

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||

        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||

        (fs_ctx->export_flags & V9FS_SM_NONE)) {

        return lchown(rpath(fs_ctx, path, buffer),

                      credp->fc_uid, credp->fc_gid);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);

    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {

        return local_set_mapped_file_attr(fs_ctx, path, credp);

    }

    return -1;

}
",0,0,3,0,0,0,0,0,1,0,0,0,1,1,1
5104,qemu,0,"static void qdict_crumple_test_recursive(void)

{

    QDict *src, *dst, *rule, *vnc, *acl, *listen;

    QObject *child, *res;

    QList *rules;



    src = qdict_new();

    qdict_put(src, ""vnc.listen.addr"", qstring_from_str(""127.0.0.1""));

    qdict_put(src, ""vnc.listen.port"", qstring_from_str(""5901""));

    qdict_put(src, ""vnc.acl.rules.0.match"", qstring_from_str(""fred""));

    qdict_put(src, ""vnc.acl.rules.0.policy"", qstring_from_str(""allow""));

    qdict_put(src, ""vnc.acl.rules.1.match"", qstring_from_str(""bob""));

    qdict_put(src, ""vnc.acl.rules.1.policy"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl.default"", qstring_from_str(""deny""));

    qdict_put(src, ""vnc.acl..name"", qstring_from_str(""acl0""));

    qdict_put(src, ""vnc.acl.rule..name"", qstring_from_str(""acl0""));



    res = qdict_crumple(src, &error_abort);



    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);



    dst = qobject_to_qdict(res);



    g_assert_cmpint(qdict_size(dst), ==, 1);



    child = qdict_get(dst, ""vnc",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
5121,qemu,1,"static void test_validate_fail_alternate(TestInputVisitorData *data,

                                         const void *unused)

{

    UserDefAlternate *tmp;

    Visitor *v;

    Error *err = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAlternate(v, NULL, &tmp, &err);

    error_free_or_abort(&err);

    qapi_free_UserDefAlternate(tmp);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
5129,qemu,1,"static int qcow2_co_flush(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    int ret;



    qemu_co_mutex_lock(&s->lock);

    ret = qcow2_cache_flush(bs, s->l2_table_cache);

    if (ret < 0) {


        return ret;

    }



    ret = qcow2_cache_flush(bs, s->refcount_block_cache);

    if (ret < 0) {


        return ret;

    }




    return bdrv_co_flush(bs->file);

}",0,0,2,0,0,0,0,1,1,1,1,1,1,1,1
5138,FFmpeg,1,"static int vc1_init_common(VC1Context *v)

{

    static int done = 0;

    int i = 0;



    v->hrd_rate = v->hrd_buffer = NULL;



    /* VLC tables */

    if(!done)

    {

        done = 1;

        init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,

                 ff_vc1_bfraction_bits, 1, 1,

                 ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,

                 ff_vc1_norm2_bits, 1, 1,

                 ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,

                 ff_vc1_norm6_bits, 1, 1,

                 ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC);

        init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,

                 ff_vc1_imode_bits, 1, 1,

                 ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC);

        for (i=0; i<3; i++)

        {

            init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16,

                     ff_vc1_",1,0,1,0,0,0,1,0,0,1,0,1,1,1,1
5146,FFmpeg,1,"int av_read_packet(AVFormatContext *s, AVPacket *pkt)
{
    int ret, i;
    AVStream *st;
    for(;;){
        AVPacketList *pktl = s->raw_packet_buffer;
        if (pktl) {
            *pkt = pktl->pkt;
            if(s->streams[pkt->stream_index]->codec->codec_id != CODEC_ID_PROBE ||
               !s->streams[pkt->stream_index]->probe_packets ||
               s->raw_packet_buffer_remaining_size < pkt->size){
                AVProbeData *pd = &s->streams[pkt->stream_index]->probe_data;
                av_freep(&pd->buf);
                pd->buf_size = 0;
                s->raw_packet_buffer = pktl->next;
                s->raw_packet_buffer_remaining_size += pkt->size;
                av_free(pktl);
                return 0;
        av_init_packet(pkt);
        ret= s->iformat->read_packet(s, pkt);
        if (ret < 0) {
            if (!pktl || ret == AVERROR(EAGAIN))
                return ret;
            for (i = 0; i < s->nb_streams; i++)
                s->streams[i]->probe_packets = 0;
        st= s",3,0,5,0,0,0,0,0,0,0,0,0,1,1,1
5171,qemu,1,"static int nbd_can_accept(void)

{

    return nb_fds < shared;

}
",0,0,0,0,0,0,1,1,1,0,1,0,1,0,0
5172,qemu,1,"static int net_connect(struct XenDevice *xendev)

{

    struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev);

    int rx_copy;



    if (xenstore_read_fe_int(&netdev->xendev, ""tx-ring-ref"",

                             &netdev->tx_ring_ref) == -1) {

        return -1;

    }

    if (xenstore_read_fe_int(&netdev->xendev, ""rx-ring-ref"",

                             &netdev->rx_ring_ref) == -1) {

        return 1;

    }

    if (xenstore_read_fe_int(&netdev->xendev, ""event-channel"",

                             &netdev->xendev.remote_port) == -1) {

        return -1;

    }



    if (xenstore_read_fe_int(&netdev->xendev, ""request-rx-copy"", &rx_copy) == -1) {

        rx_copy = 0;

    }

    if (rx_copy == 0) {

        xen_be_printf(&netdev->xendev, 0, ""frontend doesn't support rx-copy.\n"");

        return -1;

    }



    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,

                                          netdev->xendev.dom,

                            ",0,0,5,0,0,0,0,0,0,0,0,0,1,1,1
5174,qemu,1,"static bool do_modify_softint(CPUSPARCState *env, uint32_t value)

{

    if (env->softint != value) {

        env->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(env)) {


            cpu_check_irqs(env);


        }

#endif

        return true;

    }

    return false;

}",0,0,5,0,0,0,1,1,1,1,1,1,0,1,1
5190,FFmpeg,1,"static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent, int numBands)

{

    int i,j,k,cnt;

    int   components, coding_mode_selector, coding_mode, coded_values_per_component;

    int   sfIndx, coded_values, max_coded_values, quant_step_index, coded_components;

    int   band_flags[4], mantissa[8];

    float  *pCoef;

    float  scalefactor;

    int   component_count = 0;



    components = get_bits(gb,5);



    /* no tonal components */

    if (components == 0)

        return 0;



    coding_mode_selector = get_bits(gb,2);

    if (coding_mode_selector == 2)




    coding_mode = coding_mode_selector & 1;



    for (i = 0; i < components; i++) {

        for (cnt = 0; cnt <= numBands; cnt++)

            band_flags[cnt] = get_bits1(gb);



        coded_values_per_component = get_bits(gb,3);



        quant_step_index = get_bits(gb,3);

        if (quant_step_index <= 1)




        if (coding_mode_selector == 3)

            coding_mode = get_bits1(gb);



        for",3,0,4,0,0,0,1,1,1,1,1,1,0,0,1
5191,qemu,1,"static void do_send_key(const char *string)

{

    char keybuf[16], *q;

    uint8_t keycodes[16];

    const char *p;

    int nb_keycodes, keycode, i;



    nb_keycodes = 0;

    p = string;

    while (*p != '\0') {

        q = keybuf;

        while (*p != '\0' && *p != '-') {

            if ((q - keybuf) < sizeof(keybuf) - 1) {

                *q++ = *p;

            }

            p++;

        }

        *q = '\0';

        keycode = get_keycode(keybuf);

        if (keycode < 0) {

            term_printf(""unknown key: '%s'\n"", keybuf);

            return;

        }

        keycodes[nb_keycodes++] = keycode;

        if (*p == '\0')

            break;

        p++;

    }

    /* key down events */

    for(i = 0; i < nb_keycodes; i++) {

        keycode = keycodes[i];

        if (keycode & 0x80)

            kbd_put_keycode(0xe0);

        kbd_put_keycode(keycode & 0x7f);

    }

    /* key up events */

    for(i = nb_keycodes - 1; i >= 0; i--) {

        keycode = keycodes[i];

        if",2,0,5,0,0,2,0,1,0,0,0,0,1,1,1
5198,qemu,0,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double d;

    char *ptr;

    FdMigrationState *s;

    const char *value = qdict_get_str(qdict, ""value"");



    d = strtod(value, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    }

    

}
",0,0,1,0,1,0,0,0,1,1,0,0,0,0,0
5201,qemu,0,"static inline void gen_efdneg(DisasContext *ctx)

{

    if (unlikely(!ctx->spe_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_APU);

        return;

    }

#if defined(TARGET_PPC64)

    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);

#else

    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);

    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);

#endif

}
",0,0,3,0,0,0,0,0,0,1,0,0,1,1,1
5219,qemu,0,"static void gen_srlq(DisasContext *ctx)

{

    int l1 = gen_new_label();

    int l2 = gen_new_label();

    TCGv t0 = tcg_temp_local_new();

    TCGv t1 = tcg_temp_local_new();

    TCGv t2 = tcg_temp_local_new();

    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);

    tcg_gen_movi_tl(t1, 0xFFFFFFFF);

    tcg_gen_shr_tl(t2, t1, t2);

    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);

    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);

    gen_load_spr(t0, SPR_MQ);

    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);

    tcg_gen_and_tl(t0, t0, t2);

    gen_load_spr(t1, SPR_MQ);

    tcg_gen_andc_tl(t1, t1, t2);

    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);

    gen_set_label(l2);

    tcg_temp_free(t0);

    tcg_temp_free(t1);

    tcg_temp_free(t2);

    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);

}
",0,0,1,0,0,0,0,0,0,1,1,0,0,1,1
5222,qemu,0,"static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)

{

    VirtQueueElement elem;

    VirtQueue *vq;



    vq = vser->c_ivq;

    if (!virtio_queue_ready(vq)) {

        return 0;

    }

    if (!virtqueue_pop(vq, &elem)) {

        return 0;

    }



    /* TODO: detect a buffer that's too short, set NEEDS_RESET */

    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);



    virtqueue_push(vq, &elem, len);

    virtio_notify(VIRTIO_DEVICE(vser), vq);

    return len;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
5229,qemu,0,"void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,

                  qemu_irq sci_irq)

{

    memory_region_init(&pm->io, OBJECT(lpc_pci), ""ich9-pm"", ICH9_PMIO_SIZE);

    memory_region_set_enabled(&pm->io, false);

    memory_region_add_subregion(pci_address_space_io(lpc_pci),

                                0, &pm->io);



    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);

    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);

    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->s4_val);



    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);

    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,

                          ""acpi-gpe0"", ICH9_PMIO_GPE0_LEN);

    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);



    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,

                          ""acpi-smi"", 8);

    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);



    pm->irq = sc",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
5250,qemu,0,"uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)

{

    uint8_t ret;



    OMAP_8B_REG(addr);

    cpu_physical_memory_read(addr, (void *) &ret, 1);

    return ret;

}
",0,0,0,0,0,0,0,0,0,0,0,1,1,1,1
5263,qemu,1,"static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)

{

    q->pending++;

    set_bit(q->queue, n_IRQ);

}
",0,0,0,0,0,0,0,0,1,1,0,0,1,1,1
5277,FFmpeg,1,"static int matroska_decode_buffer(uint8_t** buf, int* buf_size,

                                  MatroskaTrack *track)

{

    MatroskaTrackEncoding *encodings = track->encodings.elem;

    uint8_t* data = *buf;

    int isize = *buf_size;

    uint8_t* pkt_data = NULL;

    int pkt_size = isize;

    int result = 0;

    int olen;



    if (pkt_size >= 10000000)

        return -1;



    switch (encodings[0].compression.algo) {

    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:

        return encodings[0].compression.settings.size;

    case MATROSKA_TRACK_ENCODING_COMP_LZO:

        do {

            olen = pkt_size *= 3;

            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);

            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);

        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);

        if (result)

            goto failed;

        pkt_size -= olen;

        break;

#if CONFIG_ZLIB

    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {

        z_strea",0,1,3,0,1,1,0,1,1,1,1,1,1,1,1
5281,FFmpeg,0,"static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs)

{

    int i;



    for (i = 0; i < nb_coefs; i++) {

        int e;

        int v = abs(coef[i]);

        if (v == 0)

            e = 24;

        else {

            e = 23 - av_log2(v);

            if (e >= 24) {

                e = 24;

                coef[i] = 0;

            }

            av_assert2(e >= 0);

        }

        exp[i] = e;

    }

}
",1,0,2,0,0,0,0,0,0,0,0,0,1,1,1
5283,qemu,0,"static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

{

    /* FIXME: implement */

}
",0,0,0,0,0,0,0,0,1,0,1,0,0,0,0
5298,qemu,0,"static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)

{

    struct hp_log_full *new_hp;

    struct rtas_error_log *hdr;

    struct rtas_event_log_v6 *v6hdr;

    struct rtas_event_log_v6_maina *maina;

    struct rtas_event_log_v6_mainb *mainb;

    struct rtas_event_log_v6_hp *hp;

    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);

    sPAPRDRConnectorType drc_type = drck->get_type(drc);



    new_hp = g_malloc0(sizeof(struct hp_log_full));

    hdr = &new_hp->hdr;

    v6hdr = &new_hp->v6hdr;

    maina = &new_hp->maina;

    mainb = &new_hp->mainb;

    hp = &new_hp->hp;



    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6

                               | RTAS_LOG_SEVERITY_EVENT

                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED

                               | RTAS_LOG_OPTIONAL_PART_PRESENT

                               | RTAS_LOG_INITIATOR_HOTPLUG

                               | RTAS_LOG_TYPE_HOTPLUG);

    hdr->extended_length = cpu",0,0,0,0,0,0,0,1,0,1,1,0,1,1,1
5304,qemu,0,"static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,

                               TCGMemOp s_bits, int which)

{

    const TCGReg r0 = TCG_REG_O0;

    const TCGReg r1 = TCG_REG_O1;

    const TCGReg r2 = TCG_REG_O2;

    int tlb_ofs;



    /* Shift the page number down.  */

    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);



    /* Mask out the page offset, except for the required alignment.  */

    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,

                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));



    /* Mask the tlb index.  */

    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);

    

    /* Mask page, part 2.  */

    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);



    /* Shift the tlb index into place.  */

    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);



    /* Relative to the current ENV.  */

    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);



    /* Find a base address that can load both tlb comparator and addend.  */

    t",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
5306,qemu,0,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
",0,0,0,0,1,0,0,0,0,0,0,0,1,1,1
5308,FFmpeg,1,"SwsFunc yuv2rgb_get_func_ptr (SwsContext *c)

{

#if defined(HAVE_MMX2) || defined(HAVE_MMX)

    if(c->flags & SWS_CPU_CAPS_MMX2){

	switch(c->dstFormat){

	case PIX_FMT_RGB32: return yuv420_rgb32_MMX2;

	case PIX_FMT_BGR24: return yuv420_rgb24_MMX2;

	case PIX_FMT_BGR565: return yuv420_rgb16_MMX2;

	case PIX_FMT_BGR555: return yuv420_rgb15_MMX2;

	}

    }

    if(c->flags & SWS_CPU_CAPS_MMX){

	switch(c->dstFormat){

	case PIX_FMT_RGB32: return yuv420_rgb32_MMX;

	case PIX_FMT_BGR24: return yuv420_rgb24_MMX;

	case PIX_FMT_BGR565: return yuv420_rgb16_MMX;

	case PIX_FMT_BGR555: return yuv420_rgb15_MMX;

	}

    }

#endif

#ifdef HAVE_MLIB

    {

	SwsFunc t= yuv2rgb_init_mlib(c);

	if(t) return t;

    }

#endif

#ifdef HAVE_ALTIVEC

    if (c->flags & SWS_CPU_CAPS_ALTIVEC)

    {

	SwsFunc t = yuv2rgb_init_altivec(c);

	if(t) return t;

    }

#endif



    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");



    switch(c->dstFormat){

    case PIX_FMT_BGR32:

    case PIX_FMT_RGB",0,0,11,0,3,0,0,1,1,0,1,1,1,1,1
5314,qemu,1,"static void vnc_set_share_mode(VncState *vs, VncShareMode mode)

{

#ifdef _VNC_DEBUG

    static const char *mn[] = {

        [0]                           = ""undefined"",

        [VNC_SHARE_MODE_CONNECTING]   = ""connecting"",

        [VNC_SHARE_MODE_SHARED]       = ""shared"",

        [VNC_SHARE_MODE_EXCLUSIVE]    = ""exclusive"",

        [VNC_SHARE_MODE_DISCONNECTED] = ""disconnected"",

    };

    fprintf(stderr, ""%s/%d: %s -> %s\n"", __func__,

            vs->csock, mn[vs->share_mode], mn[mode]);

#endif



    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {

        vs->vd->num_exclusive--;

    }

    vs->share_mode = mode;

    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {

        vs->vd->num_exclusive++;

    }

}
",0,0,4,0,0,0,1,1,1,1,1,1,1,0,1
5327,FFmpeg,1,"uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)

{

    uint32_t scratch = 0;

    const uint8_t *buf_end = buf + buf_size;





    for (; buf < buf_end - 3; buf += 4)

        scratch ^= *((const uint32_t*)buf);



    scratch = xor_32_to_8(scratch);



    for (; buf < buf_end; buf++)




    return scratch;

}",2,0,0,0,0,0,0,0,1,1,0,0,1,1,1
5353,FFmpeg,0,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
",0,0,1,0,0,0,0,1,1,0,1,0,0,0,0
5356,FFmpeg,0,"av_cold int MPV_common_init(MpegEncContext *s)

{

    int y_size, c_size, yc_size, i, mb_array_size, mv_table_size, x, y, threads;



    if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)

        s->mb_height = (s->height + 31) / 32 * 2;

    else if (s->codec_id != CODEC_ID_H264)

        s->mb_height = (s->height + 15) / 16;



    if(s->avctx->pix_fmt == PIX_FMT_NONE){

        av_log(s->avctx, AV_LOG_ERROR, ""decoding to PIX_FMT_NONE is not supported.\n"");

        return -1;

    }



    if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) &&

       (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){

        av_log(s->avctx, AV_LOG_ERROR, ""too many threads\n"");

        return -1;

    }



    if((s->width || s->height) && av_image_check_size(s->width, s->height, 0, s->avctx))

        return -1;



    dsputil_init(&s->dsp, s->avctx);

    ff_dct_common_init(s);



    s->flags= s->avctx->flags;

    s->flags2= s->avct",0,0,5,0,0,0,1,1,1,1,0,1,0,0,1
5357,FFmpeg,0,"int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,

                          const char *filename, void *logctx,

                          unsigned int offset, unsigned int max_probe_size)

{

    AVProbeData pd = { filename ? filename : """", NULL, -offset };

    unsigned char *buf = NULL;

    int ret = 0, probe_size;



    if (!max_probe_size) {

        max_probe_size = PROBE_BUF_MAX;

    } else if (max_probe_size > PROBE_BUF_MAX) {

        max_probe_size = PROBE_BUF_MAX;

    } else if (max_probe_size < PROBE_BUF_MIN) {

        return AVERROR(EINVAL);

    }



    if (offset >= max_probe_size) {

        return AVERROR(EINVAL);

    }



    for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;

        probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) {

        int score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0;

        int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;

        void *buftmp;



        if (probe_si",1,0,5,0,0,0,0,0,0,0,1,0,0,0,0
5361,qemu,1,"static void slirp_smb(SlirpState* s, Monitor *mon, const char *exported_dir,

                      struct in_addr vserver_addr)

{

    static int instance;

    char smb_conf[128];

    char smb_cmdline[128];

    FILE *f;



    snprintf(s->smb_dir, sizeof(s->smb_dir), ""/tmp/qemu-smb.%ld-%d"",

             (long)getpid(), instance++);

    if (mkdir(s->smb_dir, 0700) < 0) {

        config_error(mon, ""could not create samba server dir '%s'\n"",

                     s->smb_dir);

        return;

    }

    snprintf(smb_conf, sizeof(smb_conf), ""%s/%s"", s->smb_dir, ""smb.conf"");



    f = fopen(smb_conf, ""w"");

    if (!f) {

        slirp_smb_cleanup(s);

        config_error(mon, ""could not create samba server ""

                     ""configuration file '%s'\n"", smb_conf);

        return;

    }

    fprintf(f,

            ""[global]\n""

            ""private dir=%s\n""

            ""smb ports=0\n""

            ""socket address=127.0.0.1\n""

            ""pid directory=%s\n""

            ""lock directory=%s\n""",0,0,2,0,0,0,1,1,1,1,1,1,0,0,0
5381,qemu,0,"void tlb_set_page(CPUState *env, target_ulong vaddr,

                  target_phys_addr_t paddr, int prot,

                  int mmu_idx, target_ulong size)

{

    PhysPageDesc *p;

    unsigned long pd;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    unsigned long addend;

    CPUTLBEntry *te;

    CPUWatchpoint *wp;

    target_phys_addr_t iotlb;



    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }

    p = phys_page_find(paddr >> TARGET_PAGE_BITS);

    if (!p) {

        pd = IO_MEM_UNASSIGNED;

    } else {

        pd = p->phys_offset;

    }

#if defined(DEBUG_TLB)

    printf(""tlb_set_page: vaddr="" TARGET_FMT_lx "" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\n"",

           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);

#endif



    address = vaddr;

    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {

        /* IO memory case (romd handled later) */

",0,0,5,0,0,0,0,0,0,0,0,0,0,0,0
5386,qemu,0,"void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,

                         const uint32_t *intbit_to_level,

                         qemu_irq **irq, qemu_irq **cpu_irq,

                         unsigned int cputimer)



{

    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;

    SLAVIO_INTCTLState *s;



    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));

    if (!s)

        return NULL;



    s->intbit_to_level = intbit_to_level;

    for (i = 0; i < MAX_CPUS; i++) {

	slavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);

	cpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,

                                     slavio_intctl_io_memory);

    }



    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);

    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);



    register_savevm(""slavio_intctl"", addr, 1, slavio_intctl_",1,0,1,0,0,0,1,1,1,1,1,0,1,1,1
5408,qemu,1,"void helper_frndint(void)

{

    ST0 = rint(ST0);

}
",0,0,0,0,0,0,1,1,0,1,1,1,1,1,1
5416,FFmpeg,0,"static void start_children(FFStream *feed)

{

    if (no_launch)

        return;



    for (; feed; feed = feed->next) {

        if (feed->child_argv && !feed->pid) {

            feed->pid_start = time(0);



            feed->pid = fork();



            if (feed->pid < 0) {

                http_log(""Unable to create children\n"");

                exit(1);

            }

            if (!feed->pid) {

                /* In child */

                char pathname[1024];

                char *slash;

                int i;



                av_strlcpy(pathname, my_program_name, sizeof(pathname));



                slash = strrchr(pathname, '/');

                if (!slash)

                    slash = pathname;

                else

                    slash++;

                strcpy(slash, ""ffmpeg"");



                http_log(""Launch command line: "");

                http_log(""%s "", pathname);

                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)

                   ",3,0,5,0,0,0,0,0,1,1,1,1,0,0,0
5429,FFmpeg,1,"static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)

{

    MOVContext *mov = s->priv_data;

    int i, j;



    if (!mov->fragment_index_complete)

        return 0;



    for (i = 0; i < mov->fragment_index_count; i++) {

        if (mov->fragment_index_data[i]->track_id == st->id) {

            MOVFragmentIndex *index = index = mov->fragment_index_data[i];

            for (j = index->item_count - 1; j >= 0; j--) {

                if (index->items[j].time <= timestamp) {

                    if (index->items[j].headers_read)

                        return 0;



                    return mov_switch_root(s, index->items[j].moof_offset);

                }

            }

        }

    }



    return 0;

}
",2,0,4,0,1,0,1,1,1,1,1,1,0,1,1
5430,FFmpeg,1,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",0,0,0,0,1,0,0,0,1,1,0,1,1,1,1
5437,FFmpeg,1,"int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)

{

    int ret = 0;

    if (av_strstart(p, ""pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,"", &p)) {

        AVIOContext pb;

        RTSPState *rt = s->priv_data;

        AVDictionary *opts = NULL;

        int len = strlen(p) * 6 / 8;

        char *buf = av_mallocz(len);

        AVInputFormat *iformat;



        if (!buf)

            return AVERROR(ENOMEM);

        av_base64_decode(buf, p, len);



        if (rtp_asf_fix_header(buf, len) < 0)

            av_log(s, AV_LOG_ERROR,

                   ""Failed to fix invalid RTSP-MS/ASF min_pktsize\n"");

        init_packetizer(&pb, buf, len);

        if (rt->asf_ctx) {

            avformat_close_input(&rt->asf_ctx);

        }



        if (!(iformat = av_find_input_format(""asf"")))

            return AVERROR_DEMUXER_NOT_FOUND;



        rt->asf_ctx = avformat_alloc_context();

        if (!rt->asf_ctx) {

            av_free(buf);

            return AVERROR(ENOMEM);

        }

",5,0,8,0,0,0,0,0,0,0,0,0,1,1,1
5452,FFmpeg,1,"static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame,

                              int buf_size, void *data)

{

    static const uint8_t sizes[LPC_ORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4};

    static const uint8_t bit_sizes[LPC_ORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};

    RA144Context *ractx;

    PutBitContext pb;

    int32_t lpc_data[NBLOCKS * BLOCKSIZE];

    int32_t lpc_coefs[LPC_ORDER][MAX_LPC_ORDER];

    int shift[LPC_ORDER];

    int16_t block_coefs[NBLOCKS][LPC_ORDER];

    int lpc_refl[LPC_ORDER];    /**< reflection coefficients of the frame */

    unsigned int refl_rms[NBLOCKS]; /**< RMS of the reflection coefficients */

    int energy = 0;

    int i, idx;



    if (buf_size < FRAMESIZE) {

        av_log(avctx, AV_LOG_ERROR, ""output buffer too small\n"");

        return 0;

    }

    ractx = avctx->priv_data;



    /**

     * Since the LPC coefficients are calculated on a frame centered over the

     * fourth subframe, to encode a given frame, data from the next fr",0,0,2,0,0,0,1,1,1,1,1,1,1,0,0
5457,FFmpeg,0,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)

{

    int t = rc->range * (uint64_t)cumFreq / total_freq;



    rc->code1 += t + 1;

    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);



    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {

        unsigned byte = bytestream2_get_byte(gb);

        rc->code = (rc->code << 8) | byte;

        rc->code1 <<= 8;

        rc->range <<= 8;

    }

}
",0,0,0,0,0,1,0,0,0,0,0,0,1,0,1
5482,qemu,0,"static int dmg_open(BlockDriverState *bs, const char *filename, int flags)

{

    BDRVDMGState *s = bs->opaque;

    off_t info_begin,info_end,last_in_offset,last_out_offset;

    uint32_t count;

    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;

    int64_t offset;



    s->fd = open(filename, O_RDONLY | O_BINARY);

    if (s->fd < 0)

        return -errno;

    bs->read_only = 1;

    s->n_chunks = 0;

    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;



    /* read offset of info blocks */

    offset = lseek(s->fd, -0x1d8, SEEK_END);

    if (offset < 0) {

        goto fail;

    }



    info_begin = read_off(s->fd, offset);

    if (info_begin == 0) {

	goto fail;

    }



    if (read_uint32(s->fd, info_begin) != 0x100) {

        goto fail;

    }



    count = read_uint32(s->fd, info_begin + 4);

    if (count == 0) {

        goto fail;

    }

    info_end = info_begin + count;



    offset = info_begin + 0x100;



    /* read offsets */

    last_in_offset = la",0,4,5,0,0,0,0,1,0,1,0,0,1,1,1
5490,qemu,1,"bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)

{

    assert(pkt);



    return pkt->vlan_stripped;

}
",0,0,0,0,0,0,0,0,0,0,1,0,0,1,1
5500,qemu,1,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
5508,qemu,1,"static int connect_namedsocket(const char *path)

{

    int sockfd, size;

    struct sockaddr_un helper;



    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);

    if (sockfd < 0) {

        fprintf(stderr, ""socket %s\n"", strerror(errno));

        return -1;

    }

    strcpy(helper.sun_path, path);

    helper.sun_family = AF_UNIX;

    size = strlen(helper.sun_path) + sizeof(helper.sun_family);

    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {

        fprintf(stderr, ""socket error\n"");


        return -1;

    }



    /* remove the socket for security reasons */

    unlink(path);

    return sockfd;

}",0,0,2,0,0,0,0,0,0,0,0,0,1,0,1
5509,qemu,1,"static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)
{
    EHCIState *s = ptr;
    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);
    uint32_t old = *mmio;
    int i;
    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);
    /* Only aligned reads are allowed on OHCI */
    if (addr & 3) {
        fprintf(stderr, ""usb-ehci: Mis-aligned write to addr 0x""
                TARGET_FMT_plx ""\n"", addr);
        return;
    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {
        handle_port_status_write(s, (addr-PORTSC)/4, val);
        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);
        return;
    if (addr < OPREGBASE) {
        fprintf(stderr, ""usb-ehci: write attempt to read-only register""
                TARGET_FMT_plx ""\n"", addr);
        return;
    /* Do any register specific pre-write processing here.  */
    switch(addr) {
    case USBCMD:
        if (val & USBCMD_HCRESET) {
            ehci_reset(s);
            val = s->usbcmd;
            break;
      ",0,0,4,0,1,0,0,0,0,0,1,1,1,1,1
5539,FFmpeg,0,"static av_cold int dnxhd_encode_init(AVCodecContext *avctx)

{

    DNXHDEncContext *ctx = avctx->priv_data;

    int i, index, bit_depth, ret;



    switch (avctx->pix_fmt) {

    case AV_PIX_FMT_YUV422P:

        bit_depth = 8;

        break;

    case AV_PIX_FMT_YUV422P10:

        bit_depth = 10;

        break;

    default:

        av_log(avctx, AV_LOG_ERROR,

               ""pixel format is incompatible with DNxHD\n"");

        return AVERROR(EINVAL);

    }



    ctx->cid = ff_dnxhd_find_cid(avctx, bit_depth);

    if (!ctx->cid) {

        av_log(avctx, AV_LOG_ERROR,

               ""video parameters incompatible with DNxHD\n"");

        return AVERROR(EINVAL);

    }

    av_log(avctx, AV_LOG_DEBUG, ""cid %d\n"", ctx->cid);



    index = ff_dnxhd_get_cid_table(ctx->cid);

    if (index < 0)

        return index;

    ctx->cid_table = &ff_dnxhd_cid_table[index];



    ctx->m.avctx    = avctx;

    ctx->m.mb_intra = 1;

    ctx->m.h263_aic = 1;



    avctx->bits_per_raw_sample = ctx->cid_table->",1,0,2,0,1,0,1,0,0,0,0,0,1,1,0
5567,FFmpeg,0,"static int vc1_decode_frame(AVCodecContext *avctx, void *data,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size, n_slices = 0, i;

    VC1Context *v = avctx->priv_data;

    MpegEncContext *s = &v->s;

    AVFrame *pict = data;

    uint8_t *buf2 = NULL;

    const uint8_t *buf_start = buf, *buf_start_second_field = NULL;

    int mb_height, n_slices1=-1;

    struct {

        uint8_t *buf;

        GetBitContext gb;

        int mby_start;

    } *slices = NULL, *tmp;



    v->second_field = 0;



    if(s->flags & CODEC_FLAG_LOW_DELAY)

        s->low_delay = 1;



    /* no supplementary picture */

    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) {

        /* special case for last picture */

        if (s->low_delay == 0 && s->next_picture_ptr) {

            *pict = s->next_picture_ptr->f;

            s->next_picture_ptr = NULL;



            *data_size = sizeof(AVFrame);

        }
",0,0,3,0,0,0,0,1,1,0,0,1,1,1,1
5581,qemu,0,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)

{

    bs->detect_zeroes = blk->root_state.detect_zeroes;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
5582,qemu,0,"vcard_emul_mirror_card(VReader *vreader)

{

    /*

     * lookup certs using the C_FindObjects. The Stan Cert handle won't give

     * us the real certs until we log in.

     */

    PK11GenericObject *firstObj, *thisObj;

    int cert_count;

    unsigned char **certs;

    int *cert_len;

    VCardKey **keys;

    PK11SlotInfo *slot;

    VCard *card;



    slot = vcard_emul_reader_get_slot(vreader);

    if (slot == NULL) {

        return NULL;

    }



    firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE);

    if (firstObj == NULL) {

        return NULL;

    }



    /* count the certs */

    cert_count = 0;

    for (thisObj = firstObj; thisObj;

                             thisObj = PK11_GetNextGenericObject(thisObj)) {

        cert_count++;

    }



    if (cert_count == 0) {

        PK11_DestroyGenericObjects(firstObj);

        return NULL;

    }



    /* allocate the arrays */

    vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count);



    /* fill in the arrays */",1,0,3,0,0,0,0,0,0,0,0,0,0,1,1
5587,qemu,0,"static uint64_t megasas_fw_time(void)

{

    struct tm curtime;

    uint64_t bcd_time;



    qemu_get_timedate(&curtime, 0);

    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |

        ((uint64_t)curtime.tm_min & 0xff)  << 40 |

        ((uint64_t)curtime.tm_hour & 0xff) << 32 |

        ((uint64_t)curtime.tm_mday & 0xff) << 24 |

        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |

        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);



    return bcd_time;

}
",0,0,0,0,0,0,0,0,0,1,1,0,0,1,0
5607,qemu,1,"static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)

{

    OfDpaFlow *flow;

    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;



    flow = g_new0(OfDpaFlow, 1);

    if (!flow) {

        return NULL;

    }



    flow->cookie = cookie;

    flow->mask.tbl_id = 0xffffffff;



    flow->stats.install_time = flow->stats.refresh_time = now;



    return flow;

}
",0,0,1,0,0,0,1,1,1,1,1,1,0,1,1
5617,FFmpeg,0,"static int rtp_open(URLContext *h, const char *uri, int flags)

{

    RTPContext *s;

    int port, is_output, ttl, local_port;

    char hostname[256];

    char buf[1024];

    char path[1024];

    const char *p;



    is_output = (flags & URL_WRONLY);



    s = av_mallocz(sizeof(RTPContext));

    if (!s)

        return AVERROR(ENOMEM);

    h->priv_data = s;



    url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port,

              path, sizeof(path), uri);

    /* extract parameters */

    ttl = -1;

    local_port = -1;

    p = strchr(uri, '?');

    if (p) {

        if (find_info_tag(buf, sizeof(buf), ""ttl"", p)) {

            ttl = strtol(buf, NULL, 10);

        }

        if (find_info_tag(buf, sizeof(buf), ""localport"", p)) {

            local_port = strtol(buf, NULL, 10);

        }

    }



    build_udp_url(buf, sizeof(buf),

                  hostname, port, local_port, ttl);

    if (url_open(&s->rtp_hd, buf, flags) < 0)

        goto fail;

    local_port = udp_get_local_po",0,1,5,0,0,0,0,1,0,1,0,1,0,1,0
5621,FFmpeg,1,"static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,

                                       PutBitContext *pb, const float *in,

                                       const float *scaled, int size, int scale_idx,

                                       int cb, const float lambda, const float uplim,

                                       int *bits)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    float cost = 0;

    int qc1, qc2, qc3, qc4;

    int curbits = 0;



    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];

    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];



    for (i = 0; i < size; i += 4) {

        const float *vec, *vec2;

        int curidx, curidx2, sign1, count1, sign2, count2;

        int   *in_int = (int   *)&in[i];

        float *in_pos = (float *)&in[i];

        float di0, di1",1,0,0,0,0,0,0,0,0,0,0,0,0,0,1
5624,qemu,1,"QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)

{

    JSONParserContext ctxt = {};

    QList *working = qlist_copy(tokens);

    QObject *result;



    result = parse_value(&ctxt, &working, ap);



    QDECREF(working);



    error_propagate(errp, ctxt.err);



    return result;

}
",0,0,0,0,0,0,1,1,1,1,0,1,0,0,1
5630,qemu,1,"static int init_directories(BDRVVVFATState* s,

                            const char *dirname, int heads, int secs,

                            Error **errp)

{

    bootsector_t* bootsector;

    mapping_t* mapping;

    unsigned int i;

    unsigned int cluster;



    memset(&(s->first_sectors[0]),0,0x40*0x200);



    s->cluster_size=s->sectors_per_cluster*0x200;

    s->cluster_buffer=g_malloc(s->cluster_size);



    /*

     * The formula: sc = spf+1+spf*spc*(512*8/fat_type),

     * where sc is sector_count,

     * spf is sectors_per_fat,

     * spc is sectors_per_clusters, and

     * fat_type = 12, 16 or 32.

     */

    i = 1+s->sectors_per_cluster*0x200*8/s->fat_type;

    s->sectors_per_fat=(s->sector_count+i)/i; /* round up */



    s->offset_to_fat = s->offset_to_bootsector + 1;

    s->offset_to_root_dir = s->offset_to_fat + s->sectors_per_fat * 2;



    array_init(&(s->mapping),sizeof(mapping_t));

    array_init(&(s->directory),sizeof(direntry_t));



    /* add volume label */

    ",1,0,0,0,0,0,1,1,1,1,1,1,1,1,1
5646,qemu,0,"void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)

{

    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);

    s->freq = PXA25X_FREQ;

    s->tm4 = NULL;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
5670,qemu,0,"struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size,

                const char *core)

{

    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)

            g_malloc0(sizeof(struct omap_mpu_state_s));

    ram_addr_t sram_base, q2_base;

    qemu_irq *cpu_irq;

    qemu_irq dma_irqs[4];

    DriveInfo *dinfo;

    int i;

    SysBusDevice *busdev;

    struct omap_target_agent_s *ta;



    /* Core */

    s->mpu_model = omap2420;

    s->env = cpu_init(core ?: ""arm1136-r2"");

    if (!s->env) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }

    s->sdram_size = sdram_size;

    s->sram_size = OMAP242X_SRAM_SIZE;



    s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];



    /* Clocks */

    omap_clk_init(s);



    /* Memory-mapped stuff */

    cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size,

                    (q2_base = qemu_ram_alloc(NULL, ""omap2.dram"",

                                              s->sdram_size)) | IO",0,0,1,0,0,0,1,1,1,1,1,1,1,0,0
5672,qemu,0,"static void tcg_out_qemu_ld_slow_path (TCGContext *s, TCGLabelQemuLdst *label)

{

    int s_bits;

    int ir;

    int opc = label->opc;

    int mem_index = label->mem_index;

    int data_reg = label->datalo_reg;

    int data_reg2 = label->datahi_reg;

    int addr_reg = label->addrlo_reg;

    uint8_t *raddr = label->raddr;

    uint8_t **label_ptr = &label->label_ptr[0];



    s_bits = opc & 3;



    /* resolve label address */

    reloc_pc14 (label_ptr[0], (tcg_target_long) s->code_ptr);



    /* slow path */

    ir = 3;

    tcg_out_mov (s, TCG_TYPE_I32, ir++, TCG_AREG0);

#if TARGET_LONG_BITS == 32

    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);

#else

#ifdef TCG_TARGET_CALL_ALIGN_ARGS

    ir |= 1;

#endif

    tcg_out_mov (s, TCG_TYPE_I32, ir++, label->addrhi_reg);

    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);

#endif

    tcg_out_movi (s, TCG_TYPE_I32, ir, mem_index);

    tcg_out_call (s, (tcg_target_long) qemu_ld_helpers[s_bits], 1);

    tcg_out32 (s, B | 8);

    tcg_out32 (s,",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
5673,qemu,0,"static int nbd_negotiate_handle_info(NBDClient *client, uint32_t length,

                                     uint32_t opt, uint16_t myflags,

                                     Error **errp)

{

    int rc;

    char name[NBD_MAX_NAME_SIZE + 1];

    NBDExport *exp;

    uint16_t requests;

    uint16_t request;

    uint32_t namelen;

    bool sendname = false;

    bool blocksize = false;

    uint32_t sizes[3];

    char buf[sizeof(uint64_t) + sizeof(uint16_t)];

    const char *msg;



    /* Client sends:

        4 bytes: L, name length (can be 0)

        L bytes: export name

        2 bytes: N, number of requests (can be 0)

        N * 2 bytes: N requests

    */

    if (length < sizeof(namelen) + sizeof(requests)) {

        msg = ""overall request too short"";

        goto invalid;

    }

    if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) {

        return -EIO;

    }

    be32_to_cpus(&namelen);

    length -= sizeof(namelen);

    if (namelen > length - sizeof(requests) ||",0,1,3,0,0,0,0,0,1,0,0,0,0,0,0
5676,qemu,0,"static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)

{

    switch (buf[0]) {

    /* stream commands */

    case ERASE_12:

    case ERASE_16:

        cmd->xfer = 0;

        break;

    case READ_6:

    case READ_REVERSE:

    case RECOVER_BUFFERED_DATA:

    case WRITE_6:

        cmd->len = 6;

        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);

        if (buf[1] & 0x01) { /* fixed */

            cmd->xfer *= dev->blocksize;

        }

        break;

    case READ_16:

    case READ_REVERSE_16:

    case VERIFY_16:

    case WRITE_16:

        cmd->len = 16;

        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);

        if (buf[1] & 0x01) { /* fixed */

            cmd->xfer *= dev->blocksize;

        }

        break;

    case REWIND:

    case LOAD_UNLOAD:

        cmd->len = 6;

        cmd->xfer = 0;

        break;

    case SPACE_16:

        cmd->xfer = buf[13] | (buf[12] << 8);

        break;

    case READ_POSITION:

        cmd->xfer ",0,0,2,0,1,0,1,1,0,1,1,1,0,0,0
5694,qemu,0,"static void gen_tst_cc (DisasContext *dc, TCGv cc, int cond)

{

	int arith_opt, move_opt;



	/* TODO: optimize more condition codes.  */



	/*

	 * If the flags are live, we've gotta look into the bits of CCS.

	 * Otherwise, if we just did an arithmetic operation we try to

	 * evaluate the condition code faster.

	 *

	 * When this function is done, T0 should be non-zero if the condition

	 * code is true.

	 */

	arith_opt = arith_cc(dc) && !dc->flags_uptodate;

	move_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate;

	switch (cond) {

		case CC_EQ:

			if (arith_opt || move_opt) {

				/* If cc_result is zero, T0 should be 

				   non-zero otherwise T0 should be zero.  */

				int l1;

				l1 = gen_new_label();

				tcg_gen_movi_tl(cc, 0);

				tcg_gen_brcondi_tl(TCG_COND_NE, cc_result, 

						   0, l1);

				tcg_gen_movi_tl(cc, 1);

				gen_set_label(l1);

			}

			else {

				cris_evaluate_flags(dc);

				tcg_gen_andi_tl(cc, 

						cpu_PR[PR_CCS], Z_FLAG);

			}

			break;

		case CC_NE:

			",0,0,3,0,1,0,0,1,1,0,0,0,0,0,0
5707,qemu,0,"void do_smm_enter(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    CPUState *cs = CPU(cpu);

    target_ulong sm_state;

    SegmentCache *dt;

    int i, offset;



    qemu_log_mask(CPU_LOG_INT, ""SMM: enter\n"");

    log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);



    env->hflags |= HF_SMM_MASK;

    if (env->hflags2 & HF2_NMI_MASK) {

        env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK;

    } else {

        env->hflags2 |= HF2_NMI_MASK;

    }

    cpu_smm_update(env);



    sm_state = env->smbase + 0x8000;



#ifdef TARGET_X86_64

    for (i = 0; i < 6; i++) {

        dt = &env->segs[i];

        offset = 0x7e00 + i * 16;

        x86_stw_phys(cs, sm_state + offset, dt->selector);

        x86_stw_phys(cs, sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff);

        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);

        x86_stq_phys(cs, sm_state + offset + 8, dt->base);

    }



    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);

    x86_stl_phys(cs, sm_state + 0x7e64, env->",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
5718,qemu,1,"PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,

                        const char *default_devaddr)

{

    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;

    PCIDevice *pci_dev;

    DeviceState *dev;

    int i;



    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);

    pci_dev = pci_create(pci_nic_names[i], devaddr);

    dev = &pci_dev->qdev;

    if (nd->id)

        dev->id = qemu_strdup(nd->id);

    dev->nd = nd;

    qdev_init(dev);

    nd->private = dev;

    return pci_dev;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
5731,FFmpeg,1,"void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)

{

#if HAVE_7REGS && HAVE_TEN_OPERANDS

    c->mlp_filter_channel = mlp_filter_channel_x86;

#endif

}
",0,0,2,0,0,0,1,1,1,0,1,1,1,1,1
5754,FFmpeg,1,"static av_cold int roq_encode_init(AVCodecContext *avctx)
{
    RoqContext *enc = avctx->priv_data;
    av_lfg_init(&enc->randctx, 1);
    enc->framesSinceKeyframe = 0;
    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions must be divisible by 16\n"");
        return AVERROR(EINVAL);
    if (avctx->width > 65535 || avctx->height > 65535) {
        av_log(avctx, AV_LOG_ERROR, ""Dimensions are max %d\n"", enc->quake3_compat ? 32768 : 65535);
        return AVERROR(EINVAL);
    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))
        av_log(avctx, AV_LOG_ERROR, ""Warning: dimensions not power of two, this is not supported by quake\n"");
    enc->width = avctx->width;
    enc->height = avctx->height;
    enc->framesSinceKeyframe = 0;
    enc->first_frame = 1;
    enc->last_frame    = av_frame_alloc();
    enc->current_frame = av_frame_alloc();
    if (!enc->last_frame || !enc->current_frame) {
    enc->tmpData      = av_malloc(sizeof(RoqTemp",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
5755,FFmpeg,1,"void ff_h264_flush_change(H264Context *h)

{

    int i, j;



    h->next_outputed_poc = INT_MIN;

    h->prev_interlaced_frame = 1;

    idr(h);



    h->poc.prev_frame_num = -1;

    if (h->cur_pic_ptr) {

        h->cur_pic_ptr->reference = 0;

        for (j=i=0; h->delayed_pic[i]; i++)

            if (h->delayed_pic[i] != h->cur_pic_ptr)

                h->delayed_pic[j++] = h->delayed_pic[i];

        h->delayed_pic[j] = NULL;

    }

    ff_h264_unref_picture(h, &h->last_pic_for_ec);



    h->first_field = 0;

    ff_h264_sei_uninit(&h->sei);

    h->recovery_frame = -1;

    h->frame_recovered = 0;

    h->current_slice = 0;

    h->mmco_reset = 1;

    for (i = 0; i < h->nb_slice_ctx; i++)

        h->slice_ctx[i].list_count = 0;

}
",3,0,2,0,0,0,0,0,0,1,1,1,0,0,0
5762,FFmpeg,0,"static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)

{

    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);

    void *dst;

    if (o_out)

        *o_out= o;

    if (!o || o->offset<=0)

        return AVERROR_OPTION_NOT_FOUND;



    if (o->max*den < num*intnum || o->min*den > num*intnum) {

        av_log(obj, AV_LOG_ERROR, ""Value %lf for parameter '%s' out of range\n"", num, name);

        return AVERROR(ERANGE);

    }



    dst= ((uint8_t*)obj) + o->offset;



    switch (o->type) {

    case FF_OPT_TYPE_FLAGS:

    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;

    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;

    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;

    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;

    case FF_OPT_TYPE_RATIONAL:

        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den}",1,0,4,0,1,0,0,0,0,0,0,0,0,0,0
5767,qemu,1,"static void qxl_realize_common(PCIQXLDevice *qxl, Error **errp)

{

    uint8_t* config = qxl->pci.config;

    uint32_t pci_device_rev;

    uint32_t io_size;



    qxl->mode = QXL_MODE_UNDEFINED;

    qxl->generation = 1;

    qxl->num_memslots = NUM_MEMSLOTS;

    qemu_mutex_init(&qxl->track_lock);

    qemu_mutex_init(&qxl->async_lock);

    qxl->current_async = QXL_UNDEFINED_IO;

    qxl->guest_bug = 0;



    switch (qxl->revision) {

    case 1: /* spice 0.4 -- qxl-1 */

        pci_device_rev = QXL_REVISION_STABLE_V04;

        io_size = 8;

        break;

    case 2: /* spice 0.6 -- qxl-2 */

        pci_device_rev = QXL_REVISION_STABLE_V06;

        io_size = 16;

        break;

    case 3: /* qxl-3 */

        pci_device_rev = QXL_REVISION_STABLE_V10;

        io_size = 32; /* PCI region size must be pow2 */

        break;

    case 4: /* qxl-4 */

        pci_device_rev = QXL_REVISION_STABLE_V12;

        io_size = pow2ceil(QXL_IO_RANGE_SIZE);

        break;

    default:

        error_setg(",0,0,0,0,1,0,0,0,0,0,0,0,1,0,1
5781,FFmpeg,1,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",1,0,0,0,0,0,1,1,1,0,0,1,0,1,1
5789,FFmpeg,1,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
",0,0,0,0,1,0,0,1,1,1,0,1,0,1,0
5797,qemu,1,"static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)

{

    OpenPICState *opp = opaque;

    uint32_t retval = -1;

    int idx;



    DPRINTF(""%s: addr %08x\n"", __func__, addr);

    if (addr & 0xF) {

        goto out;

    }

    idx = (addr >> 6) & 0x3;

    if (addr == 0x0) {

        /* TIFR (TFRR) */

        retval = opp->tifr;

        goto out;

    }

    switch (addr & 0x30) {

    case 0x00: /* TICC (GTCCR) */

        retval = opp->timers[idx].ticc;

        break;

    case 0x10: /* TIBC (GTBCR) */

        retval = opp->timers[idx].tibc;

        break;

    case 0x20: /* TIPV (TIPV) */

        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);

        break;

    case 0x30: /* TIDE (TIDR) */

        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);

        break;

    }



out:

    DPRINTF(""%s: => %08x\n"", __func__, retval);



    return retval;

}
",0,2,3,0,1,0,0,0,0,0,1,0,0,0,0
5810,qemu,0,"static void gen_exception_insn(DisasContext *s, int offset, int excp)

{

    gen_a64_set_pc_im(s->pc - offset);

    gen_exception(excp);

    s->is_jmp = DISAS_JUMP;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
5820,qemu,0,"static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)

{

    const QDictEntry *ent;

    const char *arg_name;

    const QObject *arg_obj;

    bool has_exec_key = false;

    QDict *dict = NULL;



    if (qobject_type(request) != QTYPE_QDICT) {

        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,

                   ""request is not a dictionary"");

        return NULL;

    }



    dict = qobject_to_qdict(request);



    for (ent = qdict_first(dict); ent;

         ent = qdict_next(dict, ent)) {

        arg_name = qdict_entry_key(ent);

        arg_obj = qdict_entry_value(ent);



        if (!strcmp(arg_name, ""execute"")) {

            if (qobject_type(arg_obj) != QTYPE_QSTRING) {

                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"",

                           ""string"");

                return NULL;

            }

            has_exec_key = true;

        } else if (strcmp(arg_name, ""arguments"")) {

            error_setg(errp, QERR_QMP_EXTRA_MEMBER, ar",1,0,4,0,0,0,0,0,0,1,0,0,0,1,0
5826,FFmpeg,0,"static void sha1_transform(uint32_t state[5], const uint8_t buffer[64])

{

    uint32_t block[80];

    unsigned int i, a, b, c, d, e;



    a = state[0];

    b = state[1];

    c = state[2];

    d = state[3];

    e = state[4];

#if CONFIG_SMALL

    for (i = 0; i < 80; i++) {

        int t;

        if (i < 16)

            t = AV_RB32(buffer + 4 * i);

        else

            t = rol(block[i-3] ^ block[i-8] ^ block[i-14] ^ block[i-16], 1);

        block[i] = t;

        t += e + rol(a, 5);

        if (i < 40) {

            if (i < 20)

                t += ((b&(c^d))^d)     + 0x5A827999;

            else

                t += ( b^c     ^d)     + 0x6ED9EBA1;

        } else {

            if (i < 60)

                t += (((b|c)&d)|(b&c)) + 0x8F1BBCDC;

            else

                t += ( b^c     ^d)     + 0xCA62C1D6;

        }

        e = d;

        d = c;

        c = rol(b, 30);

        b = a;

        a = t;

    }

#else

    for (i = 0; i < 15; i += 5) {

        R0(a, b, c, d, e,",3,0,5,0,0,0,0,0,0,0,0,0,1,1,0
5834,qemu,1,"static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
5837,qemu,1,"static void acpi_build_update(void *build_opaque, uint32_t offset)

{

    AcpiBuildState *build_state = build_opaque;

    AcpiBuildTables tables;



    /* No state to update or already patched? Nothing to do. */

    if (!build_state || build_state->patched) {

        return;

    }

    build_state->patched = 1;



    acpi_build_tables_init(&tables);



    acpi_build(build_state->guest_info, &tables);



    assert(acpi_data_len(tables.table_data) == build_state->table_size);

    memcpy(build_state->table_ram, tables.table_data->data,

           build_state->table_size);



    acpi_build_tables_cleanup(&tables, true);

}
",0,0,1,0,0,0,0,0,0,0,0,1,0,1,1
5845,FFmpeg,1,"static av_cold int amr_nb_encode_init(AVCodecContext *avctx)

{

    AMRContext *s = avctx->priv_data;



    if (avctx->sample_rate != 8000) {

        av_log(avctx, AV_LOG_ERROR, ""Only 8000Hz sample rate supported\n"");

        return AVERROR(ENOSYS);

    }



    if (avctx->channels != 1) {

        av_log(avctx, AV_LOG_ERROR, ""Only mono supported\n"");

        return AVERROR(ENOSYS);

    }



    avctx->frame_size  = 160;

    avctx->coded_frame = avcodec_alloc_frame();





    s->enc_state = Encoder_Interface_init(s->enc_dtx);

    if (!s->enc_state) {

        av_log(avctx, AV_LOG_ERROR, ""Encoder_Interface_init error\n"");


        return -1;

    }



    s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);

    s->enc_bitrate = avctx->bit_rate;



    return 0;

}",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
5846,FFmpeg,1,"void help(void)

{

    printf(""dct-test [-i] [<test-number>]\n""

           ""test-number 0 -> test with random matrixes\n""

           ""            1 -> test with random sparse matrixes\n""

           ""            2 -> do 3. test from mpeg4 std\n""

           ""-i          test IDCT implementations\n""

           ""-4          test IDCT248 implementations\n"");

    exit(1);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
5855,qemu,1,"PPC_OP(slw)

{

    if (T1 & 0x20) {

        T0 = 0;

    } else {

        T0 = T0 << T1;

    }

    RETURN();

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,1
5864,FFmpeg,1,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}
",0,0,1,0,0,0,1,1,1,1,1,1,0,0,0
5875,qemu,0,"CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_size,

                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],

                        int do_init, const char *cpu_model)

{

    MemoryRegion *ram_memories

        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));

    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];

    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];

    CPUState *env;

    qemu_irq *pic;

    qemu_irq *irqs;

    qemu_irq *pci_irqs;



    if (cpu_model == NULL) {

        cpu_model = ""440-Xilinx""; // XXX: should be 440EP

    }

    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }



    ppc_booke_timers_init(env, 400000000, 0);

    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[",0,0,2,0,0,0,0,0,0,0,0,0,1,1,0
5899,qemu,0,"static int piix4_initfn(PCIDevice *dev)

{

    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);

    uint8_t *pci_conf;



    isa_bus_new(&d->dev.qdev);



    pci_conf = d->dev.config;

    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge

    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);



    piix4_dev = &d->dev;

    qemu_register_reset(piix4_reset, d);

    return 0;

}
",0,0,0,0,0,0,1,1,1,0,1,1,1,1,1
5905,FFmpeg,1,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)

{

    int i;

    pixel *dst = (pixel *) _dst;

    dctcoef *src = (dctcoef *) _src;

    stride /= sizeof(pixel);



    for (i = 0; i < 8; i++) {

        dst[0] += src[0];

        dst[1] += src[1];

        dst[2] += src[2];

        dst[3] += src[3];

        dst[4] += src[4];

        dst[5] += src[5];

        dst[6] += src[6];

        dst[7] += src[7];



        dst += stride;

        src += 8;

    }



    memset(_src, 0, sizeof(dctcoef) * 64);

}
",1,0,0,0,0,0,1,1,1,0,1,0,0,0,0
5908,FFmpeg,1,"static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)

{

    int i;

    int ret = av_frame_ref(dst, src);

    if (ret < 0)

        return ret;



    if (!h->sps.crop)

        return 0;



    for (i = 0; i < 3; i++) {

        int hshift = (i > 0) ? h->chroma_x_shift : 0;

        int vshift = (i > 0) ? h->chroma_y_shift : 0;

        int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +

            (h->sps.crop_top  >> vshift) * dst->linesize[i];

        dst->data[i] += off;

    }

    return 0;

}
",1,0,9,0,0,0,1,0,0,1,1,1,0,0,0
5920,qemu,1,"void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)

{

    double units = 1.0;



    /* if cfg.op_size is defined and smaller than size we compute unit count */

    if (ts->cfg.op_size && size > ts->cfg.op_size) {

        units = (double) size / ts->cfg.op_size;

    }



    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;

    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;



    if (is_write) {

        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;

        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;

    } else {

        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;

        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;

    }

}
",0,0,2,0,0,0,1,1,1,1,1,1,0,0,0
5931,qemu,1,"void bdrv_remove_aio_context_notifier(BlockDriverState *bs,

                                      void (*attached_aio_context)(AioContext *,

                                                                   void *),

                                      void (*detach_aio_context)(void *),

                                      void *opaque)

{

    BdrvAioNotifier *ban, *ban_next;



    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {

        if (ban->attached_aio_context == attached_aio_context &&

            ban->detach_aio_context   == detach_aio_context   &&

            ban->opaque               == opaque)

        {

            QLIST_REMOVE(ban, list);

            g_free(ban);



            return;

        }

    }



    abort();

}
",0,0,4,0,0,0,0,0,0,0,1,0,1,1,1
5962,qemu,1,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
5963,qemu,1,"static void test_bmdma_simple_rw(void)

{

    QPCIDevice *dev;

    void *bmdma_base, *ide_base;

    uint8_t status;

    uint8_t *buf;

    uint8_t *cmpbuf;

    size_t len = 512;

    uintptr_t guest_buf = guest_alloc(guest_malloc, len);



    PrdtEntry prdt[] = {

        {

            .addr = cpu_to_le32(guest_buf),

            .size = cpu_to_le32(len | PRDT_EOT),

        },

    };



    dev = get_pci_device(&bmdma_base, &ide_base);



    buf = g_malloc(len);

    cmpbuf = g_malloc(len);



    /* Write 0x55 pattern to sector 0 */

    memset(buf, 0x55, len);

    memwrite(guest_buf, buf, len);



    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,

                              ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Write 0xaa pattern to sector 1 */

    memset(buf, 0xaa, len);

    memwrite(guest_buf, buf, len);



    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,

",0,0,0,0,0,0,1,0,0,1,1,1,1,1,1
5965,FFmpeg,1,"static int idcin_read_packet(AVFormatContext *s,

                             AVPacket *pkt)

{

    int ret;

    unsigned int command;

    unsigned int chunk_size;

    IdcinDemuxContext *idcin = s->priv_data;

    AVIOContext *pb = s->pb;

    int i;

    int palette_scale;

    unsigned char r, g, b;

    unsigned char palette_buffer[768];

    uint32_t palette[256];



    if (s->pb->eof_reached)

        return AVERROR(EIO);



    if (idcin->next_chunk_is_video) {

        command = avio_rl32(pb);

        if (command == 2) {

            return AVERROR(EIO);

        } else if (command == 1) {

            /* trigger a palette change */

            if (avio_read(pb, palette_buffer, 768) != 768)

                return AVERROR(EIO);

            /* scale the palette as necessary */

            palette_scale = 2;

            for (i = 0; i < 768; i++)

                if (palette_buffer[i] > 63) {

                    palette_scale = 0;

                    break;




            for (i = 0; i < 256",2,0,6,0,0,0,1,1,0,1,1,1,0,0,0
5981,FFmpeg,1,"static inline void RENAME(yuv2rgb555_2)(SwsContext *c, const uint16_t *buf0,

                                        const uint16_t *buf1, const uint16_t *ubuf0,

                                        const uint16_t *ubuf1, const uint16_t *vbuf0,

                                        const uint16_t *vbuf1, const uint16_t *abuf0,

                                        const uint16_t *abuf1, uint8_t *dest,

                                        int dstW, int yalpha, int uvalpha, int y)

{

    x86_reg uv_off = c->uv_off << 1;



    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(

    __asm__ volatile(

        ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""

        ""mov        %4, %%""REG_b""               \n\t""

        ""push %%""REG_BP""                        \n\t""

        YSCALEYUV2RGB(%%REGBP, %5, %6)

        ""pxor    %%mm7, %%mm7                   \n\t""

        /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */

#ifdef DITHER1XBPP

        ""paddusb ""BLUE_DITHER""(%5), %%mm2      \n\",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
6007,qemu,0,"static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)

{

    VirtIOBlockReq *req = virtio_blk_alloc_request(s);



    if (!virtqueue_pop(s->vq, &req->elem)) {

        virtio_blk_free_request(req);

        return NULL;

    }



    return req;

}
",0,0,1,0,0,0,1,1,0,1,1,0,1,1,1
6008,FFmpeg,0,"static int output_packet(InputStream *ist, const AVPacket *pkt)

{

    int ret = 0, i;

    int got_output;



    AVPacket avpkt;

    if (!ist->saw_first_ts) {

        ist->dts = ist->st->avg_frame_rate.num ? - ist->st->codec->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0;

        ist->pts = 0;

        if (pkt != NULL && pkt->pts != AV_NOPTS_VALUE && !ist->decoding_needed) {

            ist->dts += av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);

            ist->pts = ist->dts; //unused but better to set it to a value thats not totally wrong

        }

        ist->saw_first_ts = 1;

    }



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->dts;

    if (ist->next_pts == AV_NOPTS_VALUE)

        ist->next_pts = ist->pts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts ",0,1,6,0,0,0,0,0,0,1,1,0,0,0,0
6025,qemu,1,"void qemu_system_reset(void)

{

    QEMUResetEntry *re, *nre;



    /* reset all devices */

    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {

        re->func(re->opaque);

    }


}",0,0,0,0,0,0,0,1,1,1,1,0,0,0,0
6032,qemu,0,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
",0,0,2,0,1,0,0,0,0,1,1,1,1,0,1
6033,qemu,0,"static void phys_page_set(AddressSpaceDispatch *d,

                          target_phys_addr_t index, target_phys_addr_t nb,

                          uint16_t leaf)

{

    /* Wildly overreserve - it doesn't matter much. */

    phys_map_node_reserve(3 * P_L2_LEVELS);



    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);

}
",0,0,0,0,0,0,0,1,1,0,0,0,0,0,1
6043,qemu,0,"static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,

                              const int *const_args)

{

    int c;



    switch (opc) {

    case INDEX_op_exit_tb:

        if (check_fit_tl(args[0], 13)) {

            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);

            tcg_out_movi_imm13(s, TCG_REG_O0, args[0]);

        } else {

            tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0] & ~0x3ff);

            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);

            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0,

                           args[0] & 0x3ff, ARITH_OR);

        }

        break;

    case INDEX_op_goto_tb:

        if (s->tb_jmp_offset) {

            /* direct jump method */

            uint32_t old_insn = *(uint32_t *)s->code_ptr;

            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;

            /* Make sure to preserve links during retranslation.  */

            tcg_out32(s, CALL | (old_insn & ~INSN_OP(-1)));

    ",0,1,2,0,1,0,0,0,0,0,0,0,1,1,1
6063,FFmpeg,0,"static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,

                                 int *got_frame_ptr, AVPacket *avpkt)

{

    EightSvxContext *esc = avctx->priv_data;

    int n, out_data_size;

    int ch, ret;

    uint8_t *src;



    /* decode and interleave the first packet */

    if (!esc->samples && avpkt) {

        int packet_size = avpkt->size;



        if (packet_size % avctx->channels) {

            av_log(avctx, AV_LOG_WARNING, ""Packet with odd size, ignoring last byte\n"");

            if (packet_size < avctx->channels)

                return packet_size;

            packet_size -= packet_size % avctx->channels;

        }

        esc->samples_size = !esc->table ?

            packet_size : avctx->channels + (packet_size-avctx->channels) * 2;

        if (!(esc->samples = av_malloc(esc->samples_size)))

            return AVERROR(ENOMEM);



        /* decompress */

        if (esc->table) {

            const uint8_t *buf = avpkt->data;

            uint8_t *dst;

 ",0,0,5,0,0,0,0,0,1,0,0,0,1,1,1
6069,qemu,0,"static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIOSerial *s = opaque;

    VirtIOSerialPort *port;

    uint32_t max_nr_ports, nr_active_ports, ports_map;

    unsigned int i;

    int ret;



    if (version_id > 3) {

        return -EINVAL;

    }



    /* The virtio device */

    ret = virtio_load(&s->vdev, f);

    if (ret) {

        return ret;

    }



    if (version_id < 2) {

        return 0;

    }



    /* The config space */

    qemu_get_be16s(f, &s->config.cols);

    qemu_get_be16s(f, &s->config.rows);



    qemu_get_be32s(f, &max_nr_ports);

    tswap32s(&max_nr_ports);

    if (max_nr_ports > tswap32(s->config.max_nr_ports)) {

        /* Source could have had more ports than us. Fail migration. */

        return -EINVAL;

    }



    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {

        qemu_get_be32s(f, &ports_map);



        if (ports_map != s->ports_map[i]) {

            /*

             * Ports active on source and destination don't

 ",1,0,5,0,0,0,0,0,0,0,0,0,1,1,1
6092,qemu,0,"static CharDriverState *qemu_chr_open_spice_port(const char *id,

                                                 ChardevBackend *backend,

                                                 ChardevReturn *ret,

                                                 Error **errp)

{

    const char *name = backend->spiceport->fqdn;

    CharDriverState *chr;

    SpiceCharDriver *s;



    if (name == NULL) {

        fprintf(stderr, ""spice-qemu-char: missing name parameter\n"");

        return NULL;

    }



    chr = chr_open(""port"", spice_port_set_fe_open);

    s = chr->opaque;

    s->sin.portname = g_strdup(name);



    return chr;

}
",0,0,1,0,0,0,1,1,1,1,0,0,1,1,1
6098,qemu,0,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)

{

#if defined(TARGET_HAS_ICE)

    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);



    breakpoint_invalidate(cpu, breakpoint->pc);



    g_free(breakpoint);

#endif

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
6103,FFmpeg,1,"static int flv_write_trailer(AVFormatContext *s)

{

    int64_t file_size;



    AVIOContext *pb = s->pb;

    FLVContext *flv = s->priv_data;

    int i;



    /* Add EOS tag */

    for (i = 0; i < s->nb_streams; i++) {

        AVCodecContext *enc = s->streams[i]->codec;

        FLVStreamContext *sc = s->streams[i]->priv_data;

        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&

            enc->codec_id == AV_CODEC_ID_H264)

            put_avc_eos_tag(pb, sc->last_ts);

    }



    file_size = avio_tell(pb);



    /* update information */

    avio_seek(pb, flv->duration_offset, SEEK_SET);

    put_amf_double(pb, flv->duration / (double)1000);

    avio_seek(pb, flv->filesize_offset, SEEK_SET);

    put_amf_double(pb, file_size);



    avio_seek(pb, file_size, SEEK_SET);

    return 0;

}
",1,0,1,0,0,0,1,1,1,1,1,1,0,0,0
6108,qemu,1,"static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,

                                     const void *match_data, hwaddr *load_addr)

{

    BostonState *s = BOSTON(opaque);

    MachineState *machine = s->mach;

    const char *cmdline;

    int err;

    void *fdt;

    size_t fdt_sz, ram_low_sz, ram_high_sz;



    fdt_sz = fdt_totalsize(fdt_orig) * 2;

    fdt = g_malloc0(fdt_sz);



    err = fdt_open_into(fdt_orig, fdt, fdt_sz);

    if (err) {

        fprintf(stderr, ""unable to open FDT\n"");

        return NULL;

    }



    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])

            ? machine->kernel_cmdline : "" "";

    err = qemu_fdt_setprop_string(fdt, ""/chosen"", ""bootargs"", cmdline);

    if (err < 0) {

        fprintf(stderr, ""couldn't set /chosen/bootargs\n"");

        return NULL;

    }



    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);

    ram_high_sz = machine->ram_size - ram_low_sz;

    qemu_fdt_setprop_sized_cells(fdt, ""/memory@0"", ""reg"",",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
6112,FFmpeg,1,"static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

#if CONFIG_ZLIB

    AVIOContext ctx;

    uint8_t *cmov_data;

    uint8_t *moov_data; /* uncompressed data */

    long cmov_len, moov_len;

    int ret = -1;



    avio_rb32(pb); /* dcom atom */

    if (avio_rl32(pb) != MKTAG('d','c','o','m'))

        return AVERROR_INVALIDDATA;

    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {

        av_log(c->fc, AV_LOG_ERROR, ""unknown compression for cmov atom !"");

        return AVERROR_INVALIDDATA;

    }

    avio_rb32(pb); /* cmvd atom */

    if (avio_rl32(pb) != MKTAG('c','m','v','d'))

        return AVERROR_INVALIDDATA;

    moov_len = avio_rb32(pb); /* uncompressed size */

    cmov_len = atom.size - 6 * 4;



    cmov_data = av_malloc(cmov_len);

    if (!cmov_data)

        return AVERROR(ENOMEM);

    moov_data = av_malloc(moov_len);

    if (!moov_data) {

        av_free(cmov_data);

        return AVERROR(ENOMEM);

    }

    avio_read(pb, cmov_data, cmov_len);

    if (unc",1,0,7,0,0,0,0,1,1,0,0,0,0,0,0
6125,FFmpeg,1,"static int sdp_parse_rtpmap(AVFormatContext *s,

                            AVCodecContext *codec, RTSPStream *rtsp_st,

                            int payload_type, const char *p)

{

    char buf[256];

    int i;

    AVCodec *c;

    const char *c_name;



    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and

     * see if we can handle this kind of payload.

     * The space should normally not be there but some Real streams or

     * particular servers (""RealServer Version 6.1.3.970"", see issue 1658)

     * have a trailing space. */

    get_word_sep(buf, sizeof(buf), ""/ "", &p);

    if (payload_type >= RTP_PT_PRIVATE) {

        RTPDynamicProtocolHandler *handler;

        for (handler = RTPFirstDynamicPayloadHandler;

             handler; handler = handler->next) {

            if (!strcasecmp(buf, handler->enc_name) &&

                codec->codec_type == handler->codec_type) {

                codec->codec_id          = handler->codec_id;

                rtsp_st->dynamic_ha",1,0,3,0,0,0,0,0,0,0,0,0,1,1,1
6140,FFmpeg,0,"void ff_mpv_frame_end(MpegEncContext *s)

{

#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    /* redraw edges for the frame if decoding didn't complete */

    // just to make sure that all data is rendered.

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {

        ff_xvmc_field_end(s);

    } else

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    emms_c();



    if (s->current_picture.reference)

        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);

}
",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
6160,FFmpeg,1,"static int read_ffserver_streams(AVFormatContext *s, const char *filename)

{

    int i, err;

    AVFormatContext *ic;

    int nopts = 0;



    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);

    if (err < 0)

        return err;

    /* copy stream format */

    s->nb_streams = ic->nb_streams;

    for(i=0;i<ic->nb_streams;i++) {

        AVStream *st;

        AVCodec *codec;



        // FIXME: a more elegant solution is needed

        st = av_mallocz(sizeof(AVStream));

        memcpy(st, ic->streams[i], sizeof(AVStream));

        st->codec = avcodec_alloc_context();

        if (!st->codec) {

            print_error(filename, AVERROR(ENOMEM));

            ffmpeg_exit(1);

        }

        avcodec_copy_context(st->codec, ic->streams[i]->codec);

        s->streams[i] = st;



        codec = avcodec_find_encoder(st->codec->codec_id);

        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (audio_stream_copy) {

                st->stream_copy = 1;

  ",1,0,4,0,0,0,1,1,1,1,1,1,0,1,1
6165,FFmpeg,1,"static void uninit(AVFilterContext *ctx)

{

    ZScaleContext *s = ctx->priv;



    zimg_filter_graph_free(s->graph);


    av_freep(&s->tmp);

    s->tmp_size = 0;

}",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
6186,qemu,0,"static void decode_bo_addrmode_post_pre_base(CPUTriCoreState *env,

                                             DisasContext *ctx)

{

    uint32_t op2;

    uint32_t off10;

    int32_t r1, r2;

    TCGv temp;



    r1 = MASK_OP_BO_S1D(ctx->opcode);

    r2  = MASK_OP_BO_S2(ctx->opcode);

    off10 = MASK_OP_BO_OFF10_SEXT(ctx->opcode);

    op2 = MASK_OP_BO_OP2(ctx->opcode);



    switch (op2) {

    case OPC2_32_BO_CACHEA_WI_SHORTOFF:

    case OPC2_32_BO_CACHEA_W_SHORTOFF:

    case OPC2_32_BO_CACHEA_I_SHORTOFF:

        /* instruction to access the cache */

        break;

    case OPC2_32_BO_CACHEA_WI_POSTINC:

    case OPC2_32_BO_CACHEA_W_POSTINC:

    case OPC2_32_BO_CACHEA_I_POSTINC:

        /* instruction to access the cache, but we still need to handle

           the addressing mode */

        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);

        break;

    case OPC2_32_BO_CACHEA_WI_PREINC:

    case OPC2_32_BO_CACHEA_W_PREINC:

    case OPC2_32_BO_CACHEA_I_PREINC:

        /* instr",0,0,0,0,1,0,0,0,0,0,0,1,1,1,1
6189,qemu,0,"static int kvm_mips_get_fpu_registers(CPUState *cs)

{

    MIPSCPU *cpu = MIPS_CPU(cs);

    CPUMIPSState *env = &cpu->env;

    int err, ret = 0;

    unsigned int i;



    /* Only get FPU state if we're emulating a CPU with an FPU */

    if (env->CP0_Config1 & (1 << CP0C1_FP)) {

        /* FPU Control Registers */

        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR,

                                    &env->active_fpu.fcr0);

        if (err < 0) {

            DPRINTF(""%s: Failed to get FCR_IR (%d)\n"", __func__, err);

            ret = err;

        }

        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR,

                                    &env->active_fpu.fcr31);

        if (err < 0) {

            DPRINTF(""%s: Failed to get FCR_CSR (%d)\n"", __func__, err);

            ret = err;

        } else {

            restore_fp_status(env);

        }



        /* Floating point registers */

        for (i = 0; i < 32; ++i) {

            if (env->CP0_Status & (1 << CP0St_FR)) {

   ",1,0,4,0,0,0,0,0,0,0,0,0,1,0,0
6193,qemu,0,"static void gen_loongson_integer(DisasContext *ctx, uint32_t opc,

                                 int rd, int rs, int rt)

{

    const char *opn = ""loongson"";

    TCGv t0, t1;



    if (rd == 0) {

        /* Treat as NOP. */

        MIPS_DEBUG(""NOP"");

        return;

    }



    switch (opc) {

    case OPC_MULT_G_2E:

    case OPC_MULT_G_2F:

    case OPC_MULTU_G_2E:

    case OPC_MULTU_G_2F:

#if defined(TARGET_MIPS64)

    case OPC_DMULT_G_2E:

    case OPC_DMULT_G_2F:

    case OPC_DMULTU_G_2E:

    case OPC_DMULTU_G_2F:

#endif

        t0 = tcg_temp_new();

        t1 = tcg_temp_new();

        break;

    default:

        t0 = tcg_temp_local_new();

        t1 = tcg_temp_local_new();

        break;

    }



    gen_load_gpr(t0, rs);

    gen_load_gpr(t1, rt);



    switch (opc) {

    case OPC_MULT_G_2E:

    case OPC_MULT_G_2F:

        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);

        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);

        opn = ""mult.g"";

        break;

    case OPC_MULTU_G",0,0,3,0,2,0,1,1,1,1,1,1,1,1,1
6196,qemu,0,"static void vfio_pci_load_rom(VFIOPCIDevice *vdev)

{

    struct vfio_region_info reg_info = {

        .argsz = sizeof(reg_info),

        .index = VFIO_PCI_ROM_REGION_INDEX

    };

    uint64_t size;

    off_t off = 0;

    size_t bytes;



    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {

        error_report(""vfio: Error getting ROM info: %m"");

        return;

    }



    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,

                            (unsigned long)reg_info.offset,

                            (unsigned long)reg_info.flags);



    vdev->rom_size = size = reg_info.size;

    vdev->rom_offset = reg_info.offset;



    if (!vdev->rom_size) {

        vdev->rom_read_failed = true;

        error_report(""vfio-pci: Cannot read device rom at ""

                    ""%s"", vdev->vbasedev.name);

        error_printf(""Device option ROM contents are probably invalid ""

                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """,0,0,2,0,0,0,0,1,0,1,0,1,0,0,0
6206,qemu,1,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_max_ns);



        if (max_ns) {

            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    return false;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,1
6217,qemu,1,"static void pci_basic(gconstpointer data)

{

    QVirtioPCIDevice *dev;

    QPCIBus *bus;

    QVirtQueuePCI *tx, *rx;

    QGuestAllocator *alloc;

    void (*func) (const QVirtioBus *bus,

                  QVirtioDevice *dev,

                  QGuestAllocator *alloc,

                  QVirtQueue *rvq,

                  QVirtQueue *tvq,

                  int socket) = data;

    int sv[2], ret;



    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);

    g_assert_cmpint(ret, !=, -1);



    bus = pci_test_start(sv[1]);

    dev = virtio_net_pci_init(bus, PCI_SLOT);



    alloc = pc_alloc_init();

    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 0);

    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,

                                           alloc, 1);



    driver_init(&qvirtio_pci, &dev->vdev);

    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);



    /* End test */

    close(sv[0]);

    gue",0,0,0,0,0,0,0,1,0,0,0,1,1,0,0
6241,qemu,0,"static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
6243,qemu,0,"static int vnc_validate_certificate(struct VncState *vs)

{

    int ret;

    unsigned int status;

    const gnutls_datum_t *certs;

    unsigned int nCerts, i;

    time_t now;



    VNC_DEBUG(""Validating client certificate\n"");

    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {

	VNC_DEBUG(""Verify failed %s\n"", gnutls_strerror(ret));

	return -1;

    }



    if ((now = time(NULL)) == ((time_t)-1)) {

	return -1;

    }



    if (status != 0) {

	if (status & GNUTLS_CERT_INVALID)

	    VNC_DEBUG(""The certificate is not trusted.\n"");



	if (status & GNUTLS_CERT_SIGNER_NOT_FOUND)

	    VNC_DEBUG(""The certificate hasn't got a known issuer.\n"");



	if (status & GNUTLS_CERT_REVOKED)

	    VNC_DEBUG(""The certificate has been revoked.\n"");



	if (status & GNUTLS_CERT_INSECURE_ALGORITHM)

	    VNC_DEBUG(""The certificate uses an insecure algorithm\n"");



	return -1;

    } else {

	VNC_DEBUG(""Certificate is valid!\n"");

    }



    /* Only support x509 for now */

    if (g",0,0,18,0,0,0,0,0,0,0,0,0,0,1,1
6251,qemu,0,"int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,

                        void *callback_opaque, uint8_t *data, size_t len)

{

    FWCfgState *s = opaque;

    int arch = !!(key & FW_CFG_ARCH_LOCAL);



    key &= FW_CFG_ENTRY_MASK;



    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)

        || len > 65535)

        return 0;



    s->entries[arch][key].data = data;

    s->entries[arch][key].len = len;

    s->entries[arch][key].callback_opaque = callback_opaque;

    s->entries[arch][key].callback = callback;



    return 1;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,0
6272,FFmpeg,1,"static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],

                                   int order, int qlevel, int len, int bps)

{

    int i, j;

    int ebps = 1 << (bps-1);

    unsigned sigma = 0;



    for (i = order; i < len; i++)

        sigma |= decoded[i] + ebps;



    if (sigma < 2*ebps)

        return;



    for (i = len - 1; i >= order; i--) {

        int64_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (int64_t)decoded[i-order+j];

        decoded[i] -= p >> qlevel;

    }

    for (i = order; i < len; i++, decoded++) {

        int32_t p = 0;

        for (j = 0; j < order; j++)

            p += coeffs[j] * (uint32_t)decoded[j];

        decoded[j] += p >> qlevel;

    }

}
",5,0,1,0,0,0,1,1,1,1,1,1,1,0,0
6277,FFmpeg,0,"static int read_thread(void *arg)

{

    VideoState *is = arg;

    AVFormatContext *ic = NULL;

    int err, i, ret;

    int st_index[AVMEDIA_TYPE_NB];

    AVPacket pkt1, *pkt = &pkt1;

    int eof = 0;

    int pkt_in_play_range = 0;

    AVDictionaryEntry *t;

    AVDictionary **opts;

    int orig_nb_streams;

    SDL_mutex *wait_mutex = SDL_CreateMutex();



    memset(st_index, -1, sizeof(st_index));

    is->last_video_stream = is->video_stream = -1;

    is->last_audio_stream = is->audio_stream = -1;

    is->last_subtitle_stream = is->subtitle_stream = -1;



    ic = avformat_alloc_context();

    ic->interrupt_callback.callback = decode_interrupt_cb;

    ic->interrupt_callback.opaque = is;

    err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);

    if (err < 0) {

        print_error(is->filename, err);

        ret = -1;

        goto fail;

    }

    if ((t = av_dict_get(format_opts, """", NULL, AV_DICT_IGNORE_SUFFIX))) {

        av_log(NULL, AV_LOG_ERROR, ""Option %s no",5,1,3,0,0,0,1,1,0,1,1,0,1,1,1
6293,FFmpeg,0,"int ff_xvmc_field_start(MpegEncContext *s, AVCodecContext *avctx)

{

    struct xvmc_pix_fmt *last, *next, *render = (struct xvmc_pix_fmt*)s->current_picture.data[2];

    const int mb_block_count = 4 + (1 << s->chroma_format);



    assert(avctx);

    if (!render || render->xvmc_id != AV_XVMC_ID ||

        !render->data_blocks || !render->mv_blocks) {

        av_log(avctx, AV_LOG_ERROR,

               ""Render token doesn't look as expected.\n"");

        return -1; // make sure that this is a render packet

    }



    if (render->filled_mv_blocks_num) {

        av_log(avctx, AV_LOG_ERROR,

               ""Rendering surface contains %i unprocessed blocks.\n"",

               render->filled_mv_blocks_num);

        return -1;

    }

    if (render->allocated_mv_blocks   < 1 ||

        render->allocated_data_blocks <  render->allocated_mv_blocks*mb_block_count ||

        render->start_mv_blocks_num   >= render->allocated_mv_blocks                ||

        render->next_free_data_block_num >

      ",1,0,3,0,0,0,0,0,0,0,0,0,1,1,1
6307,FFmpeg,1,"static int calculate_bitrate(AVFormatContext *s)

{

    AVIContext *avi = s->priv_data;

    int i, j;

    int64_t lensum = 0;

    int64_t maxpos = 0;



    for (i = 0; i<s->nb_streams; i++) {

        int64_t len = 0;

        AVStream *st = s->streams[i];



        if (!st->nb_index_entries)

            continue;



        for (j = 0; j < st->nb_index_entries; j++)

            len += st->index_entries[j].size;

        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);

        lensum += len;

    }

    if (maxpos < avi->io_fsize*9/10) // index does not cover the whole file

        return 0;

    if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch

        return 0;



    for (i = 0; i<s->nb_streams; i++) {

        int64_t len = 0;

        AVStream *st = s->streams[i];

        int64_t duration;



        for (j = 0; j < st->nb_index_entries; j++)

            len += st->index_entries[j].size;



        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)",4,0,4,0,0,0,0,0,0,1,1,0,0,1,0
6335,qemu,1,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
6346,qemu,1,"static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,1,1
6374,qemu,1,"static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,

                                                 Error **errp)

{

    struct addrinfo ai, *res;

    int rc;

    Error *err = NULL;



    memset(&ai, 0, sizeof(ai));



    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;

    ai.ai_family = inet_ai_family_from_address(saddr, &err);

    ai.ai_socktype = SOCK_STREAM;



    if (err) {

        error_propagate(errp, err);

        return NULL;

    }



    if (saddr->host == NULL || saddr->port == NULL) {

        error_setg(errp, ""host and/or port not specified"");

        return NULL;

    }



    /* lookup */

    rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);

    if (rc != 0) {

        error_setg(errp, ""address resolution failed for %s:%s: %s"",

                   saddr->host, saddr->port, gai_strerror(rc));

        return NULL;

    }

    return res;

}
",1,0,4,0,0,0,0,1,0,0,0,0,0,0,1
6385,qemu,1,"static void bamboo_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *isa = g_new(MemoryRegion, 1);

    MemoryRegion *ram_memories

        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));

    hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS];

    hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS];

    qemu_irq *pic;

    qemu_irq *irqs;

    PCIBus *pcibus;

    PowerPCCPU *cpu;

    CPUPPCState *env;

    uint64_t elf_entry;

    uint64_t elf_lowaddr;

    hwaddr loadaddr = 0;

    target_long initrd_size = 0;

    DeviceState *dev;

    int success;

    int i;



    /* Setup CPU. */

    if (machine->cpu_model == NULL) {

        machine->cpu_model = ""440EP"";

    }

   ",0,0,1,0,0,0,0,0,0,1,1,0,0,0,0
6408,qemu,0,"void HELPER(stpq)(CPUS390XState *env, uint64_t addr,

                  uint64_t low, uint64_t high)

{

    uintptr_t ra = GETPC();



    if (parallel_cpus) {

#ifndef CONFIG_ATOMIC128

        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);

#else

        int mem_idx = cpu_mmu_index(env, false);

        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);



        Int128 v = int128_make128(low, high);

        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);

#endif

    } else {

        check_alignment(env, addr, 16, ra);



        cpu_stq_data_ra(env, addr + 0, high, ra);

        cpu_stq_data_ra(env, addr + 8, low, ra);

    }

}
",0,0,3,0,0,0,0,0,0,1,0,0,1,0,1
6432,FFmpeg,1,"static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)

{

#ifdef HAVE_MMX

	asm volatile(

		""movq ""MANGLE(bm01010101)"", %%mm4\n\t""

		""mov %0, %%""REG_a""		\n\t""

		""1:				\n\t""

		""movq (%1, %%""REG_a"",4), %%mm0	\n\t""

		""movq 8(%1, %%""REG_a"",4), %%mm1	\n\t""

		""psrlw $8, %%mm0		\n\t""

		""psrlw $8, %%mm1		\n\t""

		""packuswb %%mm1, %%mm0		\n\t""

		""movq %%mm0, %%mm1		\n\t""

		""psrlw $8, %%mm0		\n\t""

		""pand %%mm4, %%mm1		\n\t""

		""packuswb %%mm0, %%mm0		\n\t""

		""packuswb %%mm1, %%mm1		\n\t""

		""movd %%mm0, (%3, %%""REG_a"")	\n\t""

		""movd %%mm1, (%2, %%""REG_a"")	\n\t""

		""add $4, %%""REG_a""		\n\t""

		"" js 1b				\n\t""

		: : ""g"" (-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)

		: ""%""REG_a

	);

#else

	int i;

	for(i=0; i<width; i++)

	{

		dstU[i]= src1[4*i + 1];

		dstV[i]= src1[4*i + 3];

	}

#endif

        assert(src1 == src2);

}
",1,0,2,0,0,0,0,0,0,1,0,0,0,0,0
6452,FFmpeg,0,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
",2,0,0,0,0,0,0,0,0,0,0,0,1,1,1
6455,FFmpeg,1,"static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(

        ""mov                  %0, %%""REG_a""         \n\t""

        ""1:                                         \n\t""

        ""movq  (%1, %%""REG_a"",2), %%mm0             \n\t""

        ""movq 8(%1, %%""REG_a"",2), %%mm1             \n\t""

        ""psrlw                $8, %%mm0             \n\t""

        ""psrlw                $8, %%mm1             \n\t""

        ""packuswb          %%mm1, %%mm0             \n\t""

        ""movq              %%mm0, (%2, %%""REG_a"")   \n\t""

        ""add                  $8, %%""REG_a""         \n\t""

        "" js                  1b                    \n\t""

        : : ""g"" ((x86_reg)-width), ""r"" (src+width*2), ""r"" (dst+width)

        : ""%""REG_a

    );

#else

    int i;

    for (i=0; i<width; i++)

        dst[i]= src[2*i+1];

#endif

}
",1,0,2,0,0,0,1,1,1,1,1,1,0,0,0
6486,qemu,1,"static void simple_number(void)

{

    int i;

    struct {

        const char *encoded;

        int64_t decoded;

        int skip;

    } test_cases[] = {

        { ""0"", 0 },

        { ""1234"", 1234 },

        { ""1"", 1 },

        { ""-32"", -32 },

        { ""-0"", 0, .skip = 1 },

        { },

    };



    for (i = 0; test_cases[i].encoded; i++) {

        QInt *qint;



        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));

        g_assert(qint);

        g_assert(qint_get_int(qint) == test_cases[i].decoded);

        if (test_cases[i].skip == 0) {

            QString *str;



            str = qobject_to_json(QOBJECT(qint));

            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);

            QDECREF(str);

        }



        QDECREF(qint);

    }

}
",1,0,1,0,0,0,1,1,1,1,0,1,0,1,0
6489,FFmpeg,1,"static int video_thread(void *arg)

{

    VideoState *is = arg;

    AVFrame *frame = avcodec_alloc_frame();

    int64_t pts_int;

    double pts;

    int ret;



#if CONFIG_AVFILTER

    AVFilterGraph *graph = avfilter_graph_alloc();

    AVFilterContext *filt_out = NULL;

    int64_t pos;

    int last_w = is->video_st->codec->width;

    int last_h = is->video_st->codec->height;



    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

        goto the_end;

    filt_out = is->out_video_filter;

#endif



    for (;;) {

#if !CONFIG_AVFILTER

        AVPacket pkt;

#else

        AVFilterBufferRef *picref;

        AVRational tb;

#endif

        while (is->paused && !is->videoq.abort_request)

            SDL_Delay(10);

#if CONFIG_AVFILTER

        if (   last_w != is->video_st->codec->width

            || last_h != is->video_st->codec->height) {

            av_dlog(NULL, ""Changing size %dx%d -> %dx%d\n"", last_w, last_h,

                    is->video_st->codec->width, is->video_st->code",1,1,7,0,0,1,0,0,0,1,0,1,0,0,0
6500,qemu,1,"static int ccid_initfn(USBDevice *dev)

{

    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);



    s->bus = ccid_bus_new(&dev->qdev);

    s->card = NULL;

    s->cardinfo = NULL;

    s->migration_state = MIGRATION_NONE;

    s->migration_target_ip = 0;

    s->migration_target_port = 0;

    s->dev.speed = USB_SPEED_FULL;

    s->notify_slot_change = false;

    s->powered = true;

    s->pending_answers_num = 0;

    s->last_answer_error = 0;

    s->bulk_in_pending_start = 0;

    s->bulk_in_pending_end = 0;

    s->current_bulk_in = NULL;

    ccid_reset_error_status(s);

    s->bulk_out_pos = 0;

    ccid_reset_parameters(s);

    ccid_reset(s);

    return 0;

}
",0,0,1,0,0,0,0,1,1,0,0,0,0,0,0
6507,qemu,1,"static void ppc4xx_pob_reset (void *opaque)

{

    ppc4xx_pob_t *pob;



    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
6509,FFmpeg,1,"int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)

{

    int i, j, t, rconpointer = 0;

    uint8_t tk[8][4];

    int KC = key_bits >> 5;

    int rounds = KC + 6;

    uint8_t log8[256];

    uint8_t alog8[512];



    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {

        j = 1;

        for (i = 0; i < 255; i++) {

            alog8[i] = alog8[i + 255] = j;

            log8[j] = i;

            j ^= j + j;

            if (j > 255)

                j ^= 0x11B;

        }

        for (i = 0; i < 256; i++) {

            j = i ? alog8[255 - log8[i]] : 0;

            j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4);

            j = (j ^ (j >> 8) ^ 99) & 255;

            inv_sbox[j] = i;

            sbox[i] = j;

        }

        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },

                     log8, alog8, inv_sbox);

        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },

                     log8, a",2,0,2,0,0,0,0,0,0,1,1,1,1,0,0
6519,FFmpeg,1,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}
",0,0,0,0,0,0,0,0,0,1,1,0,1,1,1
6524,qemu,0,"static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,

                                  sPAPRMachineState *spapr)

{

    PowerPCCPU *cpu = POWERPC_CPU(cs);

    CPUPPCState *env = &cpu->env;

    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);

    int index = ppc_get_vcpu_dt_id(cpu);

    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),

                       0xffffffff, 0xffffffff};

    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()

        : SPAPR_TIMEBASE_FREQ;

    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;

    uint32_t page_sizes_prop[64];

    size_t page_sizes_prop_size;

    uint32_t vcpus_per_socket = smp_threads * smp_cores;

    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};

    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));

    sPAPRDRConnector *drc;

    int drc_index;

    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];

    int i;



    drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index);

  ",0,0,1,0,0,0,1,0,1,1,0,1,0,1,0
6532,qemu,0,"static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)

{

    XHCIState *xhci = epctx->xhci;

    XHCIStreamContext *stctx;

    XHCITransfer *xfer;

    XHCIRing *ring;

    USBEndpoint *ep = NULL;

    uint64_t mfindex;

    int length;

    int i;



    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);



    /* If the device has been detached, but the guest has not noticed this

       yet the 2 above checks will succeed, but we must NOT continue */

    if (!xhci->slots[epctx->slotid - 1].uport ||

        !xhci->slots[epctx->slotid - 1].uport->dev ||

        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {

        return;

    }



    if (epctx->retry) {

        XHCITransfer *xfer = epctx->retry;



        trace_usb_xhci_xfer_retry(xfer);

        assert(xfer->running_retry);

        if (xfer->timed_xfer) {

            /* time to kick the transfer? */

            mfindex = xhci_mfindex_get(xhci);

            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfin",0,0,3,0,0,0,0,0,0,0,0,0,1,0,0
6535,FFmpeg,0,"static int opt_preset(const char *opt, const char *arg)

{

    FILE *f=NULL;

    char filename[1000], tmp[1000], tmp2[1000], line[1000];

    int i;

    const char *base[3]= { getenv(""HOME""),

                           ""/usr/local/share"",

                           ""/usr/share"",

                         };



    for(i=!base[0]; i<3 && !f; i++){

        snprintf(filename, sizeof(filename), ""%s/%sffmpeg/%s.ffpreset"", base[i], i ? """" : ""."", arg);

        f= fopen(filename, ""r"");

        if(!f){

            char *codec_name= *opt == 'v' ? video_codec_name :

                              *opt == 'a' ? audio_codec_name :

                                            subtitle_codec_name;

            snprintf(filename, sizeof(filename), ""%s/%sffmpeg/%s-%s.ffpreset"", base[i],  i ? """" : ""."", codec_name, arg);

            f= fopen(filename, ""r"");

        }

    }

    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||

              is_dos_path(arg))){

        snprintf(filename, sizeof(filename), ar",1,0,2,0,0,0,0,0,0,0,0,0,1,1,1
6543,FFmpeg,1,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, asf->offset, size);

    return 0;

}
",1,0,3,0,0,0,0,0,0,0,0,0,1,0,0
6545,qemu,1,"static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s,

                          void *data, uint32_t length, uint64_t offset)

{

    int ret = 0;

    void *buffer = NULL;

    void *merged_sector = NULL;

    void *data_tmp, *sector_write;

    unsigned int i;

    int sector_offset;

    uint32_t desc_sectors, sectors, total_length;

    uint32_t sectors_written = 0;

    uint32_t aligned_length;

    uint32_t leading_length = 0;

    uint32_t trailing_length = 0;

    uint32_t partial_sectors = 0;

    uint32_t bytes_written = 0;

    uint64_t file_offset;

    VHDXHeader *header;

    VHDXLogEntryHeader new_hdr;

    VHDXLogDescriptor *new_desc = NULL;

    VHDXLogDataSector *data_sector = NULL;

    MSGUID new_guid = { 0 };



    header = s->headers[s->curr_header];



    /* need to have offset read data, and be on 4096 byte boundary */



    if (length > header->log_length) {

        /* no log present.  we could create a log here instead of failing */

        ret = -EINVAL;

        g",0,0,1,0,0,0,1,1,1,1,0,1,0,1,0
6547,qemu,1,"static void vmxnet3_net_uninit(VMXNET3State *s)

{

    g_free(s->mcast_list);

    vmxnet_tx_pkt_reset(s->tx_pkt);

    vmxnet_tx_pkt_uninit(s->tx_pkt);

    vmxnet_rx_pkt_uninit(s->rx_pkt);

    qemu_del_nic(s->nic);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
6556,FFmpeg,1,"static int http_prepare_data(HTTPContext *c)

{

    int i;



    switch(c->state) {

    case HTTPSTATE_SEND_DATA_HEADER:

        memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx));

        if (c->stream->feed) {

            /* open output stream by using specified codecs */

            c->fmt_ctx.oformat = c->stream->fmt;

            c->fmt_ctx.nb_streams = c->stream->nb_streams;

            for(i=0;i<c->fmt_ctx.nb_streams;i++) {

                AVStream *st;

                st = av_mallocz(sizeof(AVStream));

                c->fmt_ctx.streams[i] = st;

                if (c->stream->feed == c->stream)

                    memcpy(st, c->stream->streams[i], sizeof(AVStream));

                else

                    memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]], sizeof(AVStream));



                st->codec.frame_number = 0; /* XXX: should be done in

                                               AVStream, not in codec */

            }

            c->got_key_frame = 0;

        } e",2,0,2,0,1,0,0,0,0,0,0,0,1,1,1
6575,FFmpeg,1,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    if (!buffer->cmd) {

        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(buffer);

}
",0,0,1,0,0,0,0,0,0,1,1,1,0,0,0
6577,qemu,1,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,1,0
6580,FFmpeg,0,"static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *src,

                                               int32_t src_stride,

                                               uint8_t *dst, int32_t dst_stride)

{

    int32_t loop_cnt;

    int16_t filt_const0 = 0xfb01;

    int16_t filt_const1 = 0x1414;

    int16_t filt_const2 = 0x1fb;

    v16u8 dst0, dst1, dst2, dst3;

    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;

    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;

    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;

    v16i8 src65_l, src87_l;

    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;

    v16i8 filt0, filt1, filt2;

    v16u8 res0, res1, res2, res3;



    filt0 = (v16i8) __msa_fill_h(filt_const0);

    filt1 = (v16i8) __msa_fill_h(filt_const1);

    filt2 = (v16i8) __msa_fill_h(filt_const2);



    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);

    src += (5 * src_stride);



    XORI_B5_128_S",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
6594,qemu,0,"static int net_socket_can_send(void *opaque)

{

    NetSocketState *s = opaque;



    return qemu_can_send_packet(&s->nc);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,0
6605,qemu,0,"static void ppc_prep_init (ram_addr_t ram_size,

                           const char *boot_device,

                           const char *kernel_filename,

                           const char *kernel_cmdline,

                           const char *initrd_filename,

                           const char *cpu_model)

{

    CPUState *env = NULL;

    char *filename;

    nvram_t nvram;

    M48t59State *m48t59;

    int PPC_io_memory;

    int linux_boot, i, nb_nics1, bios_size;

    ram_addr_t ram_offset, bios_offset;

    uint32_t kernel_base, initrd_base;

    long kernel_size, initrd_size;

    PCIBus *pci_bus;

    qemu_irq *i8259;

    qemu_irq *cpu_exit_irq;

    int ppc_boot_device;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    DriveInfo *fd[MAX_FD];



    sysctrl = qemu_mallocz(sizeof(sysctrl_t));



    linux_boot = (kernel_filename != NULL);



    /* init CPUs */

    if (cpu_model == NULL)

        cpu_model = ""602"";

    for (i = 0; i < smp_cpus; i++) {

        env = cpu_init(cpu_mo",1,0,1,0,0,0,0,0,0,1,0,0,0,0,0
6622,FFmpeg,0,"static void copy_picture_field(InterlaceContext *s,

                               AVFrame *src_frame, AVFrame *dst_frame,

                               AVFilterLink *inlink, enum FieldType field_type,

                               int lowpass)

{

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);

    int hsub = desc->log2_chroma_w;

    int vsub = desc->log2_chroma_h;

    int plane, j;



    for (plane = 0; plane < desc->nb_components; plane++) {

        int cols  = (plane == 1 || plane == 2) ? -(-inlink->w) >> hsub : inlink->w;

        int lines = (plane == 1 || plane == 2) ? -(-inlink->h) >> vsub : inlink->h;

        uint8_t *dstp = dst_frame->data[plane];

        const uint8_t *srcp = src_frame->data[plane];



        av_assert0(cols >= 0 || lines >= 0);



        lines = (lines + (field_type == FIELD_UPPER)) / 2;

        if (field_type == FIELD_LOWER)

            srcp += src_frame->linesize[plane];

        if (field_type == FIELD_LOWER)

            dstp += dst_fr",2,0,2,0,0,0,0,0,0,0,0,0,1,1,1
6628,qemu,1,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,1,1
6635,qemu,1,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#elif defined(TARGET_S390X)

    CPUState *cs;

    S390CPU *cpu;



    CPU_FOREACH(cs) {

        cpu = S390_CPU(cs);

        if (cpu->env.cpu_num == monitor_get_cpu_index()) {

            if (s390_cpu_restart(S390_CPU(cs)) == -1) {

                error_set(errp, QERR_UNSUPPORTED);

                return;

            }

            break;

        }

    }

#else

    error_set(errp, QERR_UNSUPPORTED);

#endif

}
",0,0,6,0,0,0,0,0,0,0,0,1,0,0,1
6641,qemu,1,"void helper_single_step(CPUX86State *env)

{

#ifndef CONFIG_USER_ONLY

    check_hw_breakpoints(env, 1);

    env->dr[6] |= DR6_BS;

#endif

    raise_exception(env, EXCP01_DB);

}
",0,0,2,0,0,0,0,0,1,1,1,1,1,1,1
6646,FFmpeg,1,"static av_always_inline void rv40_weak_loop_filter(uint8_t *src,

                                                   const int step,

                                                   const int stride,

                                                   const int filter_p1,

                                                   const int filter_q1,

                                                   const int alpha,

                                                   const int beta,

                                                   const int lim_p0q0,

                                                   const int lim_q1,

                                                   const int lim_p1)

{

    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;

    int i, t, u, diff;



    for (i = 0; i < 4; i++, src += stride) {

        int diff_p1p0 = src[-2*step] - src[-1*step];

        int diff_q1q0 = src[ 1*step] - src[ 0*step];

        int diff_p1p2 = src[-2*step] - src[-3*step];

        int diff_q1q2 = src[ 1*step] - src",1,0,5,0,0,0,0,0,0,0,1,0,0,0,0
6650,qemu,1,"static void con_disconnect(struct XenDevice *xendev)

{

    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);



    if (con->chr) {

        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);

        qemu_chr_fe_release(con->chr);

    }

    xen_be_unbind_evtchn(&con->xendev);



    if (con->sring) {

        if (!xendev->dev) {

            munmap(con->sring, XC_PAGE_SIZE);

        } else {

            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);

        }

        con->sring = NULL;

    }

}
",0,0,3,0,0,0,0,1,0,1,1,1,0,0,0
6670,FFmpeg,1,"static int normalize_bits(int num, int width)

{

    if (!num)

        return 0;

    if (num == -1)

        return width;

    if (num < 0)

        num = ~num;



    return width - av_log2(num);

}
",0,0,3,0,0,0,1,1,1,1,0,1,0,0,0
6674,qemu,1,"static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    k->realize = xen_pt_realize;

    k->exit = xen_pt_unregister_device;

    k->config_read = xen_pt_pci_read_config;

    k->config_write = xen_pt_pci_write_config;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->desc = ""Assign an host PCI device with Xen"";

    dc->props = xen_pci_passthrough_properties;

};",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
6685,qemu,1,"static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    ohci);



    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);

        ohci_die(ohci);

        return 0;

    }



    trace_usb_ohci_start(ohci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
6699,qemu,1,"void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,

                                   ImageInfoSpecific *info_spec)

{

    QObject *obj, *data;

    Visitor *v = qmp_output_visitor_new(&obj);



    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);

    visit_complete(v, &obj);

    assert(qobject_type(obj) == QTYPE_QDICT);

    data = qdict_get(qobject_to_qdict(obj), ""data"");

    dump_qobject(func_fprintf, f, 1, data);


    visit_free(v);

}",0,0,3,0,0,0,0,1,0,0,1,1,1,0,0
6708,FFmpeg,0,"static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (avpkt->size <= 0)

        return avpkt->size;



    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return avpkt->size;

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
6727,FFmpeg,1,"static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)

{

    YADIFContext *s = ctx->priv;

    ThreadData *td  = arg;

    int refs = s->cur->linesize[td->plane];

    int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8;

    int pix_3 = 3 * df;

    int slice_h = td->h / nb_jobs;

    int slice_start = jobnr * slice_h;

    int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;

    int y;



    /* filtering reads 3 pixels to the left/right; to avoid invalid reads,

     * we need to call the c variant which avoids this for border pixels

     */

    for (y = slice_start; y < slice_end; y++) {

        if ((y ^ td->parity) & 1) {

            uint8_t *prev = &s->prev->data[td->plane][y * refs];

            uint8_t *cur  = &s->cur ->data[td->plane][y * refs];

            uint8_t *next = &s->next->data[td->plane][y * refs];

            uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];

            int     mode  = y == 1 || y",2,0,1,0,0,0,1,1,1,1,1,1,1,1,1
6753,qemu,0,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,

                              int mmu_idx)

{

    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */

        /* TODO - Unsupported */

        error_report(""Guest Radix Support Unimplemented"");

        exit(1);

    } else { /* Guest uses hash */

        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);

    }

}
",0,0,1,0,0,0,0,0,0,1,0,0,1,1,1
6763,FFmpeg,1,"int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

    VideoDemuxData *s = s1->priv_data;

    char filename_bytes[1024];

    char *filename = filename_bytes;

    int i;

    int size[3]           = { 0 }, ret[3] = { 0 };

    AVIOContext *f[3]     = { NULL };

    AVCodecContext *codec = s1->streams[0]->codec;



    if (!s->is_pipe) {

        /* loop over input */

        if (s->loop && s->img_number > s->img_last) {

            s->img_number = s->img_first;

        }

        if (s->img_number > s->img_last)

            return AVERROR_EOF;

        if (s->use_glob) {

#if HAVE_GLOB

            filename = s->globstate.gl_pathv[s->img_number];

#endif

        } else {

        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),

                                  s->path,

                                  s->img_number) < 0 && s->img_number > 1)

            return AVERROR(EIO);

        }

        for (i = 0; i < 3; i++) {

            if (avio_open2(&f[i], filename, AVIO_",1,0,8,0,0,0,1,1,1,1,0,0,0,0,0
6775,qemu,1,"void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)

{

    IDEBus *bus = opaque;

    IDEState *s = idebus_active_if(bus);

    uint8_t *p;



    /* PIO data access allowed only when DRQ bit is set */

    if (!(s->status & DRQ_STAT))

        return;



    p = s->data_ptr;

    *(uint16_t *)p = le16_to_cpu(val);

    p += 2;

    s->data_ptr = p;

    if (p >= s->data_end)

        s->end_transfer_func(s);

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
6778,FFmpeg,1,"static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,

                                                     PutBitContext *pb, const float *in, float *out,

                                                     const float *scaled, int size, int scale_idx,

                                                     int cb, const float lambda, const float uplim,

                                                     int *bits, const float ROUNDING)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    int qc1, qc2, qc3, qc4;



    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];

    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];

    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];



    abs_pow34_v(s->scoefs, in, size);

    scaled = s->scoefs;

    for (i = 0; i < size; i += 4) {

     ",1,0,0,0,0,0,1,1,0,0,1,1,0,0,0
6801,FFmpeg,0,"static int stream_component_open(PlayerState *is, int stream_index)

{

    AVFormatContext *ic = is->ic;

    AVCodecContext *avctx;

    AVCodec *codec;

    SDL_AudioSpec wanted_spec, spec;

    AVDictionary *opts;

    AVDictionaryEntry *t = NULL;

    int ret = 0;



    if (stream_index < 0 || stream_index >= ic->nb_streams)

        return -1;

    avctx = ic->streams[stream_index]->codec;



    opts = filter_codec_opts(codec_opts, avctx->codec_id, ic, ic->streams[stream_index], NULL);



    codec = avcodec_find_decoder(avctx->codec_id);

    avctx->workaround_bugs   = workaround_bugs;

    avctx->idct_algo         = idct;

    avctx->skip_frame        = skip_frame;

    avctx->skip_idct         = skip_idct;

    avctx->skip_loop_filter  = skip_loop_filter;

    avctx->error_concealment = error_concealment;



    if (fast)

        avctx->flags2 |= AV_CODEC_FLAG2_FAST;



    if (!av_dict_get(opts, ""threads"", NULL, 0))

        av_dict_set(&opts, ""threads"", ""auto"", 0);

    if (avctx->codec_type == ",0,0,4,0,0,0,0,0,0,1,0,0,0,0,0
6816,qemu,1,"static void keyword_literal(void)

{

    QObject *obj;

    QBool *qbool;

    QObject *null;

    QString *str;



    obj = qobject_from_json(""true"", NULL);

    qbool = qobject_to_qbool(obj);

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == true);



    str = qobject_to_json(obj);

    g_assert(strcmp(qstring_get_str(str), ""true"") == 0);

    QDECREF(str);



    QDECREF(qbool);



    obj = qobject_from_json(""false"", NULL);

    qbool = qobject_to_qbool(obj);

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == false);



    str = qobject_to_json(obj);

    g_assert(strcmp(qstring_get_str(str), ""false"") == 0);

    QDECREF(str);



    QDECREF(qbool);



    qbool = qobject_to_qbool(qobject_from_jsonf(""%i"", false));

    g_assert(qbool);

    g_assert(qbool_get_bool(qbool) == false);

    QDECREF(qbool);



    /* Test that non-zero values other than 1 get collapsed to true */

    qbool = qobject_to_qbool(qobject_from_jsonf(""%i"", 2));

    g_assert(qbool);

    g_assert(qbool_get_b",0,0,0,0,0,0,1,1,1,1,1,1,0,0,1
6829,qemu,0,"static void ppc_core99_init (ram_addr_t ram_size,

                             const char *boot_device,

                             const char *kernel_filename,

                             const char *kernel_cmdline,

                             const char *initrd_filename,

                             const char *cpu_model)

{

    CPUState *env = NULL, *envs[MAX_CPUS];

    char *filename;

    qemu_irq *pic, **openpic_irqs;

    int unin_memory;

    int linux_boot, i;

    ram_addr_t ram_offset, bios_offset, vga_bios_offset;

    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;

    PCIBus *pci_bus;

    MacIONVRAMState *nvr;

    int nvram_mem_index;

    int vga_bios_size, bios_size;

    int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index;

    int ide_mem_index[3];

    int ppc_boot_device;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    void *fw_cfg;

    void *dbdma;

    uint8_t *vga_bios_ptr;

    int machine_arch;



    linux_boot = (kernel_filename != NULL",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
6838,qemu,0,"void DMA_run(void)

{

    /* XXXXX */

}
",0,0,0,0,0,0,1,0,0,0,0,0,1,1,1
6844,qemu,0,"INLINE int16 extractFloat64Exp( float64 a )

{



    return ( a>>52 ) & 0x7FF;



}
",0,0,0,0,0,0,1,1,0,1,1,1,1,1,0
6852,qemu,0,"uint32_t helper_fcmp_un(uint32_t a, uint32_t b)

{

    CPU_FloatU fa, fb;

    uint32_t r = 0;



    fa.l = a;

    fb.l = b;



    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {

        update_fpu_flags(float_flag_invalid);

        r = 1;

    }



    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {

        r = 1;

    }



    return r;

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
6867,qemu,0,"static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions options;



    if (vhost_user_running(s)) {

        return 0;

    }



    options.backend_type = VHOST_BACKEND_TYPE_USER;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    return vhost_user_running(s) ? 0 : -1;

}
",0,0,1,0,0,0,0,1,0,0,0,0,0,0,0
6879,FFmpeg,0,"static int alac_set_info(ALACContext *alac)

{

    GetByteContext gb;



    bytestream2_init(&gb, alac->avctx->extradata,

                     alac->avctx->extradata_size);



    bytestream2_skipu(&gb, 12); // size:4, alac:4, version:4



    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);

    if (alac->max_samples_per_frame >= UINT_MAX/4){

        av_log(alac->avctx, AV_LOG_ERROR,

               ""max_samples_per_frame too large\n"");

        return AVERROR_INVALIDDATA;

    }

    bytestream2_skipu(&gb, 1);  // compatible version

    alac->sample_size          = bytestream2_get_byteu(&gb);

    alac->rice_history_mult    = bytestream2_get_byteu(&gb);

    alac->rice_initial_history = bytestream2_get_byteu(&gb);

    alac->rice_limit           = bytestream2_get_byteu(&gb);

    alac->channels             = bytestream2_get_byteu(&gb);

    bytestream2_get_be16u(&gb); // maxRun

    bytestream2_get_be32u(&gb); // max coded frame size

    bytestream2_get_be32u(&gb); // average bitrate

    byt",0,0,1,0,0,0,0,0,0,0,0,0,1,0,1
6891,qemu,1,"static void sdhci_send_command(SDHCIState *s)

{

    SDRequest request;

    uint8_t response[16];

    int rlen;



    s->errintsts = 0;

    s->acmd12errsts = 0;

    request.cmd = s->cmdreg >> 8;

    request.arg = s->argument;

    DPRINT_L1(""sending CMD%u ARG[0x%08x]\n"", request.cmd, request.arg);

    rlen = sdbus_do_command(&s->sdbus, &request, response);



    if (s->cmdreg & SDHC_CMD_RESPONSE) {

        if (rlen == 4) {

            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |

                           (response[2] << 8)  |  response[3];

            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;

            DPRINT_L1(""Response: RSPREG[31..0]=0x%08x\n"", s->rspreg[0]);

        } else if (rlen == 16) {

            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |

                           (response[13] << 8) |  response[14];

            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |

                           (response[9] << 8)  |  response[10];

     ",0,0,3,0,0,0,1,1,1,0,0,1,1,0,0
6919,qemu,0,"static void test_dealloc_types(void)

{

    UserDefOne *ud1test, *ud1a, *ud1b;

    UserDefOneList *ud1list;



    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = g_strdup(""hi there 44"");



    ud1list = g_malloc0(sizeof(UserDefOneList));

    ud1list->value = ud1a;

    ud1list->next = g_malloc0(sizeof(UserDefOneList));

    ud1list->next->value = ud1b;



    qapi_free_UserDefOneList(ud1list);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
6927,qemu,0,"void net_checksum_calculate(uint8_t *data, int length)

{

    int hlen, plen, proto, csum_offset;

    uint16_t csum;



    if ((data[14] & 0xf0) != 0x40)

	return; /* not IPv4 */

    hlen  = (data[14] & 0x0f) * 4;

    plen  = (data[16] << 8 | data[17]) - hlen;

    proto = data[23];



    switch (proto) {

    case PROTO_TCP:

	csum_offset = 16;

	break;

    case PROTO_UDP:

	csum_offset = 6;

	break;

    default:

	return;

    }



    if (plen < csum_offset+2)

	return;



    data[14+hlen+csum_offset]   = 0;

    data[14+hlen+csum_offset+1] = 0;

    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);

    data[14+hlen+csum_offset]   = csum >> 8;

    data[14+hlen+csum_offset+1] = csum & 0xff;

}
",0,0,2,0,1,0,1,1,1,0,1,1,1,1,1
6935,qemu,0,"static void x86_cpu_parse_featurestr(const char *typename, char *features,

                                     Error **errp)

{

    char *featurestr; /* Single 'key=value"" string being parsed */

    static bool cpu_globals_initialized;

    bool ambiguous = false;



    if (cpu_globals_initialized) {

        return;

    }

    cpu_globals_initialized = true;



    if (!features) {

        return;

    }



    for (featurestr = strtok(features, "","");

         featurestr;

         featurestr = strtok(NULL, "","")) {

        const char *name;

        const char *val = NULL;

        char *eq = NULL;

        char num[32];

        GlobalProperty *prop;



        /* Compatibility syntax: */

        if (featurestr[0] == '+') {

            plus_features = g_list_append(plus_features,

                                          g_strdup(featurestr + 1));

            continue;

        } else if (featurestr[0] == '-') {

            minus_features = g_list_append(minus_features,

                      ",1,0,4,0,0,0,1,1,1,1,0,0,0,0,0
6946,qemu,1,"static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,

                                               VirtQueue *vq,

                                               EventNotifierHandler *handler,

                                               int n)

{

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);

    int rc;



    /* Set up virtqueue notify */

    rc = k->set_host_notifier(qbus->parent, n, true);

    if (rc != 0) {

        fprintf(stderr, ""virtio-scsi: Failed to set host notifier (%d)\n"",

                rc);

        exit(1);

    }

    r->host_notifier = *virtio_queue_get_host_notifier(vq);

    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);

    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);



    r->parent = s;



    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {

        fprintf(stderr, ""virtio-scsi: VRing setup failed\n"");

        exit",0,0,11,0,0,0,0,0,0,1,1,1,1,1,1
6951,qemu,1,"void qemu_net_queue_purge(NetQueue *queue, NetClientState *from)

{

    NetPacket *packet, *next;



    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {

        if (packet->sender == from) {

            QTAILQ_REMOVE(&queue->packets, packet, entry);


            g_free(packet);

        }

    }

}",0,0,1,0,0,0,1,1,1,0,0,1,0,0,0
6953,qemu,1,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*session, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
",0,0,2,0,0,0,0,0,0,0,0,1,0,1,1
6956,FFmpeg,1,"static int slice_end(AVCodecContext *avctx, AVFrame *pict)

{

    Mpeg1Context *s1  = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;



    if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr)

        return 0;



    if (s->avctx->hwaccel) {

        if (s->avctx->hwaccel->end_frame(s->avctx) < 0)

            av_log(avctx, AV_LOG_ERROR,

                   ""hardware accelerator failed to decode picture\n"");

    }



#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration)

        ff_xvmc_field_end(s);

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    /* end of slice reached */

    if (/* s->mb_y << field_pic == s->mb_height && */ !s->first_field) {

        /* end of image */



        ff_er_frame_end(&s->er);



        ff_MPV_frame_end(s);



        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {

            int ret = av_frame_ref(pict, &s->current_picture_ptr->f);

            if (ret < 0)

   ",0,0,9,0,0,0,0,1,1,1,1,1,1,0,1
6972,FFmpeg,1,"static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,

                                                    int16_t *block, int n)

{

    int level, i, j, run;

    RLTable *rl = &ff_rl_mpeg1;

    uint8_t * const scantable = s->intra_scantable.permutated;

    const int qscale          = s->qscale;

    OPEN_READER(re, &s->gb);

    i = -1;



    // special case for first coefficient, no need to add second VLC table

    UPDATE_CACHE(re, &s->gb);

    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {

        level = (3 * qscale) >> 1;

        if (GET_CACHE(re, &s->gb) & 0x40000000)

            level = -level;

        block[0] = level;

        i++;

        SKIP_BITS(re, &s->gb, 2);

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            goto end;

    }



    /* now quantify & encode AC coefficients */

    for (;;) {

        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);



        if (level != 0) {

            i += run;

            j  ",1,1,4,0,0,0,0,0,0,1,1,1,1,1,1
6997,FFmpeg,0,"static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
",1,0,5,0,0,0,0,1,0,1,1,1,0,0,1
6999,FFmpeg,1,"static void init_gain_table(COOKContext *q) {

    int i;

    q->gain_size_factor = q->samples_per_channel/8;

    for (i=0 ; i<23 ; i++) {

        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,

                               (1.0/(double)q->gain_size_factor));

    }

    memset(&q->gain_copy, 0, sizeof(COOKgain));

    memset(&q->gain_current, 0, sizeof(COOKgain));

    memset(&q->gain_now, 0, sizeof(COOKgain));

    memset(&q->gain_previous, 0, sizeof(COOKgain));

}
",1,0,0,0,0,0,0,1,1,1,1,1,1,1,1
7004,qemu,1,"static void qpa_fini_out (HWVoiceOut *hw)

{

    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hw;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    g_free (pa->pcm_buf);

    pa->pcm_buf = NULL;

}
",0,0,1,0,0,0,1,1,1,1,1,0,1,1,0
7017,qemu,0,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
7019,qemu,0,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
",1,0,1,0,0,0,0,0,0,0,0,0,1,1,1
7027,qemu,0,"static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,

    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)

{

    size_t fetched = 0;

    struct iovec *src = pkt->vec;



    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;



    while (fetched < pkt->virt_hdr.gso_size) {



        /* no more place in fragment iov */

        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {

            break;

        }



        /* no more data in iovec */

        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {

            break;

        }





        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;

        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,

            pkt->virt_hdr.gso_size - fetched);



        *src_offset += dst[*dst_idx].iov_len;

        fetched += dst[*dst_idx].iov_len;



        if (*src_offset == src[*src_idx].iov_len) {

            *src_offset = 0;

            (*src_idx)++;

        }



        (*dst_idx)++;

    }



    re",0,0,3,0,0,1,0,0,0,0,0,0,1,1,1
7033,qemu,0,"static void lsi_ram_write(void *opaque, target_phys_addr_t addr,

                          uint64_t val, unsigned size)

{

    LSIState *s = opaque;

    uint32_t newval;

    uint32_t mask;

    int shift;



    newval = s->script_ram[addr >> 2];

    shift = (addr & 3) * 8;

    mask = ((uint64_t)1 << (size * 8)) - 1;

    newval &= ~(mask << shift);

    newval |= val << shift;

    s->script_ram[addr >> 2] = newval;

}
",0,0,4,0,0,0,1,1,0,1,1,1,1,1,0
7048,FFmpeg,1,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
7066,FFmpeg,0,"static void avc_luma_vt_16w_msa(const uint8_t *src, int32_t src_stride,

                                uint8_t *dst, int32_t dst_stride,

                                int32_t height)

{

    int32_t loop_cnt;

    int16_t filt_const0 = 0xfb01;

    int16_t filt_const1 = 0x1414;

    int16_t filt_const2 = 0x1fb;

    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;

    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;

    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;

    v16i8 src65_l, src87_l;

    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;

    v16u8 res0, res1, res2, res3;

    v16i8 filt0, filt1, filt2;



    filt0 = (v16i8) __msa_fill_h(filt_const0);

    filt1 = (v16i8) __msa_fill_h(filt_const1);

    filt2 = (v16i8) __msa_fill_h(filt_const2);



    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);

    src += (5 * src_stride);



    XORI_B5_128_SB(src0, src1, src2, src3, src4);

    ILVR_B4_SB(src1, src0, src",0,0,0,0,0,0,0,0,0,1,1,0,0,1,0
7069,qemu,0,"static int img_commit(int argc, char **argv)

{

    int c, ret, flags;

    const char *filename, *fmt, *cache, *base;

    BlockBackend *blk;

    BlockDriverState *bs, *base_bs;

    bool progress = false, quiet = false, drop = false;

    bool writethrough;

    Error *local_err = NULL;

    CommonBlockJobCBInfo cbi;

    bool image_opts = false;

    AioContext *aio_context;



    fmt = NULL;

    cache = BDRV_DEFAULT_CACHE;

    base = NULL;

    for(;;) {

        static const struct option long_options[] = {

            {""help"", no_argument, 0, 'h'},

            {""object"", required_argument, 0, OPTION_OBJECT},

            {""image-opts"", no_argument, 0, OPTION_IMAGE_OPTS},

            {0, 0, 0, 0}

        };

        c = getopt_long(argc, argv, ""f:ht:b:dpq"",

                        long_options, NULL);

        if (c == -1) {

            break;

        }

        switch(c) {

        case '?':

        case 'h':

            help();

            break;

        case 'f':

            fmt = opt",1,0,1,0,1,0,0,0,0,0,0,0,0,0,1
7099,qemu,0,"unsigned long setup_arg_pages(void * mh, char ** argv, char ** env)

{

    unsigned long stack_base, error, size;

    int i;

    int * stack;

    int argc, envc;



    /* Create enough stack to hold everything.  If we don't use

     * it for args, we'll use it for something else...

     */

    size = stack_size;



    error = target_mmap(0,

                        size + qemu_host_page_size,

                        PROT_READ | PROT_WRITE,

                        MAP_PRIVATE | MAP_ANONYMOUS,

                        -1, 0);

    if (error == -1)

        qerror(""stk mmap"");



    /* we reserve one extra page at the top of the stack as guard */

    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);



    stack_base = error + size;

    stack = (void*)stack_base;

/*

 *    | STRING AREA |

 *    +-------------+

 *    |      0      |

*    +-------------+

 *    |  apple[n]   |

 *    +-------------+

 *           :

 *    +-------------+

 *    |  apple[0]   |

 *    +-------------+
",2,0,1,0,0,0,0,0,0,1,0,0,1,1,1
7105,qemu,0,"int sd_do_command(SDState *sd, SDRequest *req,

                  uint8_t *response) {

    uint32_t last_status = sd->card_status;

    sd_rsp_type_t rtype;

    int rsplen;



    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {

        return 0;

    }



    if (sd_req_crc_validate(req)) {

        sd->card_status |= COM_CRC_ERROR;

        rtype = sd_illegal;

        goto send_response;

    }



    sd->card_status &= ~CARD_STATUS_B;

    sd_set_status(sd);



    if (last_status & CARD_IS_LOCKED) {

        if (!cmd_valid_while_locked(sd, req)) {

            sd->card_status |= ILLEGAL_COMMAND;

            fprintf(stderr, ""SD: Card is locked\n"");

            rtype = sd_illegal;

            goto send_response;

        }

    }



    if (last_status & APP_CMD) {

        rtype = sd_app_command(sd, *req);

        sd->card_status &= ~APP_CMD;

    } else

        rtype = sd_normal_command(sd, *req);



    if (rtype == sd_illegal) {

        sd->card_status |= ILLEGAL_COMMAND;

    }
",0,2,6,0,0,1,0,0,0,0,0,0,0,0,0
7109,qemu,0,"void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,

                   uint32_t *eax, uint32_t *ebx,

                   uint32_t *ecx, uint32_t *edx)

{

    X86CPU *cpu = x86_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t pkg_offset;



    /* test if maximum index reached */

    if (index & 0x80000000) {

        if (index > env->cpuid_xlevel) {

            if (env->cpuid_xlevel2 > 0) {

                /* Handle the Centaur's CPUID instruction. */

                if (index > env->cpuid_xlevel2) {

                    index = env->cpuid_xlevel2;

                } else if (index < 0xC0000000) {

                    index = env->cpuid_xlevel;

                }

            } else {

                /* Intel documentation states that invalid EAX input will

                 * return the same information as EAX=cpuid_level

                 * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID)

                 */

                index =  env->cpuid_level;

          ",1,0,5,0,0,0,1,1,1,0,1,0,1,1,1
7111,FFmpeg,0,"static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)

{

    char *argstr_flat;

    wchar_t **argv_w;

    int i, buffsize = 0, offset = 0;



    if (win32_argv_utf8) {

        *argc_ptr = win32_argc;

        *argv_ptr = win32_argv_utf8;

        return;

    }



    win32_argc = 0;

    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);

    if (win32_argc <= 0 || !argv_w)

        return;



    /* determine the UTF-8 buffer size (including NULL-termination symbols) */

    for (i = 0; i < win32_argc; i++)

        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,

                                        NULL, 0, NULL, NULL);



    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);

    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);

    if (win32_argv_utf8 == NULL) {

        LocalFree(argv_w);

        return;

    }



    for (i = 0; i < win32_argc; i++) {

        win32_argv_utf8[i] = &argstr_flat[offset];

",2,0,3,0,0,0,0,0,0,0,0,0,0,0,0
7119,qemu,0,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)

{

    switch (size) {

    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;

    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;

    default: abort();

    }

}
",0,0,0,0,1,0,0,0,0,0,0,1,0,0,0
7122,FFmpeg,0,"int MP3lame_encode_frame(AVCodecContext *avctx,

                     unsigned char *frame, int buf_size, void *data)

{

	Mp3AudioContext *s = avctx->priv_data;

	int num, i;

//av_log(avctx, AV_LOG_DEBUG, ""%X %d %X\n"", (int)frame, buf_size, (int)data);

//        if(data==NULL)

//            return lame_encode_flush(s->gfp, frame, buf_size);



	/* lame 3.91 dies on '1-channel interleaved' data */

	if (s->stereo) {

		num = lame_encode_buffer_interleaved(s->gfp, data,

			MPA_FRAME_SIZE, frame, buf_size);

	} else {

		num = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,

			frame, buf_size);



/*av_log(avctx, AV_LOG_DEBUG, ""in:%d out:%d\n"", MPA_FRAME_SIZE, num);

for(i=0; i<num; i++){

    av_log(avctx, AV_LOG_DEBUG, ""%2X "", frame[i]);

}*/

	}



	return num;

}
",1,0,1,0,0,0,0,0,1,1,1,0,1,1,0
7125,qemu,1,"int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)

{

    int offset = 0, counter = 10;

    int res;



    if (!s->chr_sync_read) {

        return 0;

    }

    

    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {

        return replay_char_read_all_load(buf);

    }



    while (offset < len) {

        do {

            res = s->chr_sync_read(s, buf + offset, len - offset);

            if (res == -1 && errno == EAGAIN) {

                g_usleep(100);

            }

        } while (res == -1 && errno == EAGAIN);



        if (res == 0) {

            break;

        }



        if (res < 0) {

            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {

                replay_char_read_all_save_error(res);

            }

            return res;

        }



        offset += res;



        if (!counter--) {

            break;

        }

    }



    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {

        replay_char_read_all_save_buf(buf, offset);

    }
",0,0,8,0,0,2,0,1,1,0,1,0,0,0,0
7130,FFmpeg,1,"static int decode_b_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status;



    bitplane_decoding(&v->skip_mb_plane, v);

    if (status < 0) return -1;

#if TRACE

    if (v->mv_mode == MV_PMODE_MIXED_MV)

    {

        status = bitplane_decoding(&v->mv_type_mb_plane, v);

        if (status < 0)

            return -1;

#if TRACE

        av_log(v->s.avctx, AV_LOG_DEBUG, ""MB MV Type plane encoding: ""

               ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif

    }



    //bitplane

    status = bitplane_decoding(&v->direct_mb_plane, v);

    if (status < 0) return -1;

#if TRACE

    av_log(v->s.avctx, AV_LOG_DEBUG, ""MB Direct plane encoding: ""

           ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif



    av_log(v->s.avctx, AV_LOG_DEBUG, ""Skip MB plane encoding: ""

           ""Imode: %i, Invert: %i\n"", status>>1, status&1);

#endif



    /* FIXME: what is actually chosen for B frames ? */

    v->s.mv_table_index = get_bits(gb, 2); //",0,0,10,0,0,0,1,1,1,1,1,1,0,0,0
7150,FFmpeg,1,"static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)

{

    int i;



    for (i = 0; i < s->nb_streams; i++) {

        MXFTrack *track = s->streams[i]->priv_data;

        /* SMPTE 379M 7.3 */

        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))

            return i;

    }

    /* return 0 if only one stream, for OP Atom files with 0 as track number */

    return s->nb_streams == 1 ? 0 : -1;

}
",1,0,1,0,0,0,1,1,1,1,1,1,0,0,0
7168,FFmpeg,1,"static void vc1_mc_1mv(VC1Context *v, int dir)

{

    MpegEncContext *s = &v->s;

    H264ChromaContext *h264chroma = &v->h264chroma;

    uint8_t *srcY, *srcU, *srcV;

    int dxy, mx, my, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;

    int v_edge_pos = s->v_edge_pos >> v->field_mode;

    int i;

    uint8_t (*luty)[256], (*lutuv)[256];

    int use_ic;



    if ((!v->field_mode ||

         (v->ref_field_type[dir] == 1 && v->cur_field_type == 1)) &&

        !v->s.last_picture.f.data[0])

        return;



    mx = s->mv[dir][0][0];

    my = s->mv[dir][0][1];



    // store motion vectors for further use in B frames

    if (s->pict_type == AV_PICTURE_TYPE_P) {

        for (i = 0; i < 4; i++) {

            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][0] = mx;

            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][1] = my;

        }

    }



    uvmx = (mx + ((mx & 3) == 3)) >> 1;

    uvmy = (my + ((my & 3) == 3)) >> 1;

    v->luma_mv[s->mb_x][0] ",1,0,2,0,0,0,1,1,1,0,0,0,0,0,0
7174,FFmpeg,1,"static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)

{

#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)

	asm volatile(

		""movq ""MANGLE(bm01010101)"", %%mm4\n\t""

		""mov %0, %%""REG_a""		\n\t""

		""1:				\n\t""

		""movq (%1, %%""REG_a"",4), %%mm0	\n\t""

		""movq 8(%1, %%""REG_a"",4), %%mm1	\n\t""

		""movq (%2, %%""REG_a"",4), %%mm2	\n\t""

		""movq 8(%2, %%""REG_a"",4), %%mm3	\n\t""

		PAVGB(%%mm2, %%mm0)

		PAVGB(%%mm3, %%mm1)

		""psrlw $8, %%mm0		\n\t""

		""psrlw $8, %%mm1		\n\t""

		""packuswb %%mm1, %%mm0		\n\t""

		""movq %%mm0, %%mm1		\n\t""

		""psrlw $8, %%mm0		\n\t""

		""pand %%mm4, %%mm1		\n\t""

		""packuswb %%mm0, %%mm0		\n\t""

		""packuswb %%mm1, %%mm1		\n\t""

		""movd %%mm0, (%4, %%""REG_a"")	\n\t""

		""movd %%mm1, (%3, %%""REG_a"")	\n\t""

		""add $4, %%""REG_a""		\n\t""

		"" js 1b				\n\t""

		: : ""g"" ((long)-width), ""r"" (src1+width*4), ""r"" (src2+width*4), ""r"" (dstU+width), ""r"" (dstV+width)

		: ""%""REG_a

	);

#else

	int i;

	for(i=0; i<width; i++)

	{

		dstU[i]= (src1[4*i + 1",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
7177,FFmpeg,0,"static int mtv_read_header(AVFormatContext *s)

{

    MTVDemuxContext *mtv = s->priv_data;

    AVIOContext   *pb  = s->pb;

    AVStream        *st;

    unsigned int    audio_subsegments;



    avio_skip(pb, 3);

    mtv->file_size         = avio_rl32(pb);

    mtv->segments          = avio_rl32(pb);

    avio_skip(pb, 32);

    mtv->audio_identifier  = avio_rl24(pb);

    mtv->audio_br          = avio_rl16(pb);

    mtv->img_colorfmt      = avio_rl24(pb);

    mtv->img_bpp           = avio_r8(pb);

    mtv->img_width         = avio_rl16(pb);

    mtv->img_height        = avio_rl16(pb);

    mtv->img_segment_size  = avio_rl16(pb);



    /* Calculate width and height if missing from header */



    if(mtv->img_bpp>>3){

    if(!mtv->img_width && mtv->img_height)

        mtv->img_width=mtv->img_segment_size / (mtv->img_bpp>>3)

                        / mtv->img_height;



    if(!mtv->img_height && mtv->img_width)

        mtv->img_height=mtv->img_segment_size / (mtv->img_bpp>>3)

                      ",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
7191,qemu,1,"static bool qht_insert__locked(struct qht *ht, struct qht_map *map,

                               struct qht_bucket *head, void *p, uint32_t hash,

                               bool *needs_resize)

{

    struct qht_bucket *b = head;

    struct qht_bucket *prev = NULL;

    struct qht_bucket *new = NULL;

    int i;



    do {

        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {

            if (b->pointers[i]) {

                if (unlikely(b->pointers[i] == p)) {

                    return false;

                }

            } else {

                goto found;

            }

        }

        prev = b;

        b = b->next;

    } while (b);



    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));

    memset(b, 0, sizeof(*b));

    new = b;

    i = 0;

    atomic_inc(&map->n_added_buckets);

    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {

        *needs_resize = true;

    }



 found:

    /* found an empty key: acquire the seqlock and write */

    seqlock_write_begin(&head-",1,1,3,0,0,1,1,1,1,1,1,1,1,0,0
7204,FFmpeg,1,"static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)

{

    pkt->data      = NULL;

    pkt->side_data = NULL;

    if (pkt->buf) {

        AVBufferRef *ref = av_buffer_ref(src->buf);

        if (!ref)

            return AVERROR(ENOMEM);

        pkt->buf  = ref;

        pkt->data = ref->data;

    } else {

        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);

    }

#if FF_API_DESTRUCT_PACKET

FF_DISABLE_DEPRECATION_WARNINGS

    pkt->destruct = dummy_destruct_packet;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    if (pkt->side_data_elems && dup)

        pkt->side_data = src->side_data;

    if (pkt->side_data_elems && !dup) {

        return av_copy_packet_side_data(pkt, src);

    }

    return 0;



failed_alloc:

    av_destruct_packet(pkt);

    return AVERROR(ENOMEM);

}
",0,0,6,0,0,0,1,1,1,1,1,1,0,0,0
7213,qemu,0,"static void virtio_crypto_instance_init(Object *obj)

{

    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);



    /*

     * The default config_size is sizeof(struct virtio_crypto_config).

     * Can be overriden with virtio_crypto_set_config_size.

     */

    vcrypto->config_size = sizeof(struct virtio_crypto_config);



    object_property_add_link(obj, ""cryptodev"",

                             TYPE_CRYPTODEV_BACKEND,

                             (Object **)&vcrypto->conf.cryptodev,

                             virtio_crypto_check_cryptodev_is_used,

                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
7222,qemu,0,"int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw,

			     int mmu_idx, int is_softmmu)

{

    target_ulong physical;

    int prot, ret, access_type;



    access_type = ACCESS_INT;

    ret =

	get_physical_address(env, &physical, &prot, address, rw,

			     access_type);



    if (ret != MMU_OK) {

	env->tea = address;

	switch (ret) {

	case MMU_ITLB_MISS:

	case MMU_DTLB_MISS_READ:

	    env->exception_index = 0x040;

	    break;

	case MMU_DTLB_MULTIPLE:

	case MMU_ITLB_MULTIPLE:

	    env->exception_index = 0x140;

	    break;

	case MMU_ITLB_VIOLATION:

	    env->exception_index = 0x0a0;

	    break;

	case MMU_DTLB_MISS_WRITE:

	    env->exception_index = 0x060;

	    break;

	case MMU_DTLB_INITIAL_WRITE:

	    env->exception_index = 0x080;

	    break;

	case MMU_DTLB_VIOLATION_READ:

	    env->exception_index = 0x0a0;

	    break;

	case MMU_DTLB_VIOLATION_WRITE:

	    env->exception_index = 0x0c0;

	    break;

	case MMU_IADDR_ERROR:

	case MMU_DADDR_ERROR_READ:

	    ",0,0,1,0,1,0,0,1,0,1,1,1,1,1,1
7243,qemu,1,"static int virtio_blk_device_exit(DeviceState *dev)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);

    VirtIOBlock *s = VIRTIO_BLK(dev);

#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE

    remove_migration_state_change_notifier(&s->migration_state_notifier);

    virtio_blk_data_plane_destroy(s->dataplane);

    s->dataplane = NULL;

#endif

    qemu_del_vm_change_state_handler(s->change);

    unregister_savevm(dev, ""virtio-blk"", s);

    blockdev_mark_auto_del(s->bs);

    virtio_cleanup(vdev);

    return 0;

}
",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
7267,qemu,1,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    uint64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);

    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);



    mr = ddc->get_memory_region(dimm);

    value = memory_region_size(mr);



    visit_type_uint64(v, name, &value, errp);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,1,1
7269,qemu,1,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
7315,qemu,0,"static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd)

{

    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);

    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);

    int ret;



    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {

        DPRINTF(""Unimplemented LUN %d\n"", req->lun);

        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));

        scsi_req_complete(&r->req, CHECK_CONDITION);

        return 0;

    }



    if (-1 == scsi_req_parse(&r->req, cmd)) {

        BADF(""Unsupported command length, command %x\n"", cmd[0]);

        scsi_command_complete(r, -EINVAL);

        return 0;

    }

    scsi_req_fixup(&r->req);



    DPRINTF(""Command: lun=%d tag=0x%x len %zd data=0x%02x"", lun, tag,

            r->req.cmd.xfer, cmd[0]);



#ifdef DEBUG_SCSI

    {

        int i;

        for (i = 1; i < r->req.cmd.len; i++) {

            printf("" 0x%02x"", cmd[i]);

        }

        printf(""\n"");

    }

#endif



    if (r->req.cmd.xfer ==",1,0,5,0,0,0,0,0,0,0,0,0,0,0,0
7324,qemu,0,"void ip6_input(struct mbuf *m)

{

    struct ip6 *ip6;



    DEBUG_CALL(""ip6_input"");

    DEBUG_ARG(""m = %lx"", (long)m);

    DEBUG_ARG(""m_len = %d"", m->m_len);



    if (m->m_len < sizeof(struct ip6)) {

        goto bad;

    }



    ip6 = mtod(m, struct ip6 *);



    if (ip6->ip_v != IP6VERSION) {

        goto bad;

    }



    /* check ip_ttl for a correct ICMP reply */

    if (ip6->ip_hl == 0) {

        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,""ttl"");*/

        goto bad;

    }



    /*

     * Switch out to protocol's input routine.

     */

    switch (ip6->ip_nh) {

    case IPPROTO_TCP:

        /*tcp_input(m, hlen, (struct socket *)NULL);*/

        break;

    case IPPROTO_UDP:

        /*udp_input(m, hlen);*/

        break;

    case IPPROTO_ICMPV6:

        icmp6_input(m);

        break;

    default:

        m_free(m);

    }

    return;

bad:

    m_free(m);

}
",0,3,3,0,1,0,1,1,0,1,1,1,0,1,1
7326,qemu,0,"void fork_start(void)

{

    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);

    pthread_mutex_lock(&exclusive_lock);

    mmap_fork_start();

}
",2,0,0,0,0,0,0,0,0,0,0,0,1,1,1
7327,qemu,0,"static int write_dump_pages(DumpState *s)

{

    int ret = 0;

    DataCache page_desc, page_data;

    size_t len_buf_out, size_out;

#ifdef CONFIG_LZO

    lzo_bytep wrkmem = NULL;

#endif

    uint8_t *buf_out = NULL;

    off_t offset_desc, offset_data;

    PageDescriptor pd, pd_zero;

    uint8_t *buf;

    int endian = s->dump_info.d_endian;

    GuestPhysBlock *block_iter = NULL;

    uint64_t pfn_iter;



    /* get offset of page_desc and page_data in dump file */

    offset_desc = s->offset_page;

    offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable;



    prepare_data_cache(&page_desc, s, offset_desc);

    prepare_data_cache(&page_data, s, offset_data);



    /* prepare buffer to store compressed data */

    len_buf_out = get_len_buf_out(s->page_size, s->flag_compress);

    if (len_buf_out == 0) {

        dump_error(s, ""dump: failed to get length of output buffer.\n"");

        goto out;

    }



#ifdef CONFIG_LZO

    wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS);

#endif

",0,1,5,0,0,0,1,1,1,1,1,1,0,0,0
7332,qemu,0,"static void do_ext_interrupt(CPUS390XState *env)

{

    S390CPU *cpu = s390_env_get_cpu(env);

    uint64_t mask, addr;

    LowCore *lowcore;

    ExtQueue *q;



    if (!(env->psw.mask & PSW_MASK_EXT)) {

        cpu_abort(CPU(cpu), ""Ext int w/o ext mask\n"");

    }



    lowcore = cpu_map_lowcore(env);



    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {

        lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);

        lowcore->cpu_addr = 0;

        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;

    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {

        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);

        lowcore->cpu_addr = 0;

        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;

    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {

        g_assert(env->ext_index >= 0);

        /*

         * FIXME: floating IRQs should be considered by all CPUs and

         *        shuld not get cleared by CPU reset.

         */

        q = &env->ext_queue[env->",0,0,4,0,0,0,0,0,0,0,1,0,0,1,0
7334,qemu,0,"static void verdex_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    PXA2xxState *cpu;

    DriveInfo *dinfo;

    int be;

    MemoryRegion *address_space_mem = get_system_memory();



    uint32_t verdex_rom = 0x02000000;

    uint32_t verdex_ram = 0x10000000;



    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: ""pxa270-c0"");



    dinfo = drive_get(IF_PFLASH, 0, 0);

    if (!dinfo && !qtest_enabled()) {

        fprintf(stderr, ""A flash image must be given with the ""

                ""'pflash' parameter\n"");

        exit(1);

    }



#ifdef TARGET_WORDS_BIGENDIAN

    be = 1;

#else

    be = 0;

#endif

    if (!pflash_cfi01_register(0x00000000, NULL, ""verdex.rom"", verdex_rom,

                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                               sector_len, verdex_rom / sector_len,

                               2, 0, 0, 0, 0, be)) {

        fprintf(stderr, ""qemu: Error registering flash memory.\n"");

   ",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
7347,qemu,1,"static int bochs_open(BlockDriverState *bs, QDict *options, int flags,
                      Error **errp)
{
    BDRVBochsState *s = bs->opaque;
    uint32_t i;
    struct bochs_header bochs;
    int ret;
    bs->read_only = 1; // no write support yet
    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));
    if (ret < 0) {
        return ret;
    if (strcmp(bochs.magic, HEADER_MAGIC) ||
        strcmp(bochs.type, REDOLOG_TYPE) ||
        strcmp(bochs.subtype, GROWING_TYPE) ||
	((le32_to_cpu(bochs.version) != HEADER_VERSION) &&
	(le32_to_cpu(bochs.version) != HEADER_V1))) {
        error_setg(errp, ""Image not in Bochs format"");
        return -EINVAL;
    if (le32_to_cpu(bochs.version) == HEADER_V1) {
        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;
    } else {
        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;
    s->catalog_size = le32_to_cpu(bochs.catalog);
    s->catalog_bitmap = g_malloc(s->catalog_size * 4);
    ret = bdrv_pread(bs->file, le32_to_cpu(",1,0,3,0,0,0,1,1,1,1,0,1,1,1,1
7351,FFmpeg,1,"offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)

{

    offset_t offset1;

    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));



    if (whence != SEEK_CUR && whence != SEEK_SET)

        return -EINVAL;



    if (whence == SEEK_CUR) {

        offset1 = pos + (s->buf_ptr - s->buffer);

        if (offset == 0)

            return offset1;

        offset += offset1;

    }

    offset1 = offset - pos;

    if (!s->must_flush &&

        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {

        /* can do the seek inside the buffer */

        s->buf_ptr = s->buffer + offset1;

    } else {

        if (!s->seek)

            return -EPIPE;



#ifdef CONFIG_MUXERS

        if (s->write_flag) {

            flush_buffer(s);

            s->must_flush = 1;

        } else

#endif //CONFIG_MUXERS

        {

            s->buf_end = s->buffer;

        }

        s->buf_ptr = s->buffer;

        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)

        ",0,0,9,0,0,0,0,0,0,1,1,1,1,1,1
7360,qemu,0,"void ppc_translate_init(void)

{

    int i;

    char* p;

    size_t cpu_reg_names_size;

    static int done_init = 0;



    if (done_init)

        return;



    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, ""env"");



    p = cpu_reg_names;

    cpu_reg_names_size = sizeof(cpu_reg_names);



    for (i = 0; i < 8; i++) {

        snprintf(p, cpu_reg_names_size, ""crf%d"", i);

        cpu_crf[i] = tcg_global_mem_new_i32(TCG_AREG0,

                                            offsetof(CPUState, crf[i]), p);

        p += 5;

        cpu_reg_names_size -= 5;

    }



    for (i = 0; i < 32; i++) {

        snprintf(p, cpu_reg_names_size, ""r%d"", i);

        cpu_gpr[i] = tcg_global_mem_new(TCG_AREG0,

                                        offsetof(CPUState, gpr[i]), p);

        p += (i < 10) ? 3 : 4;

        cpu_reg_names_size -= (i < 10) ? 3 : 4;

#if !defined(TARGET_PPC64)

        snprintf(p, cpu_reg_names_size, ""r%dH"", i);

        cpu_gprh[i] = tcg_global_mem_new_i32(TCG_AREG0,

                    ",2,0,2,0,0,0,0,0,0,0,0,0,1,1,1
7380,qemu,0,"static void gen_mtfsfi(DisasContext *ctx)

{

    int bf, sh;

    TCGv_i64 t0;

    TCGv_i32 t1;



    if (unlikely(!ctx->fpu_enabled)) {

        gen_exception(ctx, POWERPC_EXCP_FPU);

        return;

    }

    bf = crbD(ctx->opcode) >> 2;

    sh = 7 - bf;

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_reset_fpstatus();

    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));

    t1 = tcg_const_i32(1 << sh);

    gen_helper_store_fpscr(cpu_env, t0, t1);

    tcg_temp_free_i64(t0);

    tcg_temp_free_i32(t1);

    if (unlikely(Rc(ctx->opcode) != 0)) {

        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);

        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);

    }

    /* We can raise a differed exception */

    gen_helper_float_check_status(cpu_env);

}
",0,0,2,0,0,0,1,1,1,1,1,0,1,0,0
7393,qemu,1,"void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)

{

    int i;

    size_t pagesize = getpagesize();



    memory = (memory + pagesize - 1) & -pagesize;

    for (i = 0; i < memory / pagesize; i++) {

        memset(area + pagesize * i, 0, 1);

    }

}
",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
7398,FFmpeg,1,"static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)

{

    CuvidContext *ctx = avctx->priv_data;

    AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data;

    AVCUDADeviceContext *device_hwctx = device_ctx->hwctx;

    CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx;

    AVFrame *frame = data;

    CUVIDSOURCEDATAPACKET cupkt;

    AVPacket filter_packet = { 0 };

    AVPacket filtered_packet = { 0 };

    CUdeviceptr mapped_frame = 0;

    int ret = 0, eret = 0;



    if (ctx->bsf && avpkt->size) {

        if ((ret = av_packet_ref(&filter_packet, avpkt)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""av_packet_ref failed\n"");

            return ret;

        }



        if ((ret = av_bsf_send_packet(ctx->bsf, &filter_packet)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""av_bsf_send_packet failed\n"");

            av_packet_unref(&filter_packet);

            return ret;

        }



        if ((ret = av_bsf_receive_packet(ctx",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
7420,qemu,0,"static void hotplug(void)

{

    qtest_start(""-device virtio-net-pci"");



    qpci_plug_device_test(""virtio-net-pci"", ""net1"", PCI_SLOT_HP, NULL);

    qpci_unplug_acpi_device_test(""net1"", PCI_SLOT_HP);



    test_end();

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
7428,FFmpeg,0,"static void ff_h264_idct8_add_sse2(uint8_t *dst, int16_t *block, int stride)

{

    __asm__ volatile(

        ""movdqa   0x10(%1), %%xmm1 \n""

        ""movdqa   0x20(%1), %%xmm2 \n""

        ""movdqa   0x30(%1), %%xmm3 \n""

        ""movdqa   0x50(%1), %%xmm5 \n""

        ""movdqa   0x60(%1), %%xmm6 \n""

        ""movdqa   0x70(%1), %%xmm7 \n""

        H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7)

        TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1))

        ""paddw          %4, %%xmm4 \n""

        ""movdqa     %%xmm4, 0x00(%1) \n""

        ""movdqa     %%xmm2, 0x40(%1) \n""

        H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1)

        ""movdqa     %%xmm6, 0x60(%1) \n""

        ""movdqa     %%xmm7, 0x70(%1) \n""

        ""pxor       %%xmm7, %%xmm7 \n""

        STORE_DIFF_8P(%%xmm2, (%0),      %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm0, (%0,%2),   %%xmm6, %%xmm7)

        STORE_DIFF_8P(%%xmm1, (%0,%2,2), %",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
7430,qemu,0,"static void ide_identify(IDEState *s)

{

    uint16_t *p;

    unsigned int oldsize;



    memset(s->io_buffer, 0, 512);

    p = (uint16_t *)s->io_buffer;

    stw(p + 0, 0x0040);

    stw(p + 1, s->cylinders); 

    stw(p + 3, s->heads);

    stw(p + 4, 512 * s->sectors); /* sectors */

    stw(p + 5, 512); /* sector size */

    stw(p + 6, s->sectors); 

    stw(p + 20, 3); /* buffer type */

    stw(p + 21, 512); /* cache size in sectors */

    stw(p + 22, 4); /* ecc bytes */

    padstr((uint8_t *)(p + 27), ""QEMU HARDDISK"", 40);

#if MAX_MULT_SECTORS > 1    

    stw(p + 47, MAX_MULT_SECTORS);

#endif

    stw(p + 48, 1); /* dword I/O */

    stw(p + 49, 1 << 9); /* LBA supported, no DMA */

    stw(p + 51, 0x200); /* PIO transfer cycle */

    stw(p + 52, 0x200); /* DMA transfer cycle */

    stw(p + 54, s->cylinders);

    stw(p + 55, s->heads);

    stw(p + 56, s->sectors);

    oldsize = s->cylinders * s->heads * s->sectors;

    stw(p + 57, oldsize);

    stw(p + 58, oldsize >> 16);

    if (s->m",0,0,4,0,0,0,1,1,1,1,0,0,1,1,1
7448,FFmpeg,0,"static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,

                       const AVFrame *pict, int *got_packet)

{

    PNGEncContext *s = avctx->priv_data;

    int ret;

    int enc_row_size;

    size_t max_packet_size;

    APNGFctlChunk fctl_chunk = {0};



    if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) {

        uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t));



        if (avctx->frame_number == 0) {

            s->palette_checksum = checksum;

        } else if (checksum != s->palette_checksum) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input contains more than one unique palette. APNG does not support multiple palettes.\n"");

            return -1;

        }

    }



    enc_row_size    = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3);

    max_packet_size =

        AV_INPUT_BUFFER_MIN_SIZE + // headers

        avctx->height * (

",0,0,3,0,0,0,0,0,0,1,0,0,0,0,0
7449,qemu,0,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return ret;

}
",0,0,3,0,0,0,1,1,1,1,1,0,0,0,0
7458,qemu,0,"static void migrate_set_downtime(QTestState *who, const char *value)

{

    QDict *rsp;

    gchar *cmd;



    cmd = g_strdup_printf(""{ 'execute': 'migrate_set_downtime',""

                          ""'arguments': { 'value': %s } }"", value);

    rsp = qtest_qmp(who, cmd);

    g_free(cmd);

    g_assert(qdict_haskey(rsp, ""return""));

    QDECREF(rsp);

}
",0,0,0,0,0,0,1,1,1,0,0,0,0,0,0
7462,qemu,0,"target_ulong do_arm_semihosting(CPUARMState *env)

{

    ARMCPU *cpu = arm_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    target_ulong args;

    target_ulong arg0, arg1, arg2, arg3;

    char * s;

    int nr;

    uint32_t ret;

    uint32_t len;

#ifdef CONFIG_USER_ONLY

    TaskState *ts = cs->opaque;

#else

    CPUARMState *ts = env;

#endif



    if (is_a64(env)) {

        /* Note that the syscall number is in W0, not X0 */

        nr = env->xregs[0] & 0xffffffffU;

        args = env->xregs[1];

    } else {

        nr = env->regs[0];

        args = env->regs[1];

    }



    switch (nr) {

    case TARGET_SYS_OPEN:

        GET_ARG(0);

        GET_ARG(1);

        GET_ARG(2);

        s = lock_user_string(arg0);

        if (!s) {

            /* FIXME - should this error code be -TARGET_EFAULT ? */

            return (uint32_t)-1;

        }

        if (arg1 >= 12) {

            unlock_user(s, arg0, 0);

            return (uint32_t)-1;

        }

        if (strcmp(s, "":tt"") == 0)",0,0,6,0,1,0,0,0,0,0,0,0,0,0,0
7471,FFmpeg,0,"static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,

                                         void *logctx, int size)

{

    uint8_t *user_data;

    int e, build, i;



    if (size < 16 || size >= INT_MAX - 16)

        return AVERROR_INVALIDDATA;



    user_data = av_malloc(16 + size + 1);

    if (!user_data)

        return AVERROR(ENOMEM);



    for (i = 0; i < size + 16; i++)

        user_data[i] = get_bits(gb, 8);



    user_data[i] = 0;

    e = sscanf(user_data + 16, ""x264 - core %d"", &build);

    if (e == 1 && build > 0)

        h->x264_build = build;

    if (e == 1 && build == 1 && !strncmp(user_data+16, ""x264 - core 0000"", 16))

        h->x264_build = 67;



    if (strlen(user_data + 16) > 0)

        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""\n"", user_data + 16);



    av_free(user_data);

    return 0;

}
",1,0,5,0,0,0,0,0,0,0,0,0,0,1,0
7472,FFmpeg,0,"void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)

{

    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);

    AVFilterPad *dst = link->dstpad;

    int i;



    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);



    if (!(filter_samples = dst->filter_samples))

        filter_samples = avfilter_default_filter_samples;



    /* prepare to copy the samples if the buffer has insufficient permissions */

    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||

        dst->rej_perms & samplesref->perms) {



        av_log(link->dst, AV_LOG_DEBUG,

               ""Copying audio data in avfilter (have perms %x, need %x, reject %x)\n"",

               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);



        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,

                                                          samplesref->audio->nb_samples);

        link->cur_buf->pts                = samp",0,0,2,0,0,0,1,1,1,0,1,1,1,1,1
7480,qemu,0,"static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,

                                   qemu_irq **irqs)

{

    qemu_irq *mpic;

    DeviceState *dev;

    SysBusDevice *s;

    int i, j, k;



    mpic = g_new(qemu_irq, 256);

    dev = qdev_create(NULL, ""openpic"");

    qdev_prop_set_uint32(dev, ""nb_cpus"", smp_cpus);

    qdev_prop_set_uint32(dev, ""model"", params->mpic_version);

    qdev_init_nofail(dev);

    s = SYS_BUS_DEVICE(dev);



    k = 0;

    for (i = 0; i < smp_cpus; i++) {

        for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {

            sysbus_connect_irq(s, k++, irqs[i][j]);

        }

    }



    for (i = 0; i < 256; i++) {

        mpic[i] = qdev_get_gpio_in(dev, i);

    }



    memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET,

                                s->mmio[0].memory);



    return mpic;

}
",3,0,0,0,0,0,1,1,1,0,1,0,0,1,1
7481,qemu,0,"CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))

{

    const char *p;

    CharDriverState *chr;

    QemuOpts *opts;

    Error *err = NULL;



    if (strstart(filename, ""chardev:"", &p)) {

        return qemu_chr_find(p);

    }



    opts = qemu_chr_parse_compat(label, filename);

    if (!opts)

        return NULL;



    chr = qemu_chr_new_from_opts(opts, init, &err);

    if (err) {

        error_report_err(err);

    }

    if (chr && qemu_opt_get_bool(opts, ""mux"", 0)) {

        qemu_chr_fe_claim_no_fail(chr);

        monitor_init(chr, MONITOR_USE_READLINE);

    }

    return chr;

}
",0,0,4,0,0,0,0,0,0,0,1,1,0,0,0
7490,qemu,0,"static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,

                            const char *model, const char *name,

                            const char *ifname, const char *script,

                            const char *downscript, const char *vhostfdname,

                            int vnet_hdr, int fd)

{

    TAPState *s;



    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);

    if (!s) {

        close(fd);

        return -1;

    }



    if (tap_set_sndbuf(s->fd, tap) < 0) {

        return -1;

    }



    if (tap->has_fd || tap->has_fds) {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str), ""fd=%d"", fd);

    } else if (tap->has_helper) {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str), ""helper=%s"",

                 tap->helper);

    } else {

        snprintf(s->nc.info_str, sizeof(s->nc.info_str),

                 ""ifname=%s,script=%s,downscript=%s"", ifname, script,

                 downscript);



        if (strcmp(downscript, ""no"")",0,0,8,0,0,0,0,0,0,0,0,0,0,0,0
7491,qemu,0,"int qdev_prop_check_globals(void)

{

    GList *l;

    int ret = 0;



    for (l = global_props; l; l = l->next) {

        GlobalProperty *prop = l->data;

        ObjectClass *oc;

        DeviceClass *dc;

        if (prop->used) {

            continue;

        }

        if (!prop->user_provided) {

            continue;

        }

        oc = object_class_by_name(prop->driver);

        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);

        if (!oc) {

            error_report(""Warning: global %s.%s has invalid class name"",

                       prop->driver, prop->property);

            ret = 1;

            continue;

        }

        dc = DEVICE_CLASS(oc);

        if (!dc->hotpluggable && !prop->used) {

            error_report(""Warning: global %s.%s=%s not used"",

                       prop->driver, prop->property, prop->value);

            ret = 1;

            continue;

        }

    }

    return ret;

}
",1,0,4,0,0,0,1,1,1,0,1,1,0,0,0
7498,qemu,0,"static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as)

{

    ESDVoiceOut *esd = (ESDVoiceOut *) hw;

    audsettings_t obt_as = *as;

    int esdfmt = ESD_STREAM | ESD_PLAY;

    int err;

    sigset_t set, old_set;



    sigfillset (&set);



    esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO;

    switch (as->fmt) {

    case AUD_FMT_S8:

    case AUD_FMT_U8:

        esdfmt |= ESD_BITS8;

        obt_as.fmt = AUD_FMT_U8;

        break;



    case AUD_FMT_S32:

    case AUD_FMT_U32:

        dolog (""Will use 16 instead of 32 bit samples\n"");



    case AUD_FMT_S16:

    case AUD_FMT_U16:

    deffmt:

        esdfmt |= ESD_BITS16;

        obt_as.fmt = AUD_FMT_S16;

        break;



    default:

        dolog (""Internal logic error: Bad audio format %d\n"", as->fmt);

        goto deffmt;



    }

    obt_as.endianness = AUDIO_HOST_ENDIANNESS;



    audio_pcm_init_info (&hw->info, &obt_as);



    hw->samples = conf.samples;

    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1",1,1,0,0,1,0,0,0,0,0,0,0,0,0,0
7521,qemu,1,"static void monitor_find_completion(const char *cmdline)

{

    const char *cmdname;

    char *args[MAX_ARGS];

    int nb_args, i, len;

    const char *ptype, *str;

    const mon_cmd_t *cmd;

    const KeyDef *key;



    parse_cmdline(cmdline, &nb_args, args);

#ifdef DEBUG_COMPLETION

    for(i = 0; i < nb_args; i++) {

        monitor_printf(cur_mon, ""arg%d = '%s'\n"", i, (char *)args[i]);

    }

#endif



    /* if the line ends with a space, it means we want to complete the

       next arg */

    len = strlen(cmdline);

    if (len > 0 && qemu_isspace(cmdline[len - 1])) {

        if (nb_args >= MAX_ARGS)

            return;

        args[nb_args++] = qemu_strdup("""");

    }

    if (nb_args <= 1) {

        /* command completion */

        if (nb_args == 0)

            cmdname = """";

        else

            cmdname = args[0];

        readline_set_completion_index(cur_mon->rs, strlen(cmdname));

        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {

            cmd_completion(cmdname, cmd-",2,0,7,0,0,0,0,0,0,1,0,0,0,0,0
7556,qemu,0,"static void sd_response_r1_make(SDState *sd,

                                uint8_t *response, uint32_t last_status)

{

    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;

    uint32_t status;



    status = (sd->card_status & ~mask) | (last_status & mask);

    sd->card_status &= ~CARD_STATUS_C | APP_CMD;



    response[0] = (status >> 24) & 0xff;

    response[1] = (status >> 16) & 0xff;

    response[2] = (status >> 8) & 0xff;

    response[3] = (status >> 0) & 0xff;

}
",0,0,0,0,0,0,1,1,1,0,0,1,1,1,1
7558,FFmpeg,0,"static int mpc8_decode_frame(AVCodecContext * avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    MPCContext *c = avctx->priv_data;

    GetBitContext gb2, *gb = &gb2;

    int i, j, k, ch, cnt, res, t;

    Band *bands = c->bands;

    int off;

    int maxband, keyframe;

    int last[2];



    keyframe = c->cur_frame == 0;



    if(keyframe){

        memset(c->Q, 0, sizeof(c->Q));

        c->last_bits_used = 0;

    }

    init_get_bits(gb, buf, buf_size * 8);

    skip_bits(gb, c->last_bits_used & 7);



    if(keyframe)

        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);

    else{

        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);

        if(maxband > 32) maxband -= 33;

    }

    c->last_max_band = maxband;



    /* read subband indexes */

    if(maxband){

        last[0] = last[1] = 0;

        for(i = maxband -",1,0,4,0,0,0,1,1,1,1,0,1,0,0,0
7579,qemu,0,"DeviceState *qdev_try_create(BusState *bus, const char *name)

{

    DeviceState *dev;



    if (object_class_by_name(name) == NULL) {

        return NULL;

    }

    dev = DEVICE(object_new(name));

    if (!dev) {

        return NULL;

    }



    if (!bus) {

        bus = sysbus_get_default();

    }



    qdev_set_parent_bus(dev, bus);

    qdev_prop_set_globals(dev);



    return dev;

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
7590,qemu,1,"Visitor *qobject_input_visitor_new_keyval(QObject *obj)

{

    QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);



    v->visitor.type_int64 = qobject_input_type_int64_keyval;

    v->visitor.type_uint64 = qobject_input_type_uint64_keyval;

    v->visitor.type_bool = qobject_input_type_bool_keyval;

    v->visitor.type_str = qobject_input_type_str;

    v->visitor.type_number = qobject_input_type_number_keyval;

    v->visitor.type_any = qobject_input_type_any;

    v->visitor.type_null = qobject_input_type_null;

    v->visitor.type_size = qobject_input_type_size_keyval;



    return &v->visitor;

}
",0,0,0,0,0,0,0,0,0,1,0,1,0,0,0
7596,qemu,1,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)

{

    int iomemtype;

    pl080_state *s;



    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));

    iomemtype = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */

    return s;

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
7598,FFmpeg,0,"static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table,

                                  float **plevel_table, uint16_t **pint_table,

                                  const CoefVLCTable *vlc_table)

{

    int n                        = vlc_table->n;

    const uint8_t  *table_bits   = vlc_table->huffbits;

    const uint32_t *table_codes  = vlc_table->huffcodes;

    const uint16_t *levels_table = vlc_table->levels;

    uint16_t *run_table, *level_table, *int_table;

    float *flevel_table;

    int i, l, j, k, level;



    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);



    run_table    = av_malloc(n * sizeof(uint16_t));

    level_table  = av_malloc(n * sizeof(uint16_t));

    flevel_table = av_malloc(n * sizeof(*flevel_table));

    int_table    = av_malloc(n * sizeof(uint16_t));

    i            = 2;

    level        = 1;

    k            = 0;

    while (i < n) {

        int_table[k] = i;

        l            = levels_table[k++];

        for (j = 0; j < l; j",1,0,0,0,0,1,1,0,0,0,0,1,1,1,1
7609,FFmpeg,0,"static inline int parse_nal_units(AVCodecParserContext *s,

                                  AVCodecContext *avctx,

                                  const uint8_t *buf, int buf_size)

{

    H264ParseContext *p = s->priv_data;

    const uint8_t *buf_end = buf + buf_size;



    H2645NAL nal = { NULL };



    unsigned int pps_id;

    unsigned int slice_type;

    int state = -1, got_reset = 0;

    int field_poc[2];

    int ret;



    /* set some sane default values */

    s->pict_type         = AV_PICTURE_TYPE_I;

    s->key_frame         = 0;

    s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;



    ff_h264_sei_uninit(&p->sei);



    if (!buf_size)

        return 0;



    for (;;) {

        const SPS *sps;

        int src_length, consumed;

        buf = avpriv_find_start_code(buf, buf_end, &state);

        if (buf >= buf_end)

            break;

        --buf;

        src_length = buf_end - buf;

        switch (state & 0x1f) {

        case H264_NAL_SLICE:

        case H264_NAL_IDR",1,0,2,0,1,0,1,1,1,1,1,1,0,1,0
7622,FFmpeg,1,"static av_always_inline void FUNC(intra_pred)(HEVCContext *s, int x0, int y0,

                                              int log2_size, int c_idx)

{

#define PU(x) \

    ((x) >> s->ps.sps->log2_min_pu_size)

#define MVF(x, y) \

    (s->ref->tab_mvf[(x) + (y) * min_pu_width])

#define MVF_PU(x, y) \

    MVF(PU(x0 + ((x) << hshift)), PU(y0 + ((y) << vshift)))

#define IS_INTRA(x, y) \

    (MVF_PU(x, y).pred_flag == PF_INTRA)

#define MIN_TB_ADDR_ZS(x, y) \

    s->ps.pps->min_tb_addr_zs[(y) * (s->ps.sps->tb_mask+2) + (x)]

#define EXTEND(ptr, val, len)         \

do {                                  \

    pixel4 pix = PIXEL_SPLAT_X4(val); \

    for (i = 0; i < (len); i += 4)    \

        AV_WN4P(ptr + i, pix);        \

} while (0)



#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \

        for (i = start; i < (start) + (length); i += 4)                        \

            if (!IS_INTRA(i, -1))                                              \

                AV_WN4",2,0,3,0,0,1,1,1,1,1,1,1,1,1,1
7649,FFmpeg,0,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
",0,0,0,0,0,1,0,0,0,1,1,1,0,0,0
7651,FFmpeg,0,"void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = format;

    format->next = NULL;

}
",5,0,0,0,0,1,0,0,0,0,0,0,0,0,0
7654,qemu,1,"static void decode_32Bit_opc(CPUTriCoreState *env, DisasContext *ctx)

{

    int op1;

    int32_t r1, r2, r3;

    int32_t address, const16;

    int8_t b, const4;

    int32_t bpos;

    TCGv temp, temp2, temp3;



    op1 = MASK_OP_MAJOR(ctx->opcode);



    /* handle JNZ.T opcode only being 7 bit long */

    if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) {

        op1 = OPCM_32_BRN_JTT;

    }



    switch (op1) {

/* ABS-format */

    case OPCM_32_ABS_LDW:

        decode_abs_ldw(env, ctx);


    case OPCM_32_ABS_LDB:

        decode_abs_ldb(env, ctx);


    case OPCM_32_ABS_LDMST_SWAP:

        decode_abs_ldst_swap(env, ctx);


    case OPCM_32_ABS_LDST_CONTEXT:

        decode_abs_ldst_context(env, ctx);


    case OPCM_32_ABS_STORE:

        decode_abs_store(env, ctx);


    case OPCM_32_ABS_STOREB_H:

        decode_abs_storeb_h(env, ctx);


    case OPC1_32_ABS_STOREQ:

        address = MASK_OP_ABS_OFF18(ctx->opcode);

        r1 = MASK_OP_ABS_S1D(ctx->opcode);

        temp = tcg_const_i32(EA",0,0,1,0,1,0,0,0,0,1,0,0,0,0,1
7659,FFmpeg,0,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
",1,0,1,0,0,0,1,1,1,1,1,1,0,0,0
7662,qemu,1,"void *g_realloc(void *ptr, size_t size)

{

    size_t old_size, copy;

    void *new_ptr;



    if (!ptr)

        return g_malloc(size);

    old_size = *(size_t *)((char *)ptr - 16);

    copy = old_size < size ? old_size : size;

    new_ptr = g_malloc(size);

    memcpy(new_ptr, ptr, copy);

    g_free(ptr);

    return new_ptr;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
7666,FFmpeg,1,"static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)

{

    AVStream *st;

    OutputStream *ost;

    AVCodecContext *audio_enc;



    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);

    st  = ost->st;



    audio_enc = st->codec;

    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;



    if (!ost->stream_copy) {

        char *sample_fmt = NULL;



        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);



        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);

        if (sample_fmt &&

            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {

            av_log(NULL, AV_LOG_FATAL, ""Invalid sample format '%s'\n"", sample_fmt);

            exit_program(1);

        }



        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);

    }



    return ost;

}
",1,0,2,0,0,0,0,0,0,1,1,1,1,1,1
7670,FFmpeg,1,"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
                            AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size       = avpkt->size;
    AVFrame *const p   = data;
    int compressed, xmin, ymin, xmax, ymax;
    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,
                 bytes_per_scanline;
    uint8_t *ptr;
    const uint8_t *buf_end = buf + buf_size;
    const uint8_t *bufstart = buf;
    uint8_t *scanline;
    int ret = -1;
    if (buf[0] != 0x0a || buf[1] > 5) {
        av_log(avctx, AV_LOG_ERROR, ""this is not PCX encoded data\n"");
    compressed = buf[2];
    xmin       = AV_RL16(buf + 4);
    ymin       = AV_RL16(buf + 6);
    xmax       = AV_RL16(buf + 8);
    ymax       = AV_RL16(buf + 10);
    if (xmax < xmin || ymax < ymin) {
        av_log(avctx, AV_LOG_ERROR, ""invalid image dimensions\n"");
    w = xmax - xmin + 1;
    h = ymax - ymin + 1;
    bits_per_pixel     = buf[3];
    bytes_per_line     = AV_",0,0,2,0,0,0,1,1,0,1,1,1,0,0,0
7696,qemu,1,"static void ioport_write(void *opaque, uint32_t addr, uint32_t val)

{

    PCIQXLDevice *d = opaque;

    uint32_t io_port = addr - d->io_base;



    switch (io_port) {

    case QXL_IO_RESET:

    case QXL_IO_SET_MODE:

    case QXL_IO_MEMSLOT_ADD:

    case QXL_IO_MEMSLOT_DEL:

    case QXL_IO_CREATE_PRIMARY:

        break;

    default:

        if (d->mode == QXL_MODE_NATIVE || d->mode == QXL_MODE_COMPAT)

            break;

        dprint(d, 1, ""%s: unexpected port 0x%x in vga mode\n"", __FUNCTION__, io_port);

        return;

    }



    switch (io_port) {

    case QXL_IO_UPDATE_AREA:

    {

        QXLRect update = d->ram->update_area;

        qemu_mutex_unlock_iothread();

        d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface,

                                   &update, NULL, 0, 0);

        qemu_mutex_lock_iothread();

        break;

    }

    case QXL_IO_NOTIFY_CMD:

        d->ssd.worker->wakeup(d->ssd.worker);

        break;

    case QXL_IO_NOTIFY_CURSOR:

        d",0,0,1,0,2,0,0,1,1,0,1,1,0,0,0
7716,FFmpeg,0,"static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl)

{

    const SPS *sps;

    const PPS *pps;

    unsigned int first_mb_in_slice;

    unsigned int pps_id;

    int ret;

    unsigned int slice_type, tmp, i;

    int last_pic_structure, last_pic_droppable;

    int needs_reinit = 0;

    int field_pic_flag, bottom_field_flag;

    int frame_num, droppable, picture_structure;

    int mb_aff_frame = 0;



    first_mb_in_slice = get_ue_golomb(&sl->gb);



    if (first_mb_in_slice == 0) { // FIXME better field boundary detection

        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {

            ff_h264_field_end(h, sl, 1);

        }



        h->current_slice = 0;

        if (!h->first_field) {

            if (h->cur_pic_ptr && !h->droppable) {

                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,

                                          h->picture_structure == PICT_BOTTOM_FIELD);

            }

            h->cur_pic_ptr = NULL;

        }

 ",0,0,4,0,0,0,1,0,0,0,0,1,0,0,0
7729,FFmpeg,0,"int ffurl_shutdown(URLContext *h, int flags)

{

    if (!h->prot->url_shutdown)

        return AVERROR(EINVAL);

    return h->prot->url_shutdown(h, flags);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
7732,qemu,1,"static void i82378_init(DeviceState *dev, I82378State *s)

{

    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, ""isa.0""));

    ISADevice *pit;

    qemu_irq *out0_irq;



    /* This device has:

       2 82C59 (irq)

       1 82C54 (pit)

       2 82C37 (dma)

       NMI

       Utility Bus Support Registers



       All devices accept byte access only, except timer

     */



    qdev_init_gpio_out(dev, s->out, 2);

    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);



    /* Workaround the fact that i8259 is not qdev'ified... */

    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);



    /* 2 82C59 (irq) */

    s->i8259 = i8259_init(isabus, *out0_irq);

    isa_bus_irqs(isabus, s->i8259);



    /* 1 82C54 (pit) */

    pit = pit_init(isabus, 0x40, 0, NULL);



    /* speaker */

    pcspk_init(isabus, pit);



    /* 2 82C37 (dma) */

    DMA_init(1, &s->out[1]);

    isa_create_simple(isabus, ""i82374"");



    /* timer */

    isa_create_simple(isabus, ""mc146818r",0,0,0,0,0,0,1,1,1,1,1,1,0,1,1
7749,qemu,0,"static void realview_init(ram_addr_t ram_size, int vga_ram_size,

                     const char *boot_device, DisplayState *ds,

                     const char *kernel_filename, const char *kernel_cmdline,

                     const char *initrd_filename, const char *cpu_model)

{

    CPUState *env;

    qemu_irq *pic;

    void *scsi_hba;

    PCIBus *pci_bus;

    NICInfo *nd;

    int n;

    int done_smc = 0;

    qemu_irq cpu_irq[4];

    int ncpu;

    int index;



    if (!cpu_model)

        cpu_model = ""arm926"";

    /* FIXME: obey smp_cpus.  */

    if (strcmp(cpu_model, ""arm11mpcore"") == 0) {

        ncpu = 4;

    } else {

        ncpu = 1;

    }



    for (n = 0; n < ncpu; n++) {

        env = cpu_init(cpu_model);

        if (!env) {

            fprintf(stderr, ""Unable to find CPU definition\n"");

            exit(1);

        }

        pic = arm_pic_init_cpu(env);

        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];

        if (n > 0) {

            /* Set entry point for secondary CPUs.  ",2,0,4,0,0,0,0,0,0,0,1,0,0,0,0
7754,qemu,0,"QString *qstring_from_substr(const char *str, int start, int end)

{

    QString *qstring;



    qstring = g_malloc(sizeof(*qstring));



    qstring->length = end - start + 1;

    qstring->capacity = qstring->length;



    qstring->string = g_malloc(qstring->capacity + 1);

    memcpy(qstring->string, str + start, qstring->length);

    qstring->string[qstring->length] = 0;



    QOBJECT_INIT(qstring, &qstring_type);



    return qstring;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
7761,qemu,0,"static void test_source_wait_event_notifier(void)

{

    EventNotifierTestData data = { .n = 0, .active = 1 };

    event_notifier_init(&data.e, false);

    aio_set_event_notifier(ctx, &data.e, event_ready_cb);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 0);

    g_assert_cmpint(data.active, ==, 1);



    event_notifier_set(&data.e);

    g_assert(g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);

    g_assert_cmpint(data.active, ==, 0);



    aio_set_event_notifier(ctx, &data.e, NULL);

    while (g_main_context_iteration(NULL, false));

    g_assert_cmpint(data.n, ==, 1);



    event_notifier_cleanup(&data.e);

}
",0,0,7,0,0,2,0,0,0,1,0,1,0,0,0
7762,qemu,0,"static int coroutine_fn is_allocated_base(BlockDriverState *top,

                                          BlockDriverState *base,

                                          int64_t sector_num,

                                          int nb_sectors, int *pnum)

{

    BlockDriverState *intermediate;

    int ret, n;



    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);

    if (ret) {

        *pnum = n;

        return ret;

    }



    /*

     * Is the unallocated chunk [sector_num, n] also

     * unallocated between base and top?

     */

    intermediate = top->backing_hd;



    while (intermediate != base) {

        int pnum_inter;



        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,

                                   &pnum_inter);

        if (ret < 0) {

            return ret;

        } else if (ret) {

            *pnum = pnum_inter;

            return 0;

        }



        /*

         * [sector_num, nb_sectors] is unallocated on top but intermedi",0,0,3,0,0,1,0,0,0,0,0,0,0,1,0
7766,qemu,0,"static DisplayType select_display(const char *p)

{

    Error *err = NULL;

    const char *opts;

    DisplayType display = DT_DEFAULT;



    if (strstart(p, ""sdl"", &opts)) {

#ifdef CONFIG_SDL

        display = DT_SDL;

        while (*opts) {

            const char *nextopt;



            if (strstart(opts, "",frame="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    no_frame = 0;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    no_frame = 1;

                } else {

                    goto invalid_sdl_args;

                }

            } else if (strstart(opts, "",alt_grab="", &nextopt)) {

                opts = nextopt;

                if (strstart(opts, ""on"", &nextopt)) {

                    alt_grab = 1;

                } else if (strstart(opts, ""off"", &nextopt)) {

                    alt_grab = 0;

                } else {

                    goto invalid_sdl_args;

               ",0,2,8,0,0,1,1,1,0,1,1,1,0,0,0
7777,FFmpeg,0,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
",0,0,3,0,0,0,0,0,0,1,1,0,0,0,0
7779,qemu,0,"static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)

{

    PCIDevice *p = PCI_DEVICE(s);



    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);

    cmd->frame = NULL;

    cmd->pa = 0;

    clear_bit(cmd->index, s->frame_map);

}
",0,0,0,0,0,0,1,1,1,0,1,0,0,0,0
7780,qemu,0,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,

                  int flags, int mode)

{

    int err;

    FsCred cred;



    cred_init(&cred);

    cred.fc_mode = mode & 07777;

    cred.fc_uid = fidp->uid;

    cred.fc_gid = gid;

    v9fs_co_run_in_worker(

        {

            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);

            err = 0;

            if (fidp->fs.fd == -1) {

                err = -errno;

            }

        });

    if (!err) {

        total_open_fd++;

        if (total_open_fd > open_fd_hw) {

            v9fs_reclaim_fd(s);

        }

    }

    return err;

}
",0,0,3,0,0,0,1,1,1,0,1,1,0,0,0
7782,qemu,0,"static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)

{

    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const uint8_t vlan[] = {0x81, 0x00};

    uint8_t *ptr = (uint8_t *)buf;

    int i;



    if (n->promisc)

        return 1;



    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {

        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;

        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))

            return 0;

    }



    if ((ptr[0] & 1) && n->allmulti)

        return 1;



    if (!memcmp(ptr, bcast, sizeof(bcast)))

        return 1;



    if (!memcmp(ptr, n->mac, ETH_ALEN))

        return 1;



    for (i = 0; i < n->mac_table.in_use; i++) {

        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))

            return 1;

    }



    return 0;

}
",1,0,7,0,0,0,0,0,0,0,1,1,1,1,1
7808,FFmpeg,0,"static int output_packet(InputStream *ist, int ist_index,

                         OutputStream *ost_table, int nb_ostreams,

                         const AVPacket *pkt)

{

    AVFormatContext *os;

    OutputStream *ost;

    int ret, i;

    int got_output;

    void *buffer_to_free = NULL;

    static unsigned int samples_size= 0;

    AVSubtitle subtitle, *subtitle_to_free;

    int64_t pkt_pts = AV_NOPTS_VALUE;

#if CONFIG_AVFILTER

    int frame_available;

#endif

    float quality;



    AVPacket avpkt;

    int bps = av_get_bytes_per_sample(ist->st->codec->sample_fmt);



    if(ist->next_pts == AV_NOPTS_VALUE)

        ist->next_pts= ist->pts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if(pkt->dts != AV_NOPTS_VALUE)

        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);

    if(pkt->",0,1,6,0,0,0,0,1,0,0,1,0,0,0,0
7814,qemu,0,"static void gen_tlbsx_440(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

#else

    TCGv t0;

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);

        return;

    }

    t0 = tcg_temp_new();

    gen_addr_reg_index(ctx, t0);

    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);

    tcg_temp_free(t0);

    if (Rc(ctx->opcode)) {

        int l1 = gen_new_label();

        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);

        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);

        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);

        gen_set_label(l1);

    }

#endif

}
",0,0,4,0,0,0,1,1,1,1,1,1,0,0,0
7828,qemu,0,"GSource *iohandler_get_g_source(void)

{

    iohandler_init();

    return aio_get_g_source(iohandler_ctx);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
7834,FFmpeg,0,"int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size)

{

    int i;

    uint32_t state= pc->state;



    /* EOF considered as end of frame */

    if (buf_size == 0)

        return 0;



/*

 0  frame start         -> 1/4

 1  first_SEQEXT        -> 0/2

 2  first field start   -> 3/0

 3  second_SEQEXT       -> 2/0

 4  searching end

*/



    for(i=0; i<buf_size; i++){

        assert(pc->frame_start_found>=0 && pc->frame_start_found<=4);

        if(pc->frame_start_found&1){

            if(state == EXT_START_CODE && (buf[i]&0xF0) != 0x80)

                pc->frame_start_found--;

            else if(state == EXT_START_CODE+2){

                if((buf[i]&3) == 3) pc->frame_start_found= 0;

                else                pc->frame_start_found= (pc->frame_start_found+1)&3;

            }

            state++;

        }else{

            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;

            if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE",1,0,6,0,0,0,0,0,0,0,0,0,0,0,0
7852,FFmpeg,0,"static av_cold int encode_init(AVCodecContext *avctx)

{

    FFV1Context *s = avctx->priv_data;

    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);

    int i, j, k, m, ret;



    if ((ret = ff_ffv1_common_init(avctx)) < 0)

        return ret;



    s->version = 0;



    if ((avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) ||

        avctx->slices > 1)

        s->version = FFMAX(s->version, 2);



    // Unspecified level & slices, we choose version 1.2+ to ensure multithreaded decodability

    if (avctx->slices == 0 && avctx->level < 0 && avctx->width * avctx->height > 720*576)

        s->version = FFMAX(s->version, 2);



    if (avctx->level <= 0 && s->version == 2) {

        s->version = 3;

    }

    if (avctx->level >= 0 && avctx->level <= 4) {

        if (avctx->level < s->version) {

            av_log(avctx, AV_LOG_ERROR, ""Version %d needed for requested features but %d requested\n"", s->version, avctx->level);

            return AVERROR(EINVAL);

      ",1,0,6,0,0,0,0,0,0,0,0,1,0,1,0
7854,FFmpeg,0,"static int hls_slice_data_wpp(HEVCContext *s, const HEVCNAL *nal)

{

    const uint8_t *data = nal->data;

    int length          = nal->size;

    HEVCLocalContext *lc = s->HEVClc;

    int *ret = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));

    int *arg = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));

    int64_t offset;

    int startheader, cmpt = 0;

    int i, j, res = 0;



    if (!ret || !arg) {

        av_free(ret);

        av_free(arg);

        return AVERROR(ENOMEM);

    }





    if (!s->sList[1]) {

        ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1);





        for (i = 1; i < s->threads_number; i++) {

            s->sList[i] = av_malloc(sizeof(HEVCContext));

            memcpy(s->sList[i], s, sizeof(HEVCContext));

            s->HEVClcList[i] = av_mallocz(sizeof(HEVCLocalContext));

            s->sList[i]->HEVClc = s->HEVClcList[i];

        }

    }



    offset = (lc->gb.index >> 3);



    for (j = 0, cmpt = 0, starthea",2,0,2,0,0,0,0,0,0,1,1,0,1,1,1
7866,qemu,0,"static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s,

                hwaddr addr, int *miny, int *maxy)

{

    DisplaySurface *surface = qemu_console_surface(s->con);

    int src_width, dest_width;

    drawfn fn = NULL;

    if (s->dest_width)

        fn = s->line_fn[s->transp][s->bpp];

    if (!fn)

        return;



    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */

    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)

        src_width *= 3;

    else if (s->bpp > pxa_lcdc_16bpp)

        src_width *= 4;

    else if (s->bpp > pxa_lcdc_8bpp)

        src_width *= 2;



    dest_width = s->xres * s->dest_width;

    *miny = 0;

    framebuffer_update_display(surface, s->sysmem,

                               addr, s->xres, s->yres,

                               src_width, dest_width, s->dest_width,

                               s->invalidated,

                               fn, s->dma_ch[0].palette, miny, maxy);

}
",0,0,5,0,0,0,1,1,1,1,0,1,1,1,1
7869,qemu,0,"build_dmar_q35(GArray *table_data, GArray *linker)

{

    int dmar_start = table_data->len;



    AcpiTableDmar *dmar;

    AcpiDmarHardwareUnit *drhd;



    dmar = acpi_data_push(table_data, sizeof(*dmar));

    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;

    dmar->flags = 0;    /* No intr_remap for now */



    /* DMAR Remapping Hardware Unit Definition structure */

    drhd = acpi_data_push(table_data, sizeof(*drhd));

    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);

    drhd->length = cpu_to_le16(sizeof(*drhd));   /* No device scope now */

    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;

    drhd->pci_segment = cpu_to_le16(0);

    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);



    build_header(linker, table_data, (void *)(table_data->data + dmar_start),

                 ""DMAR"", table_data->len - dmar_start, 1, NULL);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
7873,qemu,0,"static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)

{

    GtkWidget *machine_menu;

    GtkWidget *separator;



    machine_menu = gtk_menu_new();

    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);



    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(""_Pause""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);



    separator = gtk_separator_menu_item_new();

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);



    s->reset_item = gtk_menu_item_new_with_mnemonic(_(""_Reset""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);



    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(""Power _Down""));

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);



    separator = gtk_separator_menu_item_new();

    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);



    s->quit_item = gtk_menu_item_new_with_mnemonic(_(""_Quit""));

    gtk_menu_item_",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
7874,qemu,0,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,

                                     uint64_t value, unsigned size)

{

    mv88w8618_flashcfg_state *s = opaque;



    switch (offset) {

    case MP_FLASHCFG_CFGR0:

        s->cfgr0 = value;

        break;

    }

}
",0,0,0,0,1,0,1,1,1,0,1,0,1,1,1
7881,qemu,1,"static int qemu_rdma_get_fd(void *opaque)

{

    QEMUFileRDMA *rfile = opaque;

    RDMAContext *rdma = rfile->rdma;



    return rdma->comp_channel->fd;

}
",0,0,0,0,0,0,0,0,1,1,1,1,1,1,1
7882,qemu,1,"static void dump_ppc_insns (CPUPPCState *env)

{

    opc_handler_t **table, *handler;

    const char *p, *q;

    uint8_t opc1, opc2, opc3;



    printf(""Instructions set:\n"");

    /* opc1 is 6 bits long */

    for (opc1 = 0x00; opc1 < PPC_CPU_OPCODES_LEN; opc1++) {

        table = env->opcodes;

        handler = table[opc1];

        if (is_indirect_opcode(handler)) {

            /* opc2 is 5 bits long */

            for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) {

                table = env->opcodes;

                handler = env->opcodes[opc1];

                table = ind_table(handler);

                handler = table[opc2];

                if (is_indirect_opcode(handler)) {

                    table = ind_table(handler);

                    /* opc3 is 5 bits long */

                    for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN;

                            opc3++) {

                        handler = table[opc3];

                        if (handler->handler != &ge",3,0,3,0,0,0,1,1,1,1,1,1,0,0,0
7885,FFmpeg,1,"yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],

                     const int16_t *ubuf[2], const int16_t *vbuf[2],

                     const int16_t *abuf[2], uint8_t *dest, int dstW,

                     int yalpha, int uvalpha, int y,

                     enum PixelFormat target, int hasAlpha)

{

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],

                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],

                  *abuf0 = abuf[0], *abuf1 = abuf[1];

    int  yalpha1 = 4095 - yalpha;

    int uvalpha1 = 4095 - uvalpha;

    int i;



    for (i = 0; i < (dstW >> 1); i++) {

        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;

        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;

        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;

        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;

        int A1, A2;

        con",1,0,0,0,0,0,1,1,1,1,1,1,1,0,1
7892,FFmpeg,1,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
",2,0,0,0,0,0,0,0,0,1,1,0,0,0,0
7893,qemu,1,"static void fd_coroutine_enter(void *opaque)

{

    FDYieldUntilData *data = opaque;

    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);

    qemu_coroutine_enter(data->co, NULL);

}
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,1
7916,qemu,1,"static void qcow_aio_write_cb(void *opaque, int ret)

{

    QCowAIOCB *acb = opaque;

    BlockDriverState *bs = acb->common.bs;

    BDRVQcowState *s = bs->opaque;

    int index_in_cluster;

    uint64_t cluster_offset;

    const uint8_t *src_buf;

    int n_end;



    acb->hd_aiocb = NULL;



    if (ret < 0) {

    fail:

        acb->common.cb(acb->common.opaque, ret);

        qemu_aio_release(acb);

        return;

    }



    acb->nb_sectors -= acb->n;

    acb->sector_num += acb->n;

    acb->buf += acb->n * 512;



    if (acb->nb_sectors == 0) {

        /* request completed */

        acb->common.cb(acb->common.opaque, 0);

        qemu_aio_release(acb);

        return;

    }



    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);

    n_end = index_in_cluster + acb->nb_sectors;

    if (s->crypt_method &&

        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)

        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;



    cluster_offset = alloc_cluster_offset(b",0,0,3,0,0,0,0,0,0,1,0,1,1,0,0
7925,FFmpeg,0,"static int opt_input_file(const char *opt, const char *filename)

{

    AVFormatContext *ic;

    AVInputFormat *file_iformat = NULL;

    int err, i, ret, rfps, rfps_base;

    int64_t timestamp;

    uint8_t buf[128];

    AVDictionary **opts;

    int orig_nb_streams;                     // number of streams before avformat_find_stream_info



    if (last_asked_format) {

        if (!(file_iformat = av_find_input_format(last_asked_format))) {

            fprintf(stderr, ""Unknown input format: '%s'\n"", last_asked_format);

            ffmpeg_exit(1);

        }

        last_asked_format = NULL;

    }



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    using_stdin |= !strncmp(filename, ""pipe:"", 5) ||

                    !strcmp(filename, ""/dev/stdin"");



    /* get default parameters from command line */

    ic = avformat_alloc_context();

    if (!ic) {

        print_error(filename, AVERROR(ENOMEM));

        ffmpeg_exit(1);

    }

    if (audio_sample_rate) {

        snprintf",9,0,7,0,0,0,0,0,0,0,0,1,0,0,0
7936,qemu,0,"static int usb_hub_handle_control(USBDevice *dev, USBPacket *p,

               int request, int value, int index, int length, uint8_t *data)

{

    USBHubState *s = (USBHubState *)dev;

    int ret;



    ret = usb_desc_handle_control(dev, p, request, value, index, length, data);

    if (ret >= 0) {

        return ret;

    }



    switch(request) {

    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:

        if (value == 0 && index != 0x81) { /* clear ep halt */

            goto fail;

        }

        ret = 0;

        break;

    case DeviceRequest | USB_REQ_GET_INTERFACE:

        data[0] = 0;

        ret = 1;

        break;

    case DeviceOutRequest | USB_REQ_SET_INTERFACE:

        ret = 0;

        break;

        /* usb specific requests */

    case GetHubStatus:

        data[0] = 0;

        data[1] = 0;

        data[2] = 0;

        data[3] = 0;

        ret = 4;

        break;

    case GetPortStatus:

        {

            unsigned int n = index - 1;

            USBHubPort *por",0,1,2,0,1,0,0,0,0,0,0,0,0,0,0
7967,FFmpeg,0,"static int mxf_write_packet(AVFormatContext *s, AVPacket *pkt)

{

    MXFContext *mxf = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st = s->streams[pkt->stream_index];

    MXFStreamContext *sc = st->priv_data;

    MXFIndexEntry ie = {0};



    if (!mxf->edit_unit_byte_count && !(mxf->edit_units_count % EDIT_UNITS_PER_BODY)) {

        mxf->index_entries = av_realloc(mxf->index_entries,

            (mxf->edit_units_count + EDIT_UNITS_PER_BODY)*sizeof(*mxf->index_entries));

        if (!mxf->index_entries) {

            av_log(s, AV_LOG_ERROR, ""could not allocate index entries\n"");

            return -1;

        }

    }



    if (st->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO) {

        if (!mxf_parse_mpeg2_frame(s, st, pkt, &ie)) {

            av_log(s, AV_LOG_ERROR, ""could not get mpeg2 profile and level\n"");

            return -1;

        }

    }



    if (!mxf->header_written) {

        if (mxf->edit_unit_byte_count) {

            mxf_write_partition(s, 1, 2, header_open_par",0,0,6,0,0,0,0,0,0,1,0,1,0,1,0
7972,qemu,0,"int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,

                              int access_type, int mmu_idx, int is_softmmu)

{

    uint32_t phys_addr;

    target_ulong page_size;

    int prot;

    int ret, is_user;



    is_user = mmu_idx == MMU_USER_IDX;

    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,

                        &page_size);

    if (ret == 0) {

        /* Map a single [sub]page.  */

        phys_addr &= ~(uint32_t)0x3ff;

        address &= ~(uint32_t)0x3ff;

        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,

                      page_size);

        return 0;

    }



    if (access_type == 2) {

        env->cp15.c5_insn = ret;

        env->cp15.c6_insn = address;

        env->exception_index = EXCP_PREFETCH_ABORT;

    } else {

        env->cp15.c5_data = ret;

        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))

            env->cp15.c5_data |= (1 << 11);

        env->cp15.c6_data = addre",0,0,3,0,0,0,0,0,0,0,0,0,0,1,1
7977,FFmpeg,0,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){

    return h->pps.chroma_qp_table[t][qscale];

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
7980,FFmpeg,0,"static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc,

                              int plane_idx, int is_key, int is_chroma)

{

    int blk, ret;

    int i, j, bx, by;

    uint8_t *dst, *ref, *ref_start, *ref_end;

    int v, col[2];

    const uint8_t *scan;

    int xoff, yoff;

    LOCAL_ALIGNED_16(int16_t, block, [64]);

    LOCAL_ALIGNED_16(int32_t, dctblock, [64]);

    int coordmap[64];

    int ybias = is_key ? -15 : 0;

    int qp;



    const int stride = frame->linesize[plane_idx];

    int bw = is_chroma ? (c->avctx->width  + 15) >> 4 : (c->avctx->width  + 7) >> 3;

    int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3;



    binkb_init_bundles(c);

    ref_start = frame->data[plane_idx];

    ref_end   = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8;



    for (i = 0; i < 64; i++)

        coordmap[i] = (i & 7) + (i >> 3) * stride;



    for (by = 0; by < bh; by++) {

        for (i = 0; i < BINKB_NB_SRC; i",3,0,0,0,0,0,1,0,0,0,1,0,1,1,1
7982,qemu,1,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,1
7992,qemu,0,"static void term_handle_byte(int ch)

{

    switch(term_esc_state) {

    case IS_NORM:

        switch(ch) {

        case 1:

            term_bol();

            break;

        case 4:

            term_delete_char();

            break;

        case 5:

            term_eol();

            break;

        case 9:

            term_completion();

            break;

        case 10:

        case 13:

            term_cmd_buf[term_cmd_buf_size] = '\0';

	    term_hist_add(term_cmd_buf);

            term_printf(""\n"");

            term_handle_command(term_cmd_buf);

            term_show_prompt();

            break;

        case 27:

            term_esc_state = IS_ESC;

            break;

        case 127:

        case 8:

            term_backspace();

            break;

	case 155:

            term_esc_state = IS_CSI;

	    break;

        default:

            if (ch >= 32) {

                term_insert_char(ch);

            }

            break;

        }

        break;

    case IS_ESC:

",0,0,1,0,2,0,0,0,0,1,0,0,1,0,1
8010,qemu,0,"struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)

{

    struct omap_l4_s *bus = g_malloc0(

                    sizeof(*bus) + ta_num * sizeof(*bus->ta));



    bus->ta_num = ta_num;

    bus->base = base;



#ifdef L4_MUX_HACK

    omap_l4_io_entries = 1;

    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));



    omap_cpu_io_entry =

            cpu_register_io_memory(omap_l4_io_readfn,

                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);

# define L4_PAGES	(0xb4000 / TARGET_PAGE_SIZE)

    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);

    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);

#endif



    ",0,0,2,0,0,0,0,0,0,0,0,1,1,1,1
8018,qemu,0,"static void qbus_list_bus(DeviceState *dev, char *dest, int len)

{

    BusState *child;

    const char *sep = "" "";

    int pos = 0;



    pos += snprintf(dest+pos, len-pos,""child busses at \""%s\"":"",

                    dev->id ? dev->id : dev->info->name);

    LIST_FOREACH(child, &dev->child_bus, sibling) {

        pos += snprintf(dest+pos, len-pos, ""%s\""%s\"""", sep, child->name);

        sep = "", "";

    }

}
",0,0,0,0,0,0,0,0,0,0,1,0,0,1,1
8021,qemu,1,"static int read_directory(BDRVVVFATState* s, int mapping_index)

{

    mapping_t* mapping = array_get(&(s->mapping), mapping_index);

    direntry_t* direntry;

    const char* dirname = mapping->path;

    int first_cluster = mapping->begin;

    int parent_index = mapping->info.dir.parent_mapping_index;

    mapping_t* parent_mapping = (mapping_t*)

        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);

    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;



    DIR* dir=opendir(dirname);

    struct dirent* entry;

    int i;



    assert(mapping->mode & MODE_DIRECTORY);



    if(!dir) {

        mapping->end = mapping->begin;

        return -1;

    }



    i = mapping->info.dir.first_dir_index =

            first_cluster == 0 ? 0 : s->directory.next;



    if (first_cluster != 0) {

        /* create the top entries of a subdirectory */

        (void)create_short_and_long_name(s, i, ""."", 1);

        (void)create_short_and_long_name(s, i, "".."", 1);",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
8046,FFmpeg,0,"static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)

{

    const char *p;

    char *q, buf1[20], c;

    int nd, len, addchar_count;

    int found_count = 0;



    q = buf;

    p = filename;

    for (;;) {

        c = *p;

        if (c == '\0')

            break;

        if (c == '%' && *(p+1) == '%')  // %%

            addchar_count = 2;

        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {

            nd = 0;

            addchar_count = 1;

            while (av_isdigit(*(p + addchar_count))) {

                nd = nd * 10 + *(p + addchar_count) - '0';

                addchar_count++;

            }



            if (*(p + addchar_count) == placeholder) {

                len = snprintf(buf1, sizeof(buf1), ""%0*""PRId64, (number < 0) ? nd : nd++, number);

                if (len < 1)  // returned error or empty buf1

                    goto fail;

                if ((q - buf + len) > buf_size - 1)
",1,1,6,0,0,1,0,0,0,0,0,0,1,1,1
8049,qemu,0,"static void cubieboard_init(QEMUMachineInitArgs *args)

{

    CubieBoardState *s = g_new(CubieBoardState, 1);

    Error *err = NULL;



    s->a10 = AW_A10(object_new(TYPE_AW_A10));

    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);

    if (err != NULL) {

        error_report(""Couldn't realize Allwinner A10: %s\n"",

                error_get_pretty(err));

        exit(1);

    }



    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);

    vmstate_register_ram_global(&s->sdram);

    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,

                                &s->sdram);



    cubieboard_binfo.ram_size = args->ram_size;

    cubieboard_binfo.kernel_filename = args->kernel_filename;

    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;

    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
8071,qemu,0,"void esp_init(target_phys_addr_t espaddr, int it_shift,

              ESPDMAMemoryReadWriteFunc dma_memory_read,

              ESPDMAMemoryReadWriteFunc dma_memory_write,

              void *dma_opaque, qemu_irq irq, qemu_irq *reset,

              qemu_irq *dma_enable)

{

    DeviceState *dev;

    SysBusDevice *s;

    SysBusESPState *sysbus;

    ESPState *esp;



    dev = qdev_create(NULL, ""esp"");

    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);

    esp = &sysbus->esp;

    esp->dma_memory_read = dma_memory_read;

    esp->dma_memory_write = dma_memory_write;

    esp->dma_opaque = dma_opaque;

    sysbus->it_shift = it_shift;

    /* XXX for now until rc4030 has been changed to use DMA enable signal */

    esp->dma_enabled = 1;

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, espaddr);

    *reset = qdev_get_gpio_in(dev, 0);

    *dma_enable = qdev_get_gpio_in(dev, 1);

}
",0,0,3,0,0,0,0,0,0,0,1,0,0,0,0
8085,FFmpeg,0,"static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)

{

    WMACodecContext *s = avctx->priv_data;

    float **audio      = (float **) frame->extended_data;

    int len            = frame->nb_samples;

    int window_index   = s->frame_len_bits - s->block_len_bits;

    FFTContext *mdct   = &s->mdct_ctx[window_index];

    int ch;

    const float *win   = s->windows[window_index];

    int window_len     = 1 << s->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (ch = 0; ch < avctx->channels; ch++) {

        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));

        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);

        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],

                                    win, len);

        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);

        mdct->mdct_calc(mdct, s->coefs[ch], s->output);

    }

}
",1,0,0,0,0,0,0,0,0,0,0,0,1,0,1
8103,FFmpeg,1,"static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,

                                const uint8_t *s2, int stride)

{

    int i;

    vec_u8 perm1 = vec_lvsl(0, s1);

    vec_u8 perm2 = vec_lvsl(0, s2);

    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);

    vec_s16 shorts1, shorts2;



    for (i = 0; i < 4; i++) {

        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        vec_u8 pixl  = vec_ld(0,  s1);

        vec_u8 pixr  = vec_ld(15, s1);

        vec_u8 bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do t",1,0,1,0,0,0,0,0,0,0,1,0,0,0,0
8105,FFmpeg,1,"int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)

{

    PerThreadContext *p = avctx->thread_opaque;

    int *progress, err;



    f->owner = avctx;



    ff_init_buffer_info(avctx, f);



    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {

        f->thread_opaque = NULL;

        return avctx->get_buffer(avctx, f);

    }



    if (p->state != STATE_SETTING_UP &&

        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&

                avctx->get_buffer != avcodec_default_get_buffer))) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() cannot be called after ff_thread_finish_setup()\n"");

        return -1;

    }



    pthread_mutex_lock(&p->parent->buffer_mutex);

    f->thread_opaque = progress = allocate_progress(p);



    if (!progress) {

        pthread_mutex_unlock(&p->parent->buffer_mutex);

        return -1;

    }



    progress[0] =

    progress[1] = -1;



    if (avctx->thread_safe_callbacks ||

        avctx->get_buffer == avcodec_default_g",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
8111,qemu,1,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}",0,0,1,0,0,0,1,0,0,1,1,1,0,0,0
8112,FFmpeg,0,"static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}
",4,0,5,0,0,0,0,0,0,1,1,0,1,1,1
8124,FFmpeg,1,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
8130,qemu,1,"static void device_unparent(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    BusState *bus;



    if (dev->realized) {

        object_property_set_bool(obj, false, ""realized"", NULL);

    }

    while (dev->num_child_bus) {

        bus = QLIST_FIRST(&dev->child_bus);

        object_unparent(OBJECT(bus));

    }

    if (dev->parent_bus) {

        bus_remove_child(dev->parent_bus, dev);

        object_unref(OBJECT(dev->parent_bus));

        dev->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (dev->pending_deleted_event) {

        g_assert(dev->canonical_path);



        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,

                                       &error_abort);

        g_free(dev->canonical_path);

        dev->canonical_path = NULL;

    }

}
",0,0,3,0,0,1,0,0,0,1,0,0,1,1,0
8134,qemu,0,"QBool *qbool_from_bool(bool value)

{

    QBool *qb;



    qb = g_malloc(sizeof(*qb));

    qb->value = value;

    QOBJECT_INIT(qb, &qbool_type);



    return qb;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
8145,qemu,0,"static void setup_rt_frame(int usig, struct emulated_sigaction *ka, 

                           target_siginfo_t *info,

			   target_sigset_t *set, CPUState *env)

{

	struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));

	int err = 0;



#if 0

	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))

            return 1;

#endif

	__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);

	__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);

	err |= copy_siginfo_to_user(&frame->info, info);



	/* Clear all the bits of the ucontext we don't use.  */

	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));



	err |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/

				env, set->sig[0]);

	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));



	if (err == 0)

		err = setup_return(env, ka, &frame->retcode, frame, usig);



	if (err == 0) {

		/*

		 * For realtime signals we must also set the second and third

		 * arguments for",1,0,5,0,0,0,0,0,0,1,0,0,0,0,0
8154,qemu,1,"static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index,

                                uint64_t *buid, hwaddr *pio,

                                hwaddr *mmio32, hwaddr *mmio64,

                                unsigned n_dma, uint32_t *liobns, Error **errp)

{

    /*

     * New-style PHB window placement.

     *

     * Goals: Gives large (1TiB), naturally aligned 64-bit MMIO window

     * for each PHB, in addition to 2GiB 32-bit MMIO and 64kiB PIO

     * windows.

     *

     * Some guest kernels can't work with MMIO windows above 1<<46

     * (64TiB), so we place up to 31 PHBs in the area 32TiB..64TiB

     *

     * 32TiB..(33TiB+1984kiB) contains the 64kiB PIO windows for each

     * PHB stacked together.  (32TiB+2GiB)..(32TiB+64GiB) contains the

     * 2GiB 32-bit MMIO windows for each PHB.  Then 33..64TiB has the

     * 1TiB 64-bit MMIO windows for each PHB.

     */

    const uint64_t base_buid = 0x800000020000000ULL;

    const int max_phbs =

        (SPAPR_PCI_LIMI",4,0,0,0,0,0,0,1,0,1,1,1,0,1,1
8155,qemu,1,"static void ppc405ep_compute_clocks (ppc405ep_cpc_t *cpc)

{

    uint32_t CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk;

    uint32_t UART0_clk, UART1_clk;

    uint64_t VCO_out, PLL_out;

    int M, D;



    VCO_out = 0;

    if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) {

        M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; /* FBMUL */

#ifdef DEBUG_CLOCKS_LL

        printf(""FBMUL %01"" PRIx32 "" %d\n"", (cpc->pllmr[1] >> 20) & 0xF, M);

#endif

        D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); /* FWDA */

#ifdef DEBUG_CLOCKS_LL

        printf(""FWDA %01"" PRIx32 "" %d\n"", (cpc->pllmr[1] >> 16) & 0x7, D);

#endif

        VCO_out = cpc->sysclk * M * D;

        if (VCO_out < 500000000UL || VCO_out > 1000000000UL) {

            /* Error - unlock the PLL */

            printf(""VCO out of range %"" PRIu64 ""\n"", VCO_out);

#if 0

            cpc->pllmr[1] &= ~0x80000000;

            goto pll_bypass;

#endif

        }

        PLL_out = VCO_out / D;

        /* Pretend the PLL is lock",0,1,8,0,0,0,1,0,0,0,0,1,1,1,1
8157,FFmpeg,1,"av_cold void ff_wmv2_common_init(Wmv2Context * w){

    MpegEncContext * const s= &w->s;



    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);

    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
8158,qemu,1,"void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));",0,0,7,0,0,0,0,1,0,0,0,0,0,0,0
8169,FFmpeg,1,"void ff_mpeg1_encode_init(MpegEncContext *s)

{

    static int done=0;



    common_init(s);



    if(!done){

        int f_code;

        int mv;

	int i;



        done=1;

        init_rl(&rl_mpeg1);



	for(i=0; i<64; i++)

	{

		mpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i];

		mpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i];

	}

        

        init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len);



	/* build unified dc encoding tables */

	for(i=-255; i<256; i++)

	{

		int adiff, index;

		int bits, code;

		int diff=i;



		adiff = ABS(diff);

		if(diff<0) diff--;

		index = av_log2(2*adiff);



		bits= vlc_dc_lum_bits[index] + index;

		code= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1));

		mpeg1_lum_dc_uni[i+255]= bits + (code<<8);

		

		bits= vlc_dc_chroma_bits[index] + index;

		code= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1));

		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);

	}



        mv_penalty= av_mallocz( sizeof(uint8_t)*",2,0,11,0,0,0,1,1,0,1,1,1,1,0,1
8171,FFmpeg,1,"static av_cold int ac3_decode_init(AVCodecContext *avctx)

{

    AC3DecodeContext *s = avctx->priv_data;

    s->avctx = avctx;



    ff_ac3_common_init();

    ac3_tables_init();

    ff_mdct_init(&s->imdct_256, 8, 1, 1.0);

    ff_mdct_init(&s->imdct_512, 9, 1, 1.0);

    ff_kbd_window_init(s->window, 5.0, 256);

    dsputil_init(&s->dsp, avctx);

    ff_fmt_convert_init(&s->fmt_conv, avctx);

    av_lfg_init(&s->dith_state, 0);



    /* set scale value for float to int16 conversion */

    s->mul_bias = 32767.0f;



    /* allow downmixing to stereo or mono */

    if (avctx->channels > 0 && avctx->request_channels > 0 &&

            avctx->request_channels < avctx->channels &&

            avctx->request_channels <= 2) {

        avctx->channels = avctx->request_channels;

    }

    s->downmixed = 1;



    /* allocate context input buffer */

    if (avctx->error_recognition >= FF_ER_CAREFUL) {

        s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

        if (",0,0,3,0,0,0,1,1,0,1,1,1,1,1,0
8181,FFmpeg,0,"static void count_frame_bits_fixed(AC3EncodeContext *s)

{

    static const int frame_bits_inc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 };

    int blk;

    int frame_bits;



    /* assumptions:

     *   no dynamic range codes

     *   bit allocation parameters do not change between blocks

     *   no delta bit allocation

     *   no skipped data

     *   no auxilliary data

     *   no E-AC-3 metadata

     */



    /* header */

    frame_bits = 16; /* sync info */

    if (s->eac3) {

        /* bitstream info header */

        frame_bits += 35;

        frame_bits += 1 + 1 + 1;

        /* audio frame header */

        frame_bits += 2;

        frame_bits += 10;

        /* exponent strategy */

        for (blk = 0; blk < AC3_MAX_BLOCKS; blk++)

            frame_bits += 2 * s->fbw_channels + s->lfe_on;

        /* converter exponent strategy */

        frame_bits += s->fbw_channels * 5;

        /* snr offsets */

        frame_bits += 10;

        /* block start info */

        frame_bits++;

    } e",1,0,1,0,0,0,0,0,0,1,0,0,1,0,0
8197,FFmpeg,0,"static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]];

        tc[1] = tc0_table[index_a][bS[1]];

        tc[2] = tc0_table[index_a][bS[2]];

        tc[3] = tc0_table[index_a][bS[3]];

        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);

    }

}
",0,0,2,0,0,0,0,1,0,1,0,0,1,1,1
8199,FFmpeg,0,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,

                         int *frame_size_ptr,

                         uint8_t *buf, int buf_size)

{

    int ret;



    *frame_size_ptr= 0;

    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){

        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,

                                buf, buf_size);

        avctx->frame_number++;

    }else

        ret= 0;

    return ret;

}
",0,0,1,0,0,0,1,1,1,1,0,1,1,1,0
8208,FFmpeg,1,"void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,

                    int mb_x, int mb_y, int layout)

{

    VP8Macroblock *mb_edge[3] = { 0      /* top */,

                                  mb - 1 /* left */,

                                  0      /* top-left */ };

    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };

    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };

    int idx = CNT_ZERO;

    int cur_sign_bias = s->sign_bias[mb->ref_frame];

    int8_t *sign_bias = s->sign_bias;

    VP56mv near_mv[4];

    uint8_t cnt[4] = { 0 };

    VP56RangeCoder *c = &s->c;



    if (!layout) { // layout is inlined (s->mb_layout is not)

        mb_edge[0] = mb + 2;

        mb_edge[2] = mb + 1;

    } else {

        mb_edge[0] = mb - s->mb_width - 1;

        mb_edge[2] = mb - s->mb_width - 2;

    }



    AV_ZERO32(&near_mv[0]);

    AV_ZERO32(&near_mv[1]);

    AV_ZERO32(&near_mv[2]);



    /* Process MB on top, left and top-left */

#define MV_EDGE_CHECK(n)                         ",0,0,1,0,0,0,0,0,0,1,0,0,0,0,0
8209,qemu,1,"int main()

{

    int rd, rt, dsp;

    int result, resultdsp;



    rt        = 0x12345678;

    result    = 0xA000C000;

    resultdsp = 1;



    __asm

        (""shll.ph %0, %2, 0x0B\n\t""

         ""rddsp %1\n\t""

         : ""=r""(rd), ""=r""(dsp)

         : ""r""(rt)

        );

    dsp = (dsp >> 22) & 0x01;

    assert(dsp == resultdsp);

    assert(rd  == result);



    return 0;

}
",0,0,0,0,0,0,1,1,1,1,1,0,1,1,1
8211,FFmpeg,0,"int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)

{

    int count, x;

    uint8_t *out;



    out = outbuf;





        for(x = 0; x < w; x += count) {

            /* see if we can encode the next set of pixels with RLE */

            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {

                if(out + bpp + 1 > outbuf + out_size) return -1;

                *out++ = (count ^ xor) + add;

                memcpy(out, ptr, bpp);

                out += bpp;

            } else {

                /* fall back on uncompressed */

                count = count_pixels(ptr, w-x, bpp, 0);

                *out++ = count - 1;



                if(out + bpp*count > outbuf + out_size) return -1;

                memcpy(out, ptr, bpp * count);

                out += bpp * count;

        }



        ptr += count * bpp;

    }



    return out - outbuf;

}
",1,0,3,0,0,0,1,1,1,1,1,1,1,1,1
8217,FFmpeg,1,"static int vdpau_frames_init(AVHWFramesContext *ctx)

{

    VDPAUDeviceContext *device_priv = ctx->device_ctx->internal->priv;

    VDPAUFramesContext        *priv = ctx->internal->priv;



    int i;



    switch (ctx->sw_format) {

    case AV_PIX_FMT_YUV420P: priv->chroma_type = VDP_CHROMA_TYPE_420; break;

    case AV_PIX_FMT_YUV422P: priv->chroma_type = VDP_CHROMA_TYPE_422; break;

    case AV_PIX_FMT_YUV444P: priv->chroma_type = VDP_CHROMA_TYPE_444; break;

    default:

        av_log(ctx, AV_LOG_ERROR, ""Unsupported data layout: %s\n"",

               av_get_pix_fmt_name(ctx->sw_format));

        return AVERROR(ENOSYS);

    }



    for (i = 0; i < FF_ARRAY_ELEMS(vdpau_pix_fmts); i++) {

        if (vdpau_pix_fmts[i].chroma_type == priv->chroma_type) {

            priv->chroma_idx  = i;

            priv->pix_fmts    = device_priv->pix_fmts[i];

            priv->nb_pix_fmts = device_priv->nb_pix_fmts[i];

            break;

        }

    }

    if (!priv->pix_fmts) {

        av_log(ctx, AV_LOG",3,0,2,0,1,0,1,0,1,0,0,0,0,0,0
8221,qemu,1,"int vm_stop(RunState state)

{

    if (qemu_in_vcpu_thread()) {


        qemu_system_vmstop_request(state);

        /*

         * FIXME: should not return to device code in case

         * vm_stop() has been requested.

         */

        cpu_stop_current();

        return 0;

    }



    return do_vm_stop(state);

}",0,0,1,0,0,0,1,0,0,1,0,0,1,0,1
8241,FFmpeg,0,"static int dca_decode_frame(AVCodecContext *avctx, void *data,

                            int *got_frame_ptr, AVPacket *avpkt)

{

    AVFrame *frame     = data;

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;



    int lfe_samples;

    int num_core_channels = 0;

    int i, ret;

    float  **samples_flt;

    DCAContext *s = avctx->priv_data;

    int channels, full_channels;

    int core_ss_end;





    s->xch_present = 0;



    s->dca_buffer_size = ff_dca_convert_bitstream(buf, buf_size, s->dca_buffer,

                                                  DCA_MAX_FRAME_SIZE + DCA_MAX_EXSS_HEADER_SIZE);

    if (s->dca_buffer_size == AVERROR_INVALIDDATA) {

        av_log(avctx, AV_LOG_ERROR, ""Not a valid DCA frame\n"");

        return AVERROR_INVALIDDATA;

    }



    init_get_bits(&s->gb, s->dca_buffer, s->dca_buffer_size * 8);

    if ((ret = dca_parse_frame_header(s)) < 0) {

        //seems like the frame is corrupt, try with the next one

        return ret;

    }

    /",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
8247,qemu,0,"static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])

{

    S390CPU *cpu = s390_env_get_cpu(env);

    const unsigned long *features = cpu->model->features;

    unsigned max_bit = 0;

    S390Feat feat;



    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);



    if (test_bit(S390_FEAT_ZARCH, features)) {

        /* z/Architecture is always active if around */

        words[0] = 1ull << (63 - 2);

    }



    for (feat = find_first_bit(features, S390_FEAT_MAX);

         feat < S390_FEAT_MAX;

         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {

        const S390FeatDef *def = s390_feat_def(feat);

        if (def->type == S390_FEAT_TYPE_STFL) {

            unsigned bit = def->bit;

            if (bit > max_bit) {

                max_bit = bit;

            }

            assert(bit / 64 < MAX_STFL_WORDS);

            words[bit / 64] |= 1ULL << (63 - bit % 64);

        }

    }



    return max_bit / 64;

}
",1,0,3,0,0,0,1,1,1,1,1,1,0,0,0
8254,qemu,0,"static int nbd_establish_connection(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;

    int sock;

    int ret;

    off_t size;

    size_t blocksize;



    if (s->host_spec[0] == '/') {

        sock = unix_socket_outgoing(s->host_spec);

    } else {

        sock = tcp_socket_outgoing_spec(s->host_spec);

    }



    /* Failed to establish connection */

    if (sock < 0) {

        logout(""Failed to establish connection to NBD server\n"");

        return -errno;

    }



    /* NBD handshake */

    ret = nbd_receive_negotiate(sock, s->export_name, &s->nbdflags, &size,

                                &blocksize);

    if (ret < 0) {

        logout(""Failed to negotiate with the NBD server\n"");

        closesocket(sock);

        return -errno;

    }



    /* Now that we're connected, set the socket to be non-blocking and

     * kick the reply mechanism.  */

    socket_set_nonblock(sock);

    qemu_aio_set_fd_handler(s->sock, nbd_reply_ready, NULL,

                            nbd_ha",0,0,3,0,0,0,0,1,0,1,0,0,1,1,1
8271,FFmpeg,0,"static av_cold int vc2_encode_init(AVCodecContext *avctx)

{

    Plane *p;

    SubBand *b;

    int i, j, level, o, shift;

    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);

    const int depth = fmt->comp[0].depth;

    VC2EncContext *s = avctx->priv_data;



    s->picture_number = 0;



    /* Total allowed quantization range */

    s->q_ceil    = DIRAC_MAX_QUANT_INDEX;



    s->ver.major = 2;

    s->ver.minor = 0;

    s->profile   = 3;

    s->level     = 3;



    s->base_vf   = -1;

    s->strict_compliance = 1;



    s->q_avg = 0;

    s->slice_max_bytes = 0;

    s->slice_min_bytes = 0;



    /* Mark unknown as progressive */

    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||

                      (avctx->field_order == AV_FIELD_PROGRESSIVE));



    for (i = 0; i < base_video_fmts_len; i++) {

        const VC2BaseVideoFormat *fmt = &base_video_fmts[i];

        if (avctx->pix_fmt != fmt->pix_fmt)

            continue;

        if (avctx->time_base.nu",1,0,3,0,0,0,0,0,0,0,0,0,0,0,0
8273,FFmpeg,0,"void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type)

{

    int y;

    uint8_t * fcode_tab= s->fcode_tab;



    // RAL: 8 in MPEG-1, 16 in MPEG-4

    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);



    /* clip / convert to intra 16x16 type MVs */

    for(y=0; y<s->mb_height; y++){

        int x;

        int xy= (y+1)* (s->mb_width+2)+1;

        int i= y*s->mb_width;

        for(x=0; x<s->mb_width; x++)

            {

            if (s->mb_type[i] & type)    // RAL: ""type"" test added...

                {

                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0)

                    {

                    if(mv_table[xy][0]>0) 

                        mv_table[xy][0]=  range-1;

                    else

                        mv_table[xy][0]= -range;

                    }

                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0)
",2,0,4,0,0,0,0,1,0,0,0,0,1,1,1
8291,qemu,0,"S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)

{

    S390CPU *cpu;

    Error *err = NULL;



    cpu = cpu_s390x_create(cpu_model, &err);

    if (err != NULL) {

        goto out;

    }



    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);

    if (err != NULL) {

        goto out;

    }

    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);



out:

    if (err) {

        error_propagate(errp, err);

        object_unref(OBJECT(cpu));

        cpu = NULL;

    }

    return cpu;

}
",0,2,3,0,0,0,0,0,0,0,0,0,0,0,0
8296,qemu,0,"aio_compute_timeout(AioContext *ctx)

{

    int64_t deadline;

    int timeout = -1;

    QEMUBH *bh;



    for (bh = atomic_rcu_read(&ctx->first_bh); bh;

         bh = atomic_rcu_read(&bh->next)) {

        if (bh->scheduled) {

            if (bh->idle) {

                /* idle bottom halves will be polled at least

                 * every 10ms */

                timeout = 10000000;

            } else {

                /* non-idle bottom halves will be executed

                 * immediately */

                return 0;

            }

        }

    }



    deadline = timerlistgroup_deadline_ns(&ctx->tlg);

    if (deadline == 0) {

        return 0;

    } else {

        return qemu_soonest_timeout(timeout, deadline);

    }

}
",1,0,3,0,0,0,0,0,0,0,0,0,0,1,0
8313,FFmpeg,0,"static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)

{

    int n=0, x, y, i;



    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));



    /* Map to the ROQ quadtree order */

    for (y=0; y<enc->height; y+=16)

        for (x=0; x<enc->width; x+=16)

            for(i=0; i<4; i++) {

                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;

                tempData->cel_evals[n++].sourceY = y + (i&2)*4;

            }

}
",3,0,0,0,0,0,1,1,0,1,1,0,1,1,1
8340,FFmpeg,0,"static int ea_read_packet(AVFormatContext *s,

                          AVPacket *pkt)

{

    EaDemuxContext *ea = s->priv_data;

    AVIOContext *pb = s->pb;

    int ret = 0;

    int packet_read = 0;

    unsigned int chunk_type, chunk_size;

    int key = 0;

    int av_uninit(num_samples);



    while (!packet_read) {

        chunk_type = avio_rl32(pb);

        chunk_size = (ea->big_endian ? avio_rb32(pb) : avio_rl32(pb)) - 8;



        switch (chunk_type) {

        /* audio data */

        case ISNh_TAG:

            /* header chunk also contains data; skip over the header portion*/

            avio_skip(pb, 32);

            chunk_size -= 32;

        case ISNd_TAG:

        case SCDl_TAG:

        case SNDC_TAG:

        case SDEN_TAG:

            if (!ea->audio_codec) {

                avio_skip(pb, chunk_size);

                break;

            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||

                       ea->audio_codec == CODEC_ID_MP3) {

                num_samp",0,0,2,0,1,1,0,0,0,0,0,0,0,0,0
8357,qemu,1,"static void type_initialize_interface(TypeImpl *ti, const char *parent)

{

    InterfaceClass *new_iface;

    TypeInfo info = { };

    TypeImpl *iface_impl;



    info.parent = parent;

    info.name = g_strdup_printf(""%s::%s"", ti->name, info.parent);

    info.abstract = true;



    iface_impl = type_register(&info);

    type_initialize(iface_impl);

    g_free((char *)info.name);



    new_iface = (InterfaceClass *)iface_impl->class;

    new_iface->concrete_class = ti->class;



    ti->class->interfaces = g_slist_append(ti->class->interfaces,

                                           iface_impl->class);

}
",0,0,8,0,0,0,0,0,0,1,1,0,1,1,1
8370,FFmpeg,0,"static int video_open(VideoState *is){

    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;

    int w,h;



    if(is_full_screen) flags |= SDL_FULLSCREEN;

    else               flags |= SDL_RESIZABLE;



    if (is_full_screen && fs_screen_width) {

        w = fs_screen_width;

        h = fs_screen_height;

    } else if(!is_full_screen && screen_width){

        w = screen_width;

        h = screen_height;

    }else if (is->video_st && is->video_st->codec->width){

        w = is->video_st->codec->width;

        h = is->video_st->codec->height;

    } else {

        w = 640;

        h = 480;

    }

#ifndef SYS_DARWIN

    screen = SDL_SetVideoMode(w, h, 0, flags);

#else

    /* setting bits_per_pixel = 0 or 32 causes blank video on OS X */

    screen = SDL_SetVideoMode(w, h, 24, flags);

#endif

    if (!screen) {

        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");

        return -1;

    }

    SDL_WM_SetCaption(""FFplay"", ""FFplay"");



    is->width = screen->w;

    i",0,0,7,0,0,0,0,0,0,0,0,0,0,0,0
8380,qemu,0,"static uint64_t nand_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    struct nand_state_t *s = opaque;

    uint32_t r;

    int rdy;



    r = nand_getio(s->nand);

    nand_getpins(s->nand, &rdy);

    s->rdy = rdy;



    DNAND(printf(""%s addr=%x r=%x\n"", __func__, addr, r));

    return r;

}
",0,0,0,0,0,0,0,0,0,1,0,1,0,1,0
8409,qemu,0,"void qmp_migrate_set_speed(int64_t value, Error **errp)

{

    MigrationState *s;



    if (value < 0) {

        value = 0;

    }



    s = migrate_get_current();

    s->bandwidth_limit = value;

    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,1
8412,qemu,1,"void block_job_resume_all(void)

{

    BlockJob *job = NULL;

    while ((job = block_job_next(job))) {

        AioContext *aio_context = blk_get_aio_context(job->blk);



        aio_context_acquire(aio_context);

        block_job_resume(job);

        aio_context_release(aio_context);

    }

}
",0,0,0,0,0,1,1,1,1,1,1,1,1,1,1
8425,FFmpeg,0,"static int write_option(void *optctx, const OptionDef *po, const char *opt,

                        const char *arg)

{

    /* new-style options contain an offset into optctx, old-style address of

     * a global var*/

    void *dst = po->flags & (OPT_OFFSET | OPT_SPEC) ?

                (uint8_t *)optctx + po->u.off : po->u.dst_ptr;

    int *dstcount;



    if (po->flags & OPT_SPEC) {

        SpecifierOpt **so = dst;

        char *p = strchr(opt, ':');



        dstcount = (int *)(so + 1);

        *so = grow_array(*so, sizeof(**so), dstcount, *dstcount + 1);

        (*so)[*dstcount - 1].specifier = av_strdup(p ? p + 1 : """");

        dst = &(*so)[*dstcount - 1].u;

    }



    if (po->flags & OPT_STRING) {

        char *str;

        str = av_strdup(arg);

        av_freep(dst);

        *(char **)dst = str;

    } else if (po->flags & OPT_BOOL || po->flags & OPT_INT) {

        *(int *)dst = parse_number_or_die(opt, arg, OPT_INT64, INT_MIN, INT_MAX);

    } else if (po->flags & OPT_INT64) {

 ",0,0,6,0,0,0,1,1,1,1,1,1,0,0,0
8431,qemu,1,"static void put_uint8(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *v = pv;

    qemu_put_8s(f, v);

}
",0,0,0,0,0,0,1,1,1,0,1,0,1,1,1
8435,qemu,1,"static RemoveResult remove_hpte(PowerPCCPU *cpu, target_ulong ptex,

                                target_ulong avpn,

                                target_ulong flags,

                                target_ulong *vp, target_ulong *rp)

{

    CPUPPCState *env = &cpu->env;

    uint64_t token;

    target_ulong v, r, rb;



    if (!valid_pte_index(env, ptex)) {

        return REMOVE_PARM;

    }



    token = ppc_hash64_start_access(cpu, ptex);

    v = ppc_hash64_load_hpte0(cpu, token, 0);

    r = ppc_hash64_load_hpte1(cpu, token, 0);

    ppc_hash64_stop_access(token);



    if ((v & HPTE64_V_VALID) == 0 ||

        ((flags & H_AVPN) && (v & ~0x7fULL) != avpn) ||

        ((flags & H_ANDCOND) && (v & avpn) != 0)) {

        return REMOVE_NOT_FOUND;

    }

    *vp = v;

    *rp = r;

    ppc_hash64_store_hpte(cpu, ptex, HPTE64_V_HPTE_DIRTY, 0);

    rb = compute_tlbie_rb(v, r, ptex);

    ppc_tlb_invalidate_one(env, rb);

    return REMOVE_SUCCESS;

}
",0,0,2,0,0,0,0,0,1,0,0,0,0,0,0
8447,qemu,1,"int pcie_aer_init(PCIDevice *dev, uint16_t offset, uint16_t size)

{

    PCIExpressDevice *exp;



    pcie_add_capability(dev, PCI_EXT_CAP_ID_ERR, PCI_ERR_VER,

                        offset, size);

    exp = &dev->exp;

    exp->aer_cap = offset;



    /* log_max is property */

    if (dev->exp.aer_log.log_max == PCIE_AER_LOG_MAX_UNSET) {

        dev->exp.aer_log.log_max = PCIE_AER_LOG_MAX_DEFAULT;

    }

    /* clip down the value to avoid unreasobale memory usage */

    if (dev->exp.aer_log.log_max > PCIE_AER_LOG_MAX_LIMIT) {

        return -EINVAL;

    }

    dev->exp.aer_log.log = g_malloc0(sizeof dev->exp.aer_log.log[0] *

                                        dev->exp.aer_log.log_max);



    pci_set_long(dev->w1cmask + offset + PCI_ERR_UNCOR_STATUS,

                 PCI_ERR_UNC_SUPPORTED);



    pci_set_long(dev->config + offset + PCI_ERR_UNCOR_SEVER,

                 PCI_ERR_UNC_SEVERITY_DEFAULT);

    pci_set_long(dev->wmask + offset + PCI_ERR_UNCOR_SEVER,

                 PCI_ERR_U",0,0,2,0,0,0,0,0,0,1,0,0,0,0,0
8457,qemu,1,"static void qemu_tcg_init_vcpu(CPUState *cpu)

{

    char thread_name[VCPU_THREAD_NAME_SIZE];

    static QemuCond *tcg_halt_cond;

    static QemuThread *tcg_cpu_thread;



    /* share a single thread for all cpus with TCG */

    if (!tcg_cpu_thread) {

        cpu->thread = g_malloc0(sizeof(QemuThread));

        cpu->halt_cond = g_malloc0(sizeof(QemuCond));

        qemu_cond_init(cpu->halt_cond);

        tcg_halt_cond = cpu->halt_cond;

        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",

                 cpu->cpu_index);

        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,

                           cpu, QEMU_THREAD_JOINABLE);

#ifdef _WIN32

        cpu->hThread = qemu_thread_get_handle(cpu->thread);

#endif

        while (!cpu->created) {

            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);

        }

        tcg_cpu_thread = cpu->thread;

    } else {

        cpu->thread = tcg_cpu_thread;

        cpu->halt_cond = tcg_halt_cond;

    }

}
",0,0,3,0,0,1,0,0,0,1,0,0,0,0,1
8466,qemu,1,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
",0,0,5,0,0,0,1,1,1,0,0,0,0,0,0
8482,FFmpeg,0,"static av_cold int decode_init(AVCodecContext * avctx)

{

    MPADecodeContext *s = avctx->priv_data;

    static int init=0;

    int i, j, k;



    s->avctx = avctx;



    ff_mpadsp_init(&s->mpadsp);



    avctx->sample_fmt= OUT_FMT;

    s->error_recognition= avctx->error_recognition;



    if (!init && !avctx->parse_only) {

        int offset;



        /* scale factors table for layer 1/2 */

        for(i=0;i<64;i++) {

            int shift, mod;

            /* 1.0 (i = 3) is normalized to 2 ^ FRAC_BITS */

            shift = (i / 3);

            mod = i % 3;

            scale_factor_modshift[i] = mod | (shift << 2);

        }



        /* scale factor multiply for layer 1 */

        for(i=0;i<15;i++) {

            int n, norm;

            n = i + 2;

            norm = ((INT64_C(1) << n) * FRAC_ONE) / ((1 << n) - 1);

            scale_factor_mult[i][0] = MULLx(norm, FIXR(1.0          * 2.0), FRAC_BITS);

            scale_factor_mult[i][1] = MULLx(norm, FIXR(0.7937005259 * 2.0), FRAC_",2,0,5,0,0,0,1,1,0,0,1,0,1,0,1
8487,FFmpeg,0,"static int libgsm_decode_frame(AVCodecContext *avctx,

                               void *data, int *data_size,

                               AVPacket *avpkt) {

    uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    int out_size = avctx->frame_size * av_get_bytes_per_sample(avctx->sample_fmt);



    if (*data_size < out_size) {

        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");

        return AVERROR(EINVAL);

    }



    if (buf_size < avctx->block_align) {

        av_log(avctx, AV_LOG_ERROR, ""Packet is too small\n"");

        return AVERROR_INVALIDDATA;

    }



    switch(avctx->codec_id) {

    case CODEC_ID_GSM:

        if(gsm_decode(avctx->priv_data,buf,data)) return -1;

        break;

    case CODEC_ID_GSM_MS:

        if(gsm_decode(avctx->priv_data,buf,data) ||

           gsm_decode(avctx->priv_data,buf+33,((int16_t*)data)+GSM_FRAME_SIZE)) return -1;

    }



    *data_size = out_size;

    return avctx->block_align;

}
",0,0,4,0,1,0,1,1,1,1,1,1,0,0,0
8518,qemu,1,"static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)

{

    unsigned access_size_min = mr->ops->impl.min_access_size;

    unsigned access_size_max = mr->ops->impl.max_access_size;



    /* Regions are assumed to support 1-4 byte accesses unless

       otherwise specified.  */

    if (access_size_min == 0) {

        access_size_min = 1;

    }

    if (access_size_max == 0) {

        access_size_max = 4;

    }



    /* Bound the maximum access by the alignment of the address.  */

    if (!mr->ops->impl.unaligned) {

        unsigned align_size_max = addr & -addr;

        if (align_size_max != 0 && align_size_max < access_size_max) {

            access_size_max = align_size_max;

        }

    }



    /* Don't attempt accesses larger than the maximum.  */

    if (l > access_size_max) {

        l = access_size_max;

    }

    /* ??? The users of this function are wrong, not supporting minimums larger

       than the remaining length.  C.f. memory.c:access_with_adjusted_size.",0,0,6,0,0,0,0,0,0,0,0,0,1,1,0
8522,qemu,1,"void fw_cfg_add_file_callback(FWCfgState *s,  const char *filename,

                              FWCfgCallback select_cb,

                              FWCfgWriteCallback write_cb,

                              void *callback_opaque,

                              void *data, size_t len, bool read_only)

{

    int i, index, count;

    size_t dsize;

    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());

    int order = 0;



    if (!s->files) {

        dsize = sizeof(uint32_t) + sizeof(FWCfgFile) * fw_cfg_file_slots(s);

        s->files = g_malloc0(dsize);

        fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, s->files, dsize);

    }



    count = be32_to_cpu(s->files->count);

    assert(count < fw_cfg_file_slots(s));



    /* Find the insertion point. */

    if (mc->legacy_fw_cfg_order) {

        /*

         * Sort by order. For files with the same order, we keep them

         * in the sequence in which they were added.

         */

        order = get_fw_cfg_order(s, filename);

        for",1,0,2,0,0,0,0,0,0,1,0,0,0,1,0
8526,qemu,1,"static void stellaris_enet_save(QEMUFile *f, void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;

    int i;



    qemu_put_be32(f, s->ris);

    qemu_put_be32(f, s->im);

    qemu_put_be32(f, s->rctl);

    qemu_put_be32(f, s->tctl);

    qemu_put_be32(f, s->thr);

    qemu_put_be32(f, s->mctl);

    qemu_put_be32(f, s->mdv);

    qemu_put_be32(f, s->mtxd);

    qemu_put_be32(f, s->mrxd);

    qemu_put_be32(f, s->np);

    qemu_put_be32(f, s->tx_fifo_len);

    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));

    for (i = 0; i < 31; i++) {

        qemu_put_be32(f, s->rx[i].len);

        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));



    }

    qemu_put_be32(f, s->next_packet);

    qemu_put_be32(f, s->rx_fifo_offset);

}
",1,0,4,0,0,0,0,1,0,0,1,0,0,1,1
8534,FFmpeg,0,"static void exit_program(void)

{

    int i, j;



    for (i = 0; i < nb_filtergraphs; i++) {

        avfilter_graph_free(&filtergraphs[i]->graph);

        for (j = 0; j < filtergraphs[i]->nb_inputs; j++) {

            av_freep(&filtergraphs[i]->inputs[j]->name);

            av_freep(&filtergraphs[i]->inputs[j]);

        }

        av_freep(&filtergraphs[i]->inputs);

        for (j = 0; j < filtergraphs[i]->nb_outputs; j++) {

            av_freep(&filtergraphs[i]->outputs[j]->name);

            av_freep(&filtergraphs[i]->outputs[j]);

        }

        av_freep(&filtergraphs[i]->outputs);

        av_freep(&filtergraphs[i]->graph_desc);

        av_freep(&filtergraphs[i]);

    }

    av_freep(&filtergraphs);



    /* close files */

    for (i = 0; i < nb_output_files; i++) {

        AVFormatContext *s = output_files[i]->ctx;

        if (!(s->oformat->flags & AVFMT_NOFILE) && s->pb)

            avio_close(s->pb);

        avformat_free_context(s);

        av_dict_free(&output_files[i]->opts);",6,0,1,0,0,0,0,0,0,0,0,0,0,0,0
8543,qemu,1,"static int coroutine_fn cow_co_is_allocated(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *num_same)

{

    int64_t bitnum = sector_num + sizeof(struct cow_header_v2) * 8;

    uint64_t offset = (bitnum / 8) & -BDRV_SECTOR_SIZE;

    uint8_t bitmap[BDRV_SECTOR_SIZE];

    int ret;

    int changed;



    ret = bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap));

    if (ret < 0) {

        return ret;

    }



    bitnum &= BITS_PER_BITMAP_SECTOR - 1;

    changed = cow_test_bit(bitnum, bitmap);

    *num_same = cow_find_streak(bitmap, changed, bitnum, nb_sectors);

    return changed;

}
",0,0,1,0,0,0,0,0,0,1,1,1,1,1,0
8565,qemu,0,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
",0,0,2,0,0,0,1,1,1,0,0,1,0,1,0
8568,qemu,0,"static void check_refcounts(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    int64_t size;

    int nb_clusters, refcount1, refcount2, i;

    QCowSnapshot *sn;

    uint16_t *refcount_table;



    size = bdrv_getlength(s->hd);

    nb_clusters = size_to_clusters(s, size);

    refcount_table = qemu_mallocz(nb_clusters * sizeof(uint16_t));



    /* header */

    inc_refcounts(bs, refcount_table, nb_clusters,

                  0, s->cluster_size);



    check_refcounts_l1(bs, refcount_table, nb_clusters,

                       s->l1_table_offset, s->l1_size, 1);



    /* snapshots */

    for(i = 0; i < s->nb_snapshots; i++) {

        sn = s->snapshots + i;

        check_refcounts_l1(bs, refcount_table, nb_clusters,

                           sn->l1_table_offset, sn->l1_size, 0);

    }

    inc_refcounts(bs, refcount_table, nb_clusters,

                  s->snapshots_offset, s->snapshots_size);



    /* refcount data */

    inc_refcounts(bs, refcount_table, nb_clusters,

        ",1,0,0,0,0,0,0,0,0,1,1,1,0,0,0
8577,qemu,1,"static int ipoctal_init(IPackDevice *ip)

{

    IPOctalState *s = IPOCTAL(ip);

    unsigned i;



    for (i = 0; i < N_CHANNELS; i++) {

        SCC2698Channel *ch = &s->ch[i];

        ch->ipoctal = s;



        /* Redirect IP-Octal channels to host character devices */

        if (ch->devpath) {

            const char chr_name[] = ""ipoctal"";

            char label[ARRAY_SIZE(chr_name) + 2];

            static int index;



            snprintf(label, sizeof(label), ""%s%d"", chr_name, index);



            ch->dev = qemu_chr_new(label, ch->devpath, NULL);



            if (ch->dev) {

                index++;


                qemu_chr_add_handlers(ch->dev, hostdev_can_receive,

                                      hostdev_receive, hostdev_event, ch);

                DPRINTF(""Redirecting channel %u to %s (%s)\n"",

                        i, ch->devpath, label);

            } else {

                DPRINTF(""Could not redirect channel %u to %s\n"",

                        i, ch->devpath);

       ",1,0,2,0,0,0,1,1,1,1,1,1,0,0,0
8592,qemu,1,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)

{

    uint64_t start = MAX(r1.start, r2.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);

    return addrrange_make(start, end - start + 1);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
8617,FFmpeg,0,"static int wc3_read_header(AVFormatContext *s,

                           AVFormatParameters *ap)

{

    Wc3DemuxContext *wc3 = s->priv_data;

    ByteIOContext *pb = s->pb;

    unsigned int fourcc_tag;

    unsigned int size;

    AVStream *st;

    unsigned char preamble[WC3_PREAMBLE_SIZE];

    int ret = 0;

    int current_palette = 0;

    int bytes_to_read;

    int i;

    unsigned char rotate;



    /* default context members */

    wc3->width = WC3_DEFAULT_WIDTH;

    wc3->height = WC3_DEFAULT_HEIGHT;

    wc3->palettes = NULL;

    wc3->palette_count = 0;

    wc3->pts = 0;

    wc3->video_stream_index = wc3->audio_stream_index = 0;



    /* skip the first 3 32-bit numbers */

    url_fseek(pb, 12, SEEK_CUR);



    /* traverse through the chunks and load the header information before

     * the first BRCH tag */

    if ((ret = get_buffer(pb, preamble, WC3_PREAMBLE_SIZE)) !=

        WC3_PREAMBLE_SIZE)

        return AVERROR(EIO);

    fourcc_tag = AV_RL32(&preamble[0]);

    size = (AV_RB3",2,0,1,0,0,0,0,1,1,0,1,0,1,1,1
8673,qemu,0,"static int64_t do_strtosz(const char *nptr, char **end,

                          const char default_suffix, int64_t unit)

{

    int64_t retval;

    char *endptr;

    unsigned char c;

    int mul_required = 0;

    double val, mul, integral, fraction;



    errno = 0;

    val = strtod(nptr, &endptr);

    if (isnan(val) || endptr == nptr || errno != 0) {

        retval = -EINVAL;

        goto out;

    }

    fraction = modf(val, &integral);

    if (fraction != 0) {

        mul_required = 1;

    }

    c = *endptr;

    mul = suffix_mul(c, unit);

    if (mul >= 0) {

        endptr++;

    } else {

        mul = suffix_mul(default_suffix, unit);

        assert(mul >= 0);

    }

    if (mul == 1 && mul_required) {

        retval = -EINVAL;

        goto out;

    }

    if ((val * mul >= INT64_MAX) || val < 0) {

        retval = -ERANGE;

        goto out;

    }

    retval = val * mul;



out:

    if (end) {

        *end = endptr;

    } else if (*endptr) {

        retval = -EINVAL;

  ",0,3,7,0,0,0,1,0,1,0,1,1,0,0,0
8707,qemu,1,"static int check_refcounts_l1(BlockDriverState *bs,

                              BdrvCheckResult *res,

                              uint16_t **refcount_table,

                              int64_t *refcount_table_size,

                              int64_t l1_table_offset, int l1_size,

                              int flags)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t *l1_table = NULL, l2_offset, l1_size2;

    int i, ret;



    l1_size2 = l1_size * sizeof(uint64_t);



    /* Mark L1 table as used */

    ret = inc_refcounts(bs, res, refcount_table, refcount_table_size,

                        l1_table_offset, l1_size2);

    if (ret < 0) {

        goto fail;

    }



    /* Read L1 table entries from disk */

    if (l1_size2 > 0) {

        l1_table = g_try_malloc(l1_size2);

        if (l1_table == NULL) {

            ret = -ENOMEM;

            res->check_errors++;

            goto fail;

        }

        ret = bdrv_pread(bs->file, l1_table_offset, l1_table, l1_size2);

        i",0,2,3,0,0,0,0,0,0,0,1,1,0,1,1
8720,qemu,1,"static uint32_t dcr_read_pob (void *opaque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[dcrn - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
",0,0,0,0,1,0,1,1,1,1,1,1,0,1,1
8755,qemu,0,"static inline int onenand_erase(OneNANDState *s, int sec, int num)

{

    uint8_t *blankbuf, *tmpbuf;

    blankbuf = g_malloc(512);

    if (!blankbuf) {

        return 1;

    }

    tmpbuf = g_malloc(512);

    if (!tmpbuf) {

        g_free(blankbuf);

        return 1;

    }

    memset(blankbuf, 0xff, 512);

    for (; num > 0; num--, sec++) {

        if (s->bdrv_cur) {

            int erasesec = s->secs_cur + (sec >> 5);

            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {

                goto fail;

            }

            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {

                goto fail;

            }

            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);

            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {

                goto fail;

            }

        } else {

            if (sec + 1 > s->secs_cur) {

                goto fail;

            }

            memcpy(s->current + (sec << 9), blankbuf, 512);

            memcpy(s->c",1,4,7,0,0,0,0,0,0,0,0,0,0,1,1
8793,qemu,1,"static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,

                              const char *desc_file_path, Error **errp)

{

    int ret;

    char access[11];

    char type[11];

    char fname[512];

    const char *p = desc;

    int64_t sectors = 0;

    int64_t flat_offset;

    char extent_path[PATH_MAX];

    BlockDriverState *extent_file;

    BDRVVmdkState *s = bs->opaque;

    VmdkExtent *extent;



    while (*p) {

        /* parse extent line:

         * RW [size in sectors] FLAT ""file-name.vmdk"" OFFSET

         * or

         * RW [size in sectors] SPARSE ""file-name.vmdk""

         */

        flat_offset = -1;

        ret = sscanf(p, ""%10s %"" SCNd64 "" %10s \""%511[^\n\r\""]\"" %"" SCNd64,

                access, &sectors, type, fname, &flat_offset);

        if (ret < 4 || strcmp(access, ""RW"")) {

            goto next_line;

        } else if (!strcmp(type, ""FLAT"")) {

            if (ret != 5 || flat_offset < 0) {

                error_setg(errp, ""Invalid extent lines:",0,1,3,0,0,1,0,1,1,0,0,0,0,0,1
8794,FFmpeg,1,"static int default_lockmgr_cb(void **arg, enum AVLockOp op)

{

    void * volatile * mutex = arg;

    int err;



    switch (op) {

    case AV_LOCK_CREATE:

        return 0;

    case AV_LOCK_OBTAIN:

        if (!*mutex) {

            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));

            if (!tmp)

                return AVERROR(ENOMEM);

            if ((err = pthread_mutex_init(tmp, NULL))) {

                av_free(tmp);

                return AVERROR(err);

            }

            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {

                pthread_mutex_destroy(tmp);

                av_free(tmp);

            }

        }



        if ((err = pthread_mutex_lock(*mutex)))

            return AVERROR(err);



        return 0;

    case AV_LOCK_RELEASE:

        if ((err = pthread_mutex_unlock(*mutex)))

            return AVERROR(err);



        return 0;

    case AV_LOCK_DESTROY:

        if (*mutex)

            pthread_mutex_destroy(*mutex);

        av_free(*mutex)",0,0,7,0,1,0,0,1,1,1,0,0,1,1,1
8815,FFmpeg,1,"static inline int check_input_motion(MpegEncContext * s, int mb_x, int mb_y, int p_type){

    MotionEstContext * const c= &s->me;

    Picture *p= s->current_picture_ptr;

    int mb_xy= mb_x + mb_y*s->mb_stride;

    int xy= 2*mb_x + 2*mb_y*s->b8_stride;

    int mb_type= s->current_picture.mb_type[mb_xy];

    int flags= c->flags;

    int shift= (flags&FLAG_QPEL) + 1;

    int mask= (1<<shift)-1;

    int x, y, i;

    int d=0;

    me_cmp_func cmpf= s->dsp.sse[0];

    me_cmp_func chroma_cmpf= s->dsp.sse[1];

    

    assert(p_type==0 || !USES_LIST(mb_type, 1));

    assert(IS_INTRA(mb_type) || USES_LIST(mb_type,0) || USES_LIST(mb_type,1));

    

    if(IS_INTERLACED(mb_type)){

        int xy2= xy  + s->b8_stride;

        s->mb_type[mb_xy]=CANDIDATE_MB_TYPE_INTRA;

        c->stride<<=1;

        c->uvstride<<=1;

        init_interlaced_ref(s, 2);

        

        assert(s->flags & CODEC_FLAG_INTERLACED_ME);



        if(USES_LIST(mb_type, 0)){

            int field_select0= p->ref_index[0][xy ]",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
8825,FFmpeg,0,"void ff_estimate_p_frame_motion(MpegEncContext * s,

                                int mb_x, int mb_y)

{

    UINT8 *pix, *ppix;

    int sum, varc, vard, mx, my, range, dmin, xx, yy;

    int xmin, ymin, xmax, ymax;

    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;

    int pred_x=0, pred_y=0;

    int P[6][2];

    const int shift= 1+s->quarter_sample;

    int mb_type=0;

    uint8_t *ref_picture= s->last_picture[0];



    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, s->f_code);



    switch(s->me_method) {

    case ME_ZERO:

    default:

	no_motion_search(s, &mx, &my);

        dmin = 0;

        break;

    case ME_FULL:

	dmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);

        break;

    case ME_LOG:

	dmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);

        break;

    case ME_PHODS:

	dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);

        break;

    case ME_X1:

    case ",0,0,1,0,1,0,0,0,0,0,0,1,1,1,1
8835,FFmpeg,0,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)

{

    VAAPIEncodeContext *ctx = avctx->priv_data;

    VAAPIEncodePicture *pic, *next;



    for (pic = ctx->pic_start; pic; pic = next) {

        next = pic->next;

        vaapi_encode_free(avctx, pic);

    }



    if (ctx->va_context != VA_INVALID_ID) {

        vaDestroyContext(ctx->hwctx->display, ctx->va_context);

        ctx->va_context = VA_INVALID_ID;

    }



    if (ctx->va_config != VA_INVALID_ID) {

        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);

        ctx->va_config = VA_INVALID_ID;

    }



    if (ctx->codec->close)

        ctx->codec->close(avctx);



    av_buffer_pool_uninit(&ctx->output_buffer_pool);



    av_freep(&ctx->codec_sequence_params);

    av_freep(&ctx->codec_picture_params);



    av_buffer_unref(&ctx->recon_frames_ref);

    av_buffer_unref(&ctx->input_frames_ref);

    av_buffer_unref(&ctx->device_ref);



    av_freep(&ctx->priv_data);



    return 0;

}
",1,0,3,0,0,0,0,1,0,0,0,0,0,0,0
8846,qemu,0,"static ssize_t socket_read(int sockfd, void *buff, size_t size)

{

    ssize_t retval, total = 0;



    while (size) {

        retval = read(sockfd, buff, size);

        if (retval == 0) {

            return -EIO;

        }

        if (retval < 0) {

            if (errno == EINTR) {

                continue;

            }

            return -errno;

        }

        size -= retval;

        buff += retval;

        total += retval;

    }

    return total;

}
",0,0,3,0,0,1,0,1,0,1,0,0,0,0,0
8855,qemu,0,"AioContext *blk_get_aio_context(BlockBackend *blk)

{

    return bdrv_get_aio_context(blk->bs);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
8858,qemu,0,"static int vfio_load_rom(VFIODevice *vdev)

{

    uint64_t size = vdev->rom_size;

    char name[32];

    off_t off = 0, voff = vdev->rom_offset;

    ssize_t bytes;

    void *ptr;



    /* If loading ROM from file, pci handles it */

    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {

        return 0;

    }



    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,

            vdev->host.bus, vdev->host.slot, vdev->host.function);



    snprintf(name, sizeof(name), ""vfio[%04x:%02x:%02x.%x].rom"",

             vdev->host.domain, vdev->host.bus, vdev->host.slot,

             vdev->host.function);

    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);

    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);

    memset(ptr, 0xff, size);



    while (size) {

        bytes = pread(vdev->fd, ptr + off, size, voff + off);

        if (bytes == 0) {

            break; /* expect that we could get back less than the ROM BAR */

        } else if (bytes > 0) {

        ",0,0,3,0,0,1,0,1,0,1,0,0,0,1,1
8866,qemu,0,"UuidInfo *qmp_query_uuid(Error **errp)

{

    UuidInfo *info = g_malloc0(sizeof(*info));

    char uuid[64];



    snprintf(uuid, sizeof(uuid), UUID_FMT, qemu_uuid[0], qemu_uuid[1],

                   qemu_uuid[2], qemu_uuid[3], qemu_uuid[4], qemu_uuid[5],

                   qemu_uuid[6], qemu_uuid[7], qemu_uuid[8], qemu_uuid[9],

                   qemu_uuid[10], qemu_uuid[11], qemu_uuid[12], qemu_uuid[13],

                   qemu_uuid[14], qemu_uuid[15]);



    info->UUID = g_strdup(uuid);

    return info;

}
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0
8878,FFmpeg,0,"static int mpc7_decode_frame(AVCodecContext * avctx, void *data,

                             int *got_frame_ptr, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size;

    MPCContext *c = avctx->priv_data;

    GetBitContext gb;

    int i, ch;

    int mb = -1;

    Band *bands = c->bands;

    int off, ret, last_frame, skip;

    int bits_used, bits_avail;



    memset(bands, 0, sizeof(*bands) * (c->maxbands + 1));



    buf_size = avpkt->size & ~3;

    if (buf_size <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""packet size is too small (%i bytes)\n"",

               avpkt->size);

        return AVERROR_INVALIDDATA;

    }

    if (buf_size != avpkt->size) {

        av_log(avctx, AV_LOG_WARNING, ""packet size is not a multiple of 4. ""

               ""extra bytes at the end will be skipped.\n"");

    }



    skip       = buf[0];

    last_frame = buf[1];

    buf       += 4;

    buf_size  -= 4;



    /* get output buffer */

    c->frame.nb_samples = last_frame ? c->lastframe",0,0,2,0,0,0,0,1,1,1,1,1,0,0,0
8900,FFmpeg,1,"static int rle_unpack(const unsigned char *src, int src_len, int src_count,

                      unsigned char *dest, int dest_len)

{

    const unsigned char *ps;

    const unsigned char *ps_end;

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;



    ps = src;

    ps_end = src + src_len;

    pd = dest;

    if (src_count & 1) {

        if (ps_end - ps < 1)

            return 0;

        *pd++ = *ps++;

    }



    src_count >>= 1;

    i = 0;

    do {

        if (ps_end - ps < 1)

            break;

        l = *ps++;

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end || ps_end - ps < l)

                return ps - src;

            memcpy(pd, ps, l);

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end || ps_end - ps < 2)

                return ps - src;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }
",1,0,6,0,0,0,1,1,1,1,1,1,0,0,1
8901,FFmpeg,1,"int vc1_decode_sequence_header(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb)

{

    av_log(avctx, AV_LOG_DEBUG, ""Header: %0X\n"", show_bits(gb, 32));

    v->profile = get_bits(gb, 2);

    if (v->profile == PROFILE_COMPLEX)

    {

        av_log(avctx, AV_LOG_WARNING, ""WMV3 Complex Profile is not fully supported\n"");

    }



    if (v->profile == PROFILE_ADVANCED)

    {

        v->zz_8x4 = ff_vc1_adv_progressive_8x4_zz;

        v->zz_4x8 = ff_vc1_adv_progressive_4x8_zz;

        return decode_sequence_header_adv(v, gb);

    }

    else

    {

        v->zz_8x4 = wmv2_scantableA;

        v->zz_4x8 = wmv2_scantableB;

        v->res_y411   = get_bits1(gb);

        v->res_sprite = get_bits1(gb);

        if (v->res_y411)

        {

            av_log(avctx, AV_LOG_ERROR,

                   ""Old interlaced mode is not supported\n"");

            return -1;

        }

        if (v->res_sprite) {

            av_log(avctx, AV_LOG_ERROR, ""WMVP is not fully supported\n"");

        }

    }

",0,0,4,0,0,0,1,1,1,1,0,1,1,0,0
8903,qemu,1,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
",0,0,1,0,0,0,0,1,0,0,0,0,0,0,1
8927,qemu,0,"static void apic_update_irq(APICState *s)

{

    int irrv, ppr;

    if (!(s->spurious_vec & APIC_SV_ENABLE))

        return;

    irrv = get_highest_priority_int(s->irr);

    if (irrv < 0)

        return;

    ppr = apic_get_ppr(s);

    if (ppr && (irrv & 0xf0) <= (ppr & 0xf0))

        return;

    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
8931,qemu,0,"setup_sigcontext(struct target_sigcontext *sc, struct target_fpstate *fpstate,

		 CPUX86State *env, abi_ulong mask, abi_ulong fpstate_addr)

{

    CPUState *cs = CPU(x86_env_get_cpu(env));

    int err = 0;

    uint16_t magic;



	/* already locked in setup_frame() */

    __put_user(env->segs[R_GS].selector, (unsigned int *)&sc->gs);

    __put_user(env->segs[R_FS].selector, (unsigned int *)&sc->fs);

    __put_user(env->segs[R_ES].selector, (unsigned int *)&sc->es);

    __put_user(env->segs[R_DS].selector, (unsigned int *)&sc->ds);

    __put_user(env->regs[R_EDI], &sc->edi);

    __put_user(env->regs[R_ESI], &sc->esi);

    __put_user(env->regs[R_EBP], &sc->ebp);

    __put_user(env->regs[R_ESP], &sc->esp);

    __put_user(env->regs[R_EBX], &sc->ebx);

    __put_user(env->regs[R_EDX], &sc->edx);

    __put_user(env->regs[R_ECX], &sc->ecx);

    __put_user(env->regs[R_EAX], &sc->eax);

    __put_user(cs->exception_index, &sc->trapno);

    __put_user(env->error_code, &sc->err);

    __put_user(env->eip,",0,0,0,0,0,0,1,1,1,1,1,1,1,0,1
8946,qemu,0,"static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)

{

    BDRVQEDState *s = acb_to_s(acb);



    /* Free resources */

    qemu_iovec_destroy(&acb->cur_qiov);

    qed_unref_l2_cache_entry(acb->request.l2_table);



    /* Free the buffer we may have allocated for zero writes */

    if (acb->flags & QED_AIOCB_ZERO) {

        qemu_vfree(acb->qiov->iov[0].iov_base);

        acb->qiov->iov[0].iov_base = NULL;

    }



    /* Start next allocating write request waiting behind this one.  Note that

     * requests enqueue themselves when they first hit an unallocated cluster

     * but they wait until the entire request is finished before waking up the

     * next request in the queue.  This ensures that we don't cycle through

     * requests multiple times but rather finish one at a time completely.

     */

    if (acb == s->allocating_acb) {

        s->allocating_acb = NULL;

        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {

            qemu_co_enter_next(&s->allocating_write_reqs",1,0,3,0,0,0,1,1,1,1,1,1,1,1,1
8949,qemu,0,"static bool vtd_do_iommu_translate(VTDAddressSpace *vtd_as, PCIBus *bus,

                                   uint8_t devfn, hwaddr addr, bool is_write,

                                   IOMMUTLBEntry *entry)

{

    IntelIOMMUState *s = vtd_as->iommu_state;

    VTDContextEntry ce;

    uint8_t bus_num = pci_bus_num(bus);

    VTDContextCacheEntry *cc_entry = &vtd_as->context_cache_entry;

    uint64_t slpte, page_mask;

    uint32_t level;

    uint16_t source_id = vtd_make_source_id(bus_num, devfn);

    int ret_fr;

    bool is_fpd_set = false;

    bool reads = true;

    bool writes = true;

    uint8_t access_flags;

    VTDIOTLBEntry *iotlb_entry;



    /*

     * We have standalone memory region for interrupt addresses, we

     * should never receive translation requests in this region.

     */

    assert(!vtd_is_interrupt_addr(addr));



    /* Try to fetch slpte form IOTLB */

    iotlb_entry = vtd_lookup_iotlb(s, source_id, addr);

    if (iotlb_entry) {

        trace_vtd_iotlb_page_hit(sour",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
8955,qemu,0,"int load_multiboot(void *fw_cfg,

                   FILE *f,

                   const char *kernel_filename,

                   const char *initrd_filename,

                   const char *kernel_cmdline,

                   int kernel_file_size,

                   uint8_t *header)

{

    int i, is_multiboot = 0;

    uint32_t flags = 0;

    uint32_t mh_entry_addr;

    uint32_t mh_load_addr;

    uint32_t mb_kernel_size;

    MultibootState mbs;

    uint8_t bootinfo[MBI_SIZE];

    uint8_t *mb_bootinfo_data;



    /* Ok, let's see if it is a multiboot image.

       The header is 12x32bit long, so the latest entry may be 8192 - 48. */

    for (i = 0; i < (8192 - 48); i += 4) {

        if (ldl_p(header+i) == 0x1BADB002) {

            uint32_t checksum = ldl_p(header+i+8);

            flags = ldl_p(header+i+4);

            checksum += flags;

            checksum += (uint32_t)0x1BADB002;

            if (!checksum) {

                is_multiboot = 1;

                break;

            }

      ",1,0,3,0,0,0,0,0,0,0,1,0,0,0,0
8963,FFmpeg,0,"static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,

                                          int *beta, int *tc, uint8_t *no_p,

                                          uint8_t *no_q)

{

    FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),

                                beta, tc, no_p, no_q);

}
",0,0,1,0,0,0,1,1,1,0,0,0,0,0,0
8970,qemu,0,"static void tcg_out_brcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a,

                           TCGArg b, bool b_const, TCGLabel *l)

{

    intptr_t offset;

    bool need_cmp;



    if (b_const && b == 0 && (c == TCG_COND_EQ || c == TCG_COND_NE)) {

        need_cmp = false;

    } else {

        need_cmp = true;

        tcg_out_cmp(s, ext, a, b, b_const);

    }



    if (!l->has_value) {

        tcg_out_reloc(s, s->code_ptr, R_AARCH64_CONDBR19, l, 0);

        offset = tcg_in32(s) >> 5;

    } else {

        offset = l->u.value_ptr - s->code_ptr;

        assert(offset == sextract64(offset, 0, 19));

    }



    if (need_cmp) {

        tcg_out_insn(s, 3202, B_C, c, offset);

    } else if (c == TCG_COND_EQ) {

        tcg_out_insn(s, 3201, CBZ, ext, a, offset);

    } else {

        tcg_out_insn(s, 3201, CBNZ, ext, a, offset);

    }

}
",0,0,4,0,0,0,1,1,1,0,0,0,1,1,1
8988,qemu,0,"static int nbd_negotiate_options(NBDClient *client, Error **errp)

{

    uint32_t flags;

    bool fixedNewstyle = false;



    /* Client sends:

        [ 0 ..   3]   client flags



        [ 0 ..   7]   NBD_OPTS_MAGIC

        [ 8 ..  11]   NBD option

        [12 ..  15]   Data length

        ...           Rest of request



        [ 0 ..   7]   NBD_OPTS_MAGIC

        [ 8 ..  11]   Second NBD option

        [12 ..  15]   Data length

        ...           Rest of request

    */



    if (nbd_read(client->ioc, &flags, sizeof(flags), errp) < 0) {

        error_prepend(errp, ""read failed: "");

        return -EIO;

    }

    trace_nbd_negotiate_options_flags();

    be32_to_cpus(&flags);

    if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) {

        trace_nbd_negotiate_options_newstyle();

        fixedNewstyle = true;

        flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE;

    }

    if (flags & NBD_FLAG_C_NO_ZEROES) {

        trace_nbd_negotiate_options_no_zeroes();

        client->no_zeroes = true;

        fl",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
9025,qemu,1,"static void pl181_fifo_run(pl181_state *s)

{

    uint32_t bits;

    uint32_t value;

    int n;

    int is_read;



    is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0;

    if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card))

            && !s->linux_hack) {

        if (is_read) {

            n = 0;

            value = 0;

            while (s->datacnt && s->fifo_len < PL181_FIFO_LEN) {

                value |= (uint32_t)sd_read_data(s->card) << (n * 8);

                s->datacnt--;

                n++;

                if (n == 4) {

                    pl181_fifo_push(s, value);

                    n = 0;

                    value = 0;

                }

            }

            if (n != 0) {

                pl181_fifo_push(s, value);

            }

        } else { /* write */

            n = 0;

            while (s->datacnt > 0 && (s->fifo_len > 0 || n > 0)) {

                if (n == 0) {

                    value = pl181_fifo_pop(s);

                    n = 4;

      ",0,0,11,0,0,2,0,0,0,1,0,1,1,0,1
9036,FFmpeg,0,"static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)

{

    AMFDataType type;

    AVStream *stream, *astream, *vstream;

    AVIOContext *ioc;

    int i;

    // only needs to hold the string ""onMetaData"".

    // Anything longer is something we don't want.

    char buffer[11];



    astream = NULL;

    vstream = NULL;

    ioc     = s->pb;



    // first object needs to be ""onMetaData"" string

    type = avio_r8(ioc);

    if (type != AMF_DATA_TYPE_STRING ||

        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)

        return -1;



    if (!strcmp(buffer, ""onTextData""))

        return 1;



    if (strcmp(buffer, ""onMetaData""))

        return -1;



    // find the streams now so that amf_parse_object doesn't need to do

    // the lookup every time it is called.

    for (i = 0; i < s->nb_streams; i++) {

        stream = s->streams[i];

        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)

            astream = stream;

        else if (stream->codec->codec_type == AVME",1,0,5,0,0,0,0,0,0,0,0,0,0,0,1
9038,qemu,0,"static void mptsas_scsi_init(PCIDevice *dev, Error **errp)

{

    DeviceState *d = DEVICE(dev);

    MPTSASState *s = MPT_SAS(dev);

    Error *err = NULL;

    int ret;



    dev->config[PCI_LATENCY_TIMER] = 0;

    dev->config[PCI_INTERRUPT_PIN] = 0x01;



    if (s->msi != ON_OFF_AUTO_OFF) {

        ret = msi_init(dev, 0, 1, true, false, &err);

        /* Any error other than -ENOTSUP(board's MSI support is broken)

         * is a programming error */

        assert(!ret || ret == -ENOTSUP);

        if (ret && s->msi == ON_OFF_AUTO_ON) {

            /* Can't satisfy user's explicit msi=on request, fail */

            error_append_hint(&err, ""You have to use msi=auto (default) or ""

                    ""msi=off with this machine type.\n"");

            error_propagate(errp, err);

            s->msi_in_use = false;

            return;

        } else if (ret) {

            /* With msi=auto, we fall back to MSI off silently */

            error_free(err);

            s->msi_in_use = false;

    ",0,0,3,0,0,0,0,1,0,0,0,0,0,0,0
9039,qemu,0,"static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)

{

    int i;

    GICState *s = KVM_ARM_GIC(dev);

    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);

    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);



    kgc->parent_realize(dev, errp);

    if (error_is_set(errp)) {

        return;

    }



    i = s->num_irq - GIC_INTERNAL;

    /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU.

     * GPIO array layout is thus:

     *  [0..N-1] SPIs

     *  [N..N+31] PPIs for CPU 0

     *  [N+32..N+63] PPIs for CPU 1

     *   ...

     */

    i += (GIC_INTERNAL * s->num_cpu);

    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);

    /* We never use our outbound IRQ lines but provide them so that

     * we maintain the same interface as the non-KVM GIC.

     */

    for (i = 0; i < s->num_cpu; i++) {

        sysbus_init_irq(sbd, &s->parent_irq[i]);

    }

    /* Distributor */

    memory_region_init_reservation(&s->iomem, OBJECT(s),

                                   ""kvm-g",5,0,1,0,0,0,1,0,0,1,0,0,1,1,0
9047,FFmpeg,0,"static int write_fragments(struct Tracks *tracks, int start_index,

                           AVIOContext *in)

{

    char dirname[100], filename[500];

    int i, j;



    for (i = start_index; i < tracks->nb_tracks; i++) {

        struct Track *track = tracks->tracks[i];

        const char *type    = track->is_video ? ""video"" : ""audio"";

        snprintf(dirname, sizeof(dirname), ""QualityLevels(%d)"", track->bitrate);

        mkdir(dirname, 0777);

        for (j = 0; j < track->chunks; j++) {

            snprintf(filename, sizeof(filename), ""%s/Fragments(%s=%""PRId64"")"",

                     dirname, type, track->offsets[j].time);

            avio_seek(in, track->offsets[j].offset, SEEK_SET);

            write_fragment(filename, in);

        }

    }

    return 0;

}
",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0
9049,qemu,0,"char *qemu_find_file(int type, const char *name)

{

    int len;

    const char *subdir;

    char *buf;



    /* If name contains path separators then try it as a straight path.  */

    if ((strchr(name, '/') || strchr(name, '\\'))

        && access(name, R_OK) == 0) {

        return g_strdup(name);

    }

    switch (type) {

    case QEMU_FILE_TYPE_BIOS:

        subdir = """";

        break;

    case QEMU_FILE_TYPE_KEYMAP:

        subdir = ""keymaps/"";

        break;

    default:

        abort();

    }

    len = strlen(data_dir) + strlen(name) + strlen(subdir) + 2;

    buf = g_malloc0(len);

    snprintf(buf, len, ""%s/%s%s"", data_dir, subdir, name);

    if (access(buf, R_OK)) {

        g_free(buf);

        return NULL;

    }

    return buf;

}
",0,0,2,0,1,0,0,0,0,0,0,0,0,1,1
9055,qemu,0,"void term_flush(void)

{

}
",0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
9067,qemu,0,"static uint64_t elcr_ioport_read(void *opaque, target_phys_addr_t addr,

                                 unsigned size)

{

    PICCommonState *s = opaque;

    return s->elcr;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
9072,qemu,0,"static int inc_refcounts(BlockDriverState *bs,

                         BdrvCheckResult *res,

                         uint16_t *refcount_table,

                         int64_t refcount_table_size,

                         int64_t offset, int64_t size)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t start, last, cluster_offset, k;



    if (size <= 0) {

        return 0;

    }



    start = start_of_cluster(s, offset);

    last = start_of_cluster(s, offset + size - 1);

    for(cluster_offset = start; cluster_offset <= last;

        cluster_offset += s->cluster_size) {

        k = cluster_offset >> s->cluster_bits;

        if (k >= refcount_table_size) {

            fprintf(stderr, ""Warning: cluster offset=0x%"" PRIx64 "" is after ""

                ""the end of the image file, can't properly check refcounts.\n"",

                cluster_offset);

            res->check_errors++;

        } else {

            if (++refcount_table[k] == 0) {

                fprintf(stderr, ""ERROR: overflow cl",1,0,3,0,0,0,0,0,0,0,0,0,1,1,1
9087,qemu,1,"static int nbd_co_request(BlockDriverState *bs,

                          NBDRequest *request,

                          QEMUIOVector *qiov)

{

    NBDClientSession *client = nbd_get_client_session(bs);

    int ret;



    if (qiov) {

        assert(request->type == NBD_CMD_WRITE || request->type == NBD_CMD_READ);

        assert(request->len == iov_size(qiov->iov, qiov->niov));

    } else {

        assert(request->type != NBD_CMD_WRITE && request->type != NBD_CMD_READ);

    }

    ret = nbd_co_send_request(bs, request,

                              request->type == NBD_CMD_WRITE ? qiov : NULL);

    if (ret < 0) {

        return ret;

    }



    return nbd_co_receive_reply(client, request->handle,

                                request->type == NBD_CMD_READ ? qiov : NULL);

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
9091,qemu,1,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
9094,FFmpeg,0,"static av_always_inline void xchg_mb_border(H264Context *h, uint8_t *src_y,

                                            uint8_t *src_cb, uint8_t *src_cr,

                                            int linesize, int uvlinesize,

                                            int xchg, int chroma444,

                                            int simple, int pixel_shift)

{

    int deblock_topleft;

    int deblock_top;

    int top_idx = 1;

    uint8_t *top_border_m1;

    uint8_t *top_border;



    if (!simple && FRAME_MBAFF(h)) {

        if (h->mb_y & 1) {

            if (!MB_MBAFF(h))

                return;

        } else {

            top_idx = MB_MBAFF(h) ? 0 : 1;

        }

    }



    if (h->deblocking_filter == 2) {

        deblock_topleft = h->slice_table[h->mb_xy - 1 - h->mb_stride] == h->slice_num;

        deblock_top     = h->top_type;

    } else {

        deblock_topleft = (h->mb_x > 0);

        deblock_top     = (h->mb_y > !!MB_FIELD(h));

    }



    src_y  -= linesize   + 1 +",0,0,5,0,0,0,1,1,1,1,1,1,0,0,0
9095,FFmpeg,1,"static int gif_image_write_image(AVCodecContext *avctx,

                                 uint8_t **bytestream, uint8_t *end,

                                 const uint8_t *buf, int linesize)

{

    GIFContext *s = avctx->priv_data;

    int len, height;

    const uint8_t *ptr;

    /* image block */



    bytestream_put_byte(bytestream, 0x2c);

    bytestream_put_le16(bytestream, 0);

    bytestream_put_le16(bytestream, 0);

    bytestream_put_le16(bytestream, avctx->width);

    bytestream_put_le16(bytestream, avctx->height);

    bytestream_put_byte(bytestream, 0x00); /* flags */

    /* no local clut */



    bytestream_put_byte(bytestream, 0x08);



    ff_lzw_encode_init(s->lzw, s->buf, avctx->width*avctx->height,

                       12, FF_LZW_GIF, put_bits);



    ptr = buf;

    for (height = avctx->height; height--;) {

        len += ff_lzw_encode(s->lzw, ptr, avctx->width);

        ptr += linesize;

    }

    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);



    ptr = s->buf;

  ",1,0,1,0,0,0,0,0,0,0,0,0,0,1,0
9101,FFmpeg,1,"static int mov_write_stbl_tag(AVIOContext *pb, MOVTrack *track)

{

    int64_t pos = avio_tell(pb);

    avio_wb32(pb, 0); /* size */

    ffio_wfourcc(pb, ""stbl"");

    mov_write_stsd_tag(pb, track);

    mov_write_stts_tag(pb, track);

    if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||

         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&

        track->has_keyframes && track->has_keyframes < track->entry)

        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);

    if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)

        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);

    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&

        track->flags & MOV_TRACK_CTTS && track->entry)

        mov_write_ctts_tag(pb, track);

    mov_write_stsc_tag(pb, track);

    mov_write_stsz_tag(pb, track);

    mov_write_stco_tag(pb, track);

    return update_size(pb, pos);

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
9106,qemu,1,"uint64_t qcow2_get_cluster_offset(BlockDriverState *bs, uint64_t offset,

    int *num)

{

    BDRVQcowState *s = bs->opaque;

    int l1_index, l2_index;

    uint64_t l2_offset, *l2_table, cluster_offset;

    int l1_bits, c;

    int index_in_cluster, nb_available, nb_needed, nb_clusters;



    index_in_cluster = (offset >> 9) & (s->cluster_sectors - 1);

    nb_needed = *num + index_in_cluster;



    l1_bits = s->l2_bits + s->cluster_bits;



    /* compute how many bytes there are between the offset and

     * the end of the l1 entry

     */



    nb_available = (1 << l1_bits) - (offset & ((1 << l1_bits) - 1));



    /* compute the number of available sectors */



    nb_available = (nb_available >> 9) + index_in_cluster;



    if (nb_needed > nb_available) {

        nb_needed = nb_available;

    }



    cluster_offset = 0;



    /* seek the the l2 offset in the l1 table */



    l1_index = offset >> l1_bits;

    if (l1_index >= s->l1_size)

        goto out;



    l2_offset = s->l1_table",0,1,2,0,0,0,0,0,0,0,0,0,0,0,1
9109,FFmpeg,1,"static inline int RENAME(yuv420_rgb16)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

             int srcSliceH, uint8_t* dst[], int dstStride[]){

    int y, h_size;



    if(c->srcFormat == PIX_FMT_YUV422P){

	srcStride[1] *= 2;

	srcStride[2] *= 2;

    }



    h_size= (c->dstW+7)&~7;

    if(h_size*2 > FFABS(dstStride[0])) h_size-=8;



    __asm__ __volatile__ (""pxor %mm4, %mm4;"" /* zero mm4 */ );

//printf(""%X %X %X %X %X %X %X %X %X %X\n"", (int)&c->redDither, (int)&b5Dither, (int)src[0], (int)src[1], (int)src[2], (int)dst[0],

//srcStride[0],srcStride[1],srcStride[2],dstStride[0]);

    for (y= 0; y<srcSliceH; y++ ) {

	uint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];

	uint8_t *_py = src[0] + y*srcStride[0];

	uint8_t *_pu = src[1] + (y>>1)*srcStride[1];

	uint8_t *_pv = src[2] + (y>>1)*srcStride[2];

	long index= -h_size/2;



	b5Dither= dither8[y&1];

	g6Dither= dither4[y&1];

	g5Dither= dither8[y&1];

	r5Dither= dither8[(y+1)&1];

	    /* this mmx assembly code deals with ",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
9122,qemu,1,"void memory_region_add_eventfd(MemoryRegion *mr,

                               hwaddr addr,

                               unsigned size,

                               bool match_data,

                               uint64_t data,

                               EventNotifier *e)

{

    MemoryRegionIoeventfd mrfd = {

        .addr.start = int128_make64(addr),

        .addr.size = int128_make64(size),

        .match_data = match_data,

        .data = data,

        .e = e,

    };

    unsigned i;



    adjust_endianness(mr, &mrfd.data, size);

    memory_region_transaction_begin();

    for (i = 0; i < mr->ioeventfd_nb; ++i) {

        if (memory_region_ioeventfd_before(mrfd, mr->ioeventfds[i])) {

            break;

        }

    }

    ++mr->ioeventfd_nb;

    mr->ioeventfds = g_realloc(mr->ioeventfds,

                                  sizeof(*mr->ioeventfds) * mr->ioeventfd_nb);

    memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i],

            sizeof(*mr->ioeventfds) * (mr->ioeventfd_nb-1 ",2,0,2,0,0,0,0,1,0,0,0,0,1,0,1
9134,FFmpeg,0,"enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target)

{

    if (codec && codec->pix_fmts) {

        const enum AVPixelFormat *p = codec->pix_fmts;

        int has_alpha= av_pix_fmt_desc_get(target)->nb_components % 2 == 0;

        enum AVPixelFormat best= AV_PIX_FMT_NONE;

        if (st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {

            if (st->codec->codec_id == AV_CODEC_ID_MJPEG) {

                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE };

            } else if (st->codec->codec_id == AV_CODEC_ID_LJPEG) {

                p = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUV420P,

                                                 AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_BGRA, AV_PIX_FMT_NONE };

            }

        }

        for (; *p != AV_PIX_FMT_NONE; p++) {

            be",1,0,4,0,0,0,1,1,1,0,0,0,0,0,0
9150,qemu,1,"static void gic_set_irq(void *opaque, int irq, int level)

{

    /* Meaning of the 'irq' parameter:

     *  [0..N-1] : external interrupts

     *  [N..N+31] : PPI (internal) interrupts for CPU 0

     *  [N+32..N+63] : PPI (internal interrupts for CPU 1

     *  ...

     */

    GICState *s = (GICState *)opaque;

    int cm, target;

    if (irq < (s->num_irq - GIC_INTERNAL)) {

        /* The first external input line is internal interrupt 32.  */

        cm = ALL_CPU_MASK;

        irq += GIC_INTERNAL;

        target = GIC_TARGET(irq);

    } else {

        int cpu;

        irq -= (s->num_irq - GIC_INTERNAL);

        cpu = irq / GIC_INTERNAL;

        irq %= GIC_INTERNAL;

        cm = 1 << cpu;

        target = cm;

    }



    assert(irq >= GIC_NR_SGIS);



    if (level == GIC_TEST_LEVEL(irq, cm)) {

        return;

    }



    if (s->revision == REV_11MPCORE || s->revision == REV_NVIC) {

        gic_set_irq_11mpcore(s, irq, level, cm, target);

    } else {

        gic_set_irq_generic(s, ",2,0,3,0,0,0,0,0,0,0,0,0,1,0,1
9162,FFmpeg,1,"static int decode_mb_info(IVI5DecContext *ctx, IVIBandDesc *band,
                          IVITile *tile, AVCodecContext *avctx)
{
    int         x, y, mv_x, mv_y, mv_delta, offs, mb_offset,
                mv_scale, blks_per_mb;
    IVIMbInfo   *mb, *ref_mb;
    int         row_offset = band->mb_size * band->pitch;
    mb     = tile->mbs;
    ref_mb = tile->ref_mbs;
    offs   = tile->ypos * band->pitch + tile->xpos;
    /* scale factor for motion vectors */
    mv_scale = (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3);
    mv_x = mv_y = 0;
    for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mb_size) {
        mb_offset = offs;
        for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mb_size) {
            mb->xpos     = x;
            mb->ypos     = y;
            mb->buf_offs = mb_offset;
            if (get_bits1(&ctx->gb)) {
                if (ctx->frame_type == FRAMETYPE_INTRA) {
                    av_log(avctx, AV_LOG_ERROR, ""Empty macroblock in an INT",2,0,2,0,0,0,0,0,0,0,0,0,0,0,0
9172,qemu,1,"VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)
{
    VIOsPAPRDevice *sdev;
    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);
    if (!sdev && reg == 0) {
        /* Hack for kernel early debug, which always specifies reg==0.
         * We search all VIO devices, and grab the vty with the lowest
         * reg.  This attempts to mimic existing PowerVM behaviour
         * (early debug does work there, despite having no vty with
         * reg==0. */
        return spapr_vty_get_default(spapr->vio_bus);
    return sdev;",1,0,2,0,0,0,0,0,0,0,0,0,0,0,1
9174,qemu,1,"void coroutine_fn block_job_pause_point(BlockJob *job)

{

    assert(job && block_job_started(job));



    if (!block_job_should_pause(job)) {

        return;

    }

    if (block_job_is_cancelled(job)) {

        return;

    }



    if (job->driver->pause) {

        job->driver->pause(job);

    }



    if (block_job_should_pause(job) && !block_job_is_cancelled(job)) {

        job->paused = true;

        job->busy = false;

        qemu_coroutine_yield(); /* wait for block_job_resume() */

        job->busy = true;

        job->paused = false;

    }



    if (job->driver->resume) {

        job->driver->resume(job);

    }

}
",0,0,5,0,0,0,1,0,0,1,1,0,0,0,0
9176,qemu,1,"int bdrv_pread(BlockDriverState *bs, int64_t offset,
               void *buf1, int count1)
{
    BlockDriver *drv = bs->drv;
    if (!drv)
        return -ENOMEDIUM;
    if (!drv->bdrv_pread)
        return bdrv_pread_em(bs, offset, buf1, count1);
    return drv->bdrv_pread(bs, offset, buf1, count1);
}",0,0,2,0,0,0,0,0,0,0,0,0,0,0,1
9178,FFmpeg,1,"int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,

                             int max_size)

{

    uint32_t mrk;

    int i, tmp;

    const uint16_t *ssrc = (const uint16_t *) src;

    uint16_t *sdst = (uint16_t *) dst;

    PutBitContext pb;



    if ((unsigned) src_size > (unsigned) max_size)

        src_size = max_size;



    mrk = AV_RB32(src);

    switch (mrk) {

    case DCA_SYNCWORD_CORE_BE:

        memcpy(dst, src, src_size);

        return src_size;

    case DCA_SYNCWORD_CORE_LE:

        for (i = 0; i < (src_size + 1) >> 1; i++)

            *sdst++ = av_bswap16(*ssrc++);

        return src_size;

    case DCA_SYNCWORD_CORE_14B_BE:

    case DCA_SYNCWORD_CORE_14B_LE:

        init_put_bits(&pb, dst, max_size);

        for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {

            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;

            put_bits(&pb, 14, tmp);

        }

        flush_put_bits(&pb);

        retur",2,0,1,0,1,0,1,1,1,1,1,1,0,0,0
9189,qemu,1,"static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,
                               unsigned int epid)
{
    XHCISlot *slot;
    XHCIEPContext *epctx;
    int i;
    trace_usb_xhci_ep_disable(slotid, epid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    assert(epid >= 1 && epid <= 31);
    slot = &xhci->slots[slotid-1];
    if (!slot->eps[epid-1]) {
        DPRINTF(""xhci: slot %d ep %d already disabled\n"", slotid, epid);
        return CC_SUCCESS;
    xhci_ep_nuke_xfers(xhci, slotid, epid);
    epctx = slot->eps[epid-1];
    if (epctx->nr_pstreams) {
        xhci_free_streams(epctx);
    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);
    timer_free(epctx->kick_timer);
    g_free(epctx);
    slot->eps[epid-1] = NULL;
    return CC_SUCCESS;",0,0,2,0,0,0,0,0,0,1,1,1,1,1,1
9193,qemu,1,"int pvpanic_init(ISABus *bus)

{

    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0
9210,qemu,0,"static uint32_t gic_dist_readb(void *opaque, hwaddr offset, MemTxAttrs attrs)

{

    GICState *s = (GICState *)opaque;

    uint32_t res;

    int irq;

    int i;

    int cpu;

    int cm;

    int mask;



    cpu = gic_get_current_cpu(s);

    cm = 1 << cpu;

    if (offset < 0x100) {

        if (offset == 0)

            return s->enabled;

        if (offset == 4)

            /* Interrupt Controller Type Register */

            return ((s->num_irq / 32) - 1)

                    | ((NUM_CPU(s) - 1) << 5)

                    | (s->security_extn << 10);

        if (offset < 0x08)

            return 0;

        if (offset >= 0x80) {

            /* Interrupt Group Registers: these RAZ/WI if this is an NS

             * access to a GIC with the security extensions, or if the GIC

             * doesn't have groups at all.

             */

            res = 0;

            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {

                /* Every byte offset holds 8 group status bits",0,0,8,0,0,0,0,0,0,0,0,1,1,1,1
9215,qemu,0,"static inline int get_segment_6xx_tlb(CPUPPCState *env, mmu_ctx_t *ctx,

                                      target_ulong eaddr, int rw, int type)

{

    hwaddr hash;

    target_ulong vsid;

    int ds, pr, target_page_bits;

    int ret;

    target_ulong sr, pgidx;



    pr = msr_pr;

    ctx->eaddr = eaddr;



    sr = env->sr[eaddr >> 28];

    ctx->key = (((sr & 0x20000000) && (pr != 0)) ||

                ((sr & 0x40000000) && (pr == 0))) ? 1 : 0;

    ds = sr & 0x80000000 ? 1 : 0;

    ctx->nx = sr & 0x10000000 ? 1 : 0;

    vsid = sr & 0x00FFFFFF;

    target_page_bits = TARGET_PAGE_BITS;

    qemu_log_mask(CPU_LOG_MMU,

            ""Check segment v="" TARGET_FMT_lx "" %d "" TARGET_FMT_lx

            "" nip="" TARGET_FMT_lx "" lr="" TARGET_FMT_lx

            "" ir=%d dr=%d pr=%d %d t=%d\n"",

            eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msr_ir,

            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);

    pgidx = (eaddr & ~SEGMENT_MASK_256M) >> target_page_bits;

    hash = vsid ^ pg",0,0,0,0,0,0,0,0,0,0,0,0,1,1,0
9225,qemu,0,"static void slirp_socket_save(QEMUFile *f, struct socket *so)

{

    qemu_put_be32(f, so->so_urgc);

    qemu_put_be16(f, so->so_ffamily);

    switch (so->so_ffamily) {

    case AF_INET:

        qemu_put_be32(f, so->so_faddr.s_addr);

        qemu_put_be16(f, so->so_fport);

        break;

    default:

        error_report(

                ""so_ffamily unknown, unable to save so_faddr and so_fport\n"");

    }

    qemu_put_be16(f, so->so_lfamily);

    switch (so->so_lfamily) {

    case AF_INET:

        qemu_put_be32(f, so->so_laddr.s_addr);

        qemu_put_be16(f, so->so_lport);

        break;

    default:

        error_report(

                ""so_ffamily unknown, unable to save so_laddr and so_lport\n"");

    }

    qemu_put_byte(f, so->so_iptos);

    qemu_put_byte(f, so->so_emu);

    qemu_put_byte(f, so->so_type);

    qemu_put_be32(f, so->so_state);

    slirp_sbuf_save(f, &so->so_rcv);

    slirp_sbuf_save(f, &so->so_snd);

    slirp_tcp_save(f, so->so_tcpcb);

}
",0,0,0,0,2,0,1,1,1,1,0,1,0,0,0
9231,qemu,1,"void object_property_allow_set_link(Object *obj, const char *name,

                                    Object *val, Error **errp)

{

    /* Allow the link to be set, always */

}
",0,0,0,0,0,0,1,0,0,1,1,1,1,1,1
9238,FFmpeg,0,"static inline void mix_3f_1r_to_mono(AC3DecodeContext *ctx)

{

    int i;

    float (*output)[256] = ctx->audio_block.block_output;



    for (i = 0; i < 256; i++)

        output[1][i] = (output[2][i] + output[3][i] + output[4][i]);

    memset(output[2], 0, sizeof(output[2]));

    memset(output[3], 0, sizeof(output[3]));

    memset(output[4], 0, sizeof(output[4]));

}
",1,0,0,0,0,0,1,1,0,0,1,0,1,1,0
9246,FFmpeg,0,"static inline void RENAME(nv21ToUV)(uint8_t *dstU, uint8_t *dstV,

                                    const uint8_t *src1, const uint8_t *src2,

                                    long width, uint32_t *unused)

{

    RENAME(nvXXtoUV)(dstV, dstU, src1, width);

}
",0,0,0,0,0,0,1,0,0,1,1,1,1,1,1
9255,qemu,0,"static uint64_t lan9118_readl(void *opaque, target_phys_addr_t offset,

                              unsigned size)

{

    lan9118_state *s = (lan9118_state *)opaque;



    //DPRINTF(""Read reg 0x%02x\n"", (int)offset);

    if (offset < 0x20) {

        /* RX FIFO */

        return rx_fifo_pop(s);

    }

    switch (offset) {

    case 0x40:

        return rx_status_fifo_pop(s);

    case 0x44:

        return s->rx_status_fifo[s->tx_status_fifo_head];

    case 0x48:

        return tx_status_fifo_pop(s);

    case 0x4c:

        return s->tx_status_fifo[s->tx_status_fifo_head];

    case CSR_ID_REV:

        return 0x01180001;

    case CSR_IRQ_CFG:

        return s->irq_cfg;

    case CSR_INT_STS:

        return s->int_sts;

    case CSR_INT_EN:

        return s->int_en;

    case CSR_BYTE_TEST:

        return 0x87654321;

    case CSR_FIFO_INT:

        return s->fifo_int;

    case CSR_RX_CFG:

        return s->rx_cfg;

    case CSR_TX_CFG:

        return s->tx_cfg;

    case CSR_HW_CFG:

    ",0,0,9,0,1,0,0,0,0,1,0,0,1,1,0
9258,FFmpeg,0,"static int read_low_coeffs(AVCodecContext *avctx, int16_t *dst, int size, int width, ptrdiff_t stride)

{

    PixletContext *ctx = avctx->priv_data;

    GetBitContext *b = &ctx->gbit;

    unsigned cnt1, nbits, k, j = 0, i = 0;

    int64_t value, state = 3;

    int rlen, escape, flag = 0;



    while (i < size) {

        nbits = FFMIN(ff_clz((state >> 8) + 3) ^ 0x1F, 14);



        cnt1 = get_unary(b, 0, 8);

        if (cnt1 < 8) {

            value = show_bits(b, nbits);

            if (value <= 1) {

                skip_bits(b, nbits - 1);

                escape = ((1 << nbits) - 1) * cnt1;

            } else {

                skip_bits(b, nbits);

                escape = value + ((1 << nbits) - 1) * cnt1 - 1;

            }

        } else {

            escape = get_bits(b, 16);

        }



        value = -((escape + flag) & 1) | 1;

        dst[j++] = value * ((escape + flag + 1) >> 1);

        i++;

        if (j == width) {

            j = 0;

            dst += stride;

        }

",0,0,4,0,0,1,0,0,0,0,0,0,1,1,1
9260,qemu,0,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int offset)

{

    BDRVNBDState *s = bs->opaque;

    struct nbd_request request;

    struct nbd_reply reply;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {

        reply.error = errno;

    } else {

        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);

    }

    nbd_coroutine_end(s, &request);

    return -reply.error;



}
",0,0,1,0,0,0,1,1,1,1,0,1,0,0,0
9282,FFmpeg,0,"static int request_frame(AVFilterLink *link)

{

    AVFilterContext *ctx = link->src;

    IDETContext *idet = ctx->priv;



    do {

        int ret;



        if (idet->eof)

            return AVERROR_EOF;



        ret = ff_request_frame(link->src->inputs[0]);



        if (ret == AVERROR_EOF && idet->cur) {

            AVFrame *next = av_frame_clone(idet->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(link->src->inputs[0], next);

            idet->eof = 1;

        } else if (ret < 0) {

            return ret;

        }

    } while (!idet->cur);



    return 0;

}
",0,0,4,0,0,1,1,1,1,1,1,0,1,1,1
9283,FFmpeg,1,"static int dpcm_decode_frame(AVCodecContext *avctx,
                             void *data, int *data_size,
                             uint8_t *buf, int buf_size)
{
    DPCMContext *s = avctx->priv_data;
    int in, out = 0;
    int predictor[2];
    int channel_number = 0;
    short *output_samples = data;
    int shift[2];
    unsigned char byte;
    short diff;
    if (!buf_size)
        return 0;
    switch(avctx->codec->id) {
    case CODEC_ID_ROQ_DPCM:
        if (s->channels == 1)
            predictor[0] = AV_RL16(&buf[6]);
        else {
            predictor[0] = buf[7] << 8;
            predictor[1] = buf[6] << 8;
        }
        SE_16BIT(predictor[0]);
        SE_16BIT(predictor[1]);
        /* decode the samples */
        for (in = 8, out = 0; in < buf_size; in++, out++) {
            predictor[channel_number] += s->roq_square_array[buf[in]];
            predictor[channel_number] = av_clip_int16(predictor[channel_number]);
            output_samples[out] = predictor[channel_number];
       ",1,0,4,0,1,0,0,0,0,1,0,1,1,0,0
9301,FFmpeg,1,"int ff_rm_read_mdpr_codecdata(AVFormatContext *s, AVIOContext *pb,

                              AVStream *st, RMStream *rst,

                              unsigned int codec_data_size, const uint8_t *mime)

{

    unsigned int v;

    int size;

    int64_t codec_pos;

    int ret;



    if (codec_data_size > INT_MAX)

        return AVERROR_INVALIDDATA;



    avpriv_set_pts_info(st, 64, 1, 1000);

    codec_pos = avio_tell(pb);

    v = avio_rb32(pb);



    if (v == MKBETAG('M', 'L', 'T', 'I')) {

        int number_of_streams = avio_rb16(pb);

        int number_of_mdpr;

        int i;

        for (i = 0; i<number_of_streams; i++)

            avio_rb16(pb);

        number_of_mdpr = avio_rb16(pb);

        if (number_of_mdpr != 1) {

            avpriv_request_sample(s, ""MLTI with multiple MDPR"");

        }

        avio_rb32(pb);

        v = avio_rb32(pb);

    }



    if (v == MKTAG(0xfd, 'a', 'r', '.')) {

        /* ra type header */

        if (rm_read_audio_stream_info(s, pb, st, rst, 0))",1,0,5,0,0,0,0,0,0,0,0,0,0,0,0
9330,qemu,1,"int sd_do_command(SDState *sd, SDRequest *req,

                  uint8_t *response) {

    uint32_t last_status = sd->card_status;

    sd_rsp_type_t rtype;

    int rsplen;



    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {

        return 0;

    }



    if (sd_req_crc_validate(req)) {

        sd->card_status &= ~COM_CRC_ERROR;

        return 0;

    }



    sd->card_status &= ~CARD_STATUS_B;

    sd_set_status(sd);



    if (last_status & CARD_IS_LOCKED) {

        if (!cmd_valid_while_locked(sd, req)) {

            sd->card_status |= ILLEGAL_COMMAND;

            fprintf(stderr, ""SD: Card is locked\n"");

            return 0;

        }

    }



    if (last_status & APP_CMD) {

        rtype = sd_app_command(sd, *req);

        sd->card_status &= ~APP_CMD;

    } else

        rtype = sd_normal_command(sd, *req);



    sd->current_cmd = req->cmd;



    switch (rtype) {

    case sd_r1:

    case sd_r1b:

        sd_response_r1_make(sd, response, last_status);

        rsplen ",0,0,5,0,1,1,0,0,0,0,0,0,1,1,1
9343,FFmpeg,0,"static int dpcm_decode_frame(AVCodecContext *avctx,

                             void *data, int *data_size,

                             AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    DPCMContext *s = avctx->priv_data;

    int in, out = 0;

    int predictor[2];

    int ch = 0;

    int stereo = s->channels - 1;

    short *output_samples = data;

    int shift[2];

    unsigned char byte;

    short diff;



    if (!buf_size)

        return 0;



    // almost every DPCM variant expands one byte of data into two

    if(*data_size/2 < buf_size)

        return -1;



    switch(avctx->codec->id) {



    case CODEC_ID_ROQ_DPCM:

        if (stereo) {

            predictor[0] = buf[7] << 8;

            predictor[1] = buf[6] << 8;

        } else {

            predictor[0] = AV_RL16(&buf[6]);

        }

        SE_16BIT(predictor[0]);

        SE_16BIT(predictor[1]);



        /* decode the samples */

        for (in = 8, out = 0; in < buf_size; in",1,0,5,0,1,0,0,1,1,0,0,0,1,1,0
9347,FFmpeg,1,"static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,

                      int *x, int *y, int *plane, int bits_per_plane)

{

    uint8_t *d;

    int shift = *plane * bits_per_plane;

    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;

    value   <<= shift;



    while (run > 0) {

        int j;

        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {

            d = frame->data[0] + *y * frame->linesize[0];

            d[*x] |= (value >> j) & mask;

            *x += 1;

            if (*x == s->width) {

                *y -= 1;

                *x = 0;

                if (*y < 0) {

                   *y = s->height - 1;

                   *plane += 1;

                   if (*plane >= s->nb_planes)

                       return;

                   value <<= bits_per_plane;

                   mask  <<= bits_per_plane;

                }

            }

        }

        run--;

    }

}
",1,0,6,0,0,1,0,0,0,0,0,1,0,0,0
9349,FFmpeg,1,"mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){

    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf));

  mp_image_t* mpi=NULL;

  int w2;

  int number = mp_imgtype >> 16;



  av_assert0(vf->next == NULL); // all existing filters call this just on next



  //vf_dint needs these as it calls vf_get_image() before configuring the output

  if(vf->w==0 && w>0) vf->w=w;

  if(vf->h==0 && h>0) vf->h=h;



  av_assert0(w == -1 || w >= vf->w);

  av_assert0(h == -1 || h >= vf->h);

  av_assert0(vf->w > 0);

  av_assert0(vf->h > 0);



  av_log(m->avfctx, AV_LOG_DEBUG, ""get_image: %d:%d, vf: %d:%d\n"", w,h,vf->w,vf->h);



  if (w == -1) w = vf->w;

  if (h == -1) h = vf->h;



  w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w;



  // Note: we should call libvo first to check if it supports direct rendering

  // and if not, then fallback to software buffers:

  switch(mp_imgtype & 0xff){

  case MP_IMGTYPE_EX",0,0,4,0,1,0,0,0,0,0,0,0,0,1,1
9351,FFmpeg,1,"static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)

{

    Mp4Descr *descr = d->active_descr;

    int predefined;

    if (!descr)

        return -1;



    predefined = avio_r8(&d->pb);

    if (!predefined) {

        int lengths;

        int flags = avio_r8(&d->pb);

        descr->sl.use_au_start       = !!(flags & 0x80);

        descr->sl.use_au_end         = !!(flags & 0x40);

        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);

        descr->sl.use_padding        = !!(flags & 0x08);

        descr->sl.use_timestamps     = !!(flags & 0x04);

        descr->sl.use_idle           = !!(flags & 0x02);

        descr->sl.timestamp_res      = avio_rb32(&d->pb);

                                       avio_rb32(&d->pb);

        descr->sl.timestamp_len      = avio_r8(&d->pb);






        descr->sl.ocr_len            = avio_r8(&d->pb);

        descr->sl.au_len             = avio_r8(&d->pb);

        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);

        lengths         ",0,0,2,0,0,0,0,0,0,0,0,0,1,0,1
9352,qemu,1,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(env, result);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
9366,FFmpeg,1,"static int parse_chunks(AVFormatContext *s, int mode, int64_t seekts, int *len_ptr)

{

    WtvContext *wtv = s->priv_data;

    AVIOContext *pb = wtv->pb;

    while (!url_feof(pb)) {

        ff_asf_guid g;

        int len, sid, consumed;



        ff_get_guid(pb, &g);

        len = avio_rl32(pb);

        if (len < 32)

            break;

        sid = avio_rl32(pb) & 0x7FFF;

        avio_skip(pb, 8);

        consumed = 32;



        if (!ff_guidcmp(g, ff_SBE2_STREAM_DESC_EVENT)) {

            if (ff_find_stream_index(s, sid) < 0) {

                ff_asf_guid mediatype, subtype, formattype;

                int size;

                avio_skip(pb, 28);

                ff_get_guid(pb, &mediatype);

                ff_get_guid(pb, &subtype);

                avio_skip(pb, 12);

                ff_get_guid(pb, &formattype);

                size = avio_rl32(pb);

                parse_media_type(s, 0, sid, mediatype, subtype, formattype, size);

                consumed += 92 + size;

            }",3,0,3,0,0,1,1,1,1,1,1,1,0,0,1
9399,qemu,1,"static void virtio_rng_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);



    dc->props = virtio_rng_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    vdc->realize = virtio_rng_device_realize;

    vdc->unrealize = virtio_rng_device_unrealize;

    vdc->get_features = get_features;

    vdc->load = virtio_rng_load_device;

}
",0,0,0,0,0,0,0,0,0,1,1,1,0,0,0
9418,qemu,1,"int kvm_init(int smp_cpus)
{
    KVMState *s;
    int ret;
    int i;
    if (smp_cpus > 1)
        return -EINVAL;
    s = qemu_mallocz(sizeof(KVMState));
    if (s == NULL)
        return -ENOMEM;
    for (i = 0; i < ARRAY_SIZE(s->slots); i++)
        s->slots[i].slot = i;
    s->vmfd = -1;
    s->fd = open(""/dev/kvm"", O_RDWR);
    if (s->fd == -1) {
        fprintf(stderr, ""Could not access KVM kernel module: %m\n"");
        ret = -errno;
        goto err;
    }
    ret = kvm_ioctl(s, KVM_GET_API_VERSION, 0);
    if (ret < KVM_API_VERSION) {
            ret = -EINVAL;
        fprintf(stderr, ""kvm version too old\n"");
        goto err;
    }
    if (ret > KVM_API_VERSION) {
        ret = -EINVAL;
        fprintf(stderr, ""kvm version not supported\n"");
        goto err;
    }
    s->vmfd = kvm_ioctl(s, KVM_CREATE_VM, 0);
    if (s->vmfd < 0)
        goto err;
    /* initially, KVM allocated its own memory and we had to jump through
     * hooks to make phys_ram_base point to this.  Modern versions of KVM
   ",1,4,6,1,0,0,1,1,1,1,1,1,0,0,0
9434,qemu,1,"static int64_t nfs_client_open(NFSClient *client, const char *filename,

                               int flags, Error **errp)

{

    int ret = -EINVAL, i;

    struct stat st;

    URI *uri;

    QueryParams *qp = NULL;

    char *file = NULL, *strp = NULL;



    uri = uri_parse(filename);

    if (!uri) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    if (!uri->server) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    strp = strrchr(uri->path, '/');

    if (strp == NULL) {

        error_setg(errp, ""Invalid URL specified"");

        goto fail;

    }

    file = g_strdup(strp);

    *strp = 0;



    client->context = nfs_init_context();

    if (client->context == NULL) {

        error_setg(errp, ""Failed to init NFS context"");

        goto fail;

    }



    qp = query_params_parse(uri->query);

    for (i = 0; i < qp->n; i++) {

        if (!qp->p[i].value) {

            error_setg(errp, ""Value for NFS parameter expected: %s",2,4,8,0,0,0,1,1,1,1,1,1,1,1,0
9435,FFmpeg,1,"static int nut_read_header(AVFormatContext * avf, AVFormatParameters * ap) {

    NUTContext * priv = avf->priv_data;

    AVIOContext * bc = avf->pb;

    nut_demuxer_opts_tt dopts = {

        .input = {

            .priv = bc,

            .seek = av_seek,

            .read = av_read,

            .eof = NULL,

            .file_pos = 0,

        },

        .alloc = { av_malloc, av_realloc, av_free },

        .read_index = 1,

        .cache_syncpoints = 1,

    };

    nut_context_tt * nut = priv->nut = nut_demuxer_init(&dopts);

    nut_stream_header_tt * s;

    int ret, i;



    if ((ret = nut_read_headers(nut, &s, NULL))) {

        av_log(avf, AV_LOG_ERROR, "" NUT error: %s\n"", nut_error(ret));


        return -1;




    priv->s = s;



    for (i = 0; s[i].type != -1 && i < 2; i++) {

        AVStream * st = avformat_new_stream(avf, NULL);

        int j;



        for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8);



        st->codec->has_b_frames ",3,0,1,0,0,0,0,0,0,1,1,0,1,1,1
9437,qemu,1,"static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)
{
    CPUState *cs = CPU(dev);
    PowerPCCPU *cpu = POWERPC_CPU(dev);
    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
    Error *local_err = NULL;
#if !defined(CONFIG_USER_ONLY)
    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;
#endif
#if !defined(CONFIG_USER_ONLY)
    if (smp_threads > max_smt) {
        error_setg(errp, ""Cannot support more than %d threads on PPC with %s"",
                   max_smt, kvm_enabled() ? ""KVM"" : ""TCG"");
    if (!is_power_of_2(smp_threads)) {
        error_setg(errp, ""Cannot support %d threads on PPC with %s, ""
                   ""threads count must be a power of 2."",
                   smp_threads, kvm_enabled() ? ""KVM"" : ""TCG"");
#endif
    cpu_exec_init(cs, &local_err);
    if (local_err != NULL) {
        error_propagate(errp, local_err);
#if !defined(CONFIG_USER_ONLY)
    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt
        + (cs->cpu_index % smp_threads);
#endif
    if (tcg_enabled())",0,0,10,0,0,0,1,1,1,1,1,0,1,0,0
9443,qemu,1,"static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)

{

    DeviceState *dev;

    SysBusDevice *s;

    RamDevice *d;



    /* allocate RAM */

    dev = qdev_create(NULL, ""memory"");

    s = sysbus_from_qdev(dev);



    d = FROM_SYSBUS(RamDevice, s);

    d->size = RAM_size;

    qdev_init(dev);



    sysbus_mmio_map(s, 0, addr);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
9445,qemu,1,"QemuOpts *qemu_chr_parse_compat(const char *label, const char *filename)

{

    char host[65], port[33], width[8], height[8];

    int pos;

    const char *p;

    QemuOpts *opts;

    Error *local_err = NULL;



    opts = qemu_opts_create(qemu_find_opts(""chardev""), label, 1, &local_err);

    if (error_is_set(&local_err)) {

        qerror_report_err(local_err);

        error_free(local_err);

        return NULL;

    }



    if (strstart(filename, ""mon:"", &p)) {

        filename = p;

        qemu_opt_set(opts, ""mux"", ""on"");

        if (strcmp(filename, ""stdio"") == 0) {

            /* Monitor is muxed to stdio: do not exit on Ctrl+C by default

             * but pass it to the guest.  Handle this only for compat syntax,

             * for -chardev syntax we have special option for this.

             * This is what -nographic did, redirecting+muxing serial+monitor

             * to stdio causing Ctrl+C to be passed to guest. */

            qemu_opt_set(opts, ""signal"", ""off"");

        }

    }
",3,0,3,0,0,0,1,1,1,0,0,1,0,0,0
9457,qemu,1,"POWERPC_FAMILY(POWER8)(ObjectClass *oc, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(oc);

    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);



    dc->fw_name = ""PowerPC,POWER8"";

    dc->desc = ""POWER8"";

    pcc->pvr = CPU_POWERPC_POWER8_BASE;

    pcc->pvr_mask = CPU_POWERPC_POWER8_MASK;

    pcc->init_proc = init_proc_POWER7;

    pcc->check_pow = check_pow_nocheck;

    pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |

                       PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |

                       PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |

                       PPC_FLOAT_STFIWX |


                       PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |

                       PPC_MEM_SYNC | PPC_MEM_EIEIO |

                       PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |

                       PPC_64B | PPC_ALTIVEC |

                       PPC_SEGMENT_64B | PPC_SLBI |

                       PPC_POPCNTB | PPC_POPCNTWD;

    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_D",0,0,0,0,0,0,0,0,0,1,0,1,1,1,1
9482,FFmpeg,0,"static int parse_object_segment(AVCodecContext *avctx,

                                  const uint8_t *buf, int buf_size)

{

    PGSSubContext *ctx = avctx->priv_data;

    PGSSubObject *object;



    uint8_t sequence_desc;

    unsigned int rle_bitmap_len, width, height;

    int id;



    if (buf_size <= 4)

        return AVERROR_INVALIDDATA;

    buf_size -= 4;



    id = bytestream_get_be16(&buf);

    object = find_object(id, &ctx->objects);

    if (!object) {

        if (ctx->objects.count >= MAX_EPOCH_OBJECTS) {

            av_log(avctx, AV_LOG_ERROR, ""Too many objects in epoch\n"");

            return AVERROR_INVALIDDATA;

        }

        object = &ctx->objects.object[ctx->objects.count++];

        object->id = id;

    }



    /* skip object version number */

    buf += 1;



    /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */

    sequence_desc = bytestream_get_byte(&buf);



    if (!(sequence_desc & 0x80)) {

        /* Additional R",0,0,4,0,0,0,1,1,1,1,1,0,1,0,1
9508,qemu,1,"static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,

        RDMALocalBlock *block, uintptr_t host_addr,

        uint32_t *lkey, uint32_t *rkey, int chunk,

        uint8_t *chunk_start, uint8_t *chunk_end)

{

    if (block->mr) {

        if (lkey) {

            *lkey = block->mr->lkey;

        }

        if (rkey) {

            *rkey = block->mr->rkey;

        }

        return 0;

    }



    /* allocate memory to store chunk MRs */

    if (!block->pmr) {

        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));

    }



    /*

     * If 'rkey', then we're the destination, so grant access to the source.

     *

     * If 'lkey', then we're the source VM, so grant access only to ourselves.

     */

    if (!block->pmr[chunk]) {

        uint64_t len = chunk_end - chunk_start;



        trace_qemu_rdma_register_and_get_keys(len, chunk_start);



        block->pmr[chunk] = ibv_reg_mr(rdma->pd,

                chunk_start, len,

                (rkey ? (IBV_ACCESS_LO",0,0,5,0,0,0,0,1,1,1,1,1,0,0,0
9509,qemu,1,"static void vga_draw_graphic(VGAState *s, int full_update)

{

    int y1, y, update, page_min, page_max, linesize, y_start, double_scan, mask, depth;

    int width, height, shift_control, line_offset, page0, page1, bwidth, bits;

    int disp_width, multi_scan, multi_run;

    uint8_t *d;

    uint32_t v, addr1, addr;

    vga_draw_line_func *vga_draw_line;



    full_update |= update_basic_params(s);



    if (!full_update)

        vga_sync_dirty_bitmap(s);



    s->get_resolution(s, &width, &height);

    disp_width = width;



    shift_control = (s->gr[0x05] >> 5) & 3;

    double_scan = (s->cr[0x09] >> 7);

    if (shift_control != 1) {

        multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1;

    } else {

        /* in CGA modes, multi_scan is ignored */

        /* XXX: is it correct ? */

        multi_scan = double_scan;

    }

    multi_run = multi_scan;

    if (shift_control != s->shift_control ||

        double_scan != s->double_scan) {

        full_update = 1;

        s-",0,0,8,0,0,0,1,1,1,1,1,1,0,0,1
9510,qemu,1,"static int qemu_signalfd_compat(const sigset_t *mask)

{

    pthread_attr_t attr;

    pthread_t tid;

    struct sigfd_compat_info *info;

    int fds[2];



    info = malloc(sizeof(*info));

    if (info == NULL) {

        errno = ENOMEM;

        return -1;

    }



    if (pipe(fds) == -1) {

        free(info);

        return -1;

    }



    memcpy(&info->mask, mask, sizeof(*mask));

    info->fd = fds[1];



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);



    pthread_create(&tid, &attr, sigwait_compat, info);



    pthread_attr_destroy(&attr);



    return fds[0];

}
",0,0,2,0,0,0,0,0,0,1,1,1,1,1,1
9516,qemu,1,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
",0,0,2,0,0,0,1,1,1,1,1,0,1,1,1
9528,FFmpeg,1,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,

                                  cavs_vector *col_mv)

{

    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;

    int den = h->direct_den[col_mv->ref];

    int m = FF_SIGNBIT(col_mv->x);



    pmv_fw->dist = h->dist[1];

    pmv_bw->dist = h->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

    m = FF_SIGNBIT(col_mv->y);

    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

}
",0,0,0,0,0,0,0,1,0,1,1,1,1,1,1
9533,FFmpeg,0,"static inline void h264_deblock_q1(register vector unsigned char p0,

                                                   register vector unsigned char p1,

                                                   register vector unsigned char p2,

                                                   register vector unsigned char q0,

                                                   register vector unsigned char tc0) {



    register vector unsigned char average = vec_avg(p0, q0);

    register vector unsigned char temp;

    register vector unsigned char uncliped;

    register vector unsigned char ones;

    register vector unsigned char max;

    register vector unsigned char min;



    temp = vec_xor(average, p2);

    average = vec_avg(average, p2);     /*avg(p2, avg(p0, q0)) */

    ones = vec_splat_u8(1);

    temp = vec_and(temp, ones);         /*(p2^avg(p0, q0)) & 1 */

    uncliped = vec_subs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */

    max = vec_adds(p1, tc0);

    min = vec_subs(p1, tc0);

    p1 =",0,0,0,0,0,0,1,0,1,0,0,0,1,0,0
9546,qemu,0,"static inline void gen_branch_a(DisasContext *dc, target_ulong pc1,

                                target_ulong pc2, TCGv r_cond)

{

    int l1;



    l1 = gen_new_label();



    tcg_gen_brcondi_tl(TCG_COND_EQ, r_cond, 0, l1);



    gen_goto_tb(dc, 0, pc2, pc1);



    gen_set_label(l1);

    gen_goto_tb(dc, 1, pc2 + 4, pc2 + 8);

}
",0,2,0,0,0,0,0,0,0,0,0,0,1,1,1
9548,qemu,0,"uint64_t qcow2_alloc_cluster_offset(BlockDriverState *bs,

                                    uint64_t offset,

                                    int n_start, int n_end,

                                    int *num, QCowL2Meta *m)

{

    BDRVQcowState *s = bs->opaque;

    int l2_index, ret;

    uint64_t l2_offset, *l2_table, cluster_offset;

    int nb_clusters, i = 0;

    QCowL2Meta *old_alloc;



    ret = get_cluster_table(bs, offset, &l2_table, &l2_offset, &l2_index);

    if (ret == 0)

        return 0;



    nb_clusters = size_to_clusters(s, n_end << 9);



    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);



    cluster_offset = be64_to_cpu(l2_table[l2_index]);



    /* We keep all QCOW_OFLAG_COPIED clusters */



    if (cluster_offset & QCOW_OFLAG_COPIED) {

        nb_clusters = count_contiguous_clusters(nb_clusters, s->cluster_size,

                &l2_table[l2_index], 0, 0);



        cluster_offset &= ~QCOW_OFLAG_COPIED;

        m->nb_clusters = 0;



        goto out;

   ",0,1,2,0,0,0,0,0,0,0,0,0,0,0,0
9574,qemu,0,"static int tx_consume(Rocker *r, DescInfo *info)

{

    PCIDevice *dev = PCI_DEVICE(r);

    char *buf = desc_get_buf(info, true);

    RockerTlv *tlv_frag;

    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];

    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };

    uint32_t pport;

    uint32_t port;

    uint16_t tx_offload = ROCKER_TX_OFFLOAD_NONE;

    uint16_t tx_l3_csum_off = 0;

    uint16_t tx_tso_mss = 0;

    uint16_t tx_tso_hdr_len = 0;

    int iovcnt = 0;

    int err = ROCKER_OK;

    int rem;

    int i;



    if (!buf) {

        return -ROCKER_ENXIO;

    }



    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));



    if (!tlvs[ROCKER_TLV_TX_FRAGS]) {

        return -ROCKER_EINVAL;

    }



    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));

    if (!fp_port_from_pport(pport, &port)) {

        return -ROCKER_EINVAL;

    }



    if (tlvs[ROCKER_TLV_TX_OFFLOAD]) {

        tx_offload = rocker_tlv_get_u8(tlvs[ROCKER_TLV_TX_OFFLOAD]);

    }



    switch (",0,0,4,0,1,0,0,0,0,0,0,0,0,0,0
9576,FFmpeg,0,"AVFilterFormats *avfilter_all_colorspaces(void)

{

    return avfilter_make_format_list(35,

                PIX_FMT_YUV444P,  PIX_FMT_YUV422P,  PIX_FMT_YUV420P,

                PIX_FMT_YUV411P,  PIX_FMT_YUV410P,

                PIX_FMT_YUYV422,  PIX_FMT_UYVY422,  PIX_FMT_UYYVYY411,

                PIX_FMT_YUVJ444P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ420P,

                PIX_FMT_YUV440P,  PIX_FMT_YUVJ440P,

                PIX_FMT_RGB32,    PIX_FMT_BGR32,

                PIX_FMT_RGB32_1,  PIX_FMT_BGR32_1,

                PIX_FMT_RGB24,    PIX_FMT_BGR24,

                PIX_FMT_RGB565,   PIX_FMT_BGR565,

                PIX_FMT_RGB555,   PIX_FMT_BGR555,

                PIX_FMT_RGB8,     PIX_FMT_BGR8,

                PIX_FMT_RGB4_BYTE,PIX_FMT_BGR4_BYTE,

                PIX_FMT_GRAY16BE, PIX_FMT_GRAY16LE,

                PIX_FMT_GRAY8,    PIX_FMT_PAL8,

                PIX_FMT_MONOWHITE,PIX_FMT_MONOBLACK

                PIX_FMT_NV12,     PIX_FMT_NV21);

}
",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
9584,qemu,0,"MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,

              CharDriverState *chrA, CharDriverState *chrB,

              int clock, int it_shift)

{

    DeviceState *dev;

    SysBusDevice *s;

    SerialState *d;



    dev = qdev_create(NULL, ""escc"");

    qdev_prop_set_uint32(dev, ""disabled"", 0);

    qdev_prop_set_uint32(dev, ""frequency"", clock);

    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);

    qdev_prop_set_chr(dev, ""chrB"", chrB);

    qdev_prop_set_chr(dev, ""chrA"", chrA);

    qdev_prop_set_uint32(dev, ""chnBtype"", ser);

    qdev_prop_set_uint32(dev, ""chnAtype"", ser);

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irqB);

    sysbus_connect_irq(s, 1, irqA);

    if (base) {

        sysbus_mmio_map(s, 0, base);

    }



    d = FROM_SYSBUS(SerialState, s);

    return &d->mmio;

}
",0,0,4,0,0,0,1,0,1,0,0,0,1,1,1
9598,FFmpeg,1,"static void free_geotags(TiffContext *const s)

{

    int i;

    for (i = 0; i < s->geotag_count; i++) {

        if (s->geotags[i].val)

            av_freep(&s->geotags[i].val);

    }

    av_freep(&s->geotags);


}",1,0,2,0,0,0,1,0,0,0,1,0,0,1,0
9607,FFmpeg,1,"void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}
",2,0,0,0,0,0,0,1,1,1,1,1,1,1,1
9616,qemu,1,"PCIBus *pci_pmac_init(qemu_irq *pic)

{

    DeviceState *dev;

    SysBusDevice *s;

    UNINState *d;



    /* Use values found on a real PowerMac */

    /* Uninorth main bus */

    dev = qdev_create(NULL, ""Uni-north main"");

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    d = FROM_SYSBUS(UNINState, s);

    d->host_state.bus = pci_register_bus(&d->busdev.qdev, ""pci"",

                                         pci_unin_set_irq, pci_unin_map_irq,

                                         pic, 11 << 3, 4);



    pci_create_simple(d->host_state.bus, 11 << 3, ""Uni-north main"");



    sysbus_mmio_map(s, 0, 0xf2800000);

    sysbus_mmio_map(s, 1, 0xf2c00000);



    /* DEC 21154 bridge */

#if 0

    /* XXX: not activated as PPC BIOS doesn't handle multiple buses properly */

    pci_create_simple(d->host_state.bus, 12 << 3, ""DEC 21154"");

#endif



    /* Uninorth AGP bus */

    pci_create_simple(d->host_state.bus, 13 << 3, ""Uni-north AGP"");



    /* Uninorth internal bus */

#if 0

    /* ",0,0,3,0,0,0,0,0,0,0,1,1,1,0,1
9619,qemu,0,"static void json_message_process_token(JSONLexer *lexer, GString *input,

                                       JSONTokenType type, int x, int y)

{

    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);

    QDict *dict;



    switch (type) {

    case JSON_LCURLY:

        parser->brace_count++;

        break;

    case JSON_RCURLY:

        parser->brace_count--;

        break;

    case JSON_LSQUARE:

        parser->bracket_count++;

        break;

    case JSON_RSQUARE:

        parser->bracket_count--;

        break;

    default:

        break;

    }



    dict = qdict_new();

    qdict_put(dict, ""type"", qint_from_int(type));

    qdict_put(dict, ""token"", qstring_from_str(input->str));

    qdict_put(dict, ""x"", qint_from_int(x));

    qdict_put(dict, ""y"", qint_from_int(y));



    parser->token_size += input->len;



    g_queue_push_tail(parser->tokens, dict);



    if (type == JSON_ERROR) {

        goto out_emit_bad;

    } else if (parser->brace_count < 0 ||

   ",0,1,2,0,1,0,1,0,0,0,1,0,1,1,0
9629,qemu,0,"static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,

                                              target_ulong eaddr, uint32_t pid)

{

#if !defined(FLUSH_ALL_TLBS)

    CPUState *cs = CPU(ppc_env_get_cpu(env));

    ppcemb_tlb_t *tlb;

    hwaddr raddr;

    target_ulong page, end;

    int i;



    for (i = 0; i < env->nb_tlb; i++) {

        tlb = &env->tlb.tlbe[i];

        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {

            end = tlb->EPN + tlb->size;

            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {

                tlb_flush_page(cs, page);

            }

            tlb->prot &= ~PAGE_VALID;

            break;

        }

    }

#else

    ppc4xx_tlb_invalidate_all(env);

#endif

}
",2,0,3,0,0,0,0,0,0,0,0,0,1,0,0
9630,qemu,0,"void pci_bridge_initfn(PCIDevice *dev, const char *typename)

{

    PCIBus *parent = dev->bus;

    PCIBridge *br = PCI_BRIDGE(dev);

    PCIBus *sec_bus = &br->sec_bus;



    pci_word_test_and_set_mask(dev->config + PCI_STATUS,

                               PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);



    /*

     * TODO: We implement VGA Enable in the Bridge Control Register

     * therefore per the PCI to PCI bridge spec we must also implement

     * VGA Palette Snooping.  When done, set this bit writable:

     *

     * pci_word_test_and_set_mask(dev->wmask + PCI_COMMAND,

     *                            PCI_COMMAND_VGA_PALETTE);

     */



    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);

    dev->config[PCI_HEADER_TYPE] =

        (dev->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;

    pci_set_word(dev->config + PCI_SEC_STATUS,

                 PCI_STATUS_66MHZ | PCI_STATUS_FAST_BACK);



    /*

     * If we don't specify the name, ",1,0,1,0,0,0,1,1,0,0,1,1,1,1,0
9639,qemu,0,"void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,

                              int width, int y)

{

    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,

                           0, y, 0, 0, 0, 0, width, 1);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
9643,qemu,0,"static inline abi_long target_to_host_cmsg(struct msghdr *msgh,

                                           struct target_msghdr *target_msgh)

{

    struct cmsghdr *cmsg = CMSG_FIRSTHDR(msgh);

    abi_long msg_controllen;

    abi_ulong target_cmsg_addr;

    struct target_cmsghdr *target_cmsg;

    socklen_t space = 0;

    

    msg_controllen = tswapal(target_msgh->msg_controllen);

    if (msg_controllen < sizeof (struct target_cmsghdr)) 

        goto the_end;

    target_cmsg_addr = tswapal(target_msgh->msg_control);

    target_cmsg = lock_user(VERIFY_READ, target_cmsg_addr, msg_controllen, 1);

    if (!target_cmsg)

        return -TARGET_EFAULT;



    while (cmsg && target_cmsg) {

        void *data = CMSG_DATA(cmsg);

        void *target_data = TARGET_CMSG_DATA(target_cmsg);



        int len = tswapal(target_cmsg->cmsg_len)

                  - TARGET_CMSG_ALIGN(sizeof (struct target_cmsghdr));



        space += CMSG_SPACE(len);

        if (space > msgh->msg_controllen) {

            sp",0,1,3,0,0,1,0,0,0,0,0,0,0,1,1
9647,qemu,0,"static bool ga_open_pidfile(const char *pidfile)

{

    int pidfd;

    char pidstr[32];



    pidfd = open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);

    if (pidfd == -1 || lockf(pidfd, F_TLOCK, 0)) {

        g_critical(""Cannot lock pid file, %s"", strerror(errno));

        if (pidfd != -1) {

            close(pidfd);

        }

        return false;

    }



    if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEK_SET)) {

        g_critical(""Failed to truncate pid file"");

        goto fail;

    }

    sprintf(pidstr, ""%d"", getpid());

    if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) {

        g_critical(""Failed to write pid file"");

        goto fail;

    }



    return true;



fail:

    unlink(pidfile);

    return false;

}
",0,2,4,0,0,0,1,1,1,1,1,1,0,0,0
9650,qemu,1,"static void handle_pending_signal(CPUArchState *cpu_env, int sig)

{

    CPUState *cpu = ENV_GET_CPU(cpu_env);

    abi_ulong handler;

    sigset_t set, old_set;

    target_sigset_t target_old_set;

    struct target_sigaction *sa;

    struct sigqueue *q;

    TaskState *ts = cpu->opaque;

    struct emulated_sigtable *k = &ts->sigtab[sig - 1];



    trace_user_handle_signal(cpu_env, sig);

    /* dequeue signal */

    q = k->first;

    k->first = q->next;

    if (!k->first)

        k->pending = 0;



    sig = gdb_handlesig(cpu, sig);

    if (!sig) {

        sa = NULL;

        handler = TARGET_SIG_IGN;

    } else {

        sa = &sigact_table[sig - 1];

        handler = sa->_sa_handler;

    }



    if (ts->sigsegv_blocked && sig == TARGET_SIGSEGV) {

        /* Guest has blocked SIGSEGV but we got one anyway. Assume this

         * is a forced SIGSEGV (ie one the kernel handles via force_sig_info

         * because it got a real MMU fault), and treat as if default handler.

         */

   ",2,0,4,0,0,0,0,0,0,1,1,1,0,1,0
9651,qemu,1,"static void pcie_pci_bridge_write_config(PCIDevice *d,

        uint32_t address, uint32_t val, int len)

{

    pci_bridge_write_config(d, address, val, len);

    msi_write_config(d, address, val, len);

    shpc_cap_write_config(d, address, val, len);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
9670,qemu,0,"static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
",0,0,4,0,0,0,0,0,0,0,0,0,0,0,1
9683,qemu,0,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
9706,qemu,0,"static int scsi_disk_emulate_command(SCSIDiskReq *r, uint8_t *outbuf)

{

    SCSIRequest *req = &r->req;

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    uint64_t nb_sectors;

    int buflen = 0;

    int ret;



    switch (req->cmd.buf[0]) {

    case TEST_UNIT_READY:

        if (!bdrv_is_inserted(s->bs))

            goto not_ready;

        break;

    case REQUEST_SENSE:

        if (req->cmd.xfer < 4)

            goto illegal_request;

        buflen = scsi_device_get_sense(&s->qdev, outbuf, req->cmd.xfer,

                                       (req->cmd.buf[1] & 1) == 0);

        break;

    case INQUIRY:

        buflen = scsi_disk_emulate_inquiry(req, outbuf);

        if (buflen < 0)

            goto illegal_request;

        break;

    case MODE_SENSE:

    case MODE_SENSE_10:

        buflen = scsi_disk_emulate_mode_sense(req, outbuf);

        if (buflen < 0)

            goto illegal_request;

        break;

    case READ_TOC:

        buflen = scsi_disk_emulate_rea",0,4,4,0,1,0,0,0,0,0,0,0,0,0,0
9707,qemu,0,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
",0,0,2,0,0,1,0,1,1,0,0,0,1,1,1
9709,qemu,0,"static int validate_guest_space(unsigned long guest_base,

                                unsigned long guest_size)

{

    unsigned long real_start, test_page_addr;



    /* We need to check that we can force a fault on access to the

     * commpage at 0xffff0fxx

     */

    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);



    /* If the commpage lies within the already allocated guest space,

     * then there is no way we can allocate it.

     */

    if (test_page_addr >= guest_base

        && test_page_addr <= (guest_base + guest_size)) {

        return -1;

    }



    /* Note it needs to be writeable to let us initialise it */

    real_start = (unsigned long)

                 mmap((void *)test_page_addr, qemu_host_page_size,

                     PROT_READ | PROT_WRITE,

                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);



    /* If we can't map it then try another address */

    if (real_start == -1ul) {

        return 0;

    }



    if (real_s",1,0,3,0,0,0,0,0,0,0,0,0,1,1,1
9721,qemu,1,"long do_sigreturn(CPUCRISState *env)

{

	struct target_signal_frame *frame;

	abi_ulong frame_addr;

	target_sigset_t target_set;

	sigset_t set;

	int i;



	frame_addr = env->regs[R_SP];

	/* Make sure the guest isn't playing games.  */

	if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 1))

		goto badframe;



	/* Restore blocked signals */

	if (__get_user(target_set.sig[0], &frame->sc.oldmask))

		goto badframe;

	for(i = 1; i < TARGET_NSIG_WORDS; i++) {

		if (__get_user(target_set.sig[i], &frame->extramask[i - 1]))

			goto badframe;

	}

	target_to_host_sigset_internal(&set, &target_set);

        do_sigprocmask(SIG_SETMASK, &set, NULL);



	restore_sigcontext(&frame->sc, env);

	unlock_user_struct(frame, frame_addr, 0);

	return env->regs[10];

  badframe:

	unlock_user_struct(frame, frame_addr, 0);

	force_sig(TARGET_SIGSEGV);

}
",2,3,3,0,0,0,0,0,0,1,0,0,0,0,0
9722,qemu,1,"static void usbredir_interrupt_packet(void *priv, uint32_t id,

    struct usb_redir_interrupt_packet_header *interrupt_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = interrupt_packet->endpoint;



    DPRINTF(""interrupt-in status %d ep %02X len %d id %u\n"",

            interrupt_packet->status, ep, data_len, id);



    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {

        ERROR(""received int packet for non interrupt endpoint %02X\n"", ep);

        free(data);

        return;

    }



    if (ep & USB_DIR_IN) {

        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {

            DPRINTF(""received int packet while not started ep %02X\n"", ep);

            free(data);

            return;

        }



        /* bufp_alloc also adds the packet to the ep queue */

        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);

    } else {

        int len = interrupt_packet->length;



        AsyncURB *aurb = async_find(dev, i",1,0,3,0,0,1,1,0,1,1,1,1,1,1,0
9727,FFmpeg,0,"void mpeg1_encode_mb(MpegEncContext *s,

                     DCTELEM block[6][64],

                     int motion_x, int motion_y)

{

    int i, cbp;

    const int mb_x = s->mb_x;

    const int mb_y = s->mb_y;

    const int first_mb= mb_x == s->resync_mb_x && mb_y == s->resync_mb_y;



    /* compute cbp */

    cbp = 0;

    for(i=0;i<6;i++) {

        if (s->block_last_index[i] >= 0)

            cbp |= 1 << (5 - i);

    }

    

    if (cbp == 0 && !first_mb && (mb_x != s->mb_width - 1 || (mb_y != s->mb_height - 1 && s->codec_id == CODEC_ID_MPEG1VIDEO)) && 

        ((s->pict_type == P_TYPE && s->mv_type == MV_TYPE_16X16 && (motion_x | motion_y) == 0) ||

        (s->pict_type == B_TYPE && s->mv_dir == s->last_mv_dir && (((s->mv_dir & MV_DIR_FORWARD) ? ((s->mv[0][0][0] - s->last_mv[0][0][0])|(s->mv[0][0][1] - s->last_mv[0][0][1])) : 0) |

        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {

        s->mb_skip_run++",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
9744,qemu,0,"static void virtio_ccw_device_realize(VirtioCcwDevice *dev, Error **errp)

{

    unsigned int cssid = 0;

    unsigned int ssid = 0;

    unsigned int schid;

    unsigned int devno;

    bool have_devno = false;

    bool found = false;

    SubchDev *sch;

    int num;

    DeviceState *parent = DEVICE(dev);

    Error *err = NULL;

    VirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);

    VirtIODevice *vdev;



    sch = g_malloc0(sizeof(SubchDev));



    sch->driver_data = dev;

    dev->sch = sch;



    dev->indicators = NULL;



    /* Initialize subchannel structure. */

    sch->channel_prog = 0x0;

    sch->last_cmd_valid = false;

    sch->thinint_active = false;

    /*

     * Use a device number if provided. Otherwise, fall back to subchannel

     * number.

     */

    if (dev->bus_id) {

        num = sscanf(dev->bus_id, ""%x.%x.%04x"", &cssid, &ssid, &devno);

        if (num == 3) {

            if ((cssid > MAX_CSSID) || (ssid > MAX_SSID)) {

                error_setg(errp, ""I",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
9754,qemu,0,"void op_cp1_registers(void)

{

    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {

        CALL_FROM_TB1(do_raise_exception, EXCP_RI);

    }

    RETURN();

}
",0,0,1,0,0,0,0,0,1,1,1,1,0,0,0
9761,FFmpeg,1,"static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)

{

	unsigned i;

#ifdef HAVE_MMX

	long mmx_size= 23 - src_size;

	asm volatile (

		""test %%""REG_a"", %%""REG_a""	\n\t""

		""jns 2f				\n\t""

		""movq ""MANGLE(mask24r)"", %%mm5	\n\t""

		""movq ""MANGLE(mask24g)"", %%mm6	\n\t""

		""movq ""MANGLE(mask24b)"", %%mm7	\n\t""

		ASMALIGN(4)

		""1:				\n\t""

		PREFETCH"" 32(%1, %%""REG_a"")	\n\t""

		""movq   (%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG

		""movq   (%1, %%""REG_a""), %%mm1	\n\t"" // BGR BGR BG

		""movq  2(%1, %%""REG_a""), %%mm2	\n\t"" // R BGR BGR B

		""psllq $16, %%mm0		\n\t"" // 00 BGR BGR

		""pand %%mm5, %%mm0		\n\t""

		""pand %%mm6, %%mm1		\n\t""

		""pand %%mm7, %%mm2		\n\t""

		""por %%mm0, %%mm1		\n\t""

		""por %%mm2, %%mm1		\n\t""

		""movq  6(%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG

		MOVNTQ"" %%mm1,   (%2, %%""REG_a"")\n\t"" // RGB RGB RG

		""movq  8(%1, %%""REG_a""), %%mm1	\n\t"" // R BGR BGR B

		""movq 10(%1, %%""REG_a""), %%mm2	\n\t"" // GR BGR BGR

		""pand %%mm7, %%mm0		\n\t""

		""pand %%mm",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
9772,FFmpeg,1,"static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);",0,0,2,0,0,0,1,1,0,0,1,1,1,0,1
9781,FFmpeg,1,"static int decode_frame(AVCodecContext *avctx, void *data,

                        int *got_frame, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    H264Context *h     = avctx->priv_data;

    AVFrame *pict      = data;

    int buf_index      = 0;

    Picture *out;

    int i, out_idx;

    int ret;



    h->flags  = avctx->flags;



    /* end of stream, output what is still in the buffers */

    if (buf_size == 0) {

 out:



        h->cur_pic_ptr = NULL;

        h->first_field = 0;



        // FIXME factorize this with the output code below

        out     = h->delayed_pic[0];

        out_idx = 0;

        for (i = 1;

             h->delayed_pic[i] &&

             !h->delayed_pic[i]->f.key_frame &&

             !h->delayed_pic[i]->mmco_reset;

             i++)

            if (h->delayed_pic[i]->poc < out->poc) {

                out     = h->delayed_pic[i];

                out_idx = i;

            }



        for (i = out_idx; h->delay",2,0,2,0,0,0,0,0,0,0,0,0,0,1,0
9787,qemu,1,"GIOStatus ga_channel_write_all(GAChannel *c, const char *buf, size_t size)

{

    GIOStatus status = G_IO_STATUS_NORMAL;

    size_t count;



    while (size) {

        status = ga_channel_write(c, buf, size, &count);

        if (status == G_IO_STATUS_NORMAL) {

            size -= count;

            buf += count;

        } else if (status != G_IO_STATUS_AGAIN) {

            break;

        }

    }



    return status;

}
",0,0,2,0,0,1,1,1,0,0,1,0,0,0,1
9789,FFmpeg,1,"static int channelmap_query_formats(AVFilterContext *ctx)

{

    ChannelMapContext *s = ctx->priv;



    ff_set_common_formats(ctx, ff_planar_sample_fmts());

    ff_set_common_samplerates(ctx, ff_all_samplerates());

    ff_channel_layouts_ref(ff_all_channel_layouts(), &ctx->inputs[0]->out_channel_layouts);

    ff_channel_layouts_ref(s->channel_layouts,       &ctx->outputs[0]->in_channel_layouts);



    return 0;

}
",2,0,0,0,0,0,0,0,0,0,0,0,1,1,1
9805,qemu,0,"static void flush_queued_work(CPUState *env)

{

    struct qemu_work_item *wi;



    if (!env->queued_work_first)

        return;



    while ((wi = env->queued_work_first)) {

        env->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

    }

    env->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
",0,0,1,0,0,1,0,0,0,0,0,0,1,1,1
9817,qemu,0,"static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,

                           struct iovec *iov, int niov, bool create,

                           enum AIOCBState aiocb_type)

{

    int nr_copies = s->inode.nr_copies;

    SheepdogObjReq hdr;

    unsigned int wlen;

    int ret;

    uint64_t oid = aio_req->oid;

    unsigned int datalen = aio_req->data_len;

    uint64_t offset = aio_req->offset;

    uint8_t flags = aio_req->flags;

    uint64_t old_oid = aio_req->base_oid;



    if (!nr_copies) {

        error_report(""bug"");

    }



    memset(&hdr, 0, sizeof(hdr));



    if (aiocb_type == AIOCB_READ_UDATA) {

        wlen = 0;

        hdr.opcode = SD_OP_READ_OBJ;

        hdr.flags = flags;

    } else if (create) {

        wlen = datalen;

        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;

        hdr.flags = SD_FLAG_CMD_WRITE | flags;

    } else {

        wlen = datalen;

        hdr.opcode = SD_OP_WRITE_OBJ;

        hdr.flags = SD_FLAG_CMD_WRITE | flags;

    }
",0,0,3,0,0,0,0,0,0,1,1,1,0,0,0
9842,FFmpeg,1,"static int img_write_packet(AVFormatContext *s, int stream_index,

                            UINT8 *buf, int size)

{

    VideoData *img = s->priv_data;

    AVStream *st = s->streams[stream_index];

    ByteIOContext pb1, *pb;

    AVPicture picture;

    int width, height, ret, size1;

    char filename[1024];



    width = st->codec.width;

    height = st->codec.height;



    switch(st->codec.pix_fmt) {

    case PIX_FMT_YUV420P:

        size1 = (width * height * 3) / 2;

        if (size != size1)

            return -EIO;

        

        picture.data[0] = buf;

        picture.data[1] = picture.data[0] + width * height;

        picture.data[2] = picture.data[1] + (width * height) / 4;

        picture.linesize[0] = width;

        picture.linesize[1] = width >> 1; 

        picture.linesize[2] = width >> 1;

        break;

    case PIX_FMT_RGB24:

        size1 = (width * height * 3);

        if (size != size1)

            return -EIO;

        picture.data[0] = buf;

        picture.linesi",0,0,2,0,1,0,1,0,1,0,0,0,1,1,1
9845,qemu,1,"int pci_drive_hot_add(Monitor *mon, const QDict *qdict, DriveInfo *dinfo)

{

    /* On non-x86 we don't do PCI hotplug */

    monitor_printf(mon, ""Can't hot-add drive to type %d\n"", dinfo->type);

    return -1;

}
",0,0,0,0,0,0,0,1,1,1,1,1,0,0,0
9846,FFmpeg,1,"static inline int yv12toyuy2_unscaled_altivec(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

     int srcSliceH, uint8_t* dstParam[], int dstStride_a[]) {

  uint8_t *dst=dstParam[0] + dstStride_a[0]*srcSliceY;

  // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] );

  uint8_t *ysrc = src[0];

  uint8_t *usrc = src[1];

  uint8_t *vsrc = src[2];

  const int width = c->srcW;

  const int height = srcSliceH;

  const int lumStride = srcStride[0];

  const int chromStride = srcStride[1];

  const int dstStride = dstStride_a[0];

  const vector unsigned char yperm = vec_lvsl(0, ysrc);

  const int vertLumPerChroma = 2;

  register unsigned int y;



  if(width&15){

    yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride);

    return srcSliceH;

  }



  /* this code assume:



  1) dst is 16 bytes-aligned

  2) dstStride is a multiple of 16

  3) width is a multiple of 16

  4) lum&chrom stride are multiple of 8
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
9864,qemu,0,"void cpu_loop(CPUAlphaState *env)

{

    CPUState *cs = CPU(alpha_env_get_cpu(env));

    int trapnr;

    target_siginfo_t info;

    abi_long sysret;



    while (1) {

        cpu_exec_start(cs);

        trapnr = cpu_alpha_exec(cs);

        cpu_exec_end(cs);



        /* All of the traps imply a transition through PALcode, which

           implies an REI instruction has been executed.  Which means

           that the intr_flag should be cleared.  */

        env->intr_flag = 0;



        switch (trapnr) {

        case EXCP_RESET:

            fprintf(stderr, ""Reset requested. Exit\n"");

            exit(EXIT_FAILURE);

            break;

        case EXCP_MCHK:

            fprintf(stderr, ""Machine check exception. Exit\n"");

            exit(EXIT_FAILURE);

            break;

        case EXCP_SMP_INTERRUPT:

        case EXCP_CLK_INTERRUPT:

        case EXCP_DEV_INTERRUPT:

            fprintf(stderr, ""External interrupt. Exit\n"");

            exit(EXIT_FAILURE);

            break;

       ",0,0,0,0,1,1,0,0,0,1,1,1,1,1,0
9870,qemu,0,"static S390PCIBusDevice *s390_pci_find_dev_by_target(const char *target)

{

    int i;

    S390PCIBusDevice *pbdev;

    S390pciState *s = s390_get_phb();



    if (!target) {

        return NULL;

    }



    for (i = 0; i < PCI_SLOT_MAX; i++) {

        pbdev = s->pbdev[i];

        if (!pbdev) {

            continue;

        }



        if (!strcmp(pbdev->target, target)) {

            return pbdev;

        }

    }



    return NULL;

}
",1,0,3,0,0,0,0,0,0,0,0,0,1,1,1
9896,FFmpeg,0,"static void cin_decode_lzss(const unsigned char *src, int src_size, unsigned char *dst, int dst_size)

{

    uint16_t cmd;

    int i, sz, offset, code;

    unsigned char *dst_end = dst + dst_size;

    const unsigned char *src_end = src + src_size;



    while (src < src_end && dst < dst_end) {

        code = *src++;

        for (i = 0; i < 8 && src < src_end && dst < dst_end; ++i) {

            if (code & (1 << i)) {

                *dst++ = *src++;

            } else {

                cmd = AV_RL16(src); src += 2;

                offset = cmd >> 4;

                sz = (cmd & 0xF) + 2;

                /* don't use memcpy/memmove here as the decoding routine (ab)uses */

                /* buffer overlappings to repeat bytes in the destination */

                sz = FFMIN(sz, dst_end - dst);

                while (sz--) {

                    *dst = *(dst - offset - 1);

                    ++dst;

                }

            }

        }

    }

}
",1,0,1,0,0,2,0,0,1,1,1,1,0,0,0
9913,FFmpeg,1,"ff_rdt_parse_open(AVFormatContext *ic, int first_stream_of_set_idx,

                  void *priv_data, RTPDynamicProtocolHandler *handler)

{

    RDTDemuxContext *s = av_mallocz(sizeof(RDTDemuxContext));

    if (!s)

        return NULL;



    s->ic = ic;

    s->streams = &ic->streams[first_stream_of_set_idx];

    do {

        s->n_streams++;

    } while (first_stream_of_set_idx + s->n_streams < ic->nb_streams &&

             s->streams[s->n_streams]->priv_data == s->streams[0]->priv_data);

    s->prev_set_id    = -1;

    s->prev_stream_id = -1;

    s->prev_timestamp = -1;

    s->parse_packet = handler->parse_packet;

    s->dynamic_protocol_context = priv_data;



    return s;

}
",0,0,1,0,0,1,1,1,1,1,1,1,0,0,0
9922,qemu,1,"static int qcow2_co_writev(BlockDriverState *bs,

                           int64_t sector_num,

                           int remaining_sectors,

                           QEMUIOVector *qiov)

{

    BDRVQcowState *s = bs->opaque;

    int index_in_cluster;

    int n_end;

    int ret;

    int cur_nr_sectors; /* number of sectors in current iteration */

    QCowL2Meta l2meta;

    uint64_t cluster_offset;

    QEMUIOVector hd_qiov;

    uint64_t bytes_done = 0;

    uint8_t *cluster_data = NULL;



    l2meta.nb_clusters = 0;

    qemu_co_queue_init(&l2meta.dependent_requests);



    qemu_iovec_init(&hd_qiov, qiov->niov);



    s->cluster_cache_offset = -1; /* disable compressed cache */



    qemu_co_mutex_lock(&s->lock);



    while (remaining_sectors != 0) {



        index_in_cluster = sector_num & (s->cluster_sectors - 1);

        n_end = index_in_cluster + remaining_sectors;

        if (s->crypt_method &&

            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {

            n_e",0,0,1,0,0,1,1,1,1,1,1,1,0,0,0
9929,qemu,1,"int vhost_dev_init(struct vhost_dev *hdev, void *opaque,

                   VhostBackendType backend_type, bool force)

{

    uint64_t features;

    int i, r;



    if (vhost_set_backend_type(hdev, backend_type) < 0) {

        close((uintptr_t)opaque);

        return -1;

    }



    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {

        close((uintptr_t)opaque);

        return -errno;

    }



    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);

    if (r < 0) {

        goto fail;

    }



    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);

    if (r < 0) {

        goto fail;

    }



    for (i = 0; i < hdev->nvqs; ++i) {

        r = vhost_virtqueue_init(hdev, hdev->vqs + i, i);

        if (r < 0) {

            goto fail_vq;

        }

    }

    hdev->features = features;



    hdev->memory_listener = (MemoryListener) {

        .begin = vhost_begin,

        .commit = vhost_commit,

        .region_add = vhost_region_add,

        .regi",2,3,5,0,0,0,0,0,0,1,1,0,0,0,0
9934,FFmpeg,1,"int ff_set_systematic_pal2(uint32_t pal[256], enum AVPixelFormat pix_fmt)

{

    int i;



    for (i = 0; i < 256; i++) {

        int r, g, b;



        switch (pix_fmt) {

        case AV_PIX_FMT_RGB8:

            r = (i>>5    )*36;

            g = ((i>>2)&7)*36;

            b = (i&3     )*85;

            break;

        case AV_PIX_FMT_BGR8:

            b = (i>>6    )*85;

            g = ((i>>3)&7)*36;

            r = (i&7     )*36;

            break;

        case AV_PIX_FMT_RGB4_BYTE:

            r = (i>>3    )*255;

            g = ((i>>1)&3)*85;

            b = (i&1     )*255;

            break;

        case AV_PIX_FMT_BGR4_BYTE:

            b = (i>>3    )*255;

            g = ((i>>1)&3)*85;

            r = (i&1     )*255;

            break;

        case AV_PIX_FMT_GRAY8:

            r = b = g = i;

            break;

        default:

            return AVERROR(EINVAL);

        }

        pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24);

    }



    return 0;

}
",1,0,0,0,1,0,0,0,0,0,0,0,1,0,0
9943,qemu,0,"void qmp_transaction(TransactionActionList *dev_list, Error **errp)

{

    TransactionActionList *dev_entry = dev_list;

    BlkTransactionState *state, *next;

    Error *local_err = NULL;



    QSIMPLEQ_HEAD(snap_bdrv_states, BlkTransactionState) snap_bdrv_states;

    QSIMPLEQ_INIT(&snap_bdrv_states);



    /* drain all i/o before any operations */

    bdrv_drain_all();



    /* We don't do anything in this loop that commits us to the operations */

    while (NULL != dev_entry) {

        TransactionAction *dev_info = NULL;

        const BdrvActionOps *ops;



        dev_info = dev_entry->value;

        dev_entry = dev_entry->next;



        assert(dev_info->kind < ARRAY_SIZE(actions));



        ops = &actions[dev_info->kind];

        assert(ops->instance_size > 0);



        state = g_malloc0(ops->instance_size);

        state->ops = ops;

        state->action = dev_info;

        QSIMPLEQ_INSERT_TAIL(&snap_bdrv_states, state, entry);



        state->ops->prepare(state, &local_err);

   ",0,0,0,0,0,1,0,0,0,1,1,0,0,1,0
9956,qemu,0,"static int intel_hda_init(PCIDevice *pci)

{

    IntelHDAState *d = DO_UPCAST(IntelHDAState, pci, pci);

    uint8_t *conf = d->pci.config;



    d->name = d->pci.qdev.info->name;



    pci_config_set_vendor_id(conf, PCI_VENDOR_ID_INTEL);

    pci_config_set_device_id(conf, 0x2668);

    pci_config_set_revision(conf, 1);

    pci_config_set_class(conf, PCI_CLASS_MULTIMEDIA_HD_AUDIO);

    pci_config_set_interrupt_pin(conf, 1);



    /* HDCTL off 0x40 bit 0 selects signaling mode (1-HDA, 0 - Ac97) 18.1.19 */

    conf[0x40] = 0x01;



    d->mmio_addr = cpu_register_io_memory(intel_hda_mmio_read,

                                          intel_hda_mmio_write, d,

                                          DEVICE_NATIVE_ENDIAN);

    pci_register_bar_simple(&d->pci, 0, 0x4000, 0, d->mmio_addr);

    if (d->msi) {

        msi_init(&d->pci, 0x50, 1, true, false);

    }



    hda_codec_bus_init(&d->pci.qdev, &d->codecs,

                       intel_hda_response, intel_hda_xfer);



    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
9961,qemu,0,"static BlockDriverAIOCB *raw_aio_writev(BlockDriverState *bs,

        int64_t sector_num, QEMUIOVector *qiov, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    acb = raw_aio_setup(bs, sector_num, qiov, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (qemu_paio_write(&acb->aiocb) < 0) {

        raw_aio_remove(acb);

        return NULL;

    }

    return &acb->common;

}
",0,0,2,0,0,0,1,1,0,1,1,1,0,0,0
9977,FFmpeg,0,"static inline void pred_direct_motion(H264Context * const h, int *mb_type){

    MpegEncContext * const s = &h->s;

    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;

    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;

    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;

    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];

    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];

    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];

    const int is_b8x8 = IS_8X8(*mb_type);

    int sub_mb_type;

    int i8, i4;



    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){

        /* FIXME save sub mb types from previous frames (or derive from MVs)

         * so we know exactly what block size to use */

        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */

        *mb_type =    MB_TYPE_8x8;

    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){

        sub",0,0,2,0,0,0,0,0,0,0,1,0,0,0,0
10000,qemu,0,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)

{

    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(env, s->pc);

        s->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(env, s->pc);

        s->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(env, s->pc);

        s->pc += 4;

        break;

    default:

        tcg_abort();

    }

    return ret;

}
",0,0,2,0,1,0,0,0,0,0,0,0,0,1,1
10026,qemu,0,"static void bdrv_throttle_write_timer_cb(void *opaque)

{

    BlockDriverState *bs = opaque;

    qemu_co_enter_next(&bs->throttled_reqs[1]);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
10049,qemu,0,"static int find_pte32(CPUPPCState *env, mmu_ctx_t *ctx, int h,

                      int rw, int type, int target_page_bits)

{

    hwaddr pteg_off;

    target_ulong pte0, pte1;

    int i, good = -1;

    int ret, r;



    ret = -1; /* No entry found */

    pteg_off = get_pteg_offset(env, ctx->hash[h], HASH_PTE_SIZE_32);

    for (i = 0; i < 8; i++) {

        if (env->external_htab) {

            pte0 = ldl_p(env->external_htab + pteg_off + (i * 8));

            pte1 = ldl_p(env->external_htab + pteg_off + (i * 8) + 4);

        } else {

            pte0 = ldl_phys(env->htab_base + pteg_off + (i * 8));

            pte1 = ldl_phys(env->htab_base + pteg_off + (i * 8) + 4);

        }

        r = pte_check_hash32(ctx, pte0, pte1, h, rw, type);

        LOG_MMU(""Load pte from %08"" HWADDR_PRIx "" => "" TARGET_FMT_lx "" ""

                TARGET_FMT_lx "" %d %d %d "" TARGET_FMT_lx ""\n"",

                pteg_off + (i * 8), pte0, pte1, (int)(pte0 >> 31), h,

                (int)((pte0 >> 6) & 1), ctx->ptem);",1,0,1,0,0,0,1,1,1,0,1,1,1,1,1
10055,qemu,0,"static int kvm_put_xcrs(CPUState *env)

{

#ifdef KVM_CAP_XCRS

    struct kvm_xcrs xcrs;



    if (!kvm_has_xcrs())

        return 0;



    xcrs.nr_xcrs = 1;

    xcrs.flags = 0;

    xcrs.xcrs[0].xcr = 0;

    xcrs.xcrs[0].value = env->xcr0;

    return kvm_vcpu_ioctl(env, KVM_SET_XCRS, &xcrs);

#else

    return 0;

#endif

}
",0,0,3,0,0,0,1,1,1,0,0,0,1,0,0
10064,qemu,0,"static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,

                                     TCGv cmp, int32_t disp)

{

    uint64_t dest = ctx->pc + (disp << 2);

    int lab_true = gen_new_label();



    if (use_goto_tb(ctx, dest)) {

        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);



        tcg_gen_goto_tb(0);

        tcg_gen_movi_i64(cpu_pc, ctx->pc);

        tcg_gen_exit_tb((uintptr_t)ctx->tb);



        gen_set_label(lab_true);

        tcg_gen_goto_tb(1);

        tcg_gen_movi_i64(cpu_pc, dest);

        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);



        return EXIT_GOTO_TB;

    } else {

        TCGv_i64 z = tcg_const_i64(0);

        TCGv_i64 d = tcg_const_i64(dest);

        TCGv_i64 p = tcg_const_i64(ctx->pc);



        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);



        tcg_temp_free_i64(z);

        tcg_temp_free_i64(d);

        tcg_temp_free_i64(p);

        return EXIT_PC_UPDATED;

    }

}
",0,3,1,0,0,0,0,0,0,0,0,0,1,0,0
10081,qemu,0,"static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)

{

    uint32_t val = pci_default_read_config(d, address, len);

#ifdef TARGET_WORDS_BIGENDIAN

    val = bswap32(val);

#endif

    return val;

}
",0,0,2,0,0,0,0,0,0,1,0,1,1,1,1
10104,qemu,1,"static void rtas_get_time_of_day(PowerPCCPU *cpu, sPAPREnvironment *spapr,

                                 uint32_t token, uint32_t nargs,

                                 target_ulong args,

                                 uint32_t nret, target_ulong rets)

{

    struct tm tm;



    if (nret != 8) {

        rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);

        return;

    }



    qemu_get_timedate(&tm, spapr->rtc_offset);



    rtas_st(rets, 0, RTAS_OUT_SUCCESS);

    rtas_st(rets, 1, tm.tm_year + 1900);

    rtas_st(rets, 2, tm.tm_mon + 1);

    rtas_st(rets, 3, tm.tm_mday);

    rtas_st(rets, 4, tm.tm_hour);

    rtas_st(rets, 5, tm.tm_min);

    rtas_st(rets, 6, tm.tm_sec);

    rtas_st(rets, 7, 0); /* we don't do nanoseconds */

}
",0,0,1,0,0,0,1,1,1,1,1,0,0,0,0
10128,qemu,0,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)

{

    BlockJob *job = find_block_job(device);



    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);

        return;

    }



    block_job_set_speed(job, speed, errp);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
10161,FFmpeg,0,"static int create_stream(AVFormatContext *s)

{

    XCBGrabContext *c = s->priv_data;

    AVStream *st      = avformat_new_stream(s, NULL);

    xcb_get_geometry_cookie_t gc;

    xcb_get_geometry_reply_t *geo;

    int ret;



    if (!st)

        return AVERROR(ENOMEM);



    ret = av_parse_video_size(&c->width, &c->height, c->video_size);

    if (ret < 0)

        return ret;



    ret = av_parse_video_rate(&st->avg_frame_rate, c->framerate);

    if (ret < 0)

        return ret;



    avpriv_set_pts_info(st, 64, 1, 1000000);



    gc  = xcb_get_geometry(c->conn, c->screen->root);

    geo = xcb_get_geometry_reply(c->conn, gc, NULL);



    c->width      = FFMIN(geo->width, c->width);

    c->height     = FFMIN(geo->height, c->height);

    c->time_base  = (AVRational){ st->avg_frame_rate.den,

                                  st->avg_frame_rate.num };

    c->time_frame = av_gettime();



    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

    st->codec->codec_id   = AV_CODEC_ID_RAWVIDEO;

    st->",1,0,3,0,0,0,0,0,0,0,0,0,1,1,1
10175,FFmpeg,0,"static int vorbis_parse_setup_hdr_codebooks(vorbis_context *vc)

{

    unsigned cb;

    uint8_t  *tmp_vlc_bits;

    uint32_t *tmp_vlc_codes;

    GetBitContext *gb = &vc->gb;

    uint16_t *codebook_multiplicands;

    int ret = 0;



    vc->codebook_count = get_bits(gb, 8) + 1;



    av_dlog(NULL, "" Codebooks: %d \n"", vc->codebook_count);



    vc->codebooks = av_mallocz(vc->codebook_count * sizeof(*vc->codebooks));

    tmp_vlc_bits  = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_bits));

    tmp_vlc_codes = av_mallocz(V_MAX_VLCS * sizeof(*tmp_vlc_codes));

    codebook_multiplicands = av_malloc(V_MAX_VLCS * sizeof(*codebook_multiplicands));



    for (cb = 0; cb < vc->codebook_count; ++cb) {

        vorbis_codebook *codebook_setup = &vc->codebooks[cb];

        unsigned ordered, t, entries, used_entries = 0;



        av_dlog(NULL, "" %u. Codebook\n"", cb);



        if (get_bits(gb, 24) != 0x564342) {

            av_log(vc->avctx, AV_LOG_ERROR,

                   "" %u. Codebook setup data corrupt.\n""",1,0,1,0,0,0,0,0,0,1,0,0,0,0,0
10180,qemu,1,"static int htab_save_later_pass(QEMUFile *f, sPAPREnvironment *spapr,

                                int64_t max_ns)

{

    bool final = max_ns < 0;

    int htabslots = HTAB_SIZE(spapr) / HASH_PTE_SIZE_64;

    int examined = 0, sent = 0;

    int index = spapr->htab_save_index;

    int64_t starttime = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);



    assert(!spapr->htab_first_pass);



    do {

        int chunkstart, invalidstart;



        /* Consume non-dirty HPTEs */

        while ((index < htabslots)

               && !HPTE_DIRTY(HPTE(spapr->htab, index))) {

            index++;

            examined++;

        }



        chunkstart = index;

        /* Consume valid dirty HPTEs */

        while ((index < htabslots)

               && HPTE_DIRTY(HPTE(spapr->htab, index))

               && HPTE_VALID(HPTE(spapr->htab, index))) {

            CLEAN_HPTE(HPTE(spapr->htab, index));

            index++;

            examined++;

        }



        invalidstart = index;

        /* Consume inva",0,0,0,0,0,2,0,1,1,1,0,1,0,0,0
10190,qemu,0,"static abi_long do_socket(int domain, int type, int protocol)

{

    int target_type = type;

    int ret;



    ret = target_to_host_sock_type(&type);

    if (ret) {

        return ret;

    }



    if (domain == PF_NETLINK)

        return -TARGET_EAFNOSUPPORT;



    if (domain == AF_PACKET ||

        (domain == AF_INET && type == SOCK_PACKET)) {

        protocol = tswap16(protocol);

    }



    ret = get_errno(socket(domain, type, protocol));

    if (ret >= 0) {

        ret = sock_flags_fixup(ret, target_type);

        if (type == SOCK_PACKET) {

            /* Manage an obsolete case :

             * if socket type is SOCK_PACKET, bind by name

             */

            fd_trans_register(ret, &target_packet_trans);

        }

    }

    return ret;

}
",0,0,6,0,0,0,0,0,0,0,0,0,0,0,0
10192,qemu,0,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
",0,0,1,0,0,0,1,1,0,1,1,0,1,1,1
10194,qemu,0,"void process_incoming_migration(QEMUFile *f)

{

    if (qemu_loadvm_state(f) < 0) {

        fprintf(stderr, ""load of migration failed\n"");

        exit(0);

    }

    qemu_announce_self();

    DPRINTF(""successfully loaded vm state\n"");



    incoming_expected = false;



    if (autostart) {

        vm_start();

    } else {

        runstate_set(RSTATE_PRE_LAUNCH);

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
10213,FFmpeg,0,"static int rv40_decode_mb_info(RV34DecContext *r)

{

    MpegEncContext *s = &r->s;

    GetBitContext *gb = &s->gb;

    int q, i;

    int prev_type = 0;

    int mb_pos = s->mb_x + s->mb_y * s->mb_stride;

    int blocks[RV34_MB_TYPES] = {0};

    int count = 0;



    if(!r->s.mb_skip_run)

        r->s.mb_skip_run = svq3_get_ue_golomb(gb) + 1;



    if(--r->s.mb_skip_run)

         return RV34_MB_SKIP;



    if(r->avail_cache[6-1])

        blocks[r->mb_type[mb_pos - 1]]++;

    if(r->avail_cache[6-4]){

        blocks[r->mb_type[mb_pos - s->mb_stride]]++;

        if(r->avail_cache[6-2])

            blocks[r->mb_type[mb_pos - s->mb_stride + 1]]++;

        if(r->avail_cache[6-5])

            blocks[r->mb_type[mb_pos - s->mb_stride - 1]]++;

    }



    for(i = 0; i < RV34_MB_TYPES; i++){

        if(blocks[i] > count){

            count = blocks[i];

            prev_type = i;

        }

    }

    if(s->pict_type == AV_PICTURE_TYPE_P){

        prev_type = block_num_to_ptype_vlc_num[prev_type];",1,0,8,0,0,0,1,1,0,0,1,0,0,1,0
10233,FFmpeg,0,"static inline void RENAME(yvu9_to_yuy2)(const uint8_t *src1, const uint8_t *src2, const uint8_t *src3,

                                        uint8_t *dst,

                                        long width, long height,

                                        long srcStride1, long srcStride2,

                                        long srcStride3, long dstStride)

{

    x86_reg x;

    long y,w,h;

    w=width/2; h=height;

    for (y=0;y<h;y++) {

        const uint8_t* yp=src1+srcStride1*y;

        const uint8_t* up=src2+srcStride2*(y>>2);

        const uint8_t* vp=src3+srcStride3*(y>>2);

        uint8_t* d=dst+dstStride*y;

        x=0;

#if COMPILE_TEMPLATE_MMX

        for (;x<w-7;x+=8) {

            __asm__ volatile(

                PREFETCH""   32(%1, %0)          \n\t""

                PREFETCH""   32(%2, %0)          \n\t""

                PREFETCH""   32(%3, %0)          \n\t""

                ""movq      (%1, %0, 4), %%mm0   \n\t"" /* Y0Y1Y2Y3Y4Y5Y6Y7 */

                ""movq         (%2, ",2,0,1,0,0,0,1,1,1,1,1,1,0,1,1
10244,FFmpeg,0,"static int pcm_decode_frame(AVCodecContext *avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    PCMDecode *s = avctx->priv_data;

    int sample_size, c, n, i;

    uint8_t *samples;

    const uint8_t *src, *src8, *src2[MAX_CHANNELS];

    int32_t *dst_int32_t;



    samples = data;

    src = buf;



    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {

        av_log(avctx, AV_LOG_ERROR, ""invalid sample_fmt\n"");

        return -1;

    }



    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){

        av_log(avctx, AV_LOG_ERROR, ""PCM channels out of bounds\n"");

        return -1;

    }



    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;



    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */

    if (CODEC_ID_PCM_DVD == avctx->codec_id)

        /* 2 samples are interleaved per block in PCM_DVD */

        sample_size = avctx->",0,0,3,0,0,0,1,1,1,0,0,0,1,1,0
10253,FFmpeg,0,"static int parse_presentation_segment(AVCodecContext *avctx,

                                      const uint8_t *buf, int buf_size,

                                      int64_t pts)

{

    PGSSubContext *ctx = avctx->priv_data;



    int x, y, ret;



    int w = bytestream_get_be16(&buf);

    int h = bytestream_get_be16(&buf);



    ctx->presentation.pts = pts;



    av_dlog(avctx, ""Video Dimensions %dx%d\n"",

            w, h);

    ret = ff_set_dimensions(avctx, w, h);

    if (ret < 0)

        return ret;



    /* Skip 1 bytes of unknown, frame rate? */

    buf++;



    ctx->presentation.id_number = bytestream_get_be16(&buf);



    /*

     * Skip 3 bytes of unknown:

     *     state

     *     palette_update_flag (0x80),

     *     palette_id_to_use,

     */

    buf += 3;



    ctx->presentation.object_number = bytestream_get_byte(&buf);

    ctx->presentation.composition_flag = 0;

    if (!ctx->presentation.object_number)

        return 0;



    /*

     * Skip 3 bytes of unknown:",0,0,2,0,0,0,0,0,0,0,0,0,0,1,1
10266,qemu,0,"void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);

        co->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(co->stack);

    g_free(co);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
10268,qemu,0,"int float64_eq_signaling( float64 a, float64 b STATUS_PARAM )

{



    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )

         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )

       ) {

        float_raise( float_flag_invalid STATUS_VAR);

        return 0;

    }

    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );



}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
10269,qemu,0,"static int tpm_passthrough_unix_tx_bufs(int tpm_fd,

                                        const uint8_t *in, uint32_t in_len,

                                        uint8_t *out, uint32_t out_len)

{

    int ret;



    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);

    if (ret != in_len) {

        error_report(""tpm_passthrough: error while transmitting data ""

                     ""to TPM: %s (%i)\n"",

                     strerror(errno), errno);

        goto err_exit;

    }



    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);

    if (ret < 0) {

        error_report(""tpm_passthrough: error while reading data from ""

                     ""TPM: %s (%i)\n"",

                     strerror(errno), errno);

    } else if (ret < sizeof(struct tpm_resp_hdr) ||

               tpm_passthrough_get_size_from_buffer(out) != ret) {

        ret = -1;

        error_report(""tpm_passthrough: received invalid response ""

                     ""packet from TPM\n"");

    }



err_exit:

    if (ret",0,1,4,0,0,2,0,0,0,0,0,0,1,1,1
10278,qemu,0,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }

    return 0;

}
",0,0,3,0,0,1,0,0,0,0,0,0,0,1,0
10282,qemu,0,"struct omap_uwire_s *omap_uwire_init(MemoryRegion *system_memory,

                target_phys_addr_t base,

                qemu_irq *irq, qemu_irq dma, omap_clk clk)

{

    struct omap_uwire_s *s = (struct omap_uwire_s *)

            g_malloc0(sizeof(struct omap_uwire_s));



    s->txirq = irq[0];

    s->rxirq = irq[1];

    s->txdrq = dma;

    omap_uwire_reset(s);



    memory_region_init_io(&s->iomem, &omap_uwire_ops, s, ""omap-uwire"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}
",0,0,0,0,0,0,0,0,0,0,1,1,1,1,1
10291,qemu,0,"static int send_sub_rect(VncState *vs, int x, int y, int w, int h)

{

    VncPalette *palette = &color_count_palette;

    uint32_t bg = 0, fg = 0;

    int colors;

    int ret = 0;

#ifdef CONFIG_VNC_JPEG

    bool force_jpeg = false;

    bool allow_jpeg = true;

#endif



    vnc_framebuffer_update(vs, x, y, w, h, vs->tight.type);



    vnc_tight_start(vs);

    vnc_raw_send_framebuffer_update(vs, x, y, w, h);

    vnc_tight_stop(vs);



#ifdef CONFIG_VNC_JPEG

    if (!vs->vd->non_adaptive && vs->tight.quality != (uint8_t)-1) {

        double freq = vnc_update_freq(vs, x, y, w, h);



        if (freq < tight_jpeg_conf[vs->tight.quality].jpeg_freq_min) {

            allow_jpeg = false;

        }

        if (freq >= tight_jpeg_conf[vs->tight.quality].jpeg_freq_threshold) {

            force_jpeg = true;

            vnc_sent_lossy_rect(vs, x, y, w, h);

        }

    }

#endif



    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, palette);



#ifdef CONFIG_VNC_JPEG

    if (allow_jpeg && v",2,0,9,0,0,0,0,1,1,1,1,1,0,0,0
10295,qemu,0,"static ExitStatus translate_one(DisasContext *ctx, uint32_t insn)

{

    uint32_t palcode;

    int32_t disp21, disp16;

#ifndef CONFIG_USER_ONLY

    int32_t disp12;

#endif

    uint16_t fn11;

    uint8_t opc, ra, rb, rc, fpfn, fn7, islit, real_islit;

    uint8_t lit;

    ExitStatus ret;



    /* Decode all instruction fields */

    opc = insn >> 26;

    ra = (insn >> 21) & 0x1F;

    rb = (insn >> 16) & 0x1F;

    rc = insn & 0x1F;

    real_islit = islit = (insn >> 12) & 1;

    if (rb == 31 && !islit) {

        islit = 1;

        lit = 0;

    } else

        lit = (insn >> 13) & 0xFF;

    palcode = insn & 0x03FFFFFF;

    disp21 = ((int32_t)((insn & 0x001FFFFF) << 11)) >> 11;

    disp16 = (int16_t)(insn & 0x0000FFFF);

#ifndef CONFIG_USER_ONLY

    disp12 = (int32_t)((insn & 0x00000FFF) << 20) >> 20;

#endif

    fn11 = (insn >> 5) & 0x000007FF;

    fpfn = fn11 & 0x3F;

    fn7 = (insn >> 5) & 0x0000007F;

    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",

              opc, ra, rb",0,0,5,0,0,0,0,0,0,0,0,0,0,0,0
10308,FFmpeg,0,"inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, long dstWidth, const uint8_t *src1, const uint8_t *src2,

                                   int srcW, int xInc, int flags, const int16_t *hChrFilter,

                                   const int16_t *hChrFilterPos, int hChrFilterSize,

                                   int srcFormat, uint8_t *formatConvBuffer,

                                   uint32_t *pal)

{

    int32_t av_unused *mmx2FilterPos = c->chrMmx2FilterPos;

    int16_t av_unused *mmx2Filter    = c->chrMmx2Filter;

    int     av_unused canMMX2BeUsed  = c->canMMX2BeUsed;

    void    av_unused *mmx2FilterCode= c->chrMmx2FilterCode;



    if (isGray(srcFormat) || srcFormat==PIX_FMT_MONOBLACK || srcFormat==PIX_FMT_MONOWHITE)

        return;



    if (srcFormat==PIX_FMT_RGB32_1 || srcFormat==PIX_FMT_BGR32_1) {

        src1 += ALT32_CORR;

        src2 += ALT32_CORR;

    }



    if (srcFormat==PIX_FMT_RGB48LE) {

        src1++;

        src2++;

    }



    if (c->hcscale_",1,0,4,0,0,0,0,1,1,0,1,0,0,1,1
10316,qemu,0,"float32 HELPER(ucf64_abss)(float32 a)

{

    return float32_abs(a);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
10322,qemu,0,"int qemu_thread_equal(QemuThread *thread1, QemuThread *thread2)

{

   return pthread_equal(thread1->thread, thread2->thread);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
10327,qemu,0,"static void ivshmem_io_writel(void *opaque, target_phys_addr_t addr,

                                                            uint32_t val)

{

    IVShmemState *s = opaque;



    uint64_t write_one = 1;

    uint16_t dest = val >> 16;

    uint16_t vector = val & 0xff;



    addr &= 0xfc;



    IVSHMEM_DPRINTF(""writing to addr "" TARGET_FMT_plx ""\n"", addr);

    switch (addr)

    {

        case INTRMASK:

            ivshmem_IntrMask_write(s, val);

            break;



        case INTRSTATUS:

            ivshmem_IntrStatus_write(s, val);

            break;



        case DOORBELL:

            /* check that dest VM ID is reasonable */

            if ((dest < 0) || (dest > s->max_peer)) {

                IVSHMEM_DPRINTF(""Invalid destination VM ID (%d)\n"", dest);

                break;

            }



            /* check doorbell range */

            if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) {

                IVSHMEM_DPRINTF(""Writing %"" PRId64 "" to VM %d on vector %d\n"",",0,0,2,0,1,0,1,1,1,1,1,1,1,1,1
10333,qemu,0,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}
",0,0,3,0,0,0,0,1,0,1,1,0,0,1,0
10338,qemu,0,"void test_fcmp(double a, double b)

{

    long eflags, fpus;



    fpu_clear_exceptions();

    asm(""fcom %2\n""

        ""fstsw %%ax\n""

        : ""=a"" (fpus)

        : ""t"" (a), ""u"" (b));

    printf(""fcom(%f %f)=%04lx \n"",

           a, b, fpus & (0x4500 | FPUS_EMASK));

    fpu_clear_exceptions();

    asm(""fucom %2\n""

        ""fstsw %%ax\n""

        : ""=a"" (fpus)

        : ""t"" (a), ""u"" (b));

    printf(""fucom(%f %f)=%04lx\n"",

           a, b, fpus & (0x4500 | FPUS_EMASK));

    if (TEST_FCOMI) {

        /* test f(u)comi instruction */

        fpu_clear_exceptions();

        asm(""fcomi %3, %2\n""

            ""fstsw %%ax\n""

            ""pushf\n""

            ""pop %0\n""

            : ""=r"" (eflags), ""=a"" (fpus)

            : ""t"" (a), ""u"" (b));

        printf(""fcomi(%f %f)=%04lx %02lx\n"",

               a, b, fpus & FPUS_EMASK, eflags & (CC_Z | CC_P | CC_C));

        fpu_clear_exceptions();

        asm(""fucomi %3, %2\n""

            ""fstsw %%ax\n""

            ""pushf\n""

            ""pop %0\n""",0,0,1,0,0,0,0,0,0,0,0,0,0,0,1
10351,qemu,1,"void tlb_set_page_with_attrs(CPUState *cpu, target_ulong vaddr,

                             hwaddr paddr, MemTxAttrs attrs, int prot,

                             int mmu_idx, target_ulong size)

{

    CPUArchState *env = cpu->env_ptr;

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    hwaddr iotlb, xlat, sz;

    unsigned vidx = env->vtlb_index++ % CPU_VTLB_SIZE;

    int asidx = cpu_asidx_from_attrs(cpu, attrs);



    assert_cpu_is_self(cpu);

    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }



    sz = size;

    section = address_space_translate_for_iotlb(cpu, asidx, paddr, &xlat, &sz);

    assert(sz >= TARGET_PAGE_SIZE);



    tlb_debug(""vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

              "" prot=%x idx=%d\n"",

              vaddr, paddr, prot, mmu_idx);



    address = vaddr;

    if (!memo",1,0,2,0,0,0,0,0,0,0,0,0,1,1,1
10355,qemu,1,"static int qcrypto_cipher_init_des_rfb(QCryptoCipher *cipher,

                                       const uint8_t *key, size_t nkey,

                                       Error **errp)

{

    QCryptoCipherBuiltin *ctxt;



    if (cipher->mode != QCRYPTO_CIPHER_MODE_ECB) {

        error_setg(errp, ""Unsupported cipher mode %d"", cipher->mode);

        return -1;

    }



    ctxt = g_new0(QCryptoCipherBuiltin, 1);



    ctxt->state.desrfb.key = g_new0(uint8_t, nkey);

    memcpy(ctxt->state.desrfb.key, key, nkey);

    ctxt->state.desrfb.nkey = nkey;




    ctxt->free = qcrypto_cipher_free_des_rfb;

    ctxt->setiv = qcrypto_cipher_setiv_des_rfb;

    ctxt->encrypt = qcrypto_cipher_encrypt_des_rfb;

    ctxt->decrypt = qcrypto_cipher_decrypt_des_rfb;



    cipher->opaque = ctxt;



    return 0;

}",0,0,1,0,0,0,1,1,1,1,1,0,1,0,0
10364,qemu,0,"static int virtio_ccw_handle_set_vq(SubchDev *sch, CCW1 ccw, bool check_len,

                                    bool is_legacy)

{

    int ret;

    VqInfoBlock info;

    VqInfoBlockLegacy linfo;

    size_t info_len = is_legacy ? sizeof(linfo) : sizeof(info);



    if (check_len) {

        if (ccw.count != info_len) {

            return -EINVAL;

        }

    } else if (ccw.count < info_len) {

        /* Can't execute command. */

        return -EINVAL;

    }

    if (!ccw.cda) {

        return -EFAULT;

    }

    if (is_legacy) {

        linfo.queue = address_space_ldq_be(&address_space_memory, ccw.cda,

                                           MEMTXATTRS_UNSPECIFIED, NULL);

        linfo.align = address_space_ldl_be(&address_space_memory,

                                           ccw.cda + sizeof(linfo.queue),

                                           MEMTXATTRS_UNSPECIFIED,

                                           NULL);

        linfo.index = address_space_lduw_be(&address_space_",0,0,5,0,0,0,0,0,0,0,0,0,1,1,1
10370,qemu,0,"static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    }

}
",0,0,1,0,0,0,0,0,0,1,0,0,1,1,1
10374,qemu,0,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(s, fd, virq, true);

}
",0,0,0,0,0,0,1,1,0,0,0,1,0,0,0
10385,qemu,0,"static gboolean udp_chr_read(GIOChannel *chan, GIOCondition cond, void *opaque)

{

    CharDriverState *chr = opaque;

    NetCharDriver *s = chr->opaque;

    gsize bytes_read = 0;

    GIOStatus status;



    if (s->max_size == 0)

        return FALSE;

    status = g_io_channel_read_chars(s->chan, (gchar *)s->buf, sizeof(s->buf),

                                     &bytes_read, NULL);

    s->bufcnt = bytes_read;

    s->bufptr = s->bufcnt;

    if (status != G_IO_STATUS_NORMAL) {

        return FALSE;

    }



    s->bufptr = 0;

    while (s->max_size > 0 && s->bufptr < s->bufcnt) {

        qemu_chr_be_write(chr, &s->buf[s->bufptr], 1);

        s->bufptr++;

        s->max_size = qemu_chr_be_can_write(chr);

    }



    return TRUE;

}
",0,0,2,0,0,1,0,0,0,0,0,0,1,1,1
10406,qemu,1,"PCIBus *pci_prep_init(qemu_irq *pic)

{

    PREPPCIState *s;

    PCIDevice *d;

    int PPC_io_memory;



    s = qemu_mallocz(sizeof(PREPPCIState));

    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);



    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);

    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);



    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);

    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);

    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);

    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);

    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);

    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);



    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,

                                           PPC_PCIIO_write, s);

    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);



    /* PCI host bridge */

    d = pci_register_device(s->bus, ""PREP H",0,0,0,0,0,0,1,1,0,1,0,1,1,1,1
10410,FFmpeg,0,"static int raw_init_encoder(AVCodecContext *avctx)

{

    avctx->coded_frame = (AVFrame *)avctx->priv_data;

    avctx->coded_frame->pict_type = FF_I_TYPE;

    avctx->coded_frame->key_frame = 1;

    avctx->codec_tag = findFourCC(avctx->pix_fmt);

    return 0;

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,1
10414,FFmpeg,1,"static int decode_sequence_header_adv(VC1Context *v, GetBitContext *gb)

{

    v->res_rtm_flag = 1;

    v->level = get_bits(gb, 3);

    if(v->level >= 5)

    {

        av_log(v->s.avctx, AV_LOG_ERROR, ""Reserved LEVEL %i\n"",v->level);

    }

    v->chromaformat = get_bits(gb, 2);

    if (v->chromaformat != 1)

    {

        av_log(v->s.avctx, AV_LOG_ERROR,

               ""Only 4:2:0 chroma format supported\n"");

        return -1;

    }



    // (fps-2)/4 (->30)

    v->frmrtq_postproc = get_bits(gb, 3); //common

    // (bitrate-32kbps)/64kbps

    v->bitrtq_postproc = get_bits(gb, 5); //common

    v->postprocflag = get_bits(gb, 1); //common



    v->s.avctx->coded_width = (get_bits(gb, 12) + 1) << 1;

    v->s.avctx->coded_height = (get_bits(gb, 12) + 1) << 1;

    v->broadcast = get_bits1(gb);

    v->interlace = get_bits1(gb);

    if(v->interlace){

        av_log(v->s.avctx, AV_LOG_ERROR, ""Interlaced mode not supported (yet)\n"");

        return -1;

    }

    v->tfcntrflag = get_bits1(gb);",3,0,3,0,0,0,0,0,0,0,0,0,0,1,1
10416,qemu,1,"int page_unprotect(target_ulong address, uintptr_t pc, void *puc)

{

    unsigned int prot;

    PageDesc *p;

    target_ulong host_start, host_end, addr;



    /* Technically this isn't safe inside a signal handler.  However we

       know this only ever happens in a synchronous SEGV handler, so in

       practice it seems to be ok.  */

    mmap_lock();



    p = page_find(address >> TARGET_PAGE_BITS);

    if (!p) {

        mmap_unlock();

        return 0;

    }



    /* if the page was really writable, then we change its

       protection back to writable */

    if ((p->flags & PAGE_WRITE_ORG) && !(p->flags & PAGE_WRITE)) {

        host_start = address & qemu_host_page_mask;

        host_end = host_start + qemu_host_page_size;



        prot = 0;

        for (addr = host_start ; addr < host_end ; addr += TARGET_PAGE_SIZE) {

            p = page_find(addr >> TARGET_PAGE_BITS);

            p->flags |= PAGE_WRITE;

            prot |= p->flags;



            /* and since the content will b",1,0,3,0,0,0,0,1,1,1,1,0,0,0,0
10429,FFmpeg,0,"void ff_put_h264_qpel8_mc23_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 1);

}
",0,0,1,0,0,0,1,1,1,1,1,1,0,1,0
10449,FFmpeg,0,"static int film_probe(AVProbeData *p)

{

    if (p->buf_size < 4)

        return 0;



    if (AV_RB32(&p->buf[0]) != FILM_TAG)

        return 0;



    return AVPROBE_SCORE_MAX;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
10478,qemu,0,"static void gen_store_v10_conditional(DisasContext *dc, TCGv addr, TCGv val,

                       unsigned int size, int mem_index)

{

    int l1 = gen_new_label();

    TCGv taddr = tcg_temp_local_new();

    TCGv tval = tcg_temp_local_new();

    TCGv t1 = tcg_temp_local_new();

    dc->postinc = 0;

    cris_evaluate_flags(dc);



    tcg_gen_mov_tl(taddr, addr);

    tcg_gen_mov_tl(tval, val);



    /* Store only if F flag isn't set */

    tcg_gen_andi_tl(t1, cpu_PR[PR_CCS], F_FLAG_V10);

    tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);

    if (size == 1) {

        tcg_gen_qemu_st8(tval, taddr, mem_index);

    } else if (size == 2) {

        tcg_gen_qemu_st16(tval, taddr, mem_index);

    } else {

        tcg_gen_qemu_st32(tval, taddr, mem_index);

    }

    gen_set_label(l1);

    tcg_gen_shri_tl(t1, t1, 1);  /* shift F to P position */

    tcg_gen_or_tl(cpu_PR[PR_CCS], cpu_PR[PR_CCS], t1); /*P=F*/

    tcg_temp_free(t1);

    tcg_temp_free(tval);

    tcg_temp_free(taddr);

}
",0,0,2,0,0,0,0,0,0,1,0,0,1,1,1
10480,qemu,0,"static void ide_trim_bh_cb(void *opaque)

{

    TrimAIOCB *iocb = opaque;



    iocb->common.cb(iocb->common.opaque, iocb->ret);



    qemu_bh_delete(iocb->bh);

    iocb->bh = NULL;

    qemu_aio_unref(iocb);

}
",0,0,0,0,0,0,1,1,1,0,0,0,1,0,0
10485,qemu,0,"static abi_long do_ioctl_dm(const IOCTLEntry *ie, uint8_t *buf_temp, int fd,

                            abi_long cmd, abi_long arg)

{

    void *argptr;

    struct dm_ioctl *host_dm;

    abi_long guest_data;

    uint32_t guest_data_size;

    int target_size;

    const argtype *arg_type = ie->arg_type;

    abi_long ret;

    void *big_buf = NULL;

    char *host_data;



    arg_type++;

    target_size = thunk_type_size(arg_type, 0);

    argptr = lock_user(VERIFY_READ, arg, target_size, 1);

    if (!argptr) {

        ret = -TARGET_EFAULT;

        goto out;

    }

    thunk_convert(buf_temp, argptr, arg_type, THUNK_HOST);

    unlock_user(argptr, arg, 0);



    /* buf_temp is too small, so fetch things into a bigger buffer */

    big_buf = g_malloc0(((struct dm_ioctl*)buf_temp)->data_size * 2);

    memcpy(big_buf, buf_temp, target_size);

    buf_temp = big_buf;

    host_dm = big_buf;



    guest_data = arg + host_dm->data_start;

    if ((guest_data - arg) < 0) {

        ret = -EINVAL;

  ",0,1,2,0,0,0,0,0,0,0,1,1,0,0,0
10498,FFmpeg,0,"static int dxva2_retrieve_data(AVCodecContext *s, AVFrame *frame)

{

    InputStream        *ist = s->opaque;

    DXVA2Context       *ctx = ist->hwaccel_ctx;

    int                ret;



    ret = av_hwframe_transfer_data(ctx->tmp_frame, frame, 0);

    if (ret < 0)

        return ret;



    ret = av_frame_copy_props(ctx->tmp_frame, frame);

    if (ret < 0) {

        av_frame_unref(ctx->tmp_frame);

        return ret;

    }



    av_frame_unref(frame);

    av_frame_move_ref(frame, ctx->tmp_frame);



    return 0;

}
",0,0,2,0,0,0,0,0,1,1,1,1,1,0,1
10502,FFmpeg,1,"void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,

                    uint8_t *segment, uint8_t *ref, int layout)

{

    VP56RangeCoder *c = &s->c;



    if (s->segmentation.update_map)

        *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid);

    else if (s->segmentation.enabled)

        *segment = ref ? *ref : *segment;

    mb->segment = *segment;



    mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;



    if (s->keyframe) {

        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra,

                                    vp8_pred16x16_prob_intra);



        if (mb->mode == MODE_I4x4) {

            decode_intra4x4_modes(s, c, mb, mb_x, 1, layout);

        } else {

            const uint32_t modes = vp8_pred4x4_mode[mb->mode] * 0x01010101u;

            if (s->mb_layout == 1)

                AV_WN32A(mb->intra4x4_pred_mode_top, modes);

            else

                AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, mod",0,0,5,0,0,0,1,1,1,1,1,0,0,0,0
10504,qemu,1,"static int decode_micromips_opc (CPUMIPSState *env, DisasContext *ctx, int *is_branch)

{

    uint32_t op;



    /* make sure instructions are on a halfword boundary */

    if (ctx->pc & 0x1) {

        env->CP0_BadVAddr = ctx->pc;

        generate_exception(ctx, EXCP_AdEL);

        ctx->bstate = BS_STOP;

        return 2;

    }



    op = (ctx->opcode >> 10) & 0x3f;

    /* Enforce properly-sized instructions in a delay slot */

    if (ctx->hflags & MIPS_HFLAG_BMASK) {

        int bits = ctx->hflags & MIPS_HFLAG_BMASK_EXT;



        switch (op) {

        case POOL32A:

        case POOL32B:

        case POOL32I:

        case POOL32C:

        case ADDI32:

        case ADDIU32:

        case ORI32:

        case XORI32:

        case SLTI32:

        case SLTIU32:

        case ANDI32:

        case JALX32:

        case LBU32:

        case LHU32:

        case POOL32F:

        case JALS32:

        case BEQ32:

        case BNE32:

        case J32:

        case JAL32:

        case SB32:

",0,0,2,0,1,0,1,1,0,1,0,1,0,0,0
10513,FFmpeg,0,"static void decouple_info(COOKContext *q, COOKSubpacket *p, int *decouple_tab)

{

    int i;

    int vlc    = get_bits1(&q->gb);

    int start  = cplband[p->js_subband_start];

    int end    = cplband[p->subbands - 1];

    int length = end - start + 1;



    if (start > end)

        return;



    if (vlc)

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_vlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2);

    else

        for (i = 0; i < length; i++)

            decouple_tab[start + i] = get_bits(&q->gb, p->js_vlc_bits);

}
",2,0,2,0,0,0,0,0,0,0,0,0,1,1,1
10520,FFmpeg,1,"static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)

{

    int ret;

    FailingMuxerPacketData *data = av_malloc(sizeof(*data));




    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));

    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));



    pkt->pts = pkt->dts = pts;

    pkt->duration = 1;



    return ret;
",0,0,0,0,0,0,1,0,0,1,0,0,0,0,1
10539,FFmpeg,0,"static void find_best_state(uint8_t best_state[256][256], const uint8_t one_state[256]){

    int i,j,k,m;

    double l2tab[256];



    for(i=1; i<256; i++)

        l2tab[i]= log2(i/256.0);



    for(i=0; i<256; i++){

        double best_len[256];

        double p= i/256.0;



        for(j=0; j<256; j++)

            best_len[j]= 1<<30;



        for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){

            double occ[256]={0};

            double len=0;

            occ[j]=1.0;

            for(k=0; k<256; k++){

                double newocc[256]={0};

                for(m=0; m<256; m++){

                    if(occ[m]){

                        len -=occ[m]*(     p *l2tab[    m]

                                      + (1-p)*l2tab[256-m]);

                    }

                }

                if(len < best_len[k]){

                    best_len[k]= len;

                    best_state[i][k]= j;

                }

                for(m=0; m<256; m++){

                    if(occ[m]){

          ",7,0,3,0,0,0,0,0,0,0,0,0,0,0,0
10547,FFmpeg,0,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
",0,0,1,0,0,0,0,1,1,1,0,0,0,0,0
10554,FFmpeg,0,"static int h264_decode_frame(AVCodecContext *avctx, void *data,

                             int *got_frame, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    H264Context *h     = avctx->priv_data;

    AVFrame *pict      = data;

    int buf_index      = 0;

    int ret;

    const uint8_t *new_extradata;

    int new_extradata_size;



    h->flags = avctx->flags;

    h->setup_finished = 0;



    /* end of stream, output what is still in the buffers */

out:

    if (buf_size == 0) {

        H264Picture *out;

        int i, out_idx;



        h->cur_pic_ptr = NULL;



        // FIXME factorize this with the output code below

        out     = h->delayed_pic[0];

        out_idx = 0;

        for (i = 1;

             h->delayed_pic[i] &&

             !h->delayed_pic[i]->f->key_frame &&

             !h->delayed_pic[i]->mmco_reset;

             i++)

            if (h->delayed_pic[i]->poc < out->poc) {

                out     = h->delayed_pic[i]",1,0,2,0,0,0,0,1,0,1,1,0,0,0,0
10556,FFmpeg,0,"static inline int16_t calc_lowcomp(int16_t a, int16_t b0, int16_t b1, uint8_t bin)

{

    if (bin < 7) {

        if ((b0 + 256) == b1)

            a = 384;

        else if (b0 > b1)

            a = FFMAX(0, a - 64);

    }

    else if (bin < 20) {

        if ((b0 + 256) == b1)

            a = 320;

        else if (b0 > b1)

            a = FFMAX(0, a - 64);

    }

    else {

        a = FFMAX(0, a - 128);

    }



    return a;

}
",0,0,6,0,0,0,0,1,1,1,1,1,0,0,0
10564,FFmpeg,0,"static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,

                                      long width, long height,

                                      long lumStride, long chromStride, long srcStride)

{

    long y;

    const x86_reg chromWidth= width>>1;

    for (y=0; y<height; y+=2) {

#if COMPILE_TEMPLATE_MMX

        __asm__ volatile(

            ""xor                 %%""REG_a"", %%""REG_a""   \n\t""

            ""pcmpeqw                 %%mm7, %%mm7       \n\t""

            ""psrlw                      $8, %%mm7       \n\t"" // FF,00,FF,00...

            "".p2align                    4              \n\t""

            ""1:                \n\t""

            PREFETCH"" 64(%0, %%""REG_a"", 4)              \n\t""

            ""movq       (%0, %%""REG_a"", 4), %%mm0       \n\t"" // YUYV YUYV(0)

            ""movq      8(%0, %%""REG_a"", 4), %%mm1       \n\t"" // YUYV YUYV(4)

            ""movq                    %%mm0, %%mm2       \n\t"" // YUYV YUYV(0)

            ""mov",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
10583,qemu,0,"static BdrvDirtyBitmap *block_dirty_bitmap_lookup(const char *node,

                                                  const char *name,

                                                  BlockDriverState **pbs,

                                                  AioContext **paio,

                                                  Error **errp)

{

    BlockDriverState *bs;

    BdrvDirtyBitmap *bitmap;

    AioContext *aio_context;



    if (!node) {

        error_setg(errp, ""Node cannot be NULL"");

        return NULL;

    }

    if (!name) {

        error_setg(errp, ""Bitmap name cannot be NULL"");

        return NULL;

    }

    bs = bdrv_lookup_bs(node, node, NULL);

    if (!bs) {

        error_setg(errp, ""Node '%s' not found"", node);

        return NULL;

    }



    aio_context = bdrv_get_aio_context(bs);

    aio_context_acquire(aio_context);



    bitmap = bdrv_find_dirty_bitmap(bs, name);

    if (!bitmap) {

        error_setg(errp, ""Dirty bitmap '%s' not found"", name);

        goto fail;",0,1,4,0,0,0,0,0,0,0,0,0,0,0,0
10594,qemu,1,"void ppce500_init(MachineState *machine, PPCE500Params *params)

{

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    PCIBus *pci_bus;

    CPUPPCState *env = NULL;

    uint64_t loadaddr;

    hwaddr kernel_base = -1LL;

    int kernel_size = 0;

    hwaddr dt_base = 0;

    hwaddr initrd_base = 0;

    int initrd_size = 0;

    hwaddr cur_base = 0;

    char *filename;

    hwaddr bios_entry = 0;

    target_long bios_size;

    struct boot_info *boot_info;

    int dt_size;

    int i;

    /* irq num for pin INTA, INTB, INTC and INTD is 1, 2, 3 and

     * 4 respectively */

    unsigned int pci_irq_nrs[PCI_NUM_PINS] = {1, 2, 3, 4};

    qemu_irq **irqs, *mpic;

    DeviceState *dev;

    CPUPPCState *firstenv = NULL;

    MemoryRegion *ccsr_addr_space;

    SysBusDevice *s;

    PPCE500CCSRState *ccsr;



    /* Setup CPUs */

    if (machine->cpu_model == NULL) {

        machine->cpu_model = ""e500v2_v30"";

    }



    irqs = g_malloc0(smp_",1,0,1,0,0,0,1,1,1,1,1,0,0,1,0
10609,FFmpeg,1,"static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)

{

    int prefix = 0;

    int suffix = 0;

    int last_coeff_abs_level_remaining;

    int i;



    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))

        prefix++;



    if (prefix < 3) {

        for (i = 0; i < rc_rice_param; i++)

            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);

        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;

    } else {

        int prefix_minus3 = prefix - 3;



        if (prefix == CABAC_MAX_BIN) {

            av_log(s->avctx, AV_LOG_ERROR, ""CABAC_MAX_BIN : %d\n"", prefix);

            return 0;

        }



        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)

            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);

        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)

                                              << rc_rice_param) + suffix;

    }

    return last_c",2,0,2,0,0,1,0,1,1,0,0,0,0,0,0
10620,FFmpeg,0,"static int segment_hls_window(AVFormatContext *s, int last)

{

    SegmentContext *seg = s->priv_data;

    int i, ret = 0;

    char buf[1024];



    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,

                              &s->interrupt_callback, NULL)) < 0)

        goto fail;



    avio_printf(seg->pb, ""#EXTM3U\n"");

    avio_printf(seg->pb, ""#EXT-X-VERSION:3\n"");

    avio_printf(seg->pb, ""#EXT-X-TARGETDURATION:%d\n"", (int)seg->time);

    avio_printf(seg->pb, ""#EXT-X-MEDIA-SEQUENCE:%d\n"",

                FFMAX(0, seg->number - seg->size));



    av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%d\n"",

           FFMAX(0, seg->number - seg->size));



    for (i = FFMAX(0, seg->number - seg->size);

         i < seg->number; i++) {

        avio_printf(seg->pb, ""#EXTINF:%d,\n"", (int)seg->time);

        if (seg->entry_prefix) {

            avio_printf(seg->pb, ""%s"", seg->entry_prefix);

        }

        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);

        if (re",1,1,3,0,0,0,0,0,0,1,0,1,1,1,1
10640,qemu,1,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
",0,0,0,0,0,0,1,1,1,0,0,0,0,0,0
10648,qemu,1,"static void vmgenid_query_monitor_test(void)

{

    QemuUUID expected, measured;

    gchar *cmd;



    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);



    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(cmd);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);



    qtest_quit(global_qtest);

    g_free(cmd);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
10665,FFmpeg,1,"static int decode_frame_byterun1(AVCodecContext *avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    IffContext *s = avctx->priv_data;

    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;

    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;

    const uint8_t *buf_end = buf+buf_size;

    int y, plane, res;



    if ((res = extract_header(avctx, avpkt)) < 0)

        return res;

    if (s->init) {

        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed\n"");

            return res;

        }

    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return res;

    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {

        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) ",0,0,6,0,0,0,0,1,1,1,0,0,1,1,1
10670,FFmpeg,1,"int alloc_picture(MpegEncContext *s, Picture *pic, int shared){

    const int big_mb_num= s->mb_stride*(s->mb_height+1) + 1; //the +1 is needed so memset(,,stride*height) does not sig11

    const int mb_array_size= s->mb_stride*s->mb_height;

    const int b8_array_size= s->b8_stride*s->mb_height*2;

    const int b4_array_size= s->b4_stride*s->mb_height*4;

    int i;



    if(shared){

        assert(pic->data[0]);

        assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED);

        pic->type= FF_BUFFER_TYPE_SHARED;

    }else{

        int r;



        assert(!pic->data[0]);



        r= s->avctx->get_buffer(s->avctx, (AVFrame*)pic);



        if(r<0 || !pic->age || !pic->type || !pic->data[0]){

            av_log(s->avctx, AV_LOG_ERROR, ""get_buffer() failed (%d %d %d %p)\n"", r, pic->age, pic->type, pic->data[0]);

            return -1;

        }



        if(s->linesize && (s->linesize != pic->linesize[0] || s->uvlinesize != pic->linesize[1])){

            av_log(s->avctx, AV_LOG_ERR",0,0,3,0,0,0,0,0,0,0,0,0,0,1,1
10671,FFmpeg,1,"static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)
{
    if (get_bits(&ctx->gb, 5) != 0x1F) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid picture start code!\n"");
        return -1;
    ctx->prev_frame_type = ctx->frame_type;
    ctx->frame_type      = get_bits(&ctx->gb, 3);
    if (ctx->frame_type >= 5) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid frame type: %d \n"", ctx->frame_type);
        return -1;
    ctx->frame_num = get_bits(&ctx->gb, 8);
    if (ctx->frame_type == FRAMETYPE_INTRA) {
        ctx->gop_invalid = 1;
        if (decode_gop_header(ctx, avctx))
            return -1;
        ctx->gop_invalid = 0;
    if (ctx->frame_type != FRAMETYPE_NULL) {
        ctx->frame_flags = get_bits(&ctx->gb, 8);
        ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;
        ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;
        /* skip unknown extension if any */
        if (ctx->frame_flags & 0x20)
            skip_hdr_extension(&ctx-",0,0,6,0,0,0,1,1,1,1,1,1,1,1,1
10672,FFmpeg,1,"static int mpegts_write_header(AVFormatContext *s)

{

    MpegTSWrite *ts = s->priv_data;

    MpegTSWriteStream *ts_st;

    MpegTSService *service;

    AVStream *st, *pcr_st = NULL;

    AVDictionaryEntry *title, *provider;

    int i, j;

    const char *service_name;

    const char *provider_name;

    int *pids;

    int ret;



    if (s->max_delay < 0) /* Not set by the caller */

        s->max_delay = 0;



    // round up to a whole number of TS packets

    ts->pes_payload_size = (ts->pes_payload_size + 14 + 183) / 184 * 184 - 14;



    ts->tsid = ts->transport_stream_id;

    ts->onid = ts->original_network_id;

    /* allocate a single DVB service */

    title = av_dict_get(s->metadata, ""service_name"", NULL, 0);

    if (!title)

        title = av_dict_get(s->metadata, ""title"", NULL, 0);

    service_name  = title ? title->value : DEFAULT_SERVICE_NAME;

    provider      = av_dict_get(s->metadata, ""service_provider"", NULL, 0);

    provider_name = provider ? provider->value : DEFAULT_PROVID",0,0,2,0,0,0,1,1,1,1,1,1,1,1,0
10699,FFmpeg,1,"void dct32(INTFLOAT *out, const INTFLOAT *tab)

{

    INTFLOAT tmp0, tmp1;



    INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 ,

             val8 , val9 , val10, val11, val12, val13, val14, val15,

             val16, val17, val18, val19, val20, val21, val22, val23,

             val24, val25, val26, val27, val28, val29, val30, val31;



    /* pass 1 */

    BF0( 0, 31, COS0_0 , 1);

    BF0(15, 16, COS0_15, 5);

    /* pass 2 */

    BF( 0, 15, COS1_0 , 1);

    BF(16, 31,-COS1_0 , 1);

    /* pass 1 */

    BF0( 7, 24, COS0_7 , 1);

    BF0( 8, 23, COS0_8 , 1);

    /* pass 2 */

    BF( 7,  8, COS1_7 , 4);

    BF(23, 24,-COS1_7 , 4);

    /* pass 3 */

    BF( 0,  7, COS2_0 , 1);

    BF( 8, 15,-COS2_0 , 1);

    BF(16, 23, COS2_0 , 1);

    BF(24, 31,-COS2_0 , 1);

    /* pass 1 */

    BF0( 3, 28, COS0_3 , 1);

    BF0(12, 19, COS0_12, 2);

    /* pass 2 */

    BF( 3, 12, COS1_3 , 1);

    BF(19, 28,-COS1_3 , 1);

    /* pass 1 */

    BF0( 4, 27, COS0_4 , 1);

    BF0(11, 20, COS",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
10721,qemu,0,"static inline void gen_op_movl_seg_T0_vm(int seg_reg)

{

    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);

    tcg_gen_st32_tl(cpu_T[0], cpu_env, 

                    offsetof(CPUX86State,segs[seg_reg].selector));

    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);

    tcg_gen_st_tl(cpu_T[0], cpu_env, 

                  offsetof(CPUX86State,segs[seg_reg].base));

}
",0,0,0,0,0,0,1,1,1,1,1,0,1,1,1
10723,FFmpeg,1,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
",1,0,0,0,0,0,0,0,0,0,0,0,0,1,0
10727,qemu,1,"void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,

                                        QGuestAllocator *alloc, uint16_t entry)

{

    uint16_t vector;

    uint32_t control;

    void *addr;



    g_assert(d->pdev->msix_enabled);

    addr = d->pdev->msix_table + (entry * 16);



    g_assert_cmpint(entry, >=, 0);

    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));

    d->config_msix_entry = entry;



    d->config_msix_data = 0x12345678;

    d->config_msix_addr = guest_alloc(alloc, 4);



    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,

                                                    d->config_msix_addr & ~0UL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,

                                            (d->config_msix_addr >> 32) & ~0UL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);



    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENT",0,0,0,0,0,0,0,0,0,1,1,1,0,0,0
10730,qemu,1,"static void gen_rdhwr(DisasContext *ctx, int rt, int rd)

{

    TCGv t0;



#if !defined(CONFIG_USER_ONLY)

    /* The Linux kernel will emulate rdhwr if it's not supported natively.

       Therefore only check the ISA in system mode.  */

    check_insn(ctx, ISA_MIPS32R2);

#endif

    t0 = tcg_temp_new();



    switch (rd) {

    case 0:

        save_cpu_state(ctx, 1);

        gen_helper_rdhwr_cpunum(t0, cpu_env);

        gen_store_gpr(t0, rt);

        break;

    case 1:

        save_cpu_state(ctx, 1);

        gen_helper_rdhwr_synci_step(t0, cpu_env);

        gen_store_gpr(t0, rt);

        break;

    case 2:

        save_cpu_state(ctx, 1);

        gen_helper_rdhwr_cc(t0, cpu_env);

        gen_store_gpr(t0, rt);

        break;

    case 3:

        save_cpu_state(ctx, 1);

        gen_helper_rdhwr_ccres(t0, cpu_env);

        gen_store_gpr(t0, rt);

        break;

    case 29:

#if defined(CONFIG_USER_ONLY)

        tcg_gen_ld_tl(t0, cpu_env, offsetof(CPUMIPSState, tls_value));

        gen",1,0,4,0,1,0,0,1,1,0,1,1,0,0,0
10735,qemu,1,"static void usb_msd_realize_bot(USBDevice *dev, Error **errp)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);



    usb_desc_create_serial(dev);

    usb_desc_init(dev);

    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),

                 &usb_msd_scsi_info_bot, NULL);

    s->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(dev);

}
",0,0,0,0,0,0,1,0,0,1,1,1,0,0,0
10738,FFmpeg,0,"static int decode_slice_header(FFV1Context *f, FFV1Context *fs)

{

    RangeCoder *c = &fs->c;

    uint8_t state[CONTEXT_SIZE];

    unsigned ps, i, context_count;

    memset(state, 128, sizeof(state));



    if (fs->ac > 1) {

        for (i = 1; i < 256; i++) {

            fs->c.one_state[i]        = f->state_transition[i];

            fs->c.zero_state[256 - i] = 256 - fs->c.one_state[i];

        }

    }



    fs->slice_x      = get_symbol(c, state, 0) * f->width;

    fs->slice_y      = get_symbol(c, state, 0) * f->height;

    fs->slice_width  = (get_symbol(c, state, 0) + 1) * f->width + fs->slice_x;

    fs->slice_height = (get_symbol(c, state, 0) + 1) * f->height + fs->slice_y;



    fs->slice_x     /= f->num_h_slices;

    fs->slice_y     /= f->num_v_slices;

    fs->slice_width  = fs->slice_width / f->num_h_slices - fs->slice_x;

    fs->slice_height = fs->slice_height / f->num_v_slices - fs->slice_y;

    if ((unsigned)fs->slice_width  > f->width ||

        (unsigned)fs->slice_height > f->",1,0,2,0,0,0,0,1,0,0,0,0,0,0,0
10741,qemu,1,"int kvm_arch_insert_sw_breakpoint(CPUState *cs, struct kvm_sw_breakpoint *bp)

{



    if (cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)&bp->saved_insn,

                            sizeof(diag_501), 0) ||

        cpu_memory_rw_debug(cs, bp->pc, (uint8_t *)diag_501,

                            sizeof(diag_501), 1)) {

        return -EINVAL;

    }

    return 0;

}
",0,0,1,0,0,0,1,0,0,0,0,0,0,0,0
10744,qemu,1,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,

                                       uint64_t i)

{

    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)

                                    + (i << RDMA_REG_CHUNK_SHIFT));

}
",0,0,0,0,0,0,1,0,1,1,1,1,1,0,0
10750,FFmpeg,0,"static int decode_element(AVCodecContext *avctx, void *data, int ch_index,

                          int channels)

{

    ALACContext *alac = avctx->priv_data;

    int has_size, bps, is_compressed, decorr_shift, decorr_left_weight, ret;

    uint32_t output_samples;

    int i, ch;



    skip_bits(&alac->gb, 4);  /* element instance tag */

    skip_bits(&alac->gb, 12); /* unused header bits */



    /* the number of output samples is stored in the frame */

    has_size = get_bits1(&alac->gb);



    alac->extra_bits = get_bits(&alac->gb, 2) << 3;

    bps = alac->sample_size - alac->extra_bits + channels - 1;

    if (bps > 32) {

        av_log(avctx, AV_LOG_ERROR, ""bps is unsupported: %d\n"", bps);

        return AVERROR_PATCHWELCOME;

    }



    /* whether the frame is compressed */

    is_compressed = !get_bits1(&alac->gb);



    if (has_size)

        output_samples = get_bits_long(&alac->gb, 32);

    else

        output_samples = alac->max_samples_per_frame;

    if (!output_samples || outp",0,0,4,0,0,0,0,0,0,0,0,0,1,0,0
10765,FFmpeg,0,"static av_always_inline float quantize_and_encode_band_cost_template(

                                struct AACEncContext *s,

                                PutBitContext *pb, const float *in,

                                const float *scaled, int size, int scale_idx,

                                int cb, const float lambda, const float uplim,

                                int *bits, int BT_ZERO, int BT_UNSIGNED,

                                int BT_PAIR, int BT_ESC)

{

    const float IQ = ff_aac_pow2sf_tab[200 + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    const float  Q = ff_aac_pow2sf_tab[200 - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float CLIPPED_ESCAPE = 165140.0f*IQ;

    int i, j, k;

    float cost = 0;

    const int dim = BT_PAIR ? 2 : 4;

    int resbits = 0;

    const float  Q34 = sqrtf(Q * sqrtf(Q));

    const int range  = aac_cb_range[cb];

    const int maxval = aac_cb_maxval[cb];

    int off;



    if (BT_ZERO) {

        for (i = 0; i < size; i++)

   ",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
10767,FFmpeg,0,"static void event_loop(VideoState *cur_stream)

{

    SDL_Event event;

    double incr, pos, frac;



    for(;;) {

        double x;

        SDL_WaitEvent(&event);

        switch(event.type) {

        case SDL_KEYDOWN:

            if (exit_on_keydown) {

                do_exit(cur_stream);

                break;

            }

            switch(event.key.keysym.sym) {

            case SDLK_ESCAPE:

            case SDLK_q:

                do_exit(cur_stream);

                break;

            case SDLK_f:

                toggle_full_screen(cur_stream);

                break;

            case SDLK_p:

            case SDLK_SPACE:

                if (cur_stream)

                    toggle_pause(cur_stream);

                break;

            case SDLK_s: //S: Step to next frame

                if (cur_stream)

                    step_to_next_frame(cur_stream);

                break;

            case SDLK_a:

                if (cur_stream)

                    stream_cycle_channel(cu",1,0,4,0,2,0,1,1,1,1,1,1,1,0,1
10772,FFmpeg,1,"static int sox_read_packet(AVFormatContext *s,

                           AVPacket *pkt)

{

    int ret, size;



    if (url_feof(s->pb))

        return AVERROR_EOF;



    size = SOX_SAMPLES*s->streams[0]->codec->block_align;

    ret = av_get_packet(s->pb, pkt, size);

    if (ret < 0)

        return AVERROR(EIO);


    pkt->stream_index = 0;

    pkt->size = ret;



    return 0;

}",0,0,2,0,0,0,0,0,0,0,1,0,1,1,1
10773,FFmpeg,1,"static av_cold int svq1_encode_init(AVCodecContext *avctx)

{

    SVQ1Context * const s = avctx->priv_data;



    dsputil_init(&s->dsp, avctx);

    avctx->coded_frame= (AVFrame*)&s->picture;



    s->frame_width = avctx->width;

    s->frame_height = avctx->height;



    s->y_block_width = (s->frame_width + 15) / 16;

    s->y_block_height = (s->frame_height + 15) / 16;



    s->c_block_width = (s->frame_width / 4 + 15) / 16;

    s->c_block_height = (s->frame_height / 4 + 15) / 16;



    s->avctx= avctx;

    s->m.avctx= avctx;


    s->m.me.scratchpad= av_mallocz((avctx->width+64)*2*16*2*sizeof(uint8_t));

    s->m.me.map       = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->m.me.score_map = av_mallocz(ME_MAP_SIZE*sizeof(uint32_t));

    s->mb_type        = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int16_t));

    s->dummy          = av_mallocz((s->y_block_width+1)*s->y_block_height*sizeof(int32_t));

    h263_encode_init(&s->m); //mv_penalty



    return 0;

}",0,0,0,0,0,0,1,1,0,0,0,1,1,0,0
10801,qemu,1,"static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)

{

    AHCICmdHdr *cmd = ad->cur_cmd;

    uint32_t opts = le32_to_cpu(cmd->opts);

    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;

    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;

    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));

    dma_addr_t real_prdt_len = prdt_len;

    uint8_t *prdt;

    int i;

    int r = 0;

    int sum = 0;

    int off_idx = -1;

    int off_pos = -1;

    int tbl_entry_size;

    IDEBus *bus = &ad->port;

    BusState *qbus = BUS(bus);



    if (!sglist_alloc_hint) {

        DPRINTF(ad->port_no, ""no sg list given by guest: 0x%08x\n"", opts);

        return -1;

    }



    /* map PRDT */

    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,

                                DMA_DIRECTION_TO_DEVICE))){

        DPRINTF(ad->port_no, ""map failed\n"");

        return -1;

    }



    if (prdt_len < real_prdt_len) {

        DPRINTF(ad->port_no, ""m",0,0,3,0,0,0,1,1,1,1,1,1,0,0,0
10836,FFmpeg,1,"static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,

                                                uint8_t *dest_y,

                                                uint8_t *dest_cb,

                                                uint8_t *dest_cr,

                                                int field_based,

                                                int bottom_field,

                                                int field_select,

                                                uint8_t **ref_picture,

                                                h264_chroma_mc_func *pix_op,

                                                int motion_x, int motion_y,

                                                int h, int mb_y)

{

    uint8_t *ptr_y, *ptr_cb, *ptr_cr;

    int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,

        uvsx, uvsy;

    const int lowres     = s->avctx->lowres;

    const int op_index   = FFMIN(lowres, 2);

    const int block_s    = 8>",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
10842,FFmpeg,1,"static int decode_frame(AVCodecContext *avctx,

                        void *data,

                        int *got_frame,

                        AVPacket *avpkt)

{

    const uint8_t *buf      = avpkt->data;

    unsigned int   buf_size = avpkt->size;

    const uint8_t *buf_end  = buf + buf_size;



    const AVPixFmtDescriptor *desc;

    EXRContext *const s = avctx->priv_data;

    AVFrame *picture  = data;

    AVFrame *const p = &s->picture;

    uint8_t *ptr;



    int i, x, y, stride, magic_number, version, flags, ret;

    int w = 0;

    int h = 0;

    unsigned int xmin   = ~0;

    unsigned int xmax   = ~0;

    unsigned int ymin   = ~0;

    unsigned int ymax   = ~0;

    unsigned int xdelta = ~0;



    int out_line_size;

    int bxmin, axmax;

    int scan_lines_per_block;

    unsigned long scan_line_size;

    unsigned long uncompressed_size;



    unsigned int current_channel_offset = 0;



    s->channel_offsets[0] = -1;

    s->channel_offsets[1] = -1;

    s->channel_offsets[2] = ",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
10847,qemu,1,"static void csrhci_reset(struct csrhci_s *s)

{

    s->out_len = 0;

    s->out_size = FIFO_LEN;

    s->in_len = 0;

    s->baud_delay = NANOSECONDS_PER_SECOND;

    s->enable = 0;

    s->in_hdr = INT_MAX;

    s->in_data = INT_MAX;



    s->modem_state = 0;

    /* After a while... (but sooner than 10ms) */

    s->modem_state |= CHR_TIOCM_CTS;



    memset(&s->bd_addr, 0, sizeof(bdaddr_t));

}
",0,0,0,0,0,0,0,0,0,1,1,1,1,1,1
10849,FFmpeg,1,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
10857,qemu,1,"int net_init_vhost_user(const Netdev *netdev, const char *name,

                        NetClientState *peer, Error **errp)

{

    int queues;

    const NetdevVhostUserOptions *vhost_user_opts;

    CharDriverState *chr;



    assert(netdev->type == NET_CLIENT_DRIVER_VHOST_USER);

    vhost_user_opts = &netdev->u.vhost_user;



    chr = net_vhost_parse_chardev(vhost_user_opts, errp);

    if (!chr) {

        return -1;

    }



    /* verify net frontend */

    if (qemu_opts_foreach(qemu_find_opts(""device""), net_vhost_check_net,

                          (char *)name, errp)) {

        return -1;

    }



    queues = vhost_user_opts->has_queues ? vhost_user_opts->queues : 1;

    if (queues < 1 || queues > MAX_QUEUE_NUM) {

        error_setg(errp,

                   ""vhost-user number of queues must be in range [1, %d]"",

                   MAX_QUEUE_NUM);

        return -1;

    }



    return net_vhost_user_init(peer, ""vhost_user"", name, chr, queues);

}
",1,0,3,0,0,0,0,1,0,0,1,0,0,0,1
10868,FFmpeg,1,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
",1,0,4,0,0,0,0,1,1,0,0,0,1,1,0
10869,FFmpeg,1,"static void check_add_res(HEVCDSPContext h, int bit_depth)

{

    int i;

    LOCAL_ALIGNED_32(int16_t, res0, [32 * 32]);

    LOCAL_ALIGNED_32(int16_t, res1, [32 * 32]);

    LOCAL_ALIGNED_32(uint8_t, dst0, [32 * 32 * 2]);

    LOCAL_ALIGNED_32(uint8_t, dst1, [32 * 32 * 2]);



    for (i = 2; i <= 5; i++) {

        int block_size = 1 << i;

        int size = block_size * block_size;

        ptrdiff_t stride = block_size << (bit_depth > 8);

        declare_func_emms(AV_CPU_FLAG_MMX, void, uint8_t *dst, int16_t *res, ptrdiff_t stride);



        randomize_buffers(res0, size);

        randomize_buffers2(dst0, size);

        memcpy(res1, res0, sizeof(*res0) * size);

        memcpy(dst1, dst0, size);



        if (check_func(h.add_residual[i - 2], ""add_res_%dx%d_%d"", block_size, block_size, bit_depth)) {

            call_ref(dst0, res0, stride);

            call_new(dst1, res1, stride);

            if (memcmp(dst0, dst1, size))

                fail();

            bench_new(dst1, res1, stride);

  ",1,0,4,0,0,0,0,1,0,1,0,1,0,0,0
10875,qemu,0,"static void test_validate_fail_union_flat(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefFlatUnion *tmp = NULL;

    Error *errp = NULL;

    Visitor *v;



    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");



    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefFlatUnion(tmp);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
10877,qemu,0,"void cpu_x86_update_cr4(CPUX86State *env, uint32_t new_cr4)

{

#if defined(DEBUG_MMU)

    printf(""CR4 update: CR4=%08x\n"", (uint32_t)env->cr[4]);

#endif

    if ((new_cr4 & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK)) !=

        (env->cr[4] & (CR4_PGE_MASK | CR4_PAE_MASK | CR4_PSE_MASK))) {

        tlb_flush(env, 1);

    }

    /* SSE handling */

    if (!(env->cpuid_features & CPUID_SSE))

        new_cr4 &= ~CR4_OSFXSR_MASK;

    if (new_cr4 & CR4_OSFXSR_MASK)

        env->hflags |= HF_OSFXSR_MASK;

    else

        env->hflags &= ~HF_OSFXSR_MASK;



    env->cr[4] = new_cr4;

}
",0,0,5,0,0,0,0,0,0,0,0,0,1,1,1
10899,qemu,0,"int drive_init(struct drive_opt *arg, int snapshot, void *opaque)

{

    char buf[128];

    char file[1024];

    char devname[128];

    char serial[21];

    const char *mediastr = """";

    BlockInterfaceType type;

    enum { MEDIA_DISK, MEDIA_CDROM } media;

    int bus_id, unit_id;

    int cyls, heads, secs, translation;

    BlockDriverState *bdrv;

    BlockDriver *drv = NULL;

    QEMUMachine *machine = opaque;

    int max_devs;

    int index;

    int cache;

    int bdrv_flags, onerror;

    int drives_table_idx;

    char *str = arg->opt;

    static const char * const params[] = { ""bus"", ""unit"", ""if"", ""index"",

                                           ""cyls"", ""heads"", ""secs"", ""trans"",

                                           ""media"", ""snapshot"", ""file"",

                                           ""cache"", ""format"", ""serial"", ""werror"",

                                           NULL };



    if (check_params(buf, sizeof(buf), params, str) < 0) {

         fprintf(stderr, ""qemu: unknown ",1,0,2,0,0,0,1,0,0,1,1,0,0,1,1
10914,qemu,1,"static void unix_wait_for_connect(int fd, Error *err, void *opaque)

{

    MigrationState *s = opaque;



    if (fd < 0) {

        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));

        s->file = NULL;

        migrate_fd_error(s);

    } else {

        DPRINTF(""migrate connect success\n"");

        s->file = qemu_fopen_socket(fd, ""wb"");

        migrate_fd_connect(s);

    }

}
",1,0,1,0,0,0,1,0,1,1,0,1,0,0,0
10950,FFmpeg,0,"static int ljpeg_encode_frame(AVCodecContext *avctx, AVPacket *pkt,

                              const AVFrame *pict, int *got_packet)

{

    LJpegEncContext *s = avctx->priv_data;

    PutBitContext pb;

    const int width  = avctx->width;

    const int height = avctx->height;

    const int mb_width  = (width  + s->hsample[0] - 1) / s->hsample[0];

    const int mb_height = (height + s->vsample[0] - 1) / s->vsample[0];

    int max_pkt_size = AV_INPUT_BUFFER_MIN_SIZE;

    int ret, header_bits;



    if (avctx->pix_fmt == AV_PIX_FMT_BGR24)

        max_pkt_size += width * height * 3 * 3;

    else {

        max_pkt_size += mb_width * mb_height * 3 * 4

                        * s->hsample[0] * s->vsample[0];

    }

    if ((ret = ff_alloc_packet(pkt, max_pkt_size)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Error getting output packet of size %d.\n"", max_pkt_size);

        return ret;

    }



    init_put_bits(&pb, pkt->data, pkt->size);



    ff_mjpeg_encode_picture_header(avctx, &pb, &s->sca",0,0,2,0,0,0,0,0,0,0,0,0,0,1,0
10962,FFmpeg,1,"int av_vsrc_buffer_add_video_buffer_ref(AVFilterContext *buffer_filter, AVFilterBufferRef *picref)

{

    BufferSourceContext *c = buffer_filter->priv;

    AVFilterLink *outlink = buffer_filter->outputs[0];

    int ret;



    if (c->picref) {

        av_log(buffer_filter, AV_LOG_ERROR,

               ""Buffering several frames is not supported. ""

               ""Please consume all available frames before adding a new one.\n""

            );

        //return -1;

    }



    if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pix_fmt) {

        AVFilterContext *scale = buffer_filter->outputs[0]->dst;

        AVFilterLink *link;

        char scale_param[1024];



        av_log(buffer_filter, AV_LOG_INFO,

               ""Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\n"",

               c->w, c->h, av_pix_fmt_descriptors[c->pix_fmt].name,

               picref->video->w, picref->video->h, av_pix_fmt_descriptors[picref->format].name);



        i",3,0,2,0,0,0,1,1,1,1,1,0,0,0,0
10971,FFmpeg,1,"int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx,
                                         H264ParamSets *ps, int bit_length)
{
    AVBufferRef *pps_buf;
    const SPS *sps;
    unsigned int pps_id = get_ue_golomb(gb);
    PPS *pps;
    int qp_bd_offset;
    int bits_left;
    int ret;
    if (pps_id >= MAX_PPS_COUNT) {
        av_log(avctx, AV_LOG_ERROR, ""pps_id %u out of range\n"", pps_id);
        return AVERROR_INVALIDDATA;
    pps_buf = av_buffer_allocz(sizeof(*pps));
    if (!pps_buf)
        return AVERROR(ENOMEM);
    pps = (PPS*)pps_buf->data;
    pps->data_size = gb->buffer_end - gb->buffer;
    if (pps->data_size > sizeof(pps->data)) {
        av_log(avctx, AV_LOG_WARNING, ""Truncating likely oversized PPS ""
               ""(%""SIZE_SPECIFIER"" > %""SIZE_SPECIFIER"")\n"",
               pps->data_size, sizeof(pps->data));
        pps->data_size = sizeof(pps->data);
    memcpy(pps->data, gb->buffer, pps->data_size);
    pps->sps_id = get_ue_golomb_31(gb);
    if ((unsigned)",0,0,4,0,0,0,0,0,0,0,0,1,1,1,1
10974,qemu,1,"static void qxl_spice_monitors_config_async(PCIQXLDevice *qxl, int replay)

{

    trace_qxl_spice_monitors_config(qxl->id);

    if (replay) {

        /*

         * don't use QXL_COOKIE_TYPE_IO:

         *  - we are not running yet (post_load), we will assert

         *    in send_events

         *  - this is not a guest io, but a reply, so async_io isn't set.

         */

        spice_qxl_monitors_config_async(&qxl->ssd.qxl,

                qxl->guest_monitors_config,

                MEMSLOT_GROUP_GUEST,

                (uintptr_t)qxl_cookie_new(

                    QXL_COOKIE_TYPE_POST_LOAD_MONITORS_CONFIG,

                    0));

    } else {

#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */

        if (qxl->max_outputs) {

            spice_qxl_set_monitors_config_limit(&qxl->ssd.qxl,

                                                qxl->max_outputs);

        }

#endif

        qxl->guest_monitors_config = qxl->ram->monitors_config;

        spice_qxl_monitors_config_async(&qxl->",0,0,4,0,0,0,0,0,0,1,1,1,1,1,1
10982,qemu,0,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(n);

    NetClientState *nc = qemu_get_queue(n->nic);

    int queues = n->multiqueue ? n->max_queues : 1;



    if (!get_vhost_net(nc->peer)) {

        return;

    }



    if (!!n->vhost_started ==

        (virtio_net_started(n, status) && !nc->peer->link_down)) {

        return;

    }

    if (!n->vhost_started) {

        int r;

        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {

            return;

        }

        n->vhost_started = 1;

        r = vhost_net_start(vdev, n->nic->ncs, queues);

        if (r < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -r);

            n->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, n->nic->ncs, queues);

        n->vhost_started = 0;

    }

}
",0,0,5,0,0,0,1,1,1,1,1,1,1,1,1
10984,qemu,0,"static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
",0,0,0,0,0,0,0,1,0,1,0,1,0,0,0
10992,FFmpeg,0,"static void init_block_mapping(Vp3DecodeContext *s) 

{

    int i, j;

    signed int hilbert_walk_y[16];

    signed int hilbert_walk_c[16];

    signed int hilbert_walk_mb[4];



    int current_fragment = 0;

    int current_width = 0;

    int current_height = 0;

    int right_edge = 0;

    int bottom_edge = 0;

    int superblock_row_inc = 0;

    int *hilbert = NULL;

    int mapping_index = 0;



    int current_macroblock;

    int c_fragment;



    signed char travel_width[16] = {

         1,  1,  0, -1, 

         0,  0,  1,  0,

         1,  0,  1,  0,

         0, -1,  0,  1

    };



    signed char travel_height[16] = {

         0,  0,  1,  0,

         1,  1,  0, -1,

         0,  1,  0, -1,

        -1,  0, -1,  0

    };



    signed char travel_width_mb[4] = {

         1,  0,  1,  0

    };



    signed char travel_height_mb[4] = {

         0,  1,  0, -1

    };



    debug_vp3(""  vp3: initialize block mapping tables\n"");



    /* figure out hilbert pattern per these frame dimen",0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
10999,qemu,0,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}
",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
11016,qemu,0,"int acpi_pcihp_device_hotplug(AcpiPciHpState *s, PCIDevice *dev,

                              PCIHotplugState state)

{

    int slot = PCI_SLOT(dev->devfn);

    int bsel = acpi_pcihp_get_bsel(dev->bus);

    if (bsel < 0) {

        return -1;

    }



    /* Don't send event when device is enabled during qemu machine creation:

     * it is present on boot, no hotplug event is necessary. We do send an

     * event when the device is disabled later. */

    if (state == PCI_COLDPLUG_ENABLED) {

        s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

        return 0;

    }



    if (state == PCI_HOTPLUG_ENABLED) {

        enable_device(s, bsel, slot);

    } else {

        disable_device(s, bsel, slot);

    }



    return 0;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
11026,FFmpeg,0,"static void frame_start(H264Context *h){

    MpegEncContext * const s = &h->s;

    int i;



    MPV_frame_start(s, s->avctx);

    ff_er_frame_start(s);



    assert(s->linesize && s->uvlinesize);



    for(i=0; i<16; i++){

        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);

        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);

    }

    for(i=0; i<4; i++){

        h->block_offset[16+i]=

        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);

        h->block_offset[24+16+i]=

        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);

    }



    /* can't be in alloc_tables because linesize isn't known there.

     * FIXME: redo bipred weight to not require extra buffer? */

    if(!s->obmc_scratchpad)

        s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize);



//    s->decode= (s->fl",2,0,1,0,0,0,0,0,0,0,0,0,0,1,1
11046,qemu,1,"static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}",0,0,0,0,0,0,0,1,0,1,0,1,1,1,1
11070,qemu,1,"void qmp_guest_file_flush(int64_t handle, Error **errp)

{

    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);

    FILE *fh;

    int ret;



    if (!gfh) {

        return;

    }



    fh = gfh->fh;

    ret = fflush(fh);

    if (ret == EOF) {

        error_setg_errno(errp, errno, ""failed to flush file"");



    }

}",0,0,2,0,0,0,1,1,1,1,1,1,1,1,0
11080,FFmpeg,0,"static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){

    MpegEncContext * const s = &h->s;

    Picture * const ref1 = &h->ref_list[1][0];

    int j, old_ref, rfield;

    int start= mbafi ? 16                      : 0;

    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];

    int interl= mbafi || s->picture_structure != PICT_FRAME;



    /* bogus; fills in for missing frames */

    memset(map[list], 0, sizeof(map[list]));



    for(rfield=0; rfield<2; rfield++){

        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){

            int poc = ref1->ref_poc[colfield][list][old_ref];



            if     (!interl)

                poc |= 3;

            else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed

                poc= (poc&~3) + rfield + 1;



            for(j=start; j<end; j++){

                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc)",3,0,3,0,0,0,0,0,0,0,0,0,1,1,1
11084,FFmpeg,0,"static void compute_frame_duration(int *pnum, int *pden,

                                   AVFormatContext *s, AVStream *st, 

                                   AVCodecParserContext *pc, AVPacket *pkt)

{

    int frame_size;



    *pnum = 0;

    *pden = 0;

    switch(st->codec.codec_type) {

    case CODEC_TYPE_VIDEO:

        *pnum = st->codec.frame_rate_base;

        *pden = st->codec.frame_rate;

        if (pc && pc->repeat_pict) {

            *pden *= 2;

            *pnum = (*pnum) * (2 + pc->repeat_pict);

        }

        break;

    case CODEC_TYPE_AUDIO:

        frame_size = get_audio_frame_size(&st->codec, pkt->size);

        if (frame_size < 0)

            break;

        *pnum = frame_size;

        *pden = st->codec.sample_rate;

        break;

    default:

        break;

    }

}
",0,0,2,0,1,0,1,1,0,1,1,0,0,1,0
11113,qemu,1,"static int os_host_main_loop_wait(int64_t timeout)
{
    GMainContext *context = g_main_context_default();
    GPollFD poll_fds[1024 * 2]; /* this is probably overkill */
    int select_ret = 0;
    int g_poll_ret, ret, i, n_poll_fds;
    PollingEntry *pe;
    WaitObjects *w = &wait_objects;
    gint poll_timeout;
    int64_t poll_timeout_ns;
    static struct timeval tv0;
    fd_set rfds, wfds, xfds;
    int nfds;
    /* XXX: need to suppress polling by better using win32 events */
    ret = 0;
    for (pe = first_polling_entry; pe != NULL; pe = pe->next) {
        ret |= pe->func(pe->opaque);
    }
    if (ret != 0) {
        return ret;
    }
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    FD_ZERO(&xfds);
    nfds = pollfds_fill(gpollfds, &rfds, &wfds, &xfds);
    if (nfds >= 0) {
        select_ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0);
        if (select_ret != 0) {
            timeout = 0;
        }
        if (select_ret > 0) {
            pollfds_poll(gpollfds, nfds, &rfds, &wfds, &xfds);
        ",1,0,4,0,0,0,0,0,0,0,1,0,1,1,1
11117,qemu,1,"int bdrv_snapshot_delete(BlockDriverState *bs, const char *snapshot_id)

{

    BlockDriver *drv = bs->drv;

    if (!drv) {

        return -ENOMEDIUM;

    }

    if (drv->bdrv_snapshot_delete) {

        return drv->bdrv_snapshot_delete(bs, snapshot_id);

    }

    if (bs->file) {

        return bdrv_snapshot_delete(bs->file, snapshot_id);

    }

    return -ENOTSUP;

}
",0,0,3,0,0,0,0,0,1,0,0,0,1,1,1
11126,qemu,0,"static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)

{

    uint32_t val;



    val = bswap32(cpu_inl(addr & IOPORTS_MASK));

    return val;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
11127,qemu,0,"static void qemu_fill_buffer(QEMUFile *f)

{

    int len;



    if (f->is_writable)

        return;

    if (f->is_file) {

        fseek(f->outfile, f->buf_offset, SEEK_SET);

        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);

        if (len < 0)

            len = 0;

    } else {

        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,

                         f->buf, IO_BUF_SIZE);

        if (len < 0)

            len = 0;

    }

    f->buf_index = 0;

    f->buf_size = len;

    f->buf_offset += len;

}
",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
11128,qemu,0,"void net_hub_check_clients(void)

{

    NetHub *hub;

    NetHubPort *port;

    NetClientState *peer;



    QLIST_FOREACH(hub, &hubs, next) {

        int has_nic = 0, has_host_dev = 0;



        QLIST_FOREACH(port, &hub->ports, next) {

            peer = port->nc.peer;

            if (!peer) {

                fprintf(stderr, ""Warning: hub port %s has no peer\n"",

                        port->nc.name);

                continue;

            }



            switch (peer->info->type) {

            case NET_CLIENT_DRIVER_NIC:

                has_nic = 1;

                break;

            case NET_CLIENT_DRIVER_USER:

            case NET_CLIENT_DRIVER_TAP:

            case NET_CLIENT_DRIVER_SOCKET:

            case NET_CLIENT_DRIVER_VDE:

            case NET_CLIENT_DRIVER_VHOST_USER:

                has_host_dev = 1;

                break;

            default:

                break;

            }

        }

        if (has_host_dev && !has_nic) {

            warn_report(""vlan %d with no ",0,0,2,0,1,0,1,1,1,1,0,1,1,1,1
11140,FFmpeg,0,"DVDemuxContext* dv_init_demux(AVFormatContext *s)

{

    DVDemuxContext *c;



    c = av_mallocz(sizeof(DVDemuxContext));

    if (!c)

        return NULL;



    c->vst = av_new_stream(s, 0);

    c->ast[0] = av_new_stream(s, 0);

    if (!c->vst || !c->ast[0])

        goto fail;

    av_set_pts_info(c->vst, 64, 1, 30000);

    av_set_pts_info(c->ast[0], 64, 1, 30000);



    c->fctx = s;

    c->ast[1] = NULL;

    c->ach = 0;

    c->frames = 0;

    c->abytes = 0;

    c->audio_pkt[0].size = 0;

    c->audio_pkt[1].size = 0;

    

    c->vst->codec.codec_type = CODEC_TYPE_VIDEO;

    c->vst->codec.codec_id = CODEC_ID_DVVIDEO;

    c->vst->codec.bit_rate = 25000000;

    

    c->ast[0]->codec.codec_type = CODEC_TYPE_AUDIO;

    c->ast[0]->codec.codec_id = CODEC_ID_PCM_S16LE;

   

    s->ctx_flags |= AVFMTCTX_NOHEADER; 

    

    return c;

    

fail:

    if (c->vst)

        av_free(c->vst);

    if (c->ast[0])

        av_free(c->ast[0]);

    av_free(c);

    return NULL;

}
",0,1,4,0,0,0,0,0,0,0,0,0,0,0,0
11141,qemu,0,"static int coroutine_fn bdrv_co_do_pwrite_zeroes(BlockDriverState *bs,

    int64_t offset, int bytes, BdrvRequestFlags flags)

{

    BlockDriver *drv = bs->drv;

    QEMUIOVector qiov;

    struct iovec iov = {0};

    int ret = 0;

    bool need_flush = false;

    int head = 0;

    int tail = 0;



    int max_write_zeroes = MIN_NON_ZERO(bs->bl.max_pwrite_zeroes, INT_MAX);

    int alignment = MAX(bs->bl.pwrite_zeroes_alignment,

                        bs->bl.request_alignment);

    int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer,

                                    MAX_WRITE_ZEROES_BOUNCE_BUFFER);



    assert(alignment % bs->bl.request_alignment == 0);

    head = offset % alignment;

    tail = (offset + bytes) % alignment;

    max_write_zeroes = QEMU_ALIGN_DOWN(max_write_zeroes, alignment);

    assert(max_write_zeroes >= bs->bl.request_alignment);



    while (bytes > 0 && !ret) {

        int num = bytes;



        /* Align request.  Block drivers can expect the ""bulk"" of the request

  ",0,0,0,0,0,1,0,0,0,1,0,1,0,0,1
11142,qemu,0,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
11143,qemu,0,"static EHCIQueue *ehci_state_fetchqh(EHCIState *ehci, int async)

{

    uint32_t entry;

    EHCIQueue *q;

    int reload;



    entry = ehci_get_fetch_addr(ehci, async);

    q = ehci_find_queue_by_qh(ehci, entry);

    if (NULL == q) {

        q = ehci_alloc_queue(ehci, async);

    }

    q->qhaddr = entry;

    q->seen++;



    if (q->seen > 1) {

        /* we are going in circles -- stop processing */

        ehci_set_state(ehci, async, EST_ACTIVE);

        q = NULL;

        goto out;

    }



    get_dwords(NLPTR_GET(q->qhaddr), (uint32_t *) &q->qh, sizeof(EHCIqh) >> 2);

    ehci_trace_qh(q, NLPTR_GET(q->qhaddr), &q->qh);



    if (q->async == EHCI_ASYNC_INFLIGHT) {

        /* I/O still in progress -- skip queue */

        ehci_set_state(ehci, async, EST_HORIZONTALQH);

        goto out;

    }

    if (q->async == EHCI_ASYNC_FINISHED) {

        /* I/O finished -- continue processing queue */

        trace_usb_ehci_queue_action(q, ""resume"");

        ehci_set_state(ehci, async, EST_EXECU",0,2,4,0,0,0,0,0,0,1,1,1,1,0,1
11167,qemu,0,"static void omap_rtc_reset(struct omap_rtc_s *s)

{

    struct tm tm;



    s->interrupts = 0;

    s->comp_reg = 0;

    s->running = 0;

    s->pm_am = 0;

    s->auto_comp = 0;

    s->round = 0;

    s->tick = qemu_get_clock(rt_clock);

    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));

    s->alarm_tm.tm_mday = 0x01;

    s->status = 1 << 7;

    qemu_get_timedate(&tm, 0);

    s->ti = mktimegm(&tm);



    omap_rtc_alarm_update(s);

    omap_rtc_tick(s);

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
11193,qemu,1,"static void tosa_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    MemoryRegion *address_space_mem = get_system_memory();

    MemoryRegion *rom = g_new(MemoryRegion, 1);

    PXA2xxState *mpu;

    TC6393xbState *tmio;

    DeviceState *scp0, *scp1;



    if (!cpu_model)

        cpu_model = ""pxa255"";



    mpu = pxa255_init(address_space_mem, tosa_binfo.ram_size);



    memory_region_init_ram(rom, NULL, ""tosa.rom"", TOSA_ROM, &error_abort);

    vmstate_register_ram_global(rom);

    memory_region_set_readonly(rom, true);

    memory_region_add_subregion(address_space_mem, 0, rom);



    tmio = tc6393xb_init(address_space_mem, 0x10000000,

            qdev_get_gpio_in(mpu->gpio, TOSA_GPIO_TC6393XB_INT));



    scp0 = sysbus_create_simple(""scoop"", 0x08800000, NULL);

    scp1 = sysbus_create_",0,0,1,0,0,0,0,1,1,1,1,1,0,0,1
11202,qemu,1,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
",0,0,1,0,0,0,0,0,0,1,1,1,0,0,0
11235,qemu,1,"struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->base = base;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,

                               omap_clk_getrate(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    return s;

}
",0,0,0,0,0,0,0,1,0,1,0,0,1,0,1
11268,qemu,0,"static int create_dynamic_disk(int fd, uint8_t *buf, int64_t total_sectors)

{

    VHDDynDiskHeader *dyndisk_header =

        (VHDDynDiskHeader *) buf;

    size_t block_size, num_bat_entries;

    int i;

    int ret = -EIO;



    // Write the footer (twice: at the beginning and at the end)

    block_size = 0x200000;

    num_bat_entries = (total_sectors + block_size / 512) / (block_size / 512);



    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {

        goto fail;

    }



    if (lseek(fd, 1536 + ((num_bat_entries * 4 + 511) & ~511), SEEK_SET) < 0) {

        goto fail;

    }

    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {

        goto fail;

    }



    // Write the initial BAT

    if (lseek(fd, 3 * 512, SEEK_SET) < 0) {

        goto fail;

    }



    memset(buf, 0xFF, 512);

    for (i = 0; i < (num_bat_entries * 4 + 511) / 512; i++) {

        if (write(fd, buf, 512) != 512) {

            goto fail;

        }

    }



    // Prepare the Dynamic Disk Header

    memset(buf, 0,",1,5,5,0,0,0,0,0,0,0,1,1,0,0,0
11303,qemu,0,"static int qemu_rbd_snap_list(BlockDriverState *bs,

                              QEMUSnapshotInfo **psn_tab)

{

    BDRVRBDState *s = bs->opaque;

    QEMUSnapshotInfo *sn_info, *sn_tab = NULL;

    int i, snap_count;

    rbd_snap_info_t *snaps;

    int max_snaps = RBD_MAX_SNAPS;



    do {

        snaps = g_malloc(sizeof(*snaps) * max_snaps);

        snap_count = rbd_snap_list(s->image, snaps, &max_snaps);

        if (snap_count < 0) {

            g_free(snaps);

        }

    } while (snap_count == -ERANGE);



    if (snap_count <= 0) {

        return snap_count;

    }



    sn_tab = g_malloc0(snap_count * sizeof(QEMUSnapshotInfo));



    for (i = 0; i < snap_count; i++) {

        const char *snap_name = snaps[i].name;



        sn_info = sn_tab + i;

        pstrcpy(sn_info->id_str, sizeof(sn_info->id_str), snap_name);

        pstrcpy(sn_info->name, sizeof(sn_info->name), snap_name);



        sn_info->vm_state_size = snaps[i].size;

        sn_info->date_sec = 0;

        sn_info->date",1,0,2,0,0,1,0,0,0,1,1,0,1,1,0
11316,qemu,0,"static bool get_phys_addr_pmsav8(CPUARMState *env, uint32_t address,

                                 MMUAccessType access_type, ARMMMUIdx mmu_idx,

                                 hwaddr *phys_ptr, int *prot, uint32_t *fsr)

{

    ARMCPU *cpu = arm_env_get_cpu(env);

    bool is_user = regime_is_user(env, mmu_idx);

    int n;

    int matchregion = -1;

    bool hit = false;



    *phys_ptr = address;

    *prot = 0;



    /* Unlike the ARM ARM pseudocode, we don't need to check whether this

     * was an exception vector read from the vector table (which is always

     * done using the default system address map), because those accesses

     * are done in arm_v7m_load_vector(), which always does a direct

     * read using address_space_ldl(), rather than going via this function.

     */

    if (regime_translation_disabled(env, mmu_idx)) { /* MPU disabled */

        hit = true;

    } else if (m_is_ppb_region(env, address)) {

        hit = true;

    } else if (pmsav7_use_background_region(cpu,",0,0,3,0,0,0,1,1,0,1,0,1,0,0,1
11328,qemu,1,"static int v9fs_xattr_read(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp,

                           uint64_t off, uint32_t max_count)

{

    ssize_t err;

    size_t offset = 7;

    int read_count;

    int64_t xattr_len;

    V9fsVirtioState *v = container_of(s, V9fsVirtioState, state);

    VirtQueueElement *elem = v->elems[pdu->idx];



    xattr_len = fidp->fs.xattr.len;

    read_count = xattr_len - off;

    if (read_count > max_count) {

        read_count = max_count;

    } else if (read_count < 0) {

        /*

         * read beyond XATTR value

         */

        read_count = 0;

    }

    err = pdu_marshal(pdu, offset, ""d"", read_count);

    if (err < 0) {

        return err;

    }

    offset += err;



    err = v9fs_pack(elem->in_sg, elem->in_num, offset,

                    ((char *)fidp->fs.xattr.value) + off,

                    read_count);

    if (err < 0) {

        return err;

    }

    offset += err;

    return offset;

}
",0,0,4,0,0,0,1,1,1,1,1,1,0,0,0
11334,qemu,1,"static coroutine_fn int vmdk_co_write(BlockDriverState *bs, int64_t sector_num,

                                      const uint8_t *buf, int nb_sectors)

{

    int ret;

    BDRVVmdkState *s = bs->opaque;

    qemu_co_mutex_lock(&s->lock);

    ret = vmdk_write(bs, sector_num, buf, nb_sectors);

    qemu_co_mutex_unlock(&s->lock);

    return ret;

}
",0,0,0,0,0,0,0,0,0,1,1,1,1,1,1
11359,qemu,1,"int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,

                         uint8_t *dst, int dlen)

{

    uint32_t zrun_len = 0, nzrun_len = 0;

    int d = 0, i = 0;

    long res, xor;

    uint8_t *nzrun_start = NULL;



    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) %

               sizeof(long)));



    while (i < slen) {

        /* overflow */

        if (d + 2 > dlen) {

            return -1;

        }



        /* not aligned to sizeof(long) */

        res = (slen - i) % sizeof(long);

        while (res && old_buf[i] == new_buf[i]) {

            zrun_len++;

            i++;

            res--;

        }



        /* word at a time for speed */

        if (!res) {

            while (i < slen &&

                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {

                i += sizeof(long);

                zrun_len += sizeof(long);

            }



            /* go over the rest */

            while (i < slen && old_buf[i] == new_",0,0,2,0,0,4,0,0,0,1,1,1,1,0,0
11361,FFmpeg,1,"static av_cold void init_atrac3_transforms(ATRAC3Context *q) {

    float enc_window[256];

    int i;



    /* Generate the mdct window, for details see

     * http://wiki.multimedia.cx/index.php?title=RealAudio_atrc#Windows */

    for (i=0 ; i<256; i++)

        enc_window[i] = (sin(((i + 0.5) / 256.0 - 0.5) * M_PI) + 1.0) * 0.5;



    if (!mdct_window[0])

        for (i=0 ; i<256; i++) {

            mdct_window[i] = enc_window[i]/(enc_window[i]*enc_window[i] + enc_window[255-i]*enc_window[255-i]);

            mdct_window[511-i] = mdct_window[i];

        }



    /* Initialize the MDCT transform. */

    ff_mdct_init(&mdct_ctx, 9, 1, 1.0);

}
",4,0,1,0,0,0,0,0,0,0,0,0,1,1,1
11368,qemu,1,"static void gd_resize(DisplayChangeListener *dcl,

                      DisplayState *ds)

{

    GtkDisplayState *s = ds->opaque;

    cairo_format_t kind;

    int stride;



    DPRINTF(""resize(width=%d, height=%d)\n"",

            ds_get_width(ds), ds_get_height(ds));



    if (s->surface) {

        cairo_surface_destroy(s->surface);

    }



    switch (ds->surface->pf.bits_per_pixel) {

    case 8:

        kind = CAIRO_FORMAT_A8;

        break;

    case 16:

        kind = CAIRO_FORMAT_RGB16_565;

        break;

    case 32:

        kind = CAIRO_FORMAT_RGB24;

        break;

    default:

        g_assert_not_reached();

        break;

    }



    stride = cairo_format_stride_for_width(kind, ds_get_width(ds));

    g_assert(ds_get_linesize(ds) == stride);



    s->surface = cairo_image_surface_create_for_data(ds_get_data(ds),

                                                     kind,

                                                     ds_get_width(ds),

                                  ",4,0,1,0,1,0,0,0,0,0,0,0,1,0,1
11381,qemu,1,"void lm32_juart_set_jtx(DeviceState *d, uint32_t jtx)

{

    LM32JuartState *s = LM32_JUART(d);

    unsigned char ch = jtx & 0xff;



    trace_lm32_juart_set_jtx(s->jtx);



    s->jtx = jtx;

    if (s->chr) {



        qemu_chr_fe_write_all(s->chr, &ch, 1);

    }

}",0,0,1,0,0,0,0,1,1,1,1,0,0,0,0
11383,FFmpeg,1,"static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,

                                    AVPacket *pkt, uint64_t display_duration)

{

    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;

    for (; *ptr!=',' && ptr<end-1; ptr++);

    if (*ptr == ',')

        layer = ++ptr;

    for (; *ptr!=',' && ptr<end-1; ptr++);

    if (*ptr == ',') {

        int64_t end_pts = pkt->pts + display_duration;

        int sc = matroska->time_scale * pkt->pts / 10000000;

        int ec = matroska->time_scale * end_pts  / 10000000;

        int sh, sm, ss, eh, em, es, len;

        sh = sc/360000;  sc -= 360000*sh;

        sm = sc/  6000;  sc -=   6000*sm;

        ss = sc/   100;  sc -=    100*ss;

        eh = ec/360000;  ec -= 360000*eh;

        em = ec/  6000;  ec -=   6000*em;

        es = ec/   100;  ec -=    100*es;

        *ptr++ = '\0';

        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;

        if (!(line = av_malloc(len)))

            return;

        snprintf(line,len,",2,0,3,0,0,0,1,1,1,0,1,1,1,0,1
11400,qemu,0,"send_msg(

    VSCMsgType type,

    uint32_t reader_id,

    const void *msg,

    unsigned int length

) {

    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);

    }



    mhHeader.type = htonl(type);

    mhHeader.reader_id = 0;

    mhHeader.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,1,0,0,1
11423,FFmpeg,0,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}
",2,0,0,0,0,0,0,1,0,0,0,0,0,0,0
11427,FFmpeg,0,"static int encode_picture_ls(AVCodecContext *avctx, AVPacket *pkt,

                             const AVFrame *pict, int *got_packet)

{

    const AVFrame *const p = pict;

    const int near         = avctx->prediction_method;

    PutBitContext pb, pb2;

    GetBitContext gb;

    uint8_t *buf2 = NULL;

    uint8_t *zero = NULL;

    uint8_t *cur  = NULL;

    uint8_t *last = NULL;

    JLSState *state;

    int i, size, ret;

    int comps;



    if (avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||

        avctx->pix_fmt == AV_PIX_FMT_GRAY16)

        comps = 1;

    else

        comps = 3;



    if ((ret = ff_alloc_packet(pkt, avctx->width * avctx->height * comps * 4 +

                               AV_INPUT_BUFFER_MIN_SIZE)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Error getting output packet.\n"");

        return ret;

    }



    buf2 = av_malloc(pkt->size);

    if (!buf2)

        goto memfail;



    init_put_bits(&pb, pkt->data, pkt->size);

    init_put_bits(&pb2, buf2, pkt->size);



    /* writ",0,1,3,0,0,0,1,1,0,0,0,1,0,0,0
11428,FFmpeg,0,"void ff_vc1_decode_blocks(VC1Context *v)

{



    v->s.esc3_level_length = 0;

    if (v->x8_type) {

        ff_intrax8_decode_picture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer);



        ff_er_add_slice(&v->s.er, 0, 0,

                        (v->s.mb_x >> 1) - 1, (v->s.mb_y >> 1) - 1,

                        ER_MB_END);

    } else {

        v->cur_blk_idx     =  0;

        v->left_blk_idx    = -1;

        v->topleft_blk_idx =  1;

        v->top_blk_idx     =  2;

        switch (v->s.pict_type) {

        case AV_PICTURE_TYPE_I:

            if (v->profile == PROFILE_ADVANCED)

                vc1_decode_i_blocks_adv(v);

            else

                vc1_decode_i_blocks(v);

            break;

        case AV_PICTURE_TYPE_P:

            if (v->p_frame_skipped)

                vc1_decode_skip_blocks(v);

            else

                vc1_decode_p_blocks(v);

            break;

        case AV_PICTURE_TYPE_B:

            if (v->bi_type) {

                if (v->profile == P",0,0,5,0,1,0,0,0,1,0,0,0,0,0,0
11433,FFmpeg,1,"paint_mouse_pointer(XImage *image, struct x11_grab *s)

{

    int x_off = s->x_off;

    int y_off = s->y_off;

    int width = s->width;

    int height = s->height;

    Display *dpy = s->dpy;

    XFixesCursorImage *xcim;

    int x, y;

    int line, column;

    int to_line, to_column;

    int image_addr, xcim_addr;



    xcim = XFixesGetCursorImage(dpy);



    x = xcim->x - xcim->xhot;

    y = xcim->y - xcim->yhot;



    to_line = FFMIN((y + xcim->height), (height + y_off));

    to_column = FFMIN((x + xcim->width), (width + x_off));



    for (line = FFMAX(y, y_off); line < to_line; line++) {

        for (column = FFMAX(x, x_off); column < to_column; column++) {

            xcim_addr = (line - y) * xcim->width + column - x;



            if ((unsigned char)(xcim->pixels[xcim_addr] >> 24) != 0) { // skip fully transparent pixel

                image_addr = ((line - y_off) * width + column - x_off) * 4;



                image->data[image_addr] = (unsigned char)(xcim->pixels[xcim_addr] >> 0);",2,0,1,0,0,0,0,0,0,0,0,0,0,0,0
11439,qemu,1,"static uint64_t boston_platreg_read(void *opaque, hwaddr addr,

                                    unsigned size)

{

    BostonState *s = opaque;

    uint32_t gic_freq, val;



    if (size != 4) {

        qemu_log_mask(LOG_UNIMP, ""%uB platform register read"", size);

        return 0;

    }



    switch (addr & 0xffff) {

    case PLAT_FPGA_BUILD:

    case PLAT_CORE_CL:

    case PLAT_WRAPPER_CL:

        return 0;

    case PLAT_DDR3_STATUS:

        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;

    case PLAT_MMCM_DIV:

        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;

        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;

        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;

        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;

        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;

        return val;

    case PLAT_BUILD_CFG:

        val = PLAT_BUILD_CFG_PCIE0_EN;

        val |= PLAT_BUILD_CFG_PCIE1_EN;

        val |= PLAT_BUILD_CFG_PCIE2_EN;

        return val;

    c",1,0,1,0,1,0,1,1,1,1,1,1,0,0,0
11444,FFmpeg,0,"int avfilter_register(AVFilter *filter)

{

    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)

        return -1;



    registered_avfilters[next_registered_avfilter_idx++] = filter;

    return 0;

}
",0,0,1,0,0,0,0,1,0,1,1,0,1,0,0
11449,qemu,1,"void qmp_migrate_cancel(Error **errp)

{

    migrate_fd_cancel(migrate_get_current());

}
",0,0,0,0,0,0,0,0,1,1,0,0,0,1,1
11455,qemu,1,"int load_snapshot(const char *name, Error **errp)

{

    BlockDriverState *bs, *bs_vm_state;

    QEMUSnapshotInfo sn;

    QEMUFile *f;

    int ret;

    AioContext *aio_context;

    MigrationIncomingState *mis = migration_incoming_get_current();



    if (!bdrv_all_can_snapshot(&bs)) {

        error_setg(errp,

                   ""Device '%s' is writable but does not support snapshots"",

                   bdrv_get_device_name(bs));

        return -ENOTSUP;

    }

    ret = bdrv_all_find_snapshot(name, &bs);

    if (ret < 0) {

        error_setg(errp,

                   ""Device '%s' does not have the requested snapshot '%s'"",

                   bdrv_get_device_name(bs), name);

        return ret;

    }



    bs_vm_state = bdrv_all_find_vmstate_bs();

    if (!bs_vm_state) {

        error_setg(errp, ""No block device supports snapshots"");

        return -ENOTSUP;

    }

    aio_context = bdrv_get_aio_context(bs_vm_state);



    /* Don't even try to load empty VM states */

    aio_context_ac",0,0,3,0,0,0,1,1,0,1,1,1,0,0,0
11468,FFmpeg,0,"static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src,

                                             ptrdiff_t buf_stride,

                                             ptrdiff_t src_stride,

                                             int block_w, int block_h,

                                             int src_x, int src_y, int w, int h)

{

    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,

                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,

                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);

}
",0,0,2,0,0,0,1,1,0,0,0,0,1,1,0
11488,FFmpeg,1,"static int mov_text_tx3g(AVCodecContext *avctx, MovTextContext *m)

{

    char *tx3g_ptr = avctx->extradata;

    int i, box_size, font_length;

    int8_t v_align, h_align;

    int style_fontID;

    StyleBox s_default;



    m->count_f = 0;

    m->ftab_entries = 0;

    box_size = BOX_SIZE_INITIAL; /* Size till ftab_entries */

    if (avctx->extradata_size < box_size)

        return -1;



    // Display Flags

    tx3g_ptr += 4;

    // Alignment

    h_align = *tx3g_ptr++;

    v_align = *tx3g_ptr++;

    if (h_align == 0) {

        if (v_align == 0)

            m->d.alignment = TOP_LEFT;

        if (v_align == 1)

            m->d.alignment = MIDDLE_LEFT;

        if (v_align == -1)

            m->d.alignment = BOTTOM_LEFT;

    }

    if (h_align == 1) {

        if (v_align == 0)

            m->d.alignment = TOP_CENTER;

        if (v_align == 1)

            m->d.alignment = MIDDLE_CENTER;

        if (v_align == -1)

            m->d.alignment = BOTTOM_CENTER;

    }

    if (h_align == -1",0,0,10,0,0,0,1,1,1,1,1,1,1,1,1
11501,qemu,1,"static void msmouse_chr_close (struct CharDriverState *chr)

{

    MouseState *mouse = chr->opaque;



    qemu_input_handler_unregister(mouse->hs);

    g_free(mouse);

    g_free(chr);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,0,1
11516,qemu,1,"int qemu_init_main_loop(void)

{

    int ret;



    ret = qemu_signal_init();

    if (ret) {

        return ret;

    }



    qemu_init_sigbus();



    return qemu_event_init();

}
",0,0,1,0,0,0,0,1,0,1,1,1,1,0,1
11524,qemu,1,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
",0,0,4,0,0,2,1,1,1,1,1,1,1,1,1
11527,FFmpeg,0,"static int avi_write_packet(AVFormatContext *s, AVPacket *pkt)

{

    unsigned char tag[5];

    unsigned int flags = 0;

    const int stream_index = pkt->stream_index;

    int size               = pkt->size;

    AVIContext *avi     = s->priv_data;

    AVIOContext *pb     = s->pb;

    AVIStream *avist    = s->streams[stream_index]->priv_data;

    AVCodecParameters *par = s->streams[stream_index]->codecpar;



    while (par->block_align == 0 && pkt->dts != AV_NOPTS_VALUE &&

           pkt->dts > avist->packet_count) {

        AVPacket empty_packet;



        av_init_packet(&empty_packet);

        empty_packet.size         = 0;

        empty_packet.data         = NULL;

        empty_packet.stream_index = stream_index;

        avi_write_packet(s, &empty_packet);

    }

    avist->packet_count++;



    // Make sure to put an OpenDML chunk when the file size exceeds the limits

    if (pb->seekable &&

        (avio_tell(pb) - avi->riff_start > AVI_MAX_RIFF_SIZE)) {

        avi_write_ix(s);

    ",0,0,2,0,0,1,0,0,0,0,0,0,0,0,0
11529,FFmpeg,0,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)

{

    if (err != CUDA_SUCCESS) {

        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);

        return 0;

    }

    return 1;

}
",0,0,1,0,0,0,0,0,1,0,0,1,1,1,1
11535,FFmpeg,0,"static void show_stream(WriterContext *w, AVFormatContext *fmt_ctx, int stream_idx, int in_program)

{

    AVStream *stream = fmt_ctx->streams[stream_idx];

    AVCodecContext *dec_ctx;

    const AVCodec *dec;

    char val_str[128];

    const char *s;

    AVRational sar, dar;

    AVBPrint pbuf;



    av_bprint_init(&pbuf, 1, AV_BPRINT_SIZE_UNLIMITED);



    writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);



    print_int(""index"", stream->index);



    if ((dec_ctx = stream->codec)) {

        const char *profile = NULL;

        dec = dec_ctx->codec;

        if (dec) {

            print_str(""codec_name"", dec->name);

            if (!do_bitexact) {

                if (dec->long_name) print_str    (""codec_long_name"", dec->long_name);

                else                print_str_opt(""codec_long_name"", ""unknown"");

            }

        } else {

            print_str_opt(""codec_name"", ""unknown"");

            if (!do_bitexact) {

                print_s",0,0,5,0,0,0,0,1,0,1,0,0,0,1,1
11543,FFmpeg,1,"static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,

                            const uint32_t *quant) {

    int coeff, i, n;

    int8_t ac;

    uint8_t dc = get_bits(gb, 8);



    // block not coded

    if (dc == 255)




    // number of non-zero coefficients

    coeff = get_bits(gb, 6);

    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)




    // normally we would only need to clear the (63 - coeff) last values,

    // but since we do not know where they are we just clear the whole block

    memset(block, 0, 64 * sizeof(DCTELEM));



    // 2 bits per coefficient

    while (coeff) {

        ac = get_sbits(gb, 2);

        if (ac == -2)

            break; // continue with more bits

        PUT_COEFF(ac);

    }



    // 4 bits per coefficient

    ALIGN(4);



    while (coeff) {

        ac = get_sbits(gb, 4);

        if (ac == -8)

            break; // continue with more bits

        PUT_COEFF(ac);

    }



    // 8 bits per coefficient

    ",0,0,4,0,0,2,0,0,0,0,0,0,1,1,1
11546,qemu,1,"static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, tmp;



    rd = new_tmp();

    tmp = new_tmp();



    tcg_gen_shli_i32(rd, t0, 16);

    tcg_gen_andi_i32(tmp, t1, 0xffff);

    tcg_gen_or_i32(rd, rd, tmp);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(tmp, t0, 0xffff0000);

    tcg_gen_or_i32(t1, t1, tmp);

    tcg_gen_mov_i32(t0, rd);



    dead_tmp(tmp);

    dead_tmp(rd);

}
",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
11553,FFmpeg,0,"static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)

{

    if (buf_size < 13)

        return AVERROR_INVALIDDATA;

    if (memcmp(buf, ""FLV"", 3))

        return AVERROR_INVALIDDATA;

    buf      += 13;

    buf_size -= 13;

    while (buf_size >= 11 + 4) {

        int type = buf[0];

        int size = AV_RB24(&buf[1]) + 11 + 4;

        if (size > buf_size)

            return AVERROR_INVALIDDATA;

        if (type == 8 || type == 9) {

            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))

                return AVERROR_INVALIDDATA;

            os->extra_packet_sizes[os->nb_extra_packets] = size;

            os->extra_packets[os->nb_extra_packets] = av_malloc(size);

            if (!os->extra_packets[os->nb_extra_packets])

                return AVERROR(ENOMEM);

            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);

            os->nb_extra_packets++;

        } else if (type == 0x12) {

            if (os->metadata)

                re",0,0,8,0,0,1,0,0,0,0,0,0,0,1,0
11566,qemu,1,"restore_sigcontext(CPUMIPSState *regs, struct target_sigcontext *sc)

{

    int err = 0;

    int i;



    __get_user(regs->CP0_EPC, &sc->sc_pc);



    __get_user(regs->active_tc.HI[0], &sc->sc_mdhi);

    __get_user(regs->active_tc.LO[0], &sc->sc_mdlo);



    for (i = 1; i < 32; ++i) {

        __get_user(regs->active_tc.gpr[i], &sc->sc_regs[i]);

    }



    __get_user(regs->active_tc.HI[1], &sc->sc_hi1);

    __get_user(regs->active_tc.HI[2], &sc->sc_hi2);

    __get_user(regs->active_tc.HI[3], &sc->sc_hi3);

    __get_user(regs->active_tc.LO[1], &sc->sc_lo1);

    __get_user(regs->active_tc.LO[2], &sc->sc_lo2);

    __get_user(regs->active_tc.LO[3], &sc->sc_lo3);

    {

        uint32_t dsp;

        __get_user(dsp, &sc->sc_dsp);

        cpu_wrdsp(dsp, 0x3ff, regs);

    }



    for (i = 0; i < 32; ++i) {

        __get_user(regs->active_fpu.fpr[i].d, &sc->sc_fpregs[i]);

    }



    return err;

}
",2,0,0,0,0,0,0,1,1,0,1,1,1,1,1
11592,qemu,0,"static void sdhci_write_block_to_card(SDHCIState *s)

{

    int index = 0;



    if (s->prnsts & SDHC_SPACE_AVAILABLE) {

        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {

            s->norintsts |= SDHC_NIS_WBUFRDY;

        }

        sdhci_update_irq(s);

        return;

    }



    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {

        if (s->blkcnt == 0) {

            return;

        } else {

            s->blkcnt--;

        }

    }



    for (index = 0; index < (s->blksize & 0x0fff); index++) {

        sd_write_data(s->card, s->fifo_buffer[index]);

    }



    /* Next data can be written through BUFFER DATORT register */

    s->prnsts |= SDHC_SPACE_AVAILABLE;



    /* Finish transfer if that was the last block of data */

    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||

            ((s->trnmod & SDHC_TRNS_MULTI) &&

            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {

        SDHCI_GET_CLASS(s)->end_data_transfer(s);

    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {

  ",1,0,7,0,0,0,0,0,0,0,1,0,0,0,0
11608,qemu,0,"static AHCIQState *ahci_boot(void)

{

    AHCIQState *s;

    const char *cli;



    s = g_malloc0(sizeof(AHCIQState));



    cli = ""-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s""

        "",format=qcow2""

        "" -M q35 ""

        ""-device ide-hd,drive=drive0 ""

        ""-global ide-hd.ver=%s"";

    s->parent = qtest_pc_boot(cli, tmp_path, ""testdisk"", ""version"");

    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);



    /* Verify that we have an AHCI device present. */

    s->dev = get_ahci_device(&s->fingerprint);



    return s;

}
",1,0,1,0,0,0,1,1,1,1,1,1,1,0,0
11624,qemu,0,"void address_space_destroy_dispatch(AddressSpace *as)

{

    AddressSpaceDispatch *d = as->dispatch;



    memory_listener_unregister(&d->listener);

    g_free(d);

    as->dispatch = NULL;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
11631,qemu,0,"mst_fpga_readb(void *opaque, target_phys_addr_t addr)

{

	mst_irq_state *s = (mst_irq_state *) opaque;



	switch (addr) {

	case MST_LEDDAT1:

		return s->leddat1;

	case MST_LEDDAT2:

		return s->leddat2;

	case MST_LEDCTRL:

		return s->ledctrl;

	case MST_GPSWR:

		return s->gpswr;

	case MST_MSCWR1:

		return s->mscwr1;

	case MST_MSCWR2:

		return s->mscwr2;

	case MST_MSCWR3:

		return s->mscwr3;

	case MST_MSCRD:

		return s->mscrd;

	case MST_INTMSKENA:

		return s->intmskena;

	case MST_INTSETCLR:

		return s->intsetclr;

	case MST_PCMCIA0:

		return s->pcmcia0;

	case MST_PCMCIA1:

		return s->pcmcia1;

	default:

		printf(""Mainstone - mst_fpga_readb: Bad register offset ""

			""0x"" TARGET_FMT_plx "" \n"", addr);

	}

	return 0;

}
",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
11635,qemu,0,"static int pci_piix_ide_initfn(PCIIDEState *d)

{

    uint8_t *pci_conf = d->dev.config;



    pci_conf[PCI_CLASS_PROG] = 0x80; // legacy ATA mode

    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);



    qemu_register_reset(piix3_reset, d);



    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);



    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);



    pci_piix_init_ports(d);



    return 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
11641,qemu,0,"static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    DeviceState *qdev = DEVICE(vpci_dev);

    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);

    virtio_net_set_netclient_name(&dev->vdev, qdev->id,

                                  object_get_typename(OBJECT(qdev)));

    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
",0,0,0,0,0,0,1,1,1,0,0,0,0,0,0
11642,qemu,0,"static void spapr_nvram_realize(VIOsPAPRDevice *dev, Error **errp)

{

    sPAPRNVRAM *nvram = VIO_SPAPR_NVRAM(dev);

    int ret;



    if (nvram->blk) {

        nvram->size = blk_getlength(nvram->blk);



        ret = blk_set_perm(nvram->blk,

                           BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,

                           BLK_PERM_ALL, errp);

        if (ret < 0) {

            return;

        }

    } else {

        nvram->size = DEFAULT_NVRAM_SIZE;

    }



    nvram->buf = g_malloc0(nvram->size);



    if ((nvram->size < MIN_NVRAM_SIZE) || (nvram->size > MAX_NVRAM_SIZE)) {

        error_setg(errp, ""spapr-nvram must be between %d and %d bytes in size"",

                   MIN_NVRAM_SIZE, MAX_NVRAM_SIZE);

        return;

    }



    if (nvram->blk) {

        int alen = blk_pread(nvram->blk, 0, nvram->buf, nvram->size);



        if (alen != nvram->size) {

            error_setg(errp, ""can't read spapr-nvram contents"");

            return;

        }

    } else if (nb_prom",0,0,6,0,0,0,0,1,1,1,1,0,1,1,1
11646,qemu,1,"static void ehci_free_packet(EHCIPacket *p)

{

    trace_usb_ehci_packet_action(p->queue, p, ""free"");

    if (p->async == EHCI_ASYNC_INFLIGHT) {

        usb_cancel_packet(&p->packet);

        usb_packet_unmap(&p->packet, &p->sgl);

        qemu_sglist_destroy(&p->sgl);












    QTAILQ_REMOVE(&p->queue->packets, p, next);

    usb_packet_cleanup(&p->packet);

    g_free(p);
",0,0,1,0,0,0,0,0,0,1,0,1,0,0,0
11662,FFmpeg,0,"static inline void RENAME(nv12ToUV)(uint8_t *dstU, uint8_t *dstV,

                                    const uint8_t *src1, const uint8_t *src2,

                                    long width, uint32_t *unused)

{

    RENAME(nvXXtoUV)(dstU, dstV, src1, width);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
11665,FFmpeg,0,"int ff_thread_init(AVCodecContext *avctx)

{

    if (avctx->thread_opaque) {

        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");

        return -1;

    }



#if HAVE_W32THREADS

    w32thread_init();

#endif



    if (avctx->codec) {

        validate_thread_parameters(avctx);



        if (avctx->active_thread_type&FF_THREAD_SLICE)

            return thread_init(avctx);

        else if (avctx->active_thread_type&FF_THREAD_FRAME)

            return frame_thread_init(avctx);

    }



    return 0;

}
",0,0,6,0,0,0,0,0,1,0,0,0,1,1,0
11674,qemu,0,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)

{

    if (memory_region_is_ram(mr)) {

        return !(is_write && mr->readonly);

    }

    if (memory_region_is_romd(mr)) {

        return !is_write;

    }



    return false;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,0
11685,qemu,0,"VirtIODevice *virtio_blk_init(DeviceState *dev, VirtIOBlkConf *blk)

{

    VirtIOBlock *s;

    int cylinders, heads, secs;

    static int virtio_blk_id;

    DriveInfo *dinfo;



    if (!blk->conf.bs) {

        error_report(""drive property not set"");

        return NULL;

    }

    if (!bdrv_is_inserted(blk->conf.bs)) {

        error_report(""Device needs media, but drive is empty"");

        return NULL;

    }



    if (!blk->serial) {

        /* try to fall back to value set with legacy -drive serial=... */

        dinfo = drive_get_by_blockdev(blk->conf.bs);

        if (*dinfo->serial) {

            blk->serial = strdup(dinfo->serial);

        }

    }



    s = (VirtIOBlock *)virtio_common_init(""virtio-blk"", VIRTIO_ID_BLOCK,

                                          sizeof(struct virtio_blk_config),

                                          sizeof(VirtIOBlock));



    s->vdev.get_config = virtio_blk_update_config;

    s->vdev.get_features = virtio_blk_get_features;

    s->vdev.reset = ",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
11712,FFmpeg,1,"static int pcm_decode_frame(AVCodecContext *avctx,
                            void *data, int *data_size,
                            AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    PCMDecode *s = avctx->priv_data;
    int sample_size, c, n, i;
    short *samples;
    const uint8_t *src, *src8, *src2[MAX_CHANNELS];
    uint8_t *dstu8;
    int16_t *dst_int16_t;
    int32_t *dst_int32_t;
    int64_t *dst_int64_t;
    uint16_t *dst_uint16_t;
    uint32_t *dst_uint32_t;
    samples = data;
    src = buf;
    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {
        av_log(avctx, AV_LOG_ERROR, ""invalid sample_fmt\n"");
        return -1;
    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){
        av_log(avctx, AV_LOG_ERROR, ""PCM channels out of bounds\n"");
        return -1;
    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;
    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */
    if (CODEC_ID_PCM_DVD == avctx->codec_id)
        /* ",0,0,3,0,0,0,1,0,1,1,1,1,0,0,0
11714,qemu,1,"static int arm946_prbs_write(CPUARMState *env, const ARMCPRegInfo *ri,

                             uint64_t value)

{

    if (ri->crm > 8) {

        return EXCP_UDEF;

    }

    env->cp15.c6_region[ri->crm] = value;

    return 0;

}
",0,0,1,0,0,0,1,1,1,1,0,1,1,1,1
11742,qemu,1,"static int usb_host_open(USBHostDevice *dev, int bus_num,

                         int addr, const char *port,

                         const char *prod_name, int speed)

{

    int fd = -1, ret;



    trace_usb_host_open_started(bus_num, addr);



    if (dev->fd != -1) {

        goto fail;

    }



    fd = usb_host_open_device(bus_num, addr);

    if (fd < 0) {

        goto fail;

    }

    DPRINTF(""husb: opened %s\n"", buf);



    dev->bus_num = bus_num;

    dev->addr = addr;

    strcpy(dev->port, port);

    dev->fd = fd;



    /* read the device description */

    dev->descr_len = read(fd, dev->descr, sizeof(dev->descr));

    if (dev->descr_len <= 0) {

        perror(""husb: reading device data failed"");

        goto fail;

    }



#ifdef DEBUG

    {

        int x;

        printf(""=== begin dumping device descriptor data ===\n"");

        for (x = 0; x < dev->descr_len; x++) {

            printf(""%02x "", dev->descr[x]);

        }

        printf(""\n=== end dumping device descriptor da",1,3,4,0,0,0,1,1,0,0,1,1,0,0,0
11748,qemu,1,"static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = PCI_ESP(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }

    return 0;

}",0,0,2,0,0,0,1,1,1,1,1,1,0,1,0
11749,FFmpeg,1,"static void copy_frame(Jpeg2000EncoderContext *s)

{

    int tileno, compno, i, y, x;

    uint8_t *line;

    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){

        Jpeg2000Tile *tile = s->tile + tileno;

        if (s->planar){

            for (compno = 0; compno < s->ncomponents; compno++){

                Jpeg2000Component *comp = tile->comp + compno;

                int *dst = comp->data;

                line = s->picture.data[compno]

                       + comp->coord[1][0] * s->picture.linesize[compno]

                       + comp->coord[0][0];

                for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){

                    uint8_t *ptr = line;

                    for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++)

                        *dst++ = *ptr++ - (1 << 7);

                    line += s->picture.linesize[compno];

                }

            }

        } else{

            line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.l",4,0,1,0,0,0,0,0,0,1,1,0,1,1,1
11781,qemu,0,"static off_t proxy_telldir(FsContext *ctx, V9fsFidOpenState *fs)

{

    return telldir(fs->dir);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
11793,FFmpeg,0,"static int filter_samples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref)

{

    AResampleContext *aresample = inlink->dst->priv;

    const int n_in  = insamplesref->audio->nb_samples;

    int n_out       = FFMAX(n_in * aresample->ratio * 2, 1);

    AVFilterLink *const outlink = inlink->dst->outputs[0];

    AVFilterBufferRef *outsamplesref = ff_get_audio_buffer(outlink, AV_PERM_WRITE, n_out);

    int ret;



    if(!outsamplesref)

        return AVERROR(ENOMEM);



    avfilter_copy_buffer_ref_props(outsamplesref, insamplesref);

    outsamplesref->format                = outlink->format;

    outsamplesref->audio->channel_layout = outlink->channel_layout;

    outsamplesref->audio->sample_rate    = outlink->sample_rate;



    if(insamplesref->pts != AV_NOPTS_VALUE) {

        int64_t inpts = av_rescale(insamplesref->pts, inlink->time_base.num * (int64_t)outlink->sample_rate * inlink->sample_rate, inlink->time_base.den);

        int64_t outpts= swr_next_pts(aresample->swr, inpts);

        are",2,0,2,0,0,0,0,0,0,0,0,0,1,1,1
11795,FFmpeg,0,"static int mov_read_ctts(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)

{

    AVStream *st = c->fc->streams[c->fc->nb_streams-1];

    MOVStreamContext *sc = st->priv_data;

    unsigned int i, entries;



    get_byte(pb); /* version */

    get_be24(pb); /* flags */

    entries = get_be32(pb);

    if(entries >= UINT_MAX / sizeof(MOV_stts_t))

        return -1;



    sc->ctts_count = entries;

    sc->ctts_data = av_malloc(entries * sizeof(MOV_stts_t));

    if (!sc->ctts_data)

        return -1;

    dprintf(c->fc, ""track[%i].ctts.entries = %i\n"", c->fc->nb_streams-1, entries);



    for(i=0; i<entries; i++) {

        int count    =get_be32(pb);

        int duration =get_be32(pb);



        if (duration < 0) {

            av_log(c->fc, AV_LOG_ERROR, ""negative ctts, ignoring\n"");

            sc->ctts_count = 0;

            url_fskip(pb, 8 * (entries - i - 1));

            break;

        }

        sc->ctts_data[i].count   = count;

        sc->ctts_data[i].duration= duration;



        s",1,0,3,0,0,0,0,0,0,1,0,1,0,0,0
11806,FFmpeg,1,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
11810,qemu,1,"void commit_active_start(BlockDriverState *bs, BlockDriverState *base,

                         int64_t speed,

                         BlockdevOnError on_error,

                         BlockDriverCompletionFunc *cb,

                         void *opaque, Error **errp)

{

    int64_t length, base_length;

    int orig_base_flags;



    orig_base_flags = bdrv_get_flags(base);



    if (bdrv_reopen(base, bs->open_flags, errp)) {

        return;

    }



    length = bdrv_getlength(bs);

    if (length < 0) {

        error_setg(errp, ""Unable to determine length of %s"", bs->filename);

        goto error_restore_flags;

    }



    base_length = bdrv_getlength(base);

    if (base_length < 0) {

        error_setg(errp, ""Unable to determine length of %s"", base->filename);

        goto error_restore_flags;

    }



    if (length > base_length) {

        if (bdrv_truncate(base, length) < 0) {

            error_setg(errp, ""Top image %s is larger than base image %s, and ""

                           ",0,2,5,0,0,0,1,0,1,0,1,0,0,0,0
11813,FFmpeg,1,"static int matroska_decode_buffer(uint8_t** buf, int* buf_size,
                                  MatroskaTrack *track)
{
    MatroskaTrackEncoding *encodings = track->encodings.elem;
    uint8_t* data = *buf;
    int isize = *buf_size;
    uint8_t* pkt_data = NULL;
    int pkt_size = isize;
    int result = 0;
    int olen;
    switch (encodings[0].compression.algo) {
    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:
        return encodings[0].compression.settings.size;
    case MATROSKA_TRACK_ENCODING_COMP_LZO:
        do {
            olen = pkt_size *= 3;
            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);
            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);
        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);
        if (result)
            goto failed;
        pkt_size -= olen;
        break;
#if CONFIG_ZLIB
    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {
        z_stream zstream = {0};
        if (inflateInit(&zstream) != Z_OK)
        zstream.next",0,1,3,0,1,1,1,1,1,1,1,0,0,0,0
11833,qemu,0,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,

                                 bool is_write, bool is_exec, int unused,

                                 unsigned size)

{

    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpu->env;



    env->trap_arg0 = addr;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
11834,qemu,0,"static int virtio_serial_init_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);

    VirtIODevice *vdev;



    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&

        proxy->class_code != PCI_CLASS_DISPLAY_OTHER && /* qemu 0.10 */

        proxy->class_code != PCI_CLASS_OTHERS)          /* qemu-kvm  */

        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;



    vdev = virtio_serial_init(&pci_dev->qdev, &proxy->serial);

    if (!vdev) {

        return -1;

    }

    vdev->nvectors = proxy->nvectors == DEV_NVECTORS_UNSPECIFIED

                                        ? proxy->serial.max_virtserial_ports + 1

                                        : proxy->nvectors;

    virtio_init_pci(proxy, vdev,

                    PCI_VENDOR_ID_REDHAT_QUMRANET,

                    PCI_DEVICE_ID_VIRTIO_CONSOLE,

                    proxy->class_code, 0x00);

    proxy->nvectors = vdev->nvectors;

    return 0;

}
",0,0,2,0,0,0,0,0,0,1,0,1,0,1,1
11840,qemu,0,"static CharDriverState *qmp_chardev_open_serial(const char *id,

                                                ChardevBackend *backend,

                                                ChardevReturn *ret,

                                                Error **errp)

{

    ChardevHostdev *serial = backend->serial;

    int fd;



    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);

    if (fd < 0) {

        return NULL;

    }

    qemu_set_nonblock(fd);

    return qemu_chr_open_tty_fd(fd);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
11843,qemu,0,"void alpha_pci_vga_setup(PCIBus *pci_bus)

{

    switch (vga_interface_type) {

#ifdef CONFIG_SPICE

    case VGA_QXL:

        pci_create_simple(pci_bus, -1, ""qxl-vga"");

        return;

#endif

    case VGA_CIRRUS:

        pci_cirrus_vga_init(pci_bus);

        return;

    case VGA_VMWARE:

        if (pci_vmsvga_init(pci_bus)) {

            return;

        }

        break;

    }

    /* If VGA is enabled at all, and one of the above didn't work, then

       fallback to Standard VGA.  */

    if (vga_interface_type != VGA_NONE) {

        pci_vga_init(pci_bus);

    }

}
",0,0,4,0,1,0,0,0,0,1,0,0,1,1,1
11844,qemu,0,"struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)

{

    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);

    struct omap_uart_s *s = omap_uart_init(base, irq,

                    fclk, iclk, txdma, rxdma, chr);

    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,

                    omap_uart_writefn, s);



    s->ta = ta;

    s->base = base;



    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);



    return s;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
11852,qemu,0,"static void QEMU_NORETURN help(void)

{

    const char *help_msg =

           QEMU_IMG_VERSION

           ""usage: qemu-img [standard options] command [command options]\n""

           ""QEMU disk image utility\n""

           ""\n""

           ""    '-h', '--help'       display this help and exit\n""

           ""    '-V', '--version'    output version information and exit\n""

           ""    '-T', '--trace'      [[enable=]<pattern>][,events=<file>][,file=<file>]\n""

           ""                         specify tracing options\n""

           ""\n""

           ""Command syntax:\n""

#define DEF(option, callback, arg_string)        \

           ""  "" arg_string ""\n""

#include ""qemu-img-cmds.h""

#undef DEF

#undef GEN_DOCS

           ""\n""

           ""Command parameters:\n""

           ""  'filename' is a disk image filename\n""

           ""  'objectdef' is a QEMU user creatable object definition. See the qemu(1)\n""

           ""    manual page for a description of the object properties. The most common\n""

          ",2,0,1,0,0,0,1,1,1,1,1,0,0,0,0
11853,qemu,0,"static void coroutine_fn bdrv_create_co_entry(void *opaque)

{

    Error *local_err = NULL;

    int ret;



    CreateCo *cco = opaque;

    assert(cco->drv);



    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);

    if (local_err) {

        error_propagate(&cco->err, local_err);

    }

    cco->ret = ret;

}
",0,0,1,0,0,0,0,1,1,0,0,0,1,1,1
11854,qemu,0,"void helper_mtc0_entryhi(CPUMIPSState *env, target_ulong arg1)

{

    target_ulong old, val, mask;

    mask = (TARGET_PAGE_MASK << 1) | env->CP0_EntryHi_ASID_mask;

    if (((env->CP0_Config4 >> CP0C4_IE) & 0x3) >= 2) {

        mask |= 1 << CP0EnHi_EHINV;

    }



    /* 1k pages not implemented */

#if defined(TARGET_MIPS64)

    if (env->insn_flags & ISA_MIPS32R6) {

        int entryhi_r = extract64(arg1, 62, 2);

        int config0_at = extract32(env->CP0_Config0, 13, 2);

        bool no_supervisor = (env->CP0_Status_rw_bitmask & 0x8) == 0;

        if ((entryhi_r == 2) ||

            (entryhi_r == 1 && (no_supervisor || config0_at == 1))) {

            /* skip EntryHi.R field if new value is reserved */

            mask &= ~(0x3ull << 62);

        }

    }

    mask &= env->SEGMask;

#endif

    old = env->CP0_EntryHi;

    val = (arg1 & mask) | (old & ~mask);

    env->CP0_EntryHi = val;

    if (env->CP0_Config3 & (1 << CP0C3_MT)) {

        sync_c0_entryhi(env, env->current_tc);

    }

    ",0,0,6,0,0,0,0,1,1,0,0,0,0,0,0
11861,qemu,1,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)

{

    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);

}
",0,0,1,0,0,0,1,1,0,1,0,0,1,1,1
11865,qemu,1,"ram_addr_t qemu_ram_addr_from_host_nofail(void *ptr)

{

    ram_addr_t ram_addr;



    if (qemu_ram_addr_from_host(ptr, &ram_addr)) {

        fprintf(stderr, ""Bad ram pointer %p\n"", ptr);

        abort();

    }

    return ram_addr;

}
",0,0,1,0,0,0,1,0,0,1,0,1,0,0,0
11877,FFmpeg,1,"static int decode_format80(VqaContext *s, int src_size,

    unsigned char *dest, int dest_size, int check_size) {



    int dest_index = 0;

    int count, opcode, start;

    int src_pos;

    unsigned char color;

    int i;



    start = bytestream2_tell(&s->gb);

    while (bytestream2_tell(&s->gb) - start < src_size) {

        opcode = bytestream2_get_byte(&s->gb);

        av_dlog(s->avctx, ""opcode %02X: "", opcode);



        /* 0x80 means that frame is finished */

        if (opcode == 0x80)

            break;



        if (dest_index >= dest_size) {

            av_log(s->avctx, AV_LOG_ERROR, ""decode_format80 problem: dest_index (%d) exceeded dest_size (%d)\n"",

                dest_index, dest_size);

            return AVERROR_INVALIDDATA;

        }



        if (opcode == 0xFF) {



            count   = bytestream2_get_le16(&s->gb);

            src_pos = bytestream2_get_le16(&s->gb);

            av_dlog(s->avctx, ""(1) copy %X bytes from absolute pos %X\n"", count, src_pos);

           ",2,0,3,0,0,1,0,0,0,1,1,1,1,1,1
11885,FFmpeg,1,"static int zero12v_decode_frame(AVCodecContext *avctx, void *data,

                                int *got_frame, AVPacket *avpkt)

{

    int line = 0, ret;

    const int width = avctx->width;

    AVFrame *pic = data;

    uint16_t *y, *u, *v;

    const uint8_t *line_end, *src = avpkt->data;

    int stride = avctx->width * 8 / 3;



    if (width == 1) {

        av_log(avctx, AV_LOG_ERROR, ""Width 1 not supported.\n"");

        return AVERROR_INVALIDDATA;

    }



    if (   avctx->codec_tag == MKTAG('0', '1', '2', 'v')

        && avpkt->size % avctx->height == 0

        && avpkt->size / avctx->height * 3 >= width * 8)

        stride = avpkt->size / avctx->height;



    if (avpkt->size < avctx->height * stride) {

        av_log(avctx, AV_LOG_ERROR, ""Packet too small: %d instead of %d\n"",

               avpkt->size, avctx->height * stride);

        return AVERROR_INVALIDDATA;

    }



    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)

        return ret;



    pic->pict_type = AV_PICTURE_TYPE_",0,0,4,0,0,0,0,1,0,1,0,0,0,1,1
11911,qemu,0,"static inline int test_bit(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
11919,qemu,0,"static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
",0,0,0,0,0,0,0,0,0,0,0,1,1,0,1
11933,qemu,1,"static void piix3_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &vmstate_piix3;

    dc->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = piix3_initfn;

    k->config_write = piix3_write_config;

    k->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
11936,qemu,1,"qio_channel_websock_source_dispatch(GSource *source,

                                    GSourceFunc callback,

                                    gpointer user_data)

{

    QIOChannelFunc func = (QIOChannelFunc)callback;

    QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source;

    GIOCondition cond = 0;



    if (wsource->wioc->rawinput.offset) {

        cond |= G_IO_IN;

    }

    if (wsource->wioc->rawoutput.offset < QIO_CHANNEL_WEBSOCK_MAX_BUFFER) {

        cond |= G_IO_OUT;

    }



    return (*func)(QIO_CHANNEL(wsource->wioc),

                   (cond & wsource->condition),

                   user_data);

}
",0,0,2,0,0,0,0,0,1,0,0,0,1,1,1
11957,qemu,0,"static void acpi_dsdt_add_pci(Aml *scope, const MemMapEntry *memmap,

                              uint32_t irq, bool use_highmem)

{

    Aml *method, *crs, *ifctx, *UUID, *ifctx1, *elsectx, *buf;

    int i, bus_no;

    hwaddr base_mmio = memmap[VIRT_PCIE_MMIO].base;

    hwaddr size_mmio = memmap[VIRT_PCIE_MMIO].size;

    hwaddr base_pio = memmap[VIRT_PCIE_PIO].base;

    hwaddr size_pio = memmap[VIRT_PCIE_PIO].size;

    hwaddr base_ecam = memmap[VIRT_PCIE_ECAM].base;

    hwaddr size_ecam = memmap[VIRT_PCIE_ECAM].size;

    int nr_pcie_buses = size_ecam / PCIE_MMCFG_SIZE_MIN;



    Aml *dev = aml_device(""%s"", ""PCI0"");

    aml_append(dev, aml_name_decl(""_HID"", aml_string(""PNP0A08"")));

    aml_append(dev, aml_name_decl(""_CID"", aml_string(""PNP0A03"")));

    aml_append(dev, aml_name_decl(""_SEG"", aml_int(0)));

    aml_append(dev, aml_name_decl(""_BBN"", aml_int(0)));

    aml_append(dev, aml_name_decl(""_ADR"", aml_int(0)));

    aml_append(dev, aml_name_decl(""_UID"", aml_string(""PCI0"")));

    aml_append(d",0,0,2,0,0,0,1,1,1,1,0,1,0,0,0
11958,qemu,0,"static int vmdk_parent_open(BlockDriverState *bs)

{

    char *p_name;

    char desc[DESC_SIZE + 1];

    BDRVVmdkState *s = bs->opaque;



    desc[DESC_SIZE] = '\0';

    if (bdrv_pread(bs->file, s->desc_offset, desc, DESC_SIZE) != DESC_SIZE) {

        return -1;

    }



    if ((p_name = strstr(desc,""parentFileNameHint"")) != NULL) {

        char *end_name;



        p_name += sizeof(""parentFileNameHint"") + 1;

        if ((end_name = strchr(p_name,'\""')) == NULL)

            return -1;

        if ((end_name - p_name) > sizeof (bs->backing_file) - 1)

            return -1;



        pstrcpy(bs->backing_file, end_name - p_name + 1, p_name);

    }



    return 0;

}
",0,0,4,0,0,0,0,1,1,0,1,0,1,1,1
11969,qemu,0,"static MemoryRegionSection address_space_do_translate(AddressSpace *as,

                                                      hwaddr addr,

                                                      hwaddr *xlat,

                                                      hwaddr *plen,

                                                      bool is_write,

                                                      bool is_mmio)

{

    IOMMUTLBEntry iotlb;

    MemoryRegionSection *section;

    MemoryRegion *mr;



    for (;;) {

        AddressSpaceDispatch *d = atomic_rcu_read(&as->dispatch);

        section = address_space_translate_internal(d, addr, &addr, plen, is_mmio);

        mr = section->mr;



        if (!mr->iommu_ops) {

            break;

        }



        iotlb = mr->iommu_ops->translate(mr, addr, is_write);

        addr = ((iotlb.translated_addr & ~iotlb.addr_mask)

                | (addr & iotlb.addr_mask));

        *plen = MIN(*plen, (addr | iotlb.addr_mask) - addr + 1);

        if (!(iotlb.pe",1,0,2,0,0,0,0,0,0,0,0,0,1,1,1
11975,qemu,0,"static void read_guest_mem(void)

{

    uint32_t *guest_mem;

    gint64 end_time;

    int i, j;

    size_t size;



    g_mutex_lock(data_mutex);



    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;

    while (!fds_num) {

        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {

            /* timeout has passed */

            g_assert(fds_num);

            break;

        }

    }



    /* check for sanity */

    g_assert_cmpint(fds_num, >, 0);

    g_assert_cmpint(fds_num, ==, memory.nregions);



    /* iterate all regions */

    for (i = 0; i < fds_num; i++) {



        /* We'll check only the region statring at 0x0*/

        if (memory.regions[i].guest_phys_addr != 0x0) {

            continue;

        }



        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);



        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;



        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,

                         MAP_SHARED, fds[i], 0);



    ",1,0,2,0,0,1,0,0,0,0,0,0,0,0,0
11978,qemu,1,"static uint64_t qemu_rdma_poll(RDMAContext *rdma, uint64_t *wr_id_out,

                               uint32_t *byte_len)

{

    int ret;

    struct ibv_wc wc;

    uint64_t wr_id;



    ret = ibv_poll_cq(rdma->cq, 1, &wc);



    if (!ret) {

        *wr_id_out = RDMA_WRID_NONE;

        return 0;

    }



    if (ret < 0) {

        fprintf(stderr, ""ibv_poll_cq return %d!\n"", ret);

        return ret;

    }



    wr_id = wc.wr_id & RDMA_WRID_TYPE_MASK;



    if (wc.status != IBV_WC_SUCCESS) {

        fprintf(stderr, ""ibv_poll_cq wc.status=%d %s!\n"",

                        wc.status, ibv_wc_status_str(wc.status));

        fprintf(stderr, ""ibv_poll_cq wrid=%s!\n"", wrid_desc[wr_id]);



        return -1;

    }



    if (rdma->control_ready_expected &&

        (wr_id >= RDMA_WRID_RECV_CONTROL)) {

        DDDPRINTF(""completion %s #%"" PRId64 "" received (%"" PRId64 "")""

                  "" left %d\n"", wrid_desc[RDMA_WRID_RECV_CONTROL],

                  wr_id - RDMA_WRID_RECV_CONTROL, wr_id, rdma",0,0,4,0,0,0,1,1,0,1,1,1,1,1,0
11979,FFmpeg,1,"static int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    uint32_t minor_ver;

    int comp_brand_size;

    char minor_ver_str[11]; /* 32 bit integer -> 10 digits + null */

    char* comp_brands_str;

    uint8_t type[5] = {0};



    avio_read(pb, type, 4);

    if (strcmp(type, ""qt  ""))

        c->isom = 1;

    av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s\n"",(char *)&type);

    av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);

    minor_ver = avio_rb32(pb); /* minor version */

    snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);

    av_dict_set(&c->fc->metadata, ""minor_version"", minor_ver_str, 0);



    comp_brand_size = atom.size - 8;

    if (comp_brand_size < 0)

        return AVERROR_INVALIDDATA;

    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */

    if (!comp_brands_str)

        return AVERROR(ENOMEM);

    avio_read(pb, comp_brands_str, comp_brand_size);

    comp_brands_str[comp_brand_size] = 0",0,0,3,0,0,0,1,1,1,1,1,1,0,0,1
11980,qemu,1,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);

}
",0,0,0,0,0,0,0,0,1,1,1,1,0,0,0
11983,FFmpeg,0,"static int decode_stream_header(NUTContext *nut){

    AVFormatContext *s= nut->avf;

    ByteIOContext *bc = &s->pb;

    StreamContext *stc;

    int class, stream_id;

    uint64_t tmp, end;

    AVStream *st;



    end= get_packetheader(nut, bc, 1);

    end += url_ftell(bc);



    GET_V(stream_id, tmp < s->nb_streams && !nut->stream[tmp].time_base);

    stc= &nut->stream[stream_id];



    st = s->streams[stream_id];

    if (!st)

        return AVERROR(ENOMEM);



    class = get_v(bc);

    tmp = get_fourcc(bc);

    st->codec->codec_tag= tmp;

    switch(class)

    {

        case 0:

            st->codec->codec_type = CODEC_TYPE_VIDEO;

            st->codec->codec_id = codec_get_id(codec_bmp_tags, tmp);

            if (st->codec->codec_id == CODEC_ID_NONE)

                av_log(s, AV_LOG_ERROR, ""Unknown codec?!\n"");

            break;

        case 1:

            st->codec->codec_type = CODEC_TYPE_AUDIO;

            st->codec->codec_id = codec_get_id(codec_wav_tags, tmp);

            if",0,0,3,0,1,0,0,1,0,0,0,0,0,0,0
11985,FFmpeg,1,"static void lz_unpack(const unsigned char *src, unsigned char *dest, int dest_len)

{

    const unsigned char *s;

    unsigned char *d;

    unsigned char *d_end;

    unsigned char queue[QUEUE_SIZE];

    unsigned int qpos;

    unsigned int dataleft;

    unsigned int chainofs;

    unsigned int chainlen;

    unsigned int speclen;

    unsigned char tag;

    unsigned int i, j;



    s = src;

    d = dest;

    d_end = d + dest_len;

    dataleft = AV_RL32(s);

    s += 4;

    memset(queue, 0x20, QUEUE_SIZE);

    if (AV_RL32(s) == 0x56781234) {

        s += 4;

        qpos = 0x111;

        speclen = 0xF + 3;

    } else {

        qpos = 0xFEE;

        speclen = 100;  /* no speclen */

    }



    while (dataleft > 0) {

        tag = *s++;

        if ((tag == 0xFF) && (dataleft > 8)) {

            if (d + 8 > d_end)

                return;

            for (i = 0; i < 8; i++) {

                queue[qpos++] = *d++ = *s++;

                qpos &= QUEUE_MASK;

            }

            data",1,0,3,0,0,1,1,1,1,0,1,1,1,0,0
11988,qemu,1,"void scsi_req_cancel(SCSIRequest *req)

{

    trace_scsi_req_cancel(req->dev->id, req->lun, req->tag);

    if (!req->enqueued) {

        return;

    }



    scsi_req_ref(req);

    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->aiocb) {

        blk_aio_cancel(req->aiocb);

    } else {

        scsi_req_cancel_complete(req);

    }

}",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
11998,qemu,1,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)

{

    TCGv_i32 tmp;

    store_reg(s, 15, pc);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
",0,0,0,0,0,0,0,1,1,0,1,0,1,1,0
12023,qemu,0,"static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,

                                            uint16_t code, const char *reason)

{

    struct iovec iov;

    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));

    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =

        cpu_to_be16(code);

    ioc->rawoutput.offset += 2;

    if (reason) {

        buffer_append(&ioc->rawoutput, reason, strlen(reason));

    }

    iov.iov_base = ioc->rawoutput.buffer;

    iov.iov_len = ioc->rawoutput.offset;

    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,

                               &iov, 1, iov.iov_len);

    buffer_reset(&ioc->rawoutput);

    qio_channel_websock_write_wire(ioc, NULL);

    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);

}
",0,0,1,0,0,0,0,0,0,1,0,1,1,0,0
12026,qemu,0,"static void fadt_setup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm)

{

    fadt->model = 1;

    fadt->reserved1 = 0;

    fadt->sci_int = cpu_to_le16(pm->sci_int);

    fadt->smi_cmd = cpu_to_le32(ACPI_PORT_SMI_CMD);

    fadt->acpi_enable = pm->acpi_enable_cmd;

    fadt->acpi_disable = pm->acpi_disable_cmd;

    /* EVT, CNT, TMR offset matches hw/acpi/core.c */

    fadt->pm1a_evt_blk = cpu_to_le32(pm->io_base);

    fadt->pm1a_cnt_blk = cpu_to_le32(pm->io_base + 0x04);

    fadt->pm_tmr_blk = cpu_to_le32(pm->io_base + 0x08);

    fadt->gpe0_blk = cpu_to_le32(pm->gpe0_blk);

    /* EVT, CNT, TMR length matches hw/acpi/core.c */

    fadt->pm1_evt_len = 4;

    fadt->pm1_cnt_len = 2;

    fadt->pm_tmr_len = 4;

    fadt->gpe0_blk_len = pm->gpe0_blk_len;

    fadt->plvl2_lat = cpu_to_le16(0xfff); /* C2 state not supported */

    fadt->plvl3_lat = cpu_to_le16(0xfff); /* C3 state not supported */

    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |

                              (1 << ACPI_FADT_F_PROC",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
12036,qemu,0,"void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)

{

    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (val & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t sus_typ = (val >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            ar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            qemu_system_reset_request();

            qemu_irq_raise(ar->pm1.cnt.cmos_s3);

        default:

            break;

        }

    }

}
",0,0,1,0,1,0,0,0,0,0,0,0,1,1,1
12038,qemu,0,"static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        exit(1);

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,1,1
12075,qemu,1,"static void qapi_dealloc_end_struct(Visitor *v, Error **errp)

{

    QapiDeallocVisitor *qov = to_qov(v);

    void **obj = qapi_dealloc_pop(qov);

    if (obj) {

        g_free(*obj);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,1
12079,qemu,1,"static void file_completion(const char *input)

{

    DIR *ffs;

    struct dirent *d;

    char path[1024];

    char file[1024], file_prefix[1024];

    int input_path_len;

    const char *p;



    p = strrchr(input, '/');

    if (!p) {

        input_path_len = 0;

        pstrcpy(file_prefix, sizeof(file_prefix), input);

        pstrcpy(path, sizeof(path), ""."");

    } else {

        input_path_len = p - input + 1;

        memcpy(path, input, input_path_len);

        if (input_path_len > sizeof(path) - 1)

            input_path_len = sizeof(path) - 1;

        path[input_path_len] = '\0';

        pstrcpy(file_prefix, sizeof(file_prefix), p + 1);

    }

#ifdef DEBUG_COMPLETION

    monitor_printf(cur_mon, ""input='%s' path='%s' prefix='%s'\n"",

                   input, path, file_prefix);

#endif

    ffs = opendir(path);

    if (!ffs)

        return;

    for(;;) {

        struct stat sb;

        d = readdir(ffs);

        if (!d)

            break;



        if (strcmp(d->d_name, ""."") ==",1,0,7,0,0,0,1,1,1,1,1,1,1,1,1
12083,qemu,1,"static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
",0,0,3,0,0,0,0,0,0,0,0,1,1,1,1
12086,qemu,1,"static void enter_migration_coroutine(void *opaque)

{

    Coroutine *co = opaque;

    qemu_coroutine_enter(co, NULL);

}
",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
12095,FFmpeg,1,"static int decode_channel_residues(WmallDecodeCtx *s, int ch, int tile_size)

{

    int i = 0;

    unsigned int ave_mean;

    s->transient[ch] = get_bits1(&s->gb);

    if (s->transient[ch]) {

        s->transient_pos[ch] = get_bits(&s->gb, av_log2(tile_size));

        if (s->transient_pos[ch])

            s->transient[ch] = 0;

        s->channel[ch].transient_counter =

            FFMAX(s->channel[ch].transient_counter, s->samples_per_frame / 2);

    } else if (s->channel[ch].transient_counter)

        s->transient[ch] = 1;



    if (s->seekable_tile) {

        ave_mean = get_bits(&s->gb, s->bits_per_sample);

        s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);

    }



    if (s->seekable_tile) {

        if (s->do_inter_ch_decorr)

            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);

        else

            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);

        i++;

    }

    for (; i < tile_size; i++) {

        int quo = 0, ",1,0,6,0,0,0,0,0,0,0,0,0,0,0,0
12099,FFmpeg,0,"static int cinaudio_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    CinAudioContext *cin = avctx->priv_data;

    const uint8_t *src = buf;

    int16_t *samples = data;

    int delta;



    buf_size = FFMIN(buf_size, *data_size/2);



    delta = cin->delta;

    if (cin->initial_decode_frame) {

        cin->initial_decode_frame = 0;

        delta = (int16_t)AV_RL16(src); src += 2;

        *samples++ = delta;

        buf_size -= 2;

    }

    while (buf_size > 0) {

        delta += cinaudio_delta16_table[*src++];

        delta = av_clip_int16(delta);

        *samples++ = delta;

        --buf_size;

    }

    cin->delta = delta;



    *data_size = (uint8_t *)samples - (uint8_t *)data;



    return src - buf;

}
",0,0,1,0,0,1,1,1,1,0,1,0,0,0,0
12106,FFmpeg,0,"static void rv34_pred_mv_rv3(RV34DecContext *r, int block_type, int dir)

{

    MpegEncContext *s = &r->s;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;

    int A[2] = {0}, B[2], C[2];

    int i, j, k;

    int mx, my;

    int avail_index = avail_indexes[0];



    if(r->avail_cache[avail_index - 1]){

        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][0];

        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - 1][1];

    }

    if(r->avail_cache[avail_index - 4]){

        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][0];

        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride][1];

    }else{

        B[0] = A[0];

        B[1] = A[1];

    }

    if(!r->avail_cache[avail_index - 4 + 2]){

        if(r->avail_cache[avail_index - 4] && (r->avail_cache[avail_index - 1])){

            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];

            C[1] = s->current_picture_ptr->f.motion_val[0][",0,0,4,0,0,0,0,0,0,0,0,1,0,0,0
12111,qemu,0,"int qemu_paio_init(struct qemu_paioinit *aioinit)

{

    int ret;



    ret = pthread_attr_init(&attr);

    if (ret) die2(ret, ""pthread_attr_init"");



    ret = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    if (ret) die2(ret, ""pthread_attr_setdetachstate"");



    TAILQ_INIT(&request_list);



    return 0;

}
",0,0,2,0,0,0,0,0,0,0,1,1,1,0,1
12130,qemu,0,"dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
12133,qemu,0,"static void s390_pcihost_hot_plug(HotplugHandler *hotplug_dev,

                                  DeviceState *dev, Error **errp)

{

    PCIDevice *pci_dev = PCI_DEVICE(dev);

    S390PCIBusDevice *pbdev;

    S390pciState *s = S390_PCI_HOST_BRIDGE(pci_device_root_bus(pci_dev)

                                           ->qbus.parent);



    pbdev = &s->pbdev[PCI_SLOT(pci_dev->devfn)];



    pbdev->fid = s390_pci_get_pfid(pci_dev);

    pbdev->pdev = pci_dev;

    pbdev->configured = true;

    pbdev->fh = s390_pci_get_pfh(pci_dev);



    s390_pcihost_setup_msix(pbdev);



    if (dev->hotplugged) {

        s390_pci_generate_plug_event(HP_EVENT_RESERVED_TO_STANDBY,

                                     pbdev->fh, pbdev->fid);

        s390_pci_generate_plug_event(HP_EVENT_TO_CONFIGURED,

                                     pbdev->fh, pbdev->fid);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,0,1
12134,qemu,0,"static uint64_t pxa2xx_mm_read(void *opaque, hwaddr addr,

                               unsigned size)

{

    PXA2xxState *s = (PXA2xxState *) opaque;



    switch (addr) {

    case MDCNFG ... SA1110:

        if ((addr & 3) == 0)

            return s->mm_regs[addr >> 2];



    default:

        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);

        break;

    }

    return 0;

}
",0,0,1,0,1,0,0,0,0,0,0,0,1,1,0
12142,qemu,0,"static int vhost_verify_ring_mappings(struct vhost_dev *dev,

                                      uint64_t start_addr,

                                      uint64_t size)

{

    int i, j;

    int r = 0;

    const char *part_name[] = {

        ""descriptor table"",

        ""available ring"",

        ""used ring""

    };



    for (i = 0; i < dev->nvqs; ++i) {

        struct vhost_virtqueue *vq = dev->vqs + i;



        j = 0;

        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,

                                           vq->desc_size, start_addr, size);

        if (!r) {

            break;

        }



        j++;

        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,

                                           vq->avail_size, start_addr, size);

        if (!r) {

            break;

        }



        j++;

        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,

                                           vq->used_size, start_addr, size);

        i",1,0,6,0,0,0,0,0,0,0,0,0,0,0,0
12145,qemu,0,"void qemu_ram_remap(ram_addr_t addr, ram_addr_t length)

{

    RAMBlock *block;

    ram_addr_t offset;

    int flags;

    void *area, *vaddr;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        offset = addr - block->offset;

        if (offset < block->length) {

            vaddr = block->host + offset;

            if (block->flags & RAM_PREALLOC_MASK) {

                ;

            } else if (xen_enabled()) {

                abort();

            } else {

                flags = MAP_FIXED;

                munmap(vaddr, length);

                if (mem_path) {

#if defined(__linux__) && !defined(TARGET_S390X)

                    if (block->fd) {

#ifdef MAP_POPULATE

                        flags |= mem_prealloc ? MAP_POPULATE | MAP_SHARED :

                            MAP_PRIVATE;

#else

                        flags |= MAP_PRIVATE;

#endif

                        area = mmap(vaddr, length, PROT_READ | PROT_WRITE,

                                    flags, block->fd, offset);

",0,0,8,0,0,0,0,0,1,0,1,0,0,1,0
12182,qemu,1,"const char *object_get_typename(Object *obj)

{

    return obj->class->type->name;

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
12190,FFmpeg,0,"static int vaapi_build_decoder_config(VAAPIDecoderContext *ctx,

                                      AVCodecContext *avctx,

                                      int fallback_allowed)

{

    AVVAAPIDeviceContext *hwctx = ctx->device->hwctx;

    AVVAAPIHWConfig *hwconfig = NULL;

    AVHWFramesConstraints *constraints = NULL;

    VAStatus vas;

    int err, i, j;

    int loglevel = fallback_allowed ? AV_LOG_VERBOSE : AV_LOG_ERROR;

    const AVCodecDescriptor *codec_desc;

    const AVPixFmtDescriptor *pix_desc;

    enum AVPixelFormat pix_fmt;

    VAProfile profile, *profile_list = NULL;

    int profile_count, exact_match, alt_profile;



    codec_desc = avcodec_descriptor_get(avctx->codec_id);

    if (!codec_desc) {

        err = AVERROR(EINVAL);

        goto fail;

    }



    profile_count = vaMaxNumProfiles(hwctx->display);

    profile_list = av_malloc(profile_count * sizeof(VAProfile));

    if (!profile_list) {

        err = AVERROR(ENOMEM);

        goto fail;

    }



    vas = vaQuer",0,2,2,0,0,0,0,0,0,0,0,0,0,0,0
12192,FFmpeg,0,"static int parse(AVCodecParserContext *ctx,

                 AVCodecContext *avctx,

                 const uint8_t **out_data, int *out_size,

                 const uint8_t *data, int size)

{

    VP9ParseContext *s = ctx->priv_data;

    int marker;



    if (size <= 0) {

        *out_size = 0;

        *out_data = data;



        return 0;

    }



    if (s->n_frames > 0) {

        *out_data = data;

        *out_size = s->size[--s->n_frames];

        parse_frame(ctx, *out_data, *out_size);



        return s->n_frames > 0 ? *out_size : size /* i.e. include idx tail */;

    }



    marker = data[size - 1];

    if ((marker & 0xe0) == 0xc0) {

        int nbytes = 1 + ((marker >> 3) & 0x3);

        int n_frames = 1 + (marker & 0x7), idx_sz = 2 + n_frames * nbytes;



        if (size >= idx_sz && data[size - idx_sz] == marker) {

            const uint8_t *idx = data + size + 1 - idx_sz;

            int first = 1;



            switch (nbytes) {

#define case_n(a, rd) \

            case a: ",0,0,4,0,1,0,0,0,0,0,1,0,0,1,1
12200,qemu,1,"static int ram_init1(SysBusDevice *dev)

{

    RamDevice *d = SUN4U_RAM(dev);



    memory_region_init_ram(&d->ram, OBJECT(d), ""sun4u.ram"", d->size,

                           &error_abort);

    vmstate_register_ram_global(&d->ram);

    sysbus_init_mmio(dev, &d->ram);

    return 0;

}
",0,0,0,0,0,0,0,1,1,0,1,1,0,0,0
12205,qemu,1,"static void stop_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val |= TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
12215,qemu,1,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
",0,0,0,0,0,0,0,0,0,1,1,1,0,0,0
12216,FFmpeg,1,"static const unsigned char *seq_unpack_rle_block(const unsigned char *src, unsigned char *dst, int dst_size)

{

    int i, len, sz;

    GetBitContext gb;

    int code_table[64];



    /* get the rle codes (at most 64 bytes) */

    init_get_bits(&gb, src, 64 * 8);

    for (i = 0, sz = 0; i < 64 && sz < dst_size; i++) {

        code_table[i] = get_sbits(&gb, 4);

        sz += FFABS(code_table[i]);

    }

    src += (get_bits_count(&gb) + 7) / 8;



    /* do the rle unpacking */

    for (i = 0; i < 64 && dst_size > 0; i++) {

        len = code_table[i];

        if (len < 0) {

            len = -len;

            memset(dst, *src++, FFMIN(len, dst_size));

        } else {

            memcpy(dst, src, FFMIN(len, dst_size));

            src += len;

        }

        dst += len;

        dst_size -= len;

    }

    return src;

}
",2,0,1,0,0,0,0,0,1,1,1,1,1,1,1
12243,qemu,1,"bool bdrv_is_first_non_filter(BlockDriverState *candidate)

{

    BlockDriverState *bs;

    BdrvNextIterator *it = NULL;



    /* walk down the bs forest recursively */

    while ((it = bdrv_next(it, &bs)) != NULL) {

        bool perm;



        /* try to recurse in this top level bs */

        perm = bdrv_recurse_is_first_non_filter(bs, candidate);



        /* candidate is the first non filter */

        if (perm) {

            return true;

        }

    }



    return false;

}
",0,0,1,0,0,1,0,0,0,0,0,1,1,1,1
12245,qemu,1,"static int vhost_user_set_mem_table(struct vhost_dev *dev,

                                    struct vhost_memory *mem)

{

    int fds[VHOST_MEMORY_MAX_NREGIONS];

    int i, fd;

    size_t fd_num = 0;

    bool reply_supported = virtio_has_feature(dev->protocol_features,

                                              VHOST_USER_PROTOCOL_F_REPLY_ACK);



    VhostUserMsg msg = {

        .hdr.request = VHOST_USER_SET_MEM_TABLE,

        .hdr.flags = VHOST_USER_VERSION,

    };



    if (reply_supported) {

        msg.hdr.flags |= VHOST_USER_NEED_REPLY_MASK;

    }



    for (i = 0; i < dev->mem->nregions; ++i) {

        struct vhost_memory_region *reg = dev->mem->regions + i;

        ram_addr_t offset;

        MemoryRegion *mr;



        assert((uintptr_t)reg->userspace_addr == reg->userspace_addr);

        mr = memory_region_from_host((void *)(uintptr_t)reg->userspace_addr,

                                     &offset);

        fd = memory_region_get_fd(mr);

        if (fd > 0) {

            ",1,0,2,0,0,0,0,1,0,1,1,0,0,1,0
12255,FFmpeg,1,"int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx,
                     uint8_t **poutbuf, int *poutbuf_size,
                     const uint8_t *buf, int buf_size,
                     int64_t pts, int64_t dts, int64_t pos)
{
    int index, i;
    uint8_t dummy_buf[AV_INPUT_BUFFER_PADDING_SIZE];
    if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) {
        s->next_frame_offset =
        s->cur_offset        = pos;
        s->flags            |= PARSER_FLAG_FETCHED_OFFSET;
    }
    if (buf_size == 0) {
        /* padding is always necessary even if EOF, so we add it here */
        memset(dummy_buf, 0, sizeof(dummy_buf));
        buf = dummy_buf;
    } else if (s->cur_offset + buf_size != s->cur_frame_end[s->cur_frame_start_index]) { /* skip remainder packets */
        /* add a new packet descriptor */
        i = (s->cur_frame_start_index + 1) & (AV_PARSER_PTS_NB - 1);
        s->cur_frame_start_index = i;
        s->cur_frame_offset[i]   = s->cur_offset;
        s->cur_frame_end[i]      = ",0,0,3,0,0,0,0,1,1,1,1,1,1,1,1
12257,qemu,1,"static int nbd_co_readv_1(NbdClientSession *client, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int offset)

{

    struct nbd_request request;

    struct nbd_reply reply;

    ssize_t ret;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(client, &request);

    ret = nbd_co_send_request(client, &request, NULL, 0);

    if (ret < 0) {

        reply.error = -ret;

    } else {

        nbd_co_receive_reply(client, &request, &reply, qiov, offset);

    }

    nbd_coroutine_end(client, &request);

    return -reply.error;



}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
12273,FFmpeg,1,"static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)

{

    const uint8_t *buf_end = buf + buf_size;



    while(buf + 48 <= buf_end) {

        int dir_length, name_size, first_sector, depth;

        uint64_t file_length;

        const uint8_t *name;

        if (ff_guidcmp(buf, dir_entry_guid)) {

            av_log(s, AV_LOG_ERROR, ""unknown guid ""FF_PRI_GUID"", expected dir_entry_guid; ""

                   ""remaining directory entries ignored\n"", FF_ARG_GUID(buf));

            break;

        }

        dir_length  = AV_RL16(buf + 16);

        file_length = AV_RL64(buf + 24);

        name_size   = 2 * AV_RL32(buf + 32);

        if (buf + 48 + name_size > buf_end) {

            av_log(s, AV_LOG_ERROR, ""filename exceeds buffer size; remaining directory entries ignored\n"");

            break;

        }

        first_sector = AV_RL32(buf + 40 + name_size);

        depth        = AV_RL32(buf + 44 + name_size);



      ",0,0,2,0,0,1,1,0,1,1,1,1,0,0,0
12278,FFmpeg,1,"static void stereo_processing(PSContext *ps, INTFLOAT (*l)[32][2], INTFLOAT (*r)[32][2], int is34)

{

    int e, b, k;



    INTFLOAT (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11;

    INTFLOAT (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12;

    INTFLOAT (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21;

    INTFLOAT (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22;

    int8_t *opd_hist = ps->opd_hist;

    int8_t *ipd_hist = ps->ipd_hist;

    int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];

    int8_t icc_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];

    int8_t ipd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];

    int8_t opd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];

    int8_t (*iid_mapped)[PS_MAX_NR_IIDICC] = iid_mapped_buf;

    int8_t (*icc_mapped)[PS_MAX_NR_IIDICC] = icc_mapped_buf;

    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;

    int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf;

    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;
",0,0,0,0,0,0,0,0,0,0,1,0,1,1,1
12281,qemu,1,"static void handle_qmp_command(JSONMessageParser *parser, QList *tokens)

{

    int err;

    QObject *obj;

    QDict *input, *args;

    const mon_cmd_t *cmd;

    Monitor *mon = cur_mon;

    const char *cmd_name, *info_item;



    args = NULL;



    obj = json_parser_parse(tokens, NULL);

    if (!obj) {

        // FIXME: should be triggered in json_parser_parse()

        qerror_report(QERR_JSON_PARSING);

        goto err_out;


        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, ""object"");

        qobject_decref(obj);

        goto err_out;

    }



    input = qobject_to_qdict(obj);



    mon->mc->id = qdict_get(input, ""id"");

    qobject_incref(mon->mc->id);



    obj = qdict_get(input, ""execute"");

    if (!obj) {

        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, ""execute"");


    } else if (qobject_type(obj) != QTYPE_QSTRING) {

        qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"", ""string"");


    }



    cmd_name = qstring_get_str(qobject_to_qstring(obj));



    if (invalid_qm",0,2,4,0,0,0,1,1,0,1,1,0,0,1,1
12305,FFmpeg,0,"static int idcin_decode_init(AVCodecContext *avctx)

{

    IdcinContext *s = avctx->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *histograms;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&s->dsp, avctx);



    /* make sure the Huffman tables make it */

    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    histograms = (unsigned char *)s->avctx->extradata;

    for (i = 0; i < 256; i++) {

        for(j = 0; j < HUF_TOKENS; j++)

            s->huff_nodes[i][j].count = histograms[histogram_index++];

        huff_build_tree(s, i);

    }



    s->frame.data[0] = NULL;



    return 0;

}
",2,0,1,0,0,0,1,0,1,1,1,1,0,1,0
12307,qemu,0,"static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,

                                 uint32_t color, int *w_ptr, int *h_ptr)

{

    int dx, dy, dw, dh;

    int w_prev;

    int w_best = 0, h_best = 0;



    w_prev = w;



    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {



        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);

        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);



        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {

            break;

        }



        for (dx = x + dw; dx < x + w_prev;) {

            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);



            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {

                break;

            }

            dx += dw;

        }



        w_prev = dx - x;

        if (w_prev * (dy + dh - y) > w_best * h_best) {

            w_best = w_prev;

            h_best = dy + dh - y;

        }

    }



    *w_ptr = w_best;

    *h_ptr = h_best;

}
",2,0,3,0,0,0,1,1,0,0,1,1,1,1,1
12314,qemu,0,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)

{

    RAMBlock *block;



    /* The list is protected by the iothread lock here.  */

    block = ram_list.mru_block;

    if (block && addr - block->offset < block->max_length) {

        goto found;

    }

    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        if (addr - block->offset < block->max_length) {

            goto found;

        }

    }



    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);

    abort();



found:

    ram_list.mru_block = block;

    return block;

}
",0,2,2,0,0,0,1,0,0,1,1,1,0,0,0
12320,qemu,0,"static int usbnet_can_receive(VLANClientState *nc)

{

    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;



    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)

        return 1;



    return !s->in_len;

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
12326,qemu,0,"static int scsi_disk_emulate_mode_sense(SCSIRequest *req, uint8_t *outbuf)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    uint64_t nb_sectors;

    int page, dbd, buflen, page_control;

    uint8_t *p;

    uint8_t dev_specific_param;



    dbd = req->cmd.buf[1]  & 0x8;

    page = req->cmd.buf[2] & 0x3f;

    page_control = (req->cmd.buf[2] & 0xc0) >> 6;

    DPRINTF(""Mode Sense(%d) (page %d, len %d, page_control %d)\n"",

        (req->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control);

    memset(outbuf, 0, req->cmd.xfer);

    p = outbuf;



    if (bdrv_is_read_only(s->bs)) {

        dev_specific_param = 0x80; /* Readonly.  */

    } else {

        dev_specific_param = 0x00;

    }



    if (req->cmd.buf[0] == MODE_SENSE) {

        p[1] = 0; /* Default media type.  */

        p[2] = dev_specific_param;

        p[3] = 0; /* Block descriptor length.  */

        p += 4;

    } else { /* MODE_SENSE_10 */

        p[2] = 0; /* Default media type.  */

        p[3] ",0,0,6,0,0,0,1,0,1,0,0,1,0,0,0
12329,qemu,0,"void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)

{

    TCGOpcode op;

    TCGOpDef *def;

    const char *ct_str;

    int i, nb_args;



    for(;;) {

        if (tdefs->op == (TCGOpcode)-1)

            break;

        op = tdefs->op;

        assert((unsigned)op < NB_OPS);

        def = &tcg_op_defs[op];

#if defined(CONFIG_DEBUG_TCG)

        /* Duplicate entry in op definitions? */

        assert(!def->used);

        def->used = 1;

#endif

        nb_args = def->nb_iargs + def->nb_oargs;

        for(i = 0; i < nb_args; i++) {

            ct_str = tdefs->args_ct_str[i];

            /* Incomplete TCGTargetOpDef entry? */

            assert(ct_str != NULL);

            tcg_regset_clear(def->args_ct[i].u.regs);

            def->args_ct[i].ct = 0;

            if (ct_str[0] >= '0' && ct_str[0] <= '9') {

                int oarg;

                oarg = ct_str[0] - '0';

                assert(oarg < def->nb_oargs);

                assert(def->args_ct[oarg].ct & TCG_CT_REG);

       ",2,0,4,0,0,0,0,0,0,1,0,0,1,1,1
12347,qemu,1,"void AUD_vlog (const char *cap, const char *fmt, va_list ap)

{

    if (conf.log_to_monitor) {

        if (cap) {

            monitor_printf(default_mon, ""%s: "", cap);

        }



        monitor_vprintf(default_mon, fmt, ap);

    }

    else {

        if (cap) {

            fprintf (stderr, ""%s: "", cap);

        }



        vfprintf (stderr, fmt, ap);

    }

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,0,0
12353,FFmpeg,0,"static int ogg_build_flac_headers(const uint8_t *extradata, int extradata_size,

                                  OGGStreamContext *oggstream, int bitexact)

{

    const char *vendor = bitexact ? ""ffmpeg"" : LIBAVFORMAT_IDENT;

    uint8_t *p;

    if (extradata_size != 34)

        return -1;

    oggstream->header_len[0] = 51;

    oggstream->header[0] = av_mallocz(51); // per ogg flac specs

    p = oggstream->header[0];

    bytestream_put_byte(&p, 0x7F);

    bytestream_put_buffer(&p, ""FLAC"", 4);

    bytestream_put_byte(&p, 1); // major version

    bytestream_put_byte(&p, 0); // minor version

    bytestream_put_be16(&p, 1); // headers packets without this one

    bytestream_put_buffer(&p, ""fLaC"", 4);

    bytestream_put_byte(&p, 0x00); // streaminfo

    bytestream_put_be24(&p, 34);

    bytestream_put_buffer(&p, extradata, 34);

    oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;

    oggstream->header[1] = av_mallocz(oggstream->header_len[1]);

    p = oggstream->header[1];

    bytestream_put_",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
12357,FFmpeg,0,"static void put_subframe(DCAEncContext *c, int subframe)

{

    int i, band, ss, ch;



    /* Subsubframes count */

    put_bits(&c->pb, 2, SUBSUBFRAMES -1);



    /* Partial subsubframe sample count: dummy */

    put_bits(&c->pb, 3, 0);



    /* Prediction mode: no ADPCM, in each channel and subband */

    for (ch = 0; ch < c->fullband_channels; ch++)

        for (band = 0; band < DCAENC_SUBBANDS; band++)

            put_bits(&c->pb, 1, 0);



    /* Prediction VQ address: not transmitted */

    /* Bit allocation index */

    for (ch = 0; ch < c->fullband_channels; ch++)

        for (band = 0; band < DCAENC_SUBBANDS; band++)

            put_bits(&c->pb, 5, c->abits[band][ch]);



    if (SUBSUBFRAMES > 1) {

        /* Transition mode: none for each channel and subband */

        for (ch = 0; ch < c->fullband_channels; ch++)

            for (band = 0; band < DCAENC_SUBBANDS; band++)

                put_bits(&c->pb, 1, 0); /* codebook A4 */

    }



    /* Scale factors */

    for (ch = 0; c",7,0,1,0,0,0,1,1,1,1,1,1,1,0,0
12362,FFmpeg,0,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;



    count/=2;



    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for(i=0; i<count; i++){

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

}
",2,0,1,0,0,0,0,0,0,0,0,0,0,1,0
12365,qemu,0,"static int start_auth_vencrypt_subauth(VncState *vs)

{

    switch (vs->vd->subauth) {

    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:

       VNC_DEBUG(""Accept TLS auth none\n"");

       vnc_write_u32(vs, 0); /* Accept auth completion */

       vnc_read_when(vs, protocol_client_init, 1);

       break;



    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(vs);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(err));

           vnc_write(vs, err, sizeof(err));

       }

       vnc_client_error(vs);

    }



    return 0;

}
",0,0,1,0,1,0,1,1,1,1,1,1,1,1,0
12367,qemu,0,"iscsi_unmap_cb(struct iscsi_context *iscsi, int status,

                     void *command_data, void *opaque)

{

    IscsiAIOCB *acb = opaque;



    if (acb->canceled != 0) {

        return;

    }



    acb->status = 0;

    if (status < 0) {

        error_report(""Failed to unmap data on iSCSI lun. %s"",

                     iscsi_get_error(iscsi));

        acb->status = -EIO;

    }



    iscsi_schedule_bh(acb);

}
",0,0,2,0,0,0,0,0,1,1,1,1,0,0,0
12376,qemu,0,"static void virtio_notify(struct subchannel_id schid)

{

    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
12377,qemu,0,"static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)

{

    struct kvm_x86_mce mce = {

        .bank = 9,

        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN

                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S

                  | 0xc0,

        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,

        .addr = paddr,

        .misc = (MCM_ADDR_PHYS << 6) | 0xc,

    };



    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);

    kvm_mce_broadcast_rest(env);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
12378,qemu,0,"static void lm32_evr_init(QEMUMachineInitArgs *args)

{

    const char *cpu_model = args->cpu_model;

    const char *kernel_filename = args->kernel_filename;

    LM32CPU *cpu;

    CPULM32State *env;

    DriveInfo *dinfo;

    MemoryRegion *address_space_mem =  get_system_memory();

    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);

    qemu_irq *cpu_irq, irq[32];

    ResetInfo *reset_info;

    int i;



    /* memory map */

    target_phys_addr_t flash_base  = 0x04000000;

    size_t flash_sector_size       = 256 * 1024;

    size_t flash_size              = 32 * 1024 * 1024;

    target_phys_addr_t ram_base    = 0x08000000;

    size_t ram_size                = 64 * 1024 * 1024;

    target_phys_addr_t timer0_base = 0x80002000;

    target_phys_addr_t uart0_base  = 0x80006000;

    target_phys_addr_t timer1_base = 0x8000a000;

    int uart0_irq                  = 0;

    int timer0_irq                 = 1;

    int timer1_irq                 = 3;



    reset_info = g_malloc0(sizeof(ResetInfo));

",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
12383,qemu,0,"static void gen_msa_branch(CPUMIPSState *env, DisasContext *ctx, uint32_t op1)

{

    uint8_t df = (ctx->opcode >> 21) & 0x3;

    uint8_t wt = (ctx->opcode >> 16) & 0x1f;

    int64_t s16 = (int16_t)ctx->opcode;



    check_msa_access(ctx);



    if (ctx->insn_flags & ISA_MIPS32R6 && ctx->hflags & MIPS_HFLAG_BMASK) {

        generate_exception_end(ctx, EXCP_RI);

        return;

    }

    switch (op1) {

    case OPC_BZ_V:

    case OPC_BNZ_V:

        {

            TCGv_i64 t0 = tcg_temp_new_i64();

            tcg_gen_or_i64(t0, msa_wr_d[wt<<1], msa_wr_d[(wt<<1)+1]);

            tcg_gen_setcondi_i64((op1 == OPC_BZ_V) ?

                    TCG_COND_EQ : TCG_COND_NE, t0, t0, 0);

            tcg_gen_trunc_i64_tl(bcond, t0);

            tcg_temp_free_i64(t0);

        }

        break;

    case OPC_BZ_B:

    case OPC_BZ_H:

    case OPC_BZ_W:

    case OPC_BZ_D:

        gen_check_zero_element(bcond, df, wt);

        break;

    case OPC_BNZ_B:

    case OPC_BNZ_H:

    case OPC_BNZ_W:

    case ",0,0,1,0,1,0,0,0,0,0,0,0,0,0,0
12384,qemu,0,"static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)

{

    QObject *token, *ret;

    QList *working = qlist_copy(*tokens);



    token = qlist_pop(working);

    if (token == NULL) {

        goto out;

    }



    if (token_get_type(token) != JSON_KEYWORD) {

        goto out;

    }



    if (token_is_keyword(token, ""true"")) {

        ret = QOBJECT(qbool_from_int(true));

    } else if (token_is_keyword(token, ""false"")) {

        ret = QOBJECT(qbool_from_int(false));

    } else {

        parse_error(ctxt, token, ""invalid keyword `%s'"", token_get_value(token));

        goto out;

    }



    qobject_decref(token);

    QDECREF(*tokens);

    *tokens = working;



    return ret;



out: 

    qobject_decref(token);

    QDECREF(working);



    return NULL;

}
",0,3,4,0,0,0,0,0,0,0,1,0,1,1,1
12395,FFmpeg,0,"static av_cold int vaapi_encode_config_attributes(AVCodecContext *avctx)

{

    VAAPIEncodeContext *ctx = avctx->priv_data;

    VAStatus vas;

    int i, n, err;

    VAProfile    *profiles    = NULL;

    VAEntrypoint *entrypoints = NULL;

    VAConfigAttrib attr[] = {

        { VAConfigAttribRTFormat        },

        { VAConfigAttribRateControl     },

        { VAConfigAttribEncMaxRefFrames },

    };



    n = vaMaxNumProfiles(ctx->hwctx->display);

    profiles = av_malloc_array(n, sizeof(VAProfile));

    if (!profiles) {

        err = AVERROR(ENOMEM);

        goto fail;

    }

    vas = vaQueryConfigProfiles(ctx->hwctx->display, profiles, &n);

    if (vas != VA_STATUS_SUCCESS) {

        av_log(ctx, AV_LOG_ERROR, ""Failed to query profiles: %d (%s).\n"",

               vas, vaErrorStr(vas));

        err = AVERROR(ENOSYS);

        goto fail;

    }

    for (i = 0; i < n; i++) {

        if (profiles[i] == ctx->va_profile)

            break;

    }

    if (i >= n) {

        av_log(ctx, AV_",1,2,4,0,0,0,1,1,0,1,0,1,1,1,1
12402,FFmpeg,0,"static int targa_encode_frame(AVCodecContext *avctx, AVPacket *pkt,

                              const AVFrame *p, int *got_packet)

{

    int bpp, picsize, datasize = -1, ret;

    uint8_t *out;



    if(avctx->width > 0xffff || avctx->height > 0xffff) {

        av_log(avctx, AV_LOG_ERROR, ""image dimensions too large\n"");

        return AVERROR(EINVAL);

    }

    picsize = av_image_get_buffer_size(avctx->pix_fmt,

                                       avctx->width, avctx->height, 1);

    if ((ret = ff_alloc_packet(pkt, picsize + 45)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""encoded frame too large\n"");

        return ret;

    }



    /* zero out the header and only set applicable fields */

    memset(pkt->data, 0, 12);

    AV_WL16(pkt->data+12, avctx->width);

    AV_WL16(pkt->data+14, avctx->height);

    /* image descriptor byte: origin is always top-left, bits 0-3 specify alpha */

    pkt->data[17] = 0x20 | (avctx->pix_fmt == AV_PIX_FMT_BGRA ? 8 : 0);



    switch(avctx->pix_fmt) {

 ",0,0,2,0,1,0,1,1,1,0,0,0,1,1,1
12409,qemu,1,"static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)

{

    cmd->xfer = scsi_cdb_length(buf);

    switch (buf[0]) {

    case TEST_UNIT_READY:

    case REWIND:

    case START_STOP:

    case SET_CAPACITY:

    case WRITE_FILEMARKS:

    case WRITE_FILEMARKS_16:

    case SPACE:

    case RESERVE:

    case RELEASE:

    case ERASE:

    case ALLOW_MEDIUM_REMOVAL:

    case SEEK_10:

    case SYNCHRONIZE_CACHE:

    case SYNCHRONIZE_CACHE_16:

    case LOCATE_16:

    case LOCK_UNLOCK_CACHE:

    case SET_CD_SPEED:

    case SET_LIMITS:

    case WRITE_LONG_10:

    case UPDATE_BLOCK:

    case RESERVE_TRACK:

    case SET_READ_AHEAD:

    case PRE_FETCH:

    case PRE_FETCH_16:

    case ALLOW_OVERWRITE:

        cmd->xfer = 0;

        break;

    case VERIFY_10:

    case VERIFY_12:

    case VERIFY_16:

        if ((buf[1] & 2) == 0) {

            cmd->xfer = 0;

        } else if ((buf[1] & 4) == 1) {

            cmd->xfer = 1;

        }

        cmd->xfer *= dev->blocksize;
",0,0,2,0,1,0,0,1,1,1,1,1,1,1,0
12412,FFmpeg,0,"static void qdm2_init(QDM2Context *q) {

    static int inited = 0;



    if (inited != 0)

        return;

    inited = 1;



    qdm2_init_vlc();

    ff_mpa_synth_init(mpa_window);

    softclip_table_init();

    rnd_table_init();

    init_noise_samples();



    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
12429,FFmpeg,1,"static int encode_frame(FlacEncodeContext *s)

{

    int ch, count;



    count = count_frame_header(s);



    for (ch = 0; ch < s->channels; ch++)

        count += encode_residual_ch(s, ch);



    count += (8 - (count & 7)) & 7; // byte alignment

    count += 16;                    // CRC-16



    return count >> 3;

}
",1,0,0,0,0,0,0,1,0,1,0,0,1,0,1
12434,qemu,0,"static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos)

{

    PCIDevice *pdev = &vdev->pdev;

    uint8_t cap_id, next, size;

    int ret;



    cap_id = pdev->config[pos];

    next = pdev->config[pos + PCI_CAP_LIST_NEXT];



    /*

     * If it becomes important to configure capabilities to their actual

     * size, use this as the default when it's something we don't recognize.

     * Since QEMU doesn't actually handle many of the config accesses,

     * exact size doesn't seem worthwhile.

     */

    size = vfio_std_cap_max_size(pdev, pos);



    /*

     * pci_add_capability always inserts the new capability at the head

     * of the chain.  Therefore to end up with a chain that matches the

     * physical device, we insert from the end by making this recursive.

     * This is also why we pre-calculate size above as cached config space

     * will be changed as we unwind the stack.

     */

    if (next) {

        ret = vfio_add_std_cap(vdev, next);

        if (ret) {

           ",1,0,2,0,0,1,0,0,0,0,0,0,0,1,0
12451,qemu,0,"int cpu_exec(CPUState *env1)

{

#define DECLARE_HOST_REGS 1

#include ""hostregs_helper.h""

    int ret, interrupt_request;

    TranslationBlock *tb;

    uint8_t *tc_ptr;

    unsigned long next_tb;



    if (cpu_halted(env1) == EXCP_HALTED)

        return EXCP_HALTED;



    cpu_single_env = env1;



    /* first we save global registers */

#define SAVE_HOST_REGS 1

#include ""hostregs_helper.h""

    env = env1;



#if defined(TARGET_I386)

    /* put eflags in CPU temporary format */

    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);

    DF = 1 - (2 * ((env->eflags >> 10) & 1));

    CC_OP = CC_OP_EFLAGS;

    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);

#elif defined(TARGET_SPARC)

#elif defined(TARGET_M68K)

    env->cc_op = CC_OP_FLAGS;

    env->cc_dest = env->sr & 0xf;

    env->cc_x = (env->sr >> 4) & 1;

#elif defined(TARGET_ALPHA)

#elif defined(TARGET_ARM)

#elif defined(TARGET_PPC)

#elif defined(TARGET_MICROBLAZE)

#elif defined(TARGET_MIPS)

#eli",0,0,9,0,0,0,0,0,0,0,0,0,1,1,1
12452,qemu,0,"void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)

{

    /* We're passed bits [11..0] of the instruction; extract

     * SYSm and the mask bits.

     * Invalid combinations of SYSm and mask are UNPREDICTABLE;

     * we choose to treat them as if the mask bits were valid.

     * NB that the pseudocode 'mask' variable is bits [11..10],

     * whereas ours is [11..8].

     */

    uint32_t mask = extract32(maskreg, 8, 4);

    uint32_t reg = extract32(maskreg, 0, 8);



    if (arm_current_el(env) == 0 && reg > 7) {

        /* only xPSR sub-fields may be written by unprivileged */

        return;

    }



    switch (reg) {

    case 0 ... 7: /* xPSR sub-fields */

        /* only APSR is actually writable */

        if (!(reg & 4)) {

            uint32_t apsrmask = 0;



            if (mask & 8) {

                apsrmask |= XPSR_NZCV | XPSR_Q;

            }

            if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) {

                apsrmask |= XPSR_GE;

      ",0,0,5,0,1,0,1,1,1,1,1,0,1,0,1
12470,qemu,0,"static bool migrate_caps_check(bool *cap_list,

                               MigrationCapabilityStatusList *params,

                               Error **errp)

{

    MigrationCapabilityStatusList *cap;

    bool old_postcopy_cap;



    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];



    for (cap = params; cap; cap = cap->next) {

        cap_list[cap->value->capability] = cap->value->state;

    }



#ifndef CONFIG_LIVE_BLOCK_MIGRATION

    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {

        error_setg(errp, ""QEMU compiled without old-style (blk/-b, inc/-i) ""

                   ""block migration"");

        error_append_hint(errp, ""Use drive_mirror+NBD instead.\n"");

        return false;

    }

#endif



    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {

        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {

            /* The decompression threads asynchronously write into RAM

             * rather than use the atomic copies needed to avoid

             * userfaulting.  I",1,0,5,0,0,0,1,1,1,0,0,0,0,0,0
12477,qemu,0,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        s->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    }



    bdrv_error_action(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
",0,0,2,0,0,0,0,0,0,0,1,1,1,1,1
12493,FFmpeg,1,"static inline void FUNC(idctRowCondDC_extrashift)(int16_t *row, int extra_shift)

#else

static inline void FUNC(idctRowCondDC)(int16_t *row, int extra_shift)

#endif

{

    int a0, a1, a2, a3, b0, b1, b2, b3;



#if HAVE_FAST_64BIT

#define ROW0_MASK (0xffffLL << 48 * HAVE_BIGENDIAN)

    if (((AV_RN64A(row) & ~ROW0_MASK) | AV_RN64A(row+4)) == 0) {

        uint64_t temp;

        if (DC_SHIFT - extra_shift >= 0) {

            temp = (row[0] * (1 << (DC_SHIFT - extra_shift))) & 0xffff;

        } else {

            temp = ((row[0] + (1<<(extra_shift - DC_SHIFT-1))) >> (extra_shift - DC_SHIFT)) & 0xffff;

        }

        temp += temp * (1 << 16);

        temp += temp * ((uint64_t) 1 << 32);

        AV_WN64A(row, temp);

        AV_WN64A(row + 4, temp);

        return;

    }

#else

    if (!(AV_RN32A(row+2) |

          AV_RN32A(row+4) |

          AV_RN32A(row+6) |

          row[1])) {

        uint32_t temp;

        if (DC_SHIFT - extra_shift >= 0) {

            temp = (row[0] * (1 << (DC_SHIFT",0,0,14,0,0,0,0,1,0,1,1,0,1,0,0
12499,qemu,1,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
",0,0,1,0,0,0,1,1,1,1,1,0,1,1,1
12544,qemu,0,"static void calxeda_init(MachineState *machine, enum cxmachines machine_id)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    DeviceState *dev = NULL;

    SysBusDevice *busdev;

    qemu_irq pic[128];

    int n;

    qemu_irq cpu_irq[4];

    qemu_irq cpu_fiq[4];

    MemoryRegion *sysram;

    MemoryRegion *dram;

    MemoryRegion *sysmem;

    char *sysboot_filename;



    if (!cpu_model) {

        switch (machine_id) {

        case CALXEDA_HIGHBANK:

            cpu_model = ""cortex-a9"";

            break;

        case CALXEDA_MIDWAY:

            cpu_model = ""cortex-a15"";

            break;

        }

    }



    for (n = 0; n < smp_cpus; n++) {

        ObjectClass *oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);

        Object *cpuobj;

        ARMCPU *cpu;

    ",1,0,1,0,1,0,0,0,0,0,0,0,1,1,1
12545,qemu,0,"static int get_phys_addr_v5(CPUState *env, uint32_t address, int access_type,

			    int is_user, uint32_t *phys_ptr, int *prot)

{

    int code;

    uint32_t table;

    uint32_t desc;

    int type;

    int ap;

    int domain;

    uint32_t phys_addr;



    /* Pagetable walk.  */

    /* Lookup l1 descriptor.  */

    table = get_level1_table_address(env, address);

    desc = ldl_phys(table);

    type = (desc & 3);

    domain = (env->cp15.c3 >> ((desc >> 4) & 0x1e)) & 3;

    if (type == 0) {

        /* Section translation fault.  */

        code = 5;

        goto do_fault;

    }

    if (domain == 0 || domain == 2) {

        if (type == 2)

            code = 9; /* Section domain fault.  */

        else

            code = 11; /* Page domain fault.  */

        goto do_fault;

    }

    if (type == 2) {

        /* 1Mb section.  */

        phys_addr = (desc & 0xfff00000) | (address & 0x000fffff);

        ap = (desc >> 10) & 3;

        code = 13;

    } else {

        /* Lookup l2 entry.",0,2,4,0,0,0,0,0,1,0,0,1,1,0,0
12548,qemu,1,"static void vmxnet3_update_mcast_filters(VMXNET3State *s)

{

    uint16_t list_bytes =

        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,

                                  devRead.rxFilterConf.mfTableLen);



    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);



    s->mcast_list = g_realloc(s->mcast_list, list_bytes);

    if (!s->mcast_list) {

        if (s->mcast_list_len == 0) {

            VMW_CFPRN(""Current multicast list is empty"");

        } else {

            VMW_ERPRN(""Failed to allocate multicast list of %d elements"",

                      s->mcast_list_len);

        }

        s->mcast_list_len = 0;

    } else {

        int i;

        hwaddr mcast_list_pa =

            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,

                                      devRead.rxFilterConf.mfTablePA);



        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);



        VMW_CFPRN(""Current multicast list len is %d:"", s->mcast_list_len);

        for (i = 0; i < s->mcast_list_l",1,0,2,0,0,0,1,1,1,1,0,0,1,1,1
12556,FFmpeg,0,"int ff_nvdec_decode_init(AVCodecContext *avctx, unsigned int dpb_size)

{

    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;



    NVDECFramePool      *pool;

    AVHWFramesContext   *frames_ctx;

    const AVPixFmtDescriptor *sw_desc;



    CUVIDDECODECREATEINFO params = { 0 };



    int cuvid_codec_type, cuvid_chroma_format;

    int ret = 0;



    sw_desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);

    if (!sw_desc)

        return AVERROR_BUG;



    cuvid_codec_type = map_avcodec_id(avctx->codec_id);

    if (cuvid_codec_type < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Unsupported codec ID\n"");

        return AVERROR_BUG;

    }



    cuvid_chroma_format = map_chroma_format(avctx->sw_pix_fmt);

    if (cuvid_chroma_format < 0) {

        av_log(avctx, AV_LOG_ERROR, ""Unsupported chroma format\n"");

        return AVERROR(ENOSYS);

    }



    if (avctx->thread_type & FF_THREAD_FRAME)

        dpb_size += avctx->thread_count;



    if (!avctx->hw_frames_ctx) {

        AVHWFramesContext *",5,0,5,0,0,0,0,0,0,0,0,0,0,1,1
12558,qemu,1,"void hmp_info_snapshots(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;

    int nb_sns, i, ret, available;

    int total;

    int *available_snapshots;



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No available block device supports snapshots\n"");

        return;

    }



    nb_sns = bdrv_snapshot_list(bs, &sn_tab);

    if (nb_sns < 0) {

        monitor_printf(mon, ""bdrv_snapshot_list: error %d\n"", nb_sns);

        return;

    }



    if (nb_sns == 0) {

        monitor_printf(mon, ""There is no snapshot available.\n"");

        return;

    }



    available_snapshots = g_malloc0(sizeof(int) * nb_sns);

    total = 0;

    for (i = 0; i < nb_sns; i++) {

        sn = &sn_tab[i];

        available = 1;

        bs1 = NULL;



        while ((bs1 = bdrv_next(bs1))) {

            if (bdrv_can_snapshot(bs1) && bs1 != bs) {

                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);

  ",1,0,4,0,0,1,1,1,1,1,1,1,0,1,0
12585,FFmpeg,1,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);

}
",0,0,1,0,0,0,1,1,1,0,1,1,1,1,1
12596,qemu,1,"static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)

{

    cirrus_fill_t rop_func;



    if (blit_is_unsafe(s)) {

        return 0;

    }

    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];

    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),

             s->cirrus_blt_dstpitch,

             s->cirrus_blt_width, s->cirrus_blt_height);

    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,

			     s->cirrus_blt_dstpitch, s->cirrus_blt_width,

			     s->cirrus_blt_height);

    cirrus_bitblt_reset(s);

    return 1;

}
",0,0,1,0,0,0,1,1,1,1,1,0,0,1,0
12607,FFmpeg,1,"static int load_ipmovie_packet(IPMVEContext *s, AVIOContext *pb,

    AVPacket *pkt) {



    int chunk_type;



    if (s->audio_chunk_offset) {








        /* adjust for PCM audio by skipping chunk header */

        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM) {

            s->audio_chunk_offset += 6;

            s->audio_chunk_size -= 6;




        avio_seek(pb, s->audio_chunk_offset, SEEK_SET);

        s->audio_chunk_offset = 0;



        if (s->audio_chunk_size != av_get_packet(pb, pkt, s->audio_chunk_size))

            return CHUNK_EOF;



        pkt->stream_index = s->audio_stream_index;

        pkt->pts = s->audio_frame_count;



        /* audio frame maintenance */

        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM)

            s->audio_frame_count +=

            (s->audio_chunk_size / s->audio_channels / (s->audio_bits / 8));

        else

            s->audio_frame_count +=

                (s->audio_chunk_size - 6) / s->audio_channels;



        av_dlog(NULL, ""sending audio f",0,0,4,0,0,0,0,0,0,0,0,0,0,1,1
12616,FFmpeg,0,"static int encode_hq_slice(AVCodecContext *avctx, void *arg)

{

    SliceArgs *slice_dat = arg;

    VC2EncContext *s = slice_dat->ctx;

    PutBitContext *pb = &slice_dat->pb;

    const int slice_x = slice_dat->x;

    const int slice_y = slice_dat->y;

    const int quant_idx = slice_dat->quant_idx;

    const int slice_bytes_max = slice_dat->bytes;

    uint8_t quants[MAX_DWT_LEVELS][4];

    int p, level, orientation;



    avpriv_align_put_bits(pb);

    skip_put_bytes(pb, s->prefix_bytes);

    put_bits(pb, 8, quant_idx);



    /* Slice quantization (slice_quantizers() in the specs) */

    for (level = 0; level < s->wavelet_depth; level++)

        for (orientation = !!level; orientation < 4; orientation++)

            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);



    /* Luma + 2 Chroma planes */

    for (p = 0; p < 3; p++) {

        int bytes_start, bytes_len, pad_s, pad_c;

        bytes_start = put_bits_count(pb) >> 3;

        put_bits(pb, 8, 0);

      ",3,0,0,0,0,0,1,1,1,1,1,1,0,0,0
12624,qemu,0,"static void do_info_commands(Monitor *mon, QObject **ret_data)

{

    QList *cmd_list;

    const mon_cmd_t *cmd;



    cmd_list = qlist_new();



    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&

            !compare_cmd(cmd->name, ""info"")) {

            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));

        }

    }



    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {

            char buf[128];

            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);

            qlist_append_obj(cmd_list, get_cmd_dict(buf));

        }

    }



    *ret_data = QOBJECT(cmd_list);

}
",2,0,2,0,0,0,0,0,0,0,0,0,1,1,0
12635,qemu,0,"static void spapr_msi_write(void *opaque, hwaddr addr,

                            uint64_t data, unsigned size)

{

    sPAPRPHBState *phb = opaque;

    int ndev = addr >> 16;

    int vec = ((addr & 0xFFFF) >> 2) | data;

    uint32_t irq = phb->msi_table[ndev].irq + vec;



    trace_spapr_pci_msi_write(addr, data, irq);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
12642,qemu,0,"static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,

                uint32_t value)

{

    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;

    if (addr > s->pm_base + PCMD31) {

        /* Special case: PWRI2C registers appear in the same range.  */

        pxa2xx_i2c_write(s->i2c[1], addr, value);

        return;

    }

    addr -= s->pm_base;



    switch (addr) {

    case PMCR:

        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);

        s->pm_regs[addr >> 2] |= value & 0x15;

        break;



    case PSSR:	/* Read-clean registers */

    case RCSR:

    case PKSR:

        s->pm_regs[addr >> 2] &= ~value;

        break;



    default:	/* Read-write registers */

        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {

            s->pm_regs[addr >> 2] = value;

            break;

        }



        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);

        break;

    }

}
",0,0,2,0,1,0,0,0,0,0,0,0,0,0,0
12645,qemu,0,"CPUX86State *cpu_x86_init(void)

{

    CPUX86State *env;

    int i;

    static int inited;



    cpu_x86_tblocks_init();



    env = malloc(sizeof(CPUX86State));

    if (!env)

        return NULL;

    memset(env, 0, sizeof(CPUX86State));

    /* basic FPU init */

    for(i = 0;i < 8; i++)

        env->fptags[i] = 1;

    env->fpuc = 0x37f;

    /* flags setup */

    env->eflags = 0;



    /* init various static tables */

    if (!inited) {

        inited = 1;

        optimize_flags_init();

    }

    return env;

}
",1,0,2,0,0,0,0,0,0,0,0,0,1,1,1
12663,qemu,0,"void readline_show_prompt(ReadLineState *rs)

{

    monitor_printf(rs->mon, ""%s"", rs->prompt);

    monitor_flush(rs->mon);

    rs->last_cmd_buf_index = 0;

    rs->last_cmd_buf_size = 0;

    rs->esc_state = IS_NORM;

}
",0,0,0,0,0,0,1,1,1,1,0,0,0,0,0
12667,qemu,0,"static int parallel_parse(const char *devname)

{

    static int index = 0;

    char label[32];



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    snprintf(label, sizeof(label), ""parallel%d"", index);

    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'\n"", devname);

        return -1;

    }

    index++;

    return 0;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,1,1
12668,qemu,0,"START_TEST(qfloat_destroy_test)

{

    QFloat *qf = qfloat_from_double(0.0);

    QDECREF(qf);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
12672,qemu,0,"static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)

{

    int err;

    char buffer[PATH_MAX];

    char *path = fs_path->data;



    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);

    if (err) {

        return err;

    }

    if (fs_ctx->fs_sm == SM_MAPPED) {

        /* Actual credentials are part of extended attrs */

        uid_t tmp_uid;

        gid_t tmp_gid;

        mode_t tmp_mode;

        dev_t tmp_dev;

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.uid"", &tmp_uid,

                    sizeof(uid_t)) > 0) {

            stbuf->st_uid = tmp_uid;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.gid"", &tmp_gid,

                    sizeof(gid_t)) > 0) {

            stbuf->st_gid = tmp_gid;

        }

        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.mode"",

                    &tmp_mode, sizeof(mode_t)) > 0) {

            stbuf->st_mode = tmp_mode;

        }

        if (getxattr(rpath(fs_ctx, path, buf",0,0,6,0,0,0,0,0,0,0,0,0,1,0,1
12686,qemu,0,"void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,

                                     uintptr_t retaddr)

{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    int t;



    cs->exception_index = EXCP_PGM;

    env->int_pgm_code = excp;



    /* Use the (ultimate) callers address to find the insn that trapped.  */

    cpu_restore_state(cs, retaddr);



    /* Advance past the insn.  */

    t = cpu_ldub_code(env, env->psw.addr);

    env->int_pgm_ilen = t = get_ilen(t);

    env->psw.addr += t;



    cpu_loop_exit(cs);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
12701,qemu,0,"static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
",1,0,4,0,0,0,0,0,0,0,0,0,1,1,1
12704,qemu,0,"SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,

                                                         bool has_id,

                                                         const char *id,

                                                         bool has_name,

                                                         const char *name,

                                                         Error **errp)

{

    BlockDriverState *bs;

    BlockBackend *blk;

    AioContext *aio_context;

    QEMUSnapshotInfo sn;

    Error *local_err = NULL;

    SnapshotInfo *info = NULL;

    int ret;



    blk = blk_by_name(device);

    if (!blk) {

        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,

                  ""Device '%s' not found"", device);

        return NULL;

    }



    aio_context = blk_get_aio_context(blk);

    aio_context_acquire(aio_context);



    if (!has_id) {

        id = NULL;

    }



    if (!has_name) {

        name = NULL;

    }



    if (!id && !",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
12710,qemu,0,"static void virtio_scsi_complete_req(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue *vq = req->vq;

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);

    if (req->sreq) {

        req->sreq->hba_private = NULL;

        scsi_req_unref(req->sreq);

    }

    virtio_scsi_free_req(req);

    virtio_notify(vdev, vq);

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,1
12724,qemu,0,"bool timer_pending(QEMUTimer *ts)

{

    QEMUTimer *t;

    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {

        if (t == ts) {

            return true;

        }

    }

    return false;

}
",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
12730,FFmpeg,0,"static int av_cold libopus_encode_init(AVCodecContext *avctx)

{

    LibopusEncContext *opus = avctx->priv_data;

    const uint8_t *channel_mapping;

    OpusMSEncoder *enc;

    int ret = OPUS_OK;

    int coupled_stream_count, header_size, frame_size;



    coupled_stream_count = opus_coupled_streams[avctx->channels - 1];

    opus->stream_count   = avctx->channels - coupled_stream_count;

    channel_mapping      = libav_libopus_channel_map[avctx->channels - 1];



    /* FIXME: Opus can handle up to 255 channels. However, the mapping for

     * anything greater than 8 is undefined. */

    if (avctx->channels > 8)

        av_log(avctx, AV_LOG_WARNING,

               ""Channel layout undefined for %d channels.\n"", avctx->channels);



    if (!avctx->bit_rate) {

        /* Sane default copied from opusenc */

        avctx->bit_rate = 64000 * opus->stream_count +

                          32000 * coupled_stream_count;

        av_log(avctx, AV_LOG_WARNING,

               ""No bit rate set. Defaultin",2,0,2,0,0,0,0,0,0,0,0,0,0,0,0
12741,qemu,0,"static void setup_rt_frame(int sig, struct emulated_sigaction *ka, 

                           target_siginfo_t *info,

			   target_sigset_t *set, CPUX86State *env)

{

	struct rt_sigframe *frame;

	int err = 0;



	frame = get_sigframe(ka, env, sizeof(*frame));



#if 0

	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))

		goto give_sigsegv;

#endif



	err |= __put_user((/*current->exec_domain

		    	   && current->exec_domain->signal_invmap

		    	   && sig < 32

		    	   ? current->exec_domain->signal_invmap[sig]

			   : */sig),

			  &frame->sig);

	err |= __put_user((target_ulong)&frame->info, &frame->pinfo);

	err |= __put_user((target_ulong)&frame->uc, &frame->puc);

	err |= copy_siginfo_to_user(&frame->info, info);

	if (err)

		goto give_sigsegv;



	/* Create the ucontext.  */

	err |= __put_user(0, &frame->uc.uc_flags);

	err |= __put_user(0, &frame->uc.uc_link);

	err |= __put_user(/*current->sas_ss_sp*/ 0, &frame->uc.uc_stack.ss_sp);

	err |= __put_user(/* sas_ss_flags(regs->esp) */ 0,",0,2,4,0,0,0,0,0,0,0,0,0,1,1,1
12777,qemu,0,"static void tcp_chr_telnet_init(QIOChannel *ioc)

{

    char buf[3];

    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */

    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */

    qio_channel_write(ioc, buf, 3, NULL);

    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */

    qio_channel_write(ioc, buf, 3, NULL);

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
12780,qemu,1,"static void blk_delete(BlockBackend *blk)

{

    assert(!blk->refcnt);

    assert(!blk->name);

    assert(!blk->dev);




    if (blk->root) {

        blk_remove_bs(blk);


    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));

    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));

    QTAILQ_REMOVE(&block_backends, blk, link);

    drive_info_del(blk->legacy_dinfo);

    block_acct_cleanup(&blk->stats);

    g_free(blk);
",0,0,5,0,0,0,0,0,0,0,0,0,1,1,1
12785,qemu,1,"static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}",0,0,5,0,0,0,1,1,0,1,1,1,0,0,0
12786,qemu,1,"static void spapr_nvram_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->props = spapr_nvram_properties;

    dc->vmsd = &vmstate_spapr_nvram;



}",0,0,0,0,0,0,0,0,0,1,1,1,0,0,0
12787,qemu,1,"static void cpu_handle_ioreq(void *opaque)

{

    XenIOState *state = opaque;

    ioreq_t *req = cpu_get_ioreq(state);



    handle_buffered_iopage(state);

    if (req) {

        ioreq_t copy = *req;



        xen_rmb();

        handle_ioreq(state, &copy);

        req->data = copy.data;



        if (req->state != STATE_IOREQ_INPROCESS) {

            fprintf(stderr, ""Badness in I/O request ... not in service?!: ""

                    ""%x, ptr: %x, port: %""PRIx64"", ""

                    ""data: %""PRIx64"", count: %u, size: %u, type: %u\n"",

                    req->state, req->data_is_ptr, req->addr,

                    req->data, req->count, req->size, req->type);

            destroy_hvm_domain(false);

            return;

        }



        xen_wmb(); /* Update ioreq contents /then/ update state. */



        /*

         * We do this before we send the response so that the tools

         * have the opportunity to pick up on the reset before the

         * guest resumes and does a hlt with i",2,0,2,0,0,0,1,1,1,1,1,1,0,1,0
12789,qemu,1,"static bool scsi_target_emulate_inquiry(SCSITargetReq *r)

{

    assert(r->req.dev->lun != r->req.lun);

    if (r->req.cmd.buf[1] & 0x2) {

        /* Command support data - optional, not implemented */

        return false;

    }



    if (r->req.cmd.buf[1] & 0x1) {

        /* Vital product data */

        uint8_t page_code = r->req.cmd.buf[2];

        r->buf[r->len++] = page_code ; /* this page */

        r->buf[r->len++] = 0x00;



        switch (page_code) {

        case 0x00: /* Supported page codes, mandatory */

        {

            int pages;

            pages = r->len++;

            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */

            r->buf[pages] = r->len - pages - 1; /* number of pages */

            break;

        }

        default:

            return false;

        }

        /* done with EVPD */

        assert(r->len < sizeof(r->buf));

        r->len = MIN(r->req.cmd.xfer, r->len);

        return true;

    }



    /* Standard INQUIRY data */

",0,0,2,0,1,0,0,0,0,0,0,0,0,1,1
12799,qemu,1,"int qcow2_expand_zero_clusters(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t *l1_table = NULL;

    uint64_t nb_clusters;

    uint8_t *expanded_clusters;

    int ret;

    int i, j;



    nb_clusters = size_to_clusters(s, bs->file->total_sectors *

                                   BDRV_SECTOR_SIZE);

    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);



    ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size,

                                     &expanded_clusters, &nb_clusters);

    if (ret < 0) {

        goto fail;

    }



    /* Inactive L1 tables may point to active L2 tables - therefore it is

     * necessary to flush the L2 table cache before trying to access the L2

     * tables pointed to by inactive L1 entries (else we might try to expand

     * zero clusters that have already been expanded); furthermore, it is also

     * necessary to empty the L2 table cache, since it may contain tables which

     * are now going to be modified directly on",2,1,2,0,0,0,0,0,0,1,1,0,0,1,0
12805,qemu,1,"static int local_open2(FsContext *fs_ctx, const char *path, int flags,

        FsCred *credp)

{

    int fd = -1;

    int err = -1;

    int serrno = 0;



    /* Determine the security model */

    if (fs_ctx->fs_sm == SM_MAPPED) {

        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);

        if (fd == -1) {

            return fd;

        }

        credp->fc_mode = credp->fc_mode|S_IFREG;

        /* Set cleint credentials in xattr */

        err = local_set_xattr(rpath(fs_ctx, path), credp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {

        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);

        if (fd == -1) {

            return fd;

        }

        err = local_post_create_passthrough(fs_ctx, path, credp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    }

    return fd;



err_end:

    close(fd);

    remove(rpath(fs_ct",0,2,6,0,0,0,1,0,1,1,1,0,0,1,1
12809,FFmpeg,1,"static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

				    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

				    uint8_t *dest, int dstW, int y)

{

	int i;

	switch(c->dstFormat)

	{

	case PIX_FMT_BGR32:

	case PIX_FMT_RGB32:

		YSCALE_YUV_2_RGBX_C(uint32_t)

			((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];

			((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];

		}

		break;

	case PIX_FMT_RGB24:

		YSCALE_YUV_2_RGBX_C(uint8_t)

			((uint8_t*)dest)[0]= r[Y1];

			((uint8_t*)dest)[1]= g[Y1];

			((uint8_t*)dest)[2]= b[Y1];

			((uint8_t*)dest)[3]= r[Y2];

			((uint8_t*)dest)[4]= g[Y2];

			((uint8_t*)dest)[5]= b[Y2];

			dest+=6;

		}
",0,0,0,0,1,0,1,1,1,1,1,1,1,1,1
12810,FFmpeg,1,"static int write_packet(AVFormatContext *s, AVPacket *pkt)
{
    int ret, did_split;
    if (s->output_ts_offset) {
        AVStream *st = s->streams[pkt->stream_index];
        int64_t offset = av_rescale_q(s->output_ts_offset, AV_TIME_BASE_Q, st->time_base);
        if (pkt->dts != AV_NOPTS_VALUE)
            pkt->dts += offset;
        if (pkt->pts != AV_NOPTS_VALUE)
            pkt->pts += offset;
    }
    if (s->avoid_negative_ts > 0) {
        AVStream *st = s->streams[pkt->stream_index];
        int64_t offset = st->mux_ts_offset;
        int64_t ts = s->internal->avoid_negative_ts_use_pts ? pkt->pts : pkt->dts;
        if (s->internal->offset == AV_NOPTS_VALUE && ts != AV_NOPTS_VALUE &&
            (ts < 0 || s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO)) {
            s->internal->offset = -ts;
            s->internal->offset_timebase = st->time_base;
        }
        if (s->internal->offset != AV_NOPTS_VALUE && !offset) {
            offset = st->mux_ts_offset =
                av_rescale_",0,0,6,0,0,0,0,0,1,1,0,1,1,1,1
12814,FFmpeg,1,"static void read_sgi_header(ByteIOContext *f, SGIInfo *info)
{
    info->magic = (unsigned short) get_be16(f);
    info->rle = get_byte(f);
    info->bytes_per_channel = get_byte(f);
    info->dimension = (unsigned short)get_be16(f);
    info->xsize = (unsigned short) get_be16(f);
    info->ysize = (unsigned short) get_be16(f);
    info->zsize = (unsigned short) get_be16(f);
#ifdef DEBUG
    printf(""sgi header fields:\n"");
    printf(""  magic: %d\n"", info->magic);
    printf(""    rle: %d\n"", info->rle);
    printf(""    bpc: %d\n"", info->bytes_per_channel);
    printf(""    dim: %d\n"", info->dimension);
    printf(""  xsize: %d\n"", info->xsize);
    printf(""  ysize: %d\n"", info->ysize);
    printf(""  zsize: %d\n"", info->zsize);
#endif
    return;
}",0,0,2,0,0,0,1,1,1,1,1,1,0,1,1
12828,qemu,1,"static void pc_init1(ram_addr_t ram_size, int vga_ram_size,

                     const char *boot_device, DisplayState *ds,

                     const char *kernel_filename, const char *kernel_cmdline,

                     const char *initrd_filename,

                     int pci_enabled, const char *cpu_model)

{

    char buf[1024];

    int ret, linux_boot, i;

    ram_addr_t ram_addr, vga_ram_addr, bios_offset, vga_bios_offset;

    ram_addr_t below_4g_mem_size, above_4g_mem_size = 0;

    int bios_size, isa_bios_size, vga_bios_size;

    PCIBus *pci_bus;

    int piix3_devfn = -1;

    CPUState *env;

    qemu_irq *cpu_irq;

    qemu_irq *i8259;

    int index;

    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    BlockDriverState *fd[MAX_FD];



    if (ram_size >= 0xe0000000 ) {

        above_4g_mem_size = ram_size - 0xe0000000;

        below_4g_mem_size = 0xe0000000;

    } else {

        below_4g_mem_size = ram_size;

    }



    linux_boot = (kernel_filename != NULL);



    /* init CP",0,0,1,0,0,0,0,0,0,1,1,1,1,1,1
12846,qemu,0,"static int slirp_hostfwd(SlirpState *s, const char *redir_str,

                         int legacy_format)

{

    struct in_addr host_addr = { .s_addr = INADDR_ANY };

    struct in_addr guest_addr = { .s_addr = 0 };

    int host_port, guest_port;

    const char *p;

    char buf[256];

    int is_udp;

    char *end;



    p = redir_str;

    if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {

        goto fail_syntax;

    }

    if (!strcmp(buf, ""tcp"") || buf[0] == '\0') {

        is_udp = 0;

    } else if (!strcmp(buf, ""udp"")) {

        is_udp = 1;

    } else {

        goto fail_syntax;

    }



    if (!legacy_format) {

        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {

            goto fail_syntax;

        }

        if (buf[0] != '\0' && !inet_aton(buf, &host_addr)) {

            goto fail_syntax;

        }

    }



    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {

        goto fail_syntax;

    }

    host_port = strtol(buf, &end, 0);

    if (*e",3,5,8,0,0,0,0,0,0,0,0,0,0,0,0
12853,qemu,0,"int kvm_arch_put_registers(CPUState *cs, int level)

{

    S390CPU *cpu = S390_CPU(cs);

    CPUS390XState *env = &cpu->env;

    struct kvm_sregs sregs;

    struct kvm_regs regs;

    struct kvm_fpu fpu;

    int r;

    int i;



    /* always save the PSW  and the GPRS*/

    cs->kvm_run->psw_addr = env->psw.addr;

    cs->kvm_run->psw_mask = env->psw.mask;



    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {

        for (i = 0; i < 16; i++) {

            cs->kvm_run->s.regs.gprs[i] = env->regs[i];

            cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_GPRS;

        }

    } else {

        for (i = 0; i < 16; i++) {

            regs.gprs[i] = env->regs[i];

        }

        r = kvm_vcpu_ioctl(cs, KVM_SET_REGS, &regs);

        if (r < 0) {

            return r;

        }

    }



    /* Floating point */

    for (i = 0; i < 16; i++) {

        fpu.fprs[i] = env->fregs[i].ll;

    }

    fpu.fpc = env->fpc;



    r = kvm_vcpu_ioctl(cs, KVM_SET_FPU, &fpu);

    if (r < 0) {
",3,0,3,0,0,0,1,1,0,1,1,1,0,0,0
12887,qemu,0,"static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,

                                    sPAPRDRConnectorType drc_type,

                                    uint32_t drc)

{

    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());

    struct hp_log_full *new_hp;

    struct rtas_error_log *hdr;

    struct rtas_event_log_v6 *v6hdr;

    struct rtas_event_log_v6_maina *maina;

    struct rtas_event_log_v6_mainb *mainb;

    struct rtas_event_log_v6_hp *hp;



    new_hp = g_malloc0(sizeof(struct hp_log_full));

    hdr = &new_hp->hdr;

    v6hdr = &new_hp->v6hdr;

    maina = &new_hp->maina;

    mainb = &new_hp->mainb;

    hp = &new_hp->hp;



    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6

                               | RTAS_LOG_SEVERITY_EVENT

                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED

                               | RTAS_LOG_OPTIONAL_PART_PRESENT

                               | RTAS_LOG_INITIATOR_HOTPLUG

                               | RTAS_",0,0,0,0,0,0,0,0,0,1,1,1,1,1,1
12894,qemu,0,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
",1,0,2,0,0,0,0,0,0,0,0,0,1,0,0
12916,qemu,1,"BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,

                                  QEMUIOVector *qiov, int nb_sectors,

                                  BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    if (!drv)

        return NULL;

    if (bs->read_only)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    if (bs->dirty_tracking) {

        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);

    }



    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,

                               cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->wr_ops ++;

    }



    return ret;

}
",0,0,5,0,0,0,0,0,0,1,0,0,0,0,1
12927,FFmpeg,0,"av_cold void ff_dct_init_x86(DCTContext *s)

{

    int cpu_flags = av_get_cpu_flags();



    if (EXTERNAL_SSE(cpu_flags))

        s->dct32 = ff_dct32_float_sse;

    if (EXTERNAL_SSE2(cpu_flags))

        s->dct32 = ff_dct32_float_sse2;

    if (EXTERNAL_AVX(cpu_flags))

        s->dct32 = ff_dct32_float_avx;

}
",0,0,3,0,0,0,0,0,0,0,1,1,1,0,1
12940,FFmpeg,1,"static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,

                             GetByteContext *gb)

{

    unsigned char rle_code;

    unsigned char extra_byte, odd_pixel;

    unsigned char stream_byte;

    unsigned int pixel_ptr = 0;

    int row_dec = pic->linesize[0];

    int row_ptr = (avctx->height - 1) * row_dec;

    int frame_size = row_dec * avctx->height;

    int i;



    while (row_ptr >= 0) {

        if (bytestream2_get_bytes_left(gb) <= 0) {

            av_log(avctx, AV_LOG_ERROR,

                   ""MS RLE: bytestream overrun, %d rows left\n"",

                   row_ptr);

            return AVERROR_INVALIDDATA;

        }

        rle_code = stream_byte = bytestream2_get_byteu(gb);

        if (rle_code == 0) {

            /* fetch the next byte to see how to handle escape code */

            stream_byte = bytestream2_get_byte(gb);

            if (stream_byte == 0) {

                /* line is done, goto the next one */

                row_ptr -= row_dec;

    ",0,0,3,0,0,1,0,0,0,0,0,0,1,1,0
12946,qemu,1,"void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)

{

    int i = 0;

    int x = 0;

    uint32_t l_64 = (l + 1) / 8;



    HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""\n"",

               __func__, l, dest, src);



#ifndef CONFIG_USER_ONLY

    if ((l > 32) &&

        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&

        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {

        if (dest == (src + 1)) {

            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));

            return;

        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {

            mvc_fast_memmove(env, l + 1, dest, src);

            return;

        }

    }

#else

    if (dest == (src + 1)) {

        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);

        return;

    } else {

        memmove(g2h(dest), g2h(src), l + 1);

        return;

    }

#endif



    /* handle the parts that fit into 8-byte loads/stores */

    if (de",0,0,7,0,0,0,0,0,0,1,1,1,1,1,1
12949,qemu,1,"static void test_properties(const char *path, bool recurse)

{

    char *child_path;

    QDict *response, *tuple;

    QList *list;

    QListEntry *entry;



    g_test_message(""Obtaining properties of %s"", path);

    response = qmp(""{ 'execute': 'qom-list',""

                   ""  'arguments': { 'path': %s } }"", path);

    g_assert(response);



    if (!recurse) {

        return;

    }



    g_assert(qdict_haskey(response, ""return""));

    list = qobject_to_qlist(qdict_get(response, ""return""));

    QLIST_FOREACH_ENTRY(list, entry) {

        tuple = qobject_to_qdict(qlist_entry_obj(entry));

        bool is_child = strstart(qdict_get_str(tuple, ""type""), ""child<"", NULL);

        bool is_link = strstart(qdict_get_str(tuple, ""type""), ""link<"", NULL);



        if (is_child || is_link) {

            child_path = g_strdup_printf(""%s/%s"",

                                         path, qdict_get_str(tuple, ""name""));

            test_properties(child_path, is_child);

            g_free(child_path);

 ",0,0,2,0,0,0,1,1,1,0,0,0,0,1,1
12951,FFmpeg,1,"static int thp_read_header(AVFormatContext *s,

                           AVFormatParameters *ap)

{

    ThpDemuxContext *thp = s->priv_data;

    AVStream *st;

    AVIOContext *pb = s->pb;

    int i;



    /* Read the file header.  */

                           avio_rb32(pb); /* Skip Magic.  */

    thp->version         = avio_rb32(pb);



                           avio_rb32(pb); /* Max buf size.  */

                           avio_rb32(pb); /* Max samples.  */



    thp->fps             = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX);

    thp->framecnt        = avio_rb32(pb);

    thp->first_framesz   = avio_rb32(pb);

                           avio_rb32(pb); /* Data size.  */



    thp->compoff         = avio_rb32(pb);

                           avio_rb32(pb); /* offsetDataOffset.  */

    thp->first_frame     = avio_rb32(pb);

    thp->last_frame      = avio_rb32(pb);



    thp->next_framesz    = thp->first_framesz;

    thp->next_frame      = thp->first_frame;



    /* Read the component st",0,0,0,0,0,0,1,1,1,0,1,1,0,0,1
12968,qemu,1,"static int rdma_add_block(RDMAContext *rdma, const char *block_name,

                         void *host_addr,

                         ram_addr_t block_offset, uint64_t length)

{

    RDMALocalBlocks *local = &rdma->local_ram_blocks;

    RDMALocalBlock *block;

    RDMALocalBlock *old = local->block;



    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));



    if (local->nb_blocks) {

        int x;



        if (rdma->blockmap) {

            for (x = 0; x < local->nb_blocks; x++) {

                g_hash_table_remove(rdma->blockmap,

                                    (void *)(uintptr_t)old[x].offset);

                g_hash_table_insert(rdma->blockmap,

                                    (void *)(uintptr_t)old[x].offset,

                                    &local->block[x]);

            }

        }

        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);

        g_free(old);

    }



    block = &local->block[local->nb_blocks];



    block->",1,0,2,0,0,0,0,0,0,0,1,0,1,1,1
12984,qemu,1,"process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)

{

    uint32_t txd_lower = le32_to_cpu(dp->lower.data);

    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);

    unsigned int split_size = txd_lower & 0xffff, bytes, sz, op;

    unsigned int msh = 0xfffff, hdr = 0;

    uint64_t addr;

    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;

    struct e1000_tx *tp = &s->tx;



    if (dtype == E1000_TXD_CMD_DEXT) {	// context descriptor

        op = le32_to_cpu(xp->cmd_and_length);

        tp->ipcss = xp->lower_setup.ip_fields.ipcss;

        tp->ipcso = xp->lower_setup.ip_fields.ipcso;

        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);

        tp->tucss = xp->upper_setup.tcp_fields.tucss;

        tp->tucso = xp->upper_setup.tcp_fields.tucso;

        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);

        tp->paylen = op & 0xfffff;

        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;

        tp->mss = le16_to_cpu(xp->tcp_seg_s",0,0,1,0,0,0,0,1,0,0,0,0,0,0,0
13001,qemu,0,"static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&vinput->vdev);



    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    /* force virtio-1.0 */

    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;

    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
13002,qemu,0,"static void test_visitor_out_string(TestOutputVisitorData *data,

                                    const void *unused)

{

    char *string = (char *) ""Q E M U"";

    Error *err = NULL;

    QObject *obj;



    visit_type_str(data->ov, &string, NULL, &err);

    g_assert(!err);



    obj = qmp_output_get_qobject(data->qov);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QSTRING);

    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);



    qobject_decref(obj);

}
",0,0,0,0,0,0,0,0,0,0,1,0,1,1,1
13012,qemu,0,"static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    pcms->vmport = value;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
13024,FFmpeg,1,"static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;

    MOVStreamContext *sc;

    int ret;



    st = avformat_new_stream(c->fc, NULL);

    if (!st) return AVERROR(ENOMEM);

    st->id = c->fc->nb_streams;

    sc = av_mallocz(sizeof(MOVStreamContext));

    if (!sc) return AVERROR(ENOMEM);



    st->priv_data = sc;

    st->codec->codec_type = AVMEDIA_TYPE_DATA;

    sc->ffindex = st->index;



    if ((ret = mov_read_default(c, pb, atom)) < 0)

        return ret;



    /* sanity checks */

    if (sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||

                            (!sc->sample_size && !sc->sample_count))) {

        av_log(c->fc, AV_LOG_ERROR, ""stream %d, missing mandatory atoms, broken header\n"",

               st->index);

        return 0;

    }



    fix_timescale(c, sc);



    avpriv_set_pts_info(st, 64, 1, sc->time_scale);



    mov_build_index(c, st);



    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {
",1,0,5,0,0,0,1,1,1,1,1,1,0,0,1
13031,qemu,1,"static int buffer_empty(Buffer *buffer)

{

    return buffer->offset == 0;

}
",0,0,0,0,0,0,0,1,1,0,1,0,0,0,0
13035,qemu,1,"static gboolean pty_chr_timer(gpointer opaque)

{

    struct CharDriverState *chr = opaque;

    PtyCharDriver *s = chr->opaque;



    if (s->connected) {

        goto out;

    }



    /* Next poll ... */

    pty_chr_update_read_handler(chr);



out:

    s->timer_tag = 0;

    return FALSE;

}
",0,1,1,0,0,0,0,0,0,1,1,0,0,0,0
13040,FFmpeg,1,"void h263_encode_init(MpegEncContext *s)

{

    static int done = 0;



    if (!done) {

        done = 1;



        init_uni_dc_tab();



        init_rl(&rl_inter);

        init_rl(&rl_intra);

        init_rl(&rl_intra_aic);

        

        init_uni_mpeg4_rl_tab(&rl_intra, uni_mpeg4_intra_rl_bits, uni_mpeg4_intra_rl_len);

        init_uni_mpeg4_rl_tab(&rl_inter, uni_mpeg4_inter_rl_bits, uni_mpeg4_inter_rl_len);



        init_uni_h263_rl_tab(&rl_intra_aic, NULL, uni_h263_intra_aic_rl_len);

        init_uni_h263_rl_tab(&rl_inter    , NULL, uni_h263_inter_rl_len);



        init_mv_penalty_and_fcode(s);

    }

    s->me.mv_penalty= mv_penalty; //FIXME exact table for msmpeg4 & h263p

    

    s->intra_ac_vlc_length     =s->inter_ac_vlc_length     = uni_h263_inter_rl_len;

    s->intra_ac_vlc_last_length=s->inter_ac_vlc_last_length= uni_h263_inter_rl_len + 128*64;

    if(s->h263_aic){

        s->intra_ac_vlc_length     = uni_h263_intra_aic_rl_len;

        s->intra_ac_vlc_last_length= uni_h263_",0,0,2,0,0,0,0,1,0,0,0,0,1,1,1
13050,qemu,0,"static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res,

                              BdrvCheckMode fix)

{

    BDRVQcow2State *s = bs->opaque;

    uint64_t *l2_table = qemu_blockalign(bs, s->cluster_size);

    int ret;

    uint64_t refcount;

    int i, j;



    for (i = 0; i < s->l1_size; i++) {

        uint64_t l1_entry = s->l1_table[i];

        uint64_t l2_offset = l1_entry & L1E_OFFSET_MASK;

        bool l2_dirty = false;



        if (!l2_offset) {

            continue;

        }



        ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,

                                 &refcount);

        if (ret < 0) {

            /* don't print message nor increment check_errors */

            continue;

        }

        if ((refcount == 1) != ((l1_entry & QCOW_OFLAG_COPIED) != 0)) {

            fprintf(stderr, ""%s OFLAG_COPIED L2 cluster: l1_index=%d ""

                    ""l1_entry=%"" PRIx64 "" refcount=%"" PRIu64 ""\n"",

                    fix & BDRV_FIX_ERRORS ? ""Repa",1,0,3,0,0,0,0,0,1,0,0,0,0,1,0
13051,qemu,0,"static void mainstone_common_init(MemoryRegion *address_space_mem,

                                  MachineState *machine,

                                  enum mainstone_model_e model, int arm_id)

{

    uint32_t sector_len = 256 * 1024;

    hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };

    PXA2xxState *mpu;

    DeviceState *mst_irq;

    DriveInfo *dinfo;

    int i;

    int be;

    MemoryRegion *rom = g_new(MemoryRegion, 1);

    const char *cpu_model = machine->cpu_model;



    if (!cpu_model)

        cpu_model = ""pxa270-c5"";



    /* Setup CPU & memory */

    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);

    memory_region_init_ram(rom, NULL, ""mainstone.rom"", MAINSTONE_ROM,

                           &error_abort);

    vmstate_register_ram_global(rom);

    memory_region_set_readonly(rom, true);

    memory_region_add_subregion(address_space_mem, 0, rom);



#ifdef TARGET_WORDS_BIGENDIAN

    be = 1;

#else

    be = 0;

#endif

    /* There ar",0,0,3,0,0,0,0,0,0,0,1,0,0,0,0
13068,FFmpeg,1,"static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,

			uint8_t *dst1, uint8_t *dst2,

			long width, long height,

			long srcStride1, long srcStride2,

			long dstStride1, long dstStride2)

{

    long y,x,w,h;

    w=width/2; h=height/2;

#ifdef HAVE_MMX

    asm volatile(

	PREFETCH"" %0\n\t""

	PREFETCH"" %1\n\t""

	::""m""(*(src1+srcStride1)),""m""(*(src2+srcStride2)):""memory"");

#endif

    for(y=0;y<h;y++){

	const uint8_t* s1=src1+srcStride1*(y>>1);

	uint8_t* d=dst1+dstStride1*y;

	x=0;

#ifdef HAVE_MMX

	for(;x<w-31;x+=32)

	{

	    asm volatile(

		PREFETCH"" 32%1\n\t""

	        ""movq	%1, %%mm0\n\t""

	        ""movq	8%1, %%mm2\n\t""

	        ""movq	16%1, %%mm4\n\t""

	        ""movq	24%1, %%mm6\n\t""

	        ""movq	%%mm0, %%mm1\n\t""

	        ""movq	%%mm2, %%mm3\n\t""

	        ""movq	%%mm4, %%mm5\n\t""

	        ""movq	%%mm6, %%mm7\n\t""

		""punpcklbw %%mm0, %%mm0\n\t""

		""punpckhbw %%mm1, %%mm1\n\t""

		""punpcklbw %%mm2, %%mm2\n\t""

		""punpckhbw %%mm3, %%mm3\n\t""

		""punpcklbw %%mm4, %%",2,0,3,0,0,0,1,1,1,1,1,1,1,0,0
13077,qemu,1,"static void puv3_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    CPUUniCore32State *env;

    UniCore32CPU *cpu;



    if (initrd_filename) {

        error_report(""Please use kernel built-in initramdisk"");

        exit(1);

    }



    if (!cpu_model) {

        cpu_model = ""UniCore-II"";

    }



    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));

    if (!cpu) {

        error_report(""Unable to find CPU definition"");

        exit(1);

    }

    env = &cpu->env;



    puv3_soc_init(env);

    puv3_board_init(env, ram_size);

    puv3_load_kernel(kernel_filename);

}
",0,0,3,0,0,0,1,1,1,1,1,1,1,1,1
13081,FFmpeg,0,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
",2,0,3,0,0,0,1,1,1,1,1,0,0,0,0
13097,qemu,1,"static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,

                                 uint64_t end_offset, void **p_feature_table,

                                 Error **errp)

{

    BDRVQcowState *s = bs->opaque;

    QCowExtension ext;

    uint64_t offset;

    int ret;



#ifdef DEBUG_EXT

    printf(""qcow2_read_extensions: start=%ld end=%ld\n"", start_offset, end_offset);

#endif

    offset = start_offset;

    while (offset < end_offset) {



#ifdef DEBUG_EXT

        /* Sanity check */

        if (offset > s->cluster_size)

            printf(""qcow2_read_extension: suspicious offset %lu\n"", offset);



        printf(""attempting to read extended header in offset %lu\n"", offset);

#endif



        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));

        if (ret < 0) {

            error_setg_errno(errp, -ret, ""qcow2_read_extension: ERROR: ""

                             ""pread fail from offset %"" PRIu64, offset);

            return 1;

        }

        be32_to_c",0,0,6,0,0,1,0,0,0,0,0,0,0,1,0
13100,FFmpeg,1,"inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth, const uint8_t *src1, const uint8_t *src2,

                                   int srcW, int xInc, const int16_t *hChrFilter,

                                   const int16_t *hChrFilterPos, int hChrFilterSize,

                                   uint8_t *formatConvBuffer,

                                   uint32_t *pal)

{



    src1 += c->chrSrcOffset;

    src2 += c->chrSrcOffset;



    if (c->chrToYV12) {

        c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);

        src1= formatConvBuffer;

        src2= formatConvBuffer+VOFW;

    }



    if (!c->hcscale_fast) {

        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);

        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);

    } else { // fast bilinear upscale / crap downscale

        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);

    }",5,0,2,0,0,0,0,0,0,0,0,0,1,1,0
13114,qemu,1,"void pl011_init(uint32_t base, qemu_irq irq,

                CharDriverState *chr)

{

    int iomemtype;

    pl011_state *s;



    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));

    iomemtype = cpu_register_io_memory(0, pl011_readfn,

                                       pl011_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->chr = chr;

    s->read_trigger = 1;

    s->ifl = 0x12;

    s->cr = 0x300;

    s->flags = 0x90;

    if (chr){ 

        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,

                              pl011_event, s);

    }

    /* ??? Save/restore.  */

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
13118,qemu,1,"static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)

{

    gen_read_xer(cpu_gpr[gprn]);

}
",0,0,0,0,0,0,1,1,0,1,0,1,1,1,1
13130,qemu,1,"static int cpu_load_old(QEMUFile *f, void *opaque, int version_id)

{

    PowerPCCPU *cpu = opaque;

    CPUPPCState *env = &cpu->env;

    unsigned int i, j;

    target_ulong sdr1;

    uint32_t fpscr;

    target_ulong xer;



    for (i = 0; i < 32; i++)

        qemu_get_betls(f, &env->gpr[i]);

#if !defined(TARGET_PPC64)

    for (i = 0; i < 32; i++)

        qemu_get_betls(f, &env->gprh[i]);

#endif

    qemu_get_betls(f, &env->lr);

    qemu_get_betls(f, &env->ctr);

    for (i = 0; i < 8; i++)

        qemu_get_be32s(f, &env->crf[i]);

    qemu_get_betls(f, &xer);

    cpu_write_xer(env, xer);

    qemu_get_betls(f, &env->reserve_addr);

    qemu_get_betls(f, &env->msr);

    for (i = 0; i < 4; i++)

        qemu_get_betls(f, &env->tgpr[i]);

    for (i = 0; i < 32; i++) {

        union {

            float64 d;

            uint64_t l;

        } u;

        u.l = qemu_get_be64(f);

        env->fpr[i] = u.d;

    }

    qemu_get_be32s(f, &fpscr);

    env->fpscr = fpscr;

    qemu_get_sbe32s(f, &",5,0,2,0,0,0,0,1,0,1,1,0,1,1,1
13136,qemu,1,"static void test_qemu_strtoul_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert(endptr == str);

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
13137,FFmpeg,0,"static void avc_luma_midv_qrt_4w_msa(const uint8_t *src, int32_t src_stride,

                                     uint8_t *dst, int32_t dst_stride,

                                     int32_t height, uint8_t ver_offset)

{

    uint32_t loop_cnt;

    v16i8 src0, src1, src2, src3, src4;

    v16i8 mask0, mask1, mask2;

    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;

    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;

    v8i16 dst0, dst1, dst2, dst3, dst4, dst5, dst6, dst7;



    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);

    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);

    src += (5 * src_stride);



    XORI_B5_128_SB(src0, src1, src2, src3, src4);



    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,

                                                          mask0, mask1, mask2);

    hz_out2 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,

                                                          mask0, mask1, mask2);



    PCKOD_D2_SH(hz_out0, hz",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
13140,qemu,1,"static void aml_free(gpointer data, gpointer user_data)

{

    Aml *var = data;

    build_free_array(var->buf);


}",0,0,0,0,0,0,0,1,1,1,1,1,0,0,0
13149,qemu,0,"static void virtio_scsi_handle_cmd(VirtIODevice *vdev, VirtQueue *vq)

{

    /* use non-QOM casts in the data path */

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;

    VirtIOSCSICommon *vs = &s->parent_obj;



    VirtIOSCSIReq *req;

    int n;



    while ((req = virtio_scsi_pop_req(s, vq))) {

        SCSIDevice *d;

        int out_size, in_size;

        if (req->elem.out_num < 1 || req->elem.in_num < 1) {

            virtio_scsi_bad_req();

        }



        out_size = req->elem.out_sg[0].iov_len;

        in_size = req->elem.in_sg[0].iov_len;

        if (out_size < sizeof(VirtIOSCSICmdReq) + vs->cdb_size ||

            in_size < sizeof(VirtIOSCSICmdResp) + vs->sense_size) {

            virtio_scsi_bad_req();

        }



        if (req->elem.out_num > 1 && req->elem.in_num > 1) {

            virtio_scsi_fail_cmd_req(req);

            continue;

        }



        d = virtio_scsi_device_find(s, req->req.cmd->lun);

        if (!d) {

            req->resp.cmd->response = VIRTIO_SCSI_S_BAD_TAR",0,0,4,0,0,1,1,1,0,1,1,1,0,1,1
13154,qemu,0,"CharDriverState *text_console_init(QemuOpts *opts)

{

    CharDriverState *chr;

    QemuConsole *s;

    unsigned width;

    unsigned height;



    chr = g_malloc0(sizeof(CharDriverState));



    width = qemu_opt_get_number(opts, ""width"", 0);

    if (width == 0)

        width = qemu_opt_get_number(opts, ""cols"", 0) * FONT_WIDTH;



    height = qemu_opt_get_number(opts, ""height"", 0);

    if (height == 0)

        height = qemu_opt_get_number(opts, ""rows"", 0) * FONT_HEIGHT;



    if (width == 0 || height == 0) {

        s = new_console(NULL, TEXT_CONSOLE);

    } else {

        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);

    }



    if (!s) {

        g_free(chr);

        return NULL;

    }



    s->chr = chr;

    s->g_width = width;

    s->g_height = height;

    chr->opaque = s;

    chr->chr_set_echo = text_console_set_echo;

    return chr;

}
",0,0,4,0,0,0,0,1,0,1,1,0,0,1,0
13155,qemu,0,"static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    EEPRO100State *s = opaque;



    switch (size) {

    case 1: return eepro100_read1(s, addr);

    case 2: return eepro100_read2(s, addr);

    case 4: return eepro100_read4(s, addr);

    default: abort();

    }

}
",0,0,0,0,1,0,1,1,1,1,1,1,1,1,0
13156,qemu,0,"bool vring_should_notify(VirtIODevice *vdev, Vring *vring)

{

    uint16_t old, new;

    bool v;

    /* Flush out used index updates. This is paired

     * with the barrier that the Guest executes when enabling

     * interrupts. */

    smp_mb();



    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&

        unlikely(!vring_more_avail(vdev, vring))) {

        return true;

    }



    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {

        return !(vring_get_avail_flags(vdev, vring) &

                 VRING_AVAIL_F_NO_INTERRUPT);

    }

    old = vring->signalled_used;

    v = vring->signalled_used_valid;

    new = vring->signalled_used = vring->last_used_idx;

    vring->signalled_used_valid = true;



    if (unlikely(!v)) {

        return true;

    }



    return vring_need_event(vring_used_event(&vring->vr), new, old);

}
",0,0,4,0,0,0,0,0,0,0,0,0,1,0,1
13163,FFmpeg,0,"static int amr_nb_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                               const AVFrame *frame, int *got_packet_ptr)

{

    AMRContext *s = avctx->priv_data;

    int written, ret;

    int16_t *flush_buf = NULL;

    const int16_t *samples = frame ? (const int16_t *)frame->data[0] : NULL;



    if (s->enc_bitrate != avctx->bit_rate) {

        s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);

        s->enc_bitrate = avctx->bit_rate;

    }



    if ((ret = ff_alloc_packet(avpkt, 32))) {

        av_log(avctx, AV_LOG_ERROR, ""Error getting output packet\n"");

        return ret;

    }



    if (frame) {

        if (frame->nb_samples < avctx->frame_size) {

            flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));

            if (!flush_buf)

                return AVERROR(ENOMEM);

            memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf));

            samples = flush_buf;

            if (frame->nb_samples < avctx->frame_siz",0,0,6,0,0,0,0,0,1,0,0,0,0,1,1
13172,qemu,0,"void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,

                          int is_asi, int size)

{

    CPUState *saved_env;

    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;

    qemu_log(""Unassigned "" TARGET_FMT_plx "" wr=%d exe=%d\n"",

             addr, is_write, is_exec);

    if (!(env->sregs[SR_MSR] & MSR_EE)) {

        return;

    }



    if (is_exec) {

        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    } else {

        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {

            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;

            helper_raise_exception(EXCP_HW_EXCP);

        }

    }

}
",0,0,5,0,0,0,0,0,0,0,0,0,1,0,1
13204,FFmpeg,1,"static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

             int srcSliceH, uint8_t* dst[], int dstStride[]){



	/* load a few things into local vars to make the code more readable? and faster */

	const int srcW= c->srcW;

	const int dstW= c->dstW;

	const int dstH= c->dstH;

	const int chrDstW= c->chrDstW;

	const int chrSrcW= c->chrSrcW;

	const int lumXInc= c->lumXInc;

	const int chrXInc= c->chrXInc;

	const int dstFormat= c->dstFormat;

	const int srcFormat= c->srcFormat;

	const int flags= c->flags;

	const int canMMX2BeUsed= c->canMMX2BeUsed;

	int16_t *vLumFilterPos= c->vLumFilterPos;

	int16_t *vChrFilterPos= c->vChrFilterPos;

	int16_t *hLumFilterPos= c->hLumFilterPos;

	int16_t *hChrFilterPos= c->hChrFilterPos;

	int16_t *vLumFilter= c->vLumFilter;

	int16_t *vChrFilter= c->vChrFilter;

	int16_t *hLumFilter= c->hLumFilter;

	int16_t *hChrFilter= c->hChrFilter;

	int32_t *lumMmxFilter= c->lumMmxFilter;

	int32_t *chrMmxFilter= c->chrMmxFilter;

	const int",0,0,0,0,0,0,1,1,1,1,0,0,1,0,0
13205,FFmpeg,1,"static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);

#else

    int i;

    for (i=0; i<width; i++) {

        int b= src[i*3+0];

        int g= src[i*3+1];

        int r= src[i*3+2];



        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);

    }

#endif /* COMPILE_TEMPLATE_MMX */

}
",1,0,2,0,0,0,0,1,0,1,0,0,0,0,0
13230,FFmpeg,1,"void FUNC(ff_simple_idct)(DCTELEM *block)

{

    int i;



    for (i = 0; i < 8; i++)

        FUNC(idctRowCondDC)(block + i*8);



    for (i = 0; i < 8; i++)

        FUNC(idctSparseCol)(block + i);

}
",2,0,0,0,0,0,1,1,1,1,1,1,0,1,1
13236,qemu,1,"static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)

{

    if (ohci->async_td &&

        ohci->usb_packet.owner != NULL &&

        ohci->usb_packet.owner->dev == dev) {

        usb_cancel_packet(&ohci->usb_packet);

        ohci->async_td = 0;

    }

}
",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
13268,FFmpeg,1,"static int av_encode(AVFormatContext **output_files,

                     int nb_output_files,

                     AVFormatContext **input_files,

                     int nb_input_files,

                     AVStreamMap *stream_maps, int nb_stream_maps)

{

    int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;

    AVFormatContext *is, *os;

    AVCodecContext *codec, *icodec;

    AVOutputStream *ost, **ost_table = NULL;

    AVInputStream *ist, **ist_table = NULL;

    AVInputFile *file_table;

    AVFormatContext *stream_no_data;

    int key;



    file_table= (AVInputFile*) av_mallocz(nb_input_files * sizeof(AVInputFile));

    if (!file_table)

        goto fail;



    /* input stream init */

    j = 0;

    for(i=0;i<nb_input_files;i++) {

        is = input_files[i];

        file_table[i].ist_index = j;

        file_table[i].nb_streams = is->nb_streams;

        j += is->nb_streams;

    }

    nb_istreams = j;



    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));

    i",1,1,1,0,0,0,0,1,0,1,0,0,0,0,0
13273,FFmpeg,1,"int avpriv_mpeg4audio_get_config(MPEG4AudioConfig *c, const uint8_t *buf,
                                 int bit_size, int sync_extension)
{
    GetBitContext gb;
    int specific_config_bitindex;
    init_get_bits(&gb, buf, bit_size);
    c->object_type = get_object_type(&gb);
    c->sample_rate = get_sample_rate(&gb, &c->sampling_index);
    c->chan_config = get_bits(&gb, 4);
    if (c->chan_config < FF_ARRAY_ELEMS(ff_mpeg4audio_channels))
        c->channels = ff_mpeg4audio_channels[c->chan_config];
    c->sbr = -1;
    c->ps  = -1;
    if (c->object_type == AOT_SBR || (c->object_type == AOT_PS &&
        // check for W6132 Annex YYYY draft MP3onMP4
        !(show_bits(&gb, 3) & 0x03 && !(show_bits(&gb, 9) & 0x3F)))) {
        if (c->object_type == AOT_PS)
            c->ps = 1;
        c->ext_object_type = AOT_SBR;
        c->sbr = 1;
        c->ext_sample_rate = get_sample_rate(&gb, &c->ext_sampling_index);
        c->object_type = get_object_type(&gb);
        if (c->object_type == AOT_ER_BSAC)
      ",0,0,5,0,0,0,0,0,1,1,0,1,0,0,0
13311,FFmpeg,1,"static av_always_inline void vc1_apply_p_h_loop_filter(VC1Context *v, int block_num)

{

    MpegEncContext *s  = &v->s;

    int mb_cbp         = v->cbp[s->mb_x - 1 - s->mb_stride],

        block_cbp      = mb_cbp      >> (block_num * 4), right_cbp,

        mb_is_intra    = v->is_intra[s->mb_x - 1 - s->mb_stride],

        block_is_intra = mb_is_intra >> (block_num * 4), right_is_intra;

    int idx, linesize  = block_num > 3 ? s->uvlinesize : s->linesize, ttblk;

    uint8_t *dst;



    if (block_num > 3) {

        dst = s->dest[block_num - 3] - 8 * linesize;

    } else {

        dst = s->dest[0] + (block_num & 1) * 8 + ((block_num & 2) * 4 - 16) * linesize - 8;

    }



    if (s->mb_x != s->mb_width || !(block_num & 5)) {

        int16_t (*mv)[2];



        if (block_num > 3) {

            right_cbp      = v->cbp[s->mb_x - s->mb_stride] >> (block_num * 4);

            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);

            mv             = &v->luma_mv[s->mb_x - s->",0,0,3,0,0,0,0,0,0,1,1,1,0,0,0
13316,FFmpeg,1,"static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)

{

    AVIOContext *pb = s->pb;

    int len;



    for(;;) {

        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);

        if (len != TS_PACKET_SIZE)

            return len < 0 ? len : AVERROR_EOF;

        /* check packet sync byte */

        if ((*data)[0] != 0x47) {

            /* find a new packet start */

            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);

            if (mpegts_resync(s) < 0)

                return AVERROR(EAGAIN);

            else

                continue;

        } else {

            break;

        }

    }

    return 0;

}
",1,0,3,0,0,0,0,0,0,0,0,1,0,0,1
13339,FFmpeg,0,"int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)

{

    char *tail;

    double srate = av_strtod(arg, &tail);

    if (*tail || srate < 1 || (int)srate != srate) {

        av_log(log_ctx, AV_LOG_ERROR, ""Invalid sample rate '%s'\n"", arg);

        return AVERROR(EINVAL);

    }

    *ret = srate;

    return 0;

}
",0,0,1,0,0,0,1,1,1,1,0,0,1,1,1
13347,qemu,1,"static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)

{

    int32_t op2;

    int32_t r1;

    uint32_t address;

    TCGv temp;



    r1 = MASK_OP_ABS_S1D(ctx->opcode);

    address = MASK_OP_ABS_OFF18(ctx->opcode);

    op2 = MASK_OP_ABS_OP2(ctx->opcode);



    temp = tcg_const_i32(EA_ABS_FORMAT(address));



    switch (op2) {

    case OPC2_32_ABS_ST_A:

        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);

        break;

    case OPC2_32_ABS_ST_D:

        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_DA:

        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);

        break;

    case OPC2_32_ABS_ST_W:

        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);

        break;



    }

    tcg_temp_free(temp);

}
",0,0,0,0,1,0,0,0,1,1,1,1,0,0,1
13357,qemu,0,"static void v9fs_readdir(void *opaque)

{

    int32_t fid;

    V9fsFidState *fidp;

    ssize_t retval = 0;

    size_t offset = 7;

    uint64_t initial_offset;

    int32_t count;

    uint32_t max_count;

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;



    pdu_unmarshal(pdu, offset, ""dqd"", &fid, &initial_offset, &max_count);



    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);



    fidp = get_fid(pdu, fid);

    if (fidp == NULL) {

        retval = -EINVAL;

        goto out_nofid;

    }

    if (!fidp->fs.dir) {

        retval = -EINVAL;

        goto out;

    }

    if (initial_offset == 0) {

        v9fs_co_rewinddir(pdu, fidp);

    } else {

        v9fs_co_seekdir(pdu, fidp, initial_offset);

    }

    count = v9fs_do_readdir(pdu, fidp, max_count);

    if (count < 0) {

        retval = count;

        goto out;

    }

    retval = offset;

    retval += pdu_marshal(pdu, offset, ""d"", count);

    retval += count;

    trace_v9fs_readdir_return(pdu->tag, ",0,3,4,0,0,0,0,0,0,1,0,1,0,0,0
13363,qemu,0,"uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)

{

    CPUState *cs = CPU(s390_env_get_cpu(env));

    uint32_t cc = 0;

    int old_exc = cs->exception_index;

    uint64_t asc = env->psw.mask & PSW_MASK_ASC;

    uint64_t ret;

    int flags;



    /* XXX incomplete - has more corner cases */

    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {

        program_interrupt(env, PGM_SPECIAL_OP, 2);

    }



    cs->exception_index = old_exc;

    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {

        cc = 3;

    }

    if (cs->exception_index == EXCP_PGM) {

        ret = env->int_pgm_code | 0x80000000;

    } else {

        ret |= addr & ~TARGET_PAGE_MASK;

    }

    cs->exception_index = old_exc;



    env->cc_op = cc;

    return ret;

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
13365,qemu,0,"static int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm,

                                  uint64_t new_shared_perm,

                                  BdrvChild *ignore_child, Error **errp)

{

    BdrvChild *c;

    uint64_t cumulative_perms = new_used_perm;

    uint64_t cumulative_shared_perms = new_shared_perm;



    /* There is no reason why anyone couldn't tolerate write_unchanged */

    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);



    QLIST_FOREACH(c, &bs->parents, next_parent) {

        if (c == ignore_child) {

            continue;

        }



        if ((new_used_perm & c->shared_perm) != new_used_perm) {

            char *user = bdrv_child_user_desc(c);

            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);

            error_setg(errp, ""Conflicts with use by %s as '%s', which does not ""

                             ""allow '%s' on %s"",

                       user, c->name, perm_names, bdrv_get_node_name(c->bs));

            g_",0,0,2,0,0,0,0,0,0,0,0,0,0,1,0
13366,qemu,0,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)

{

    QDict *qmp;



    qmp = qdict_new();



    if (!monitor_has_error(mon)) {

        /* success response */

        if (data) {

            assert(qobject_type(data) == QTYPE_QDICT);

            qobject_incref(data);

            qdict_put_obj(qmp, ""return"", data);

        } else {

            /* return an empty QDict by default */

            qdict_put(qmp, ""return"", qdict_new());

        }

    } else {

        /* error response */

        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));

        qdict_put(qmp, ""error"", mon->error->error);

        QINCREF(mon->error->error);

        QDECREF(mon->error);

        mon->error = NULL;

    }



    if (mon->mc->id) {

        qdict_put_obj(qmp, ""id"", mon->mc->id);

        mon->mc->id = NULL;

    }



    monitor_json_emitter(mon, QOBJECT(qmp));

    QDECREF(qmp);

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
13388,FFmpeg,0,"static inline int decode_vui_parameters(H264Context *h, SPS *sps)

{

    int aspect_ratio_info_present_flag;

    unsigned int aspect_ratio_idc;



    aspect_ratio_info_present_flag = get_bits1(&h->gb);



    if (aspect_ratio_info_present_flag) {

        aspect_ratio_idc = get_bits(&h->gb, 8);

        if (aspect_ratio_idc == EXTENDED_SAR) {

            sps->sar.num = get_bits(&h->gb, 16);

            sps->sar.den = get_bits(&h->gb, 16);

        } else if (aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)) {

            sps->sar = pixel_aspect[aspect_ratio_idc];

        } else {

            av_log(h->avctx, AV_LOG_ERROR, ""illegal aspect ratio\n"");

            return AVERROR_INVALIDDATA;

        }

    } else {

        sps->sar.num =

        sps->sar.den = 0;

    }



    if (get_bits1(&h->gb))      /* overscan_info_present_flag */

        get_bits1(&h->gb);      /* overscan_appropriate_flag */



    sps->video_signal_type_present_flag = get_bits1(&h->gb);

    if (sps->video_signal_type_present",0,0,5,0,0,0,0,0,0,1,0,1,1,1,1
13415,qemu,0,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
",0,0,3,0,0,0,0,0,0,1,1,1,1,0,1
13426,qemu,0,"static int usb_host_handle_control(USBDevice *dev, USBPacket *p,

               int request, int value, int index, int length, uint8_t *data)

{

    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);

    struct usbdevfs_urb *urb;

    AsyncURB *aurb;

    int ret;



    /*

     * Process certain standard device requests.

     * These are infrequent and are processed synchronously.

     */



    /* Note request is (bRequestType << 8) | bRequest */

    trace_usb_host_req_control(s->bus_num, s->addr, request, value, index);



    switch (request) {

    case DeviceOutRequest | USB_REQ_SET_ADDRESS:

        return usb_host_set_address(s, value);



    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:

        return usb_host_set_config(s, value & 0xff);



    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:

        return usb_host_set_interface(s, index, value);

    }



    /* The rest are asynchronous */



    if (length > sizeof(dev->data_buf)) {

        fprintf(stderr, ""husb: ctrl buffer",0,0,1,0,1,0,1,1,0,1,0,0,1,0,0
13429,FFmpeg,1,"static int dshow_read_header(AVFormatContext *avctx)

{

    struct dshow_ctx *ctx = avctx->priv_data;

    IGraphBuilder *graph = NULL;

    ICreateDevEnum *devenum = NULL;

    IMediaControl *control = NULL;

    IMediaEvent *media_event = NULL;

    HANDLE media_event_handle;

    HANDLE proc;

    int ret = AVERROR(EIO);

    int r;



    CoInitialize(0);



    if (!ctx->list_devices && !parse_device_name(avctx)) {

        av_log(avctx, AV_LOG_ERROR, ""Malformed dshow input string.\n"");

        goto error;

    }



    ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id

                                                : AV_CODEC_ID_RAWVIDEO;

    if (ctx->pixel_format != AV_PIX_FMT_NONE) {

        if (ctx->video_codec_id != AV_CODEC_ID_RAWVIDEO) {

            av_log(avctx, AV_LOG_ERROR, ""Pixel format may only be set when ""

                              ""video codec is not set or set to rawvideo\n"");

            ret = AVERROR(EINVAL);

            goto error;

        }

    }

    ",3,2,3,0,0,0,0,0,0,0,0,0,1,0,1
13437,qemu,1,"static inline void s390_machine_initfn(Object *obj)

{

    object_property_add_bool(obj, ""aes-key-wrap"",

                             machine_get_aes_key_wrap,

                             machine_set_aes_key_wrap, NULL);

    object_property_set_description(obj, ""aes-key-wrap"",

            ""enable/disable AES key wrapping using the CPACF wrapping key"",


    object_property_set_bool(obj, true, ""aes-key-wrap"", NULL);



    object_property_add_bool(obj, ""dea-key-wrap"",

                             machine_get_dea_key_wrap,

                             machine_set_dea_key_wrap, NULL);

    object_property_set_description(obj, ""dea-key-wrap"",

            ""enable/disable DEA key wrapping using the CPACF wrapping key"",


    object_property_set_bool(obj, true, ""dea-key-wrap"", NULL);

    object_property_add_str(obj, ""loadparm"",

            machine_get_loadparm, machine_set_loadparm, NULL);

    object_property_set_description(obj, ""loadparm"",

            ""Up to 8 chars in set of [A-Za-z0-9. ] (lower case",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0
13442,FFmpeg,0,"static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int predictor, int point_transform)

{

    int i, mb_x, mb_y;

    uint16_t (*buffer)[4];

    int left[4], top[4], topleft[4];

    const int linesize = s->linesize[0];

    const int mask     = ((1 << s->bits) - 1) << point_transform;

    int resync_mb_y = 0;

    int resync_mb_x = 0;



    if (s->nb_components != 3 && s->nb_components != 4)

        return AVERROR_INVALIDDATA;

    if (s->v_max != 1 || s->h_max != 1 || !s->lossless)

        return AVERROR_INVALIDDATA;





    s->restart_count = s->restart_interval;



    av_fast_malloc(&s->ljpeg_buffer, &s->ljpeg_buffer_size,

                   (unsigned)s->mb_width * 4 * sizeof(s->ljpeg_buffer[0][0]));

    buffer = s->ljpeg_buffer;



    for (i = 0; i < 4; i++)

        buffer[0][i] = 1 << (s->bits - 1);



    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {

        uint8_t *ptr = s->picture_ptr->data[0] + (linesize * mb_y);



        if (s->interlaced && s->bottom_field)
",4,0,3,0,0,0,1,1,1,1,0,0,1,1,1
13448,qemu,1,"static void qemu_spice_display_init_one(QemuConsole *con)

{

    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);



    qemu_spice_display_init_common(ssd);



    ssd->qxl.base.sif = &dpy_interface.base;

    qemu_spice_add_display_interface(&ssd->qxl, con);

    assert(ssd->worker);



    qemu_spice_create_host_memslot(ssd);



    ssd->dcl.ops = &display_listener_ops;

    ssd->dcl.con = con;

    register_displaychangelistener(&ssd->dcl);

}
",0,0,1,0,0,0,1,1,0,1,1,0,0,0,0
13462,FFmpeg,0,"int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,

                              int64_t wanted_timestamp, int flags)

{

    int a, b, m;

    int64_t timestamp;



    a = -1;

    b = nb_entries;



    // Optimize appending index entries at the end.

    if (b && entries[b - 1].timestamp < wanted_timestamp)

        a = b - 1;



    while (b - a > 1) {

        m         = (a + b) >> 1;



        // Search for the next non-discarded packet.

        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {

            m++;

            if (m == b && entries[m].timestamp >= wanted_timestamp) {

                m = b - 1;

                break;

            }

        }



        timestamp = entries[m].timestamp;

        if (timestamp >= wanted_timestamp)

            b = m;

        if (timestamp <= wanted_timestamp)

            a = m;

    }

    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;



    if (!(flags & AVSEEK_FLAG_ANY))

        while (m >= 0 && m < nb_entries &",0,0,5,0,0,3,1,1,1,1,1,0,0,0,0
13468,FFmpeg,1,"static int codec_get_buffer(AVCodecContext *s, AVFrame *frame)
{
    InputStream *ist = s->opaque;
    FrameBuffer *buf;
    int ret, i;
    if (!ist->buffer_pool && (ret = alloc_buffer(s, ist, &ist->buffer_pool)) < 0)
        return ret;
    buf              = ist->buffer_pool;
    ist->buffer_pool = buf->next;
    buf->next        = NULL;
    if (buf->w != s->width || buf->h != s->height || buf->pix_fmt != s->pix_fmt) {
        av_freep(&buf->base[0]);
        av_free(buf);
        ist->dr1 = 0;
        if ((ret = alloc_buffer(s, ist, &buf)) < 0)
            return ret;
    }
    buf->refcount++;
    frame->opaque        = buf;
    frame->type          = FF_BUFFER_TYPE_USER;
    frame->extended_data = frame->data;
    frame->pkt_pts       = s->pkt ? s->pkt->pts : AV_NOPTS_VALUE;
    for (i = 0; i < FF_ARRAY_ELEMS(buf->data); i++) {
        frame->base[i]     = buf->base[i];  // XXX h264.c uses base though it shouldn't
        frame->data[i]     = buf->data[i];
        frame->linesize[i] = buf->linesize[i];
",1,0,3,0,0,0,0,0,0,1,0,1,0,1,0
13488,FFmpeg,0,"static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)

{

    AVFilterContext   *ctx     = inlink->dst;

    HisteqContext     *histeq  = ctx->priv;

    AVFilterLink      *outlink = ctx->outputs[0];

    int strength  = histeq->strength  * 1000;

    int intensity = histeq->intensity * 1000;

    int x, y, i, luthi, lutlo, lut, luma, oluma, m;

    AVFrame *outpic;

    unsigned int r, g, b, jran;

    uint8_t *src, *dst;



    outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);

    if (!outpic) {

        av_frame_free(&inpic);

        return AVERROR(ENOMEM);

    }

    av_frame_copy_props(outpic, inpic);



    /* Seed random generator for antibanding. */

    jran = LCG_SEED;



    /* Calculate and store the luminance and calculate the global histogram

       based on the luminance. */

    memset(histeq->in_histogram, 0, sizeof(histeq->in_histogram));

    src = inpic->data[0];

    dst = outpic->data[0];

    for (y = 0; y < inlink->h; y++) {

        for (x = 0; x < inlink->w *",2,0,1,0,0,0,1,1,1,1,1,1,1,1,1
13494,qemu,0,"static void test_visitor_in_native_list_int32(TestInputVisitorData *data,

                                              const void *unused)

{

    test_native_list_integer_helper(data, unused,

                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);

}
",0,0,0,0,0,0,0,0,1,0,0,1,1,1,1
13504,qemu,0,"static void nbd_trip(void *opaque)

{

    NBDClient *client = opaque;

    NBDExport *exp = client->exp;

    NBDRequest *req;

    struct nbd_request request;

    struct nbd_reply reply;

    ssize_t ret;

    uint32_t command;



    TRACE(""Reading request."");

    if (client->closing) {

        return;

    }



    req = nbd_request_get(client);

    ret = nbd_co_receive_request(req, &request);

    if (ret == -EAGAIN) {

        goto done;

    }

    if (ret == -EIO) {

        goto out;

    }



    reply.handle = request.handle;

    reply.error = 0;



    if (ret < 0) {

        reply.error = -ret;

        goto error_reply;

    }

    command = request.type & NBD_CMD_MASK_COMMAND;

    if (command != NBD_CMD_DISC && (request.from + request.len) > exp->size) {

            LOG(""From: %"" PRIu64 "", Len: %u, Size: %"" PRIu64

            "", Offset: %"" PRIu64 ""\n"",

                    request.from, request.len,

                    (uint64_t)exp->size, (uint64_t)exp->dev_offset);

        LOG(""requ",0,3,5,0,0,0,0,0,0,0,0,0,1,1,1
13513,qemu,0,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)

{

    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));



    re->func = func;

    re->opaque = opaque;

    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,0,1
13517,qemu,0,"void stl_phys_notdirty(hwaddr addr, uint32_t val)

{

    uint8_t *ptr;

    MemoryRegionSection *section;



    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);



    if (!memory_region_is_ram(section->mr) || section->readonly) {

        addr = memory_region_section_addr(section, addr);

        if (memory_region_is_ram(section->mr)) {

            section = &phys_sections[phys_section_rom];

        }

        io_mem_write(section->mr, addr, val, 4);

    } else {

        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)

                               & TARGET_PAGE_MASK)

            + memory_region_section_addr(section, addr);

        ptr = qemu_get_ram_ptr(addr1);

        stl_p(ptr, val);



        if (unlikely(in_migration)) {

            if (!cpu_physical_memory_is_dirty(addr1)) {

                /* invalidate code */

                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);

                /* set dirty bit */

                cpu_phys",0,0,4,0,0,0,0,0,0,0,0,0,1,1,0
13524,FFmpeg,0,"static void compute_antialias_float(MPADecodeContext *s,

                              GranuleDef *g)

{

    float *ptr;

    int n, i;



    /* we antialias only ""long"" bands */

    if (g->block_type == 2) {

        if (!g->switch_point)

            return;

        /* XXX: check this for 8000Hz case */

        n = 1;

    } else {

        n = SBLIMIT - 1;

    }



    ptr = g->sb_hybrid + 18;

    for(i = n;i > 0;i--) {

        float tmp0, tmp1;

        float *csa = &csa_table_float[0][0];

#define FLOAT_AA(j)\

        tmp0= ptr[-1-j];\

        tmp1= ptr[   j];\

        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\

        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];



        FLOAT_AA(0)

        FLOAT_AA(1)

        FLOAT_AA(2)

        FLOAT_AA(3)

        FLOAT_AA(4)

        FLOAT_AA(5)

        FLOAT_AA(6)

        FLOAT_AA(7)



        ptr += 18;

    }

}
",1,0,2,0,1,0,0,0,0,0,0,0,0,0,0
13548,qemu,1,"PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)

{

    DeviceState *dev;

    PCIBus *b;

    PCIDevice *d;

    I440FXState *s;

    PIIX3State *piix3;



    dev = qdev_create(NULL, ""i440FX-pcihost"");

    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));

    b = pci_bus_new(&s->busdev.qdev, NULL, 0);

    s->bus = b;

    qdev_init_nofail(dev);



    d = pci_create_simple(b, 0, ""i440FX"");

    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);



    piix3 = DO_UPCAST(PIIX3State, dev,

                                 pci_create_simple(b, -1, ""PIIX3""));

    piix3->pic = pic;

    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);

    (*pi440fx_state)->piix3 = piix3;



    *piix3_devfn = piix3->dev.devfn;



    ram_size = ram_size / 8 / 1024 / 1024;

    if (ram_size > 255)

        ram_size = 255;

    (*pi440fx_state)->dev.config[0x57]=ram_size;



    return b;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
13554,qemu,1,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)

{

    return inline_cvttq(env, a, float_round_to_zero, 0);

}
",0,0,0,0,0,0,1,1,0,1,0,0,1,1,1
13555,FFmpeg,0,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
",0,0,8,0,0,0,1,1,1,0,1,1,1,1,0
13556,qemu,1,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
",0,0,0,0,0,0,1,1,1,1,1,0,1,0,1
13571,FFmpeg,0,"static int decode_init_mp3on4(AVCodecContext * avctx)

{

    MP3On4DecodeContext *s = avctx->priv_data;

    int i;



    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {

        av_log(avctx, AV_LOG_ERROR, ""Codec extradata missing or too short.\n"");

        return -1;

    }



    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;

    s->frames = mp3Frames[s->chan_cfg];

    if(!s->frames) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid channel config number.\n"");

        return -1;

    }

    avctx->channels = mp3Channels[s->chan_cfg];



    /* Init the first mp3 decoder in standard way, so that all tables get builded

     * We replace avctx->priv_data with the context of the first decoder so that

     * decode_init() does not have to be changed.

     * Other decoders will be inited here copying data from the first context

     */

    // Allocate zeroed memory for the first decoder context

    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));

    // Put",0,0,2,0,0,0,0,0,0,0,0,1,0,0,0
13589,qemu,0,"_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,

          const struct timespec *,tsp,int,flags)

#endif

#endif /* CONFIG_UTIMENSAT  */



#ifdef CONFIG_INOTIFY

#include <sys/inotify.h>



#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)

static int sys_inotify_init(void)

{

  return (inotify_init());

}
",0,0,9,0,0,0,1,1,0,1,0,0,0,0,0
13604,qemu,1,"static void curl_readv_bh_cb(void *p)

{

    CURLState *state;

    int running;



    CURLAIOCB *acb = p;

    BDRVCURLState *s = acb->common.bs->opaque;



    qemu_bh_delete(acb->bh);

    acb->bh = NULL;



    size_t start = acb->sector_num * SECTOR_SIZE;

    size_t end;



    // In case we have the requested data already (e.g. read-ahead),

    // we can just call the callback and be done.

    switch (curl_find_buf(s, start, acb->nb_sectors * SECTOR_SIZE, acb)) {

        case FIND_RET_OK:

            qemu_aio_release(acb);

            // fall through

        case FIND_RET_WAIT:

            return;

        default:

            break;

    }



    // No cache found, so let's start a new request

    state = curl_init_state(s);

    if (!state) {

        acb->common.cb(acb->common.opaque, -EIO);

        qemu_aio_release(acb);

        return;

    }



    acb->start = 0;

    acb->end = (acb->nb_sectors * SECTOR_SIZE);



    state->buf_off = 0;

    g_free(state->orig_buf);

    state->buf",0,0,1,0,1,0,1,0,1,1,0,1,0,0,0
13635,FFmpeg,1,"static int dnxhd_encode_rdo(AVCodecContext *avctx, DNXHDEncContext *ctx)

{

    int lambda, up_step, down_step;

    int last_lower = INT_MAX, last_higher = 0;

    int x, y, q;



    for (q = 1; q < avctx->qmax; q++) {

        ctx->qscale = q;

        avctx->execute2(avctx, dnxhd_calc_bits_thread, NULL, NULL, ctx->m.mb_height);

    }

    up_step = down_step = 2<<LAMBDA_FRAC_BITS;

    lambda = ctx->lambda;



    for (;;) {

        int bits = 0;

        int end = 0;

        if (lambda == last_higher) {

            lambda++;

            end = 1; // need to set final qscales/bits

        }

        for (y = 0; y < ctx->m.mb_height; y++) {

            for (x = 0; x < ctx->m.mb_width; x++) {

                unsigned min = UINT_MAX;

                int qscale = 1;

                int mb = y*ctx->m.mb_width+x;

                for (q = 1; q < avctx->qmax; q++) {

                    unsigned score = ctx->mb_rc[q][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS);

                    if (sc",5,0,2,0,0,0,0,0,0,1,0,0,1,1,1
13636,FFmpeg,1,"static int find_and_decode_index(NUTContext *nut)

{

    AVFormatContext *s = nut->avf;

    AVIOContext *bc    = s->pb;

    uint64_t tmp, end;

    int i, j, syncpoint_count;

    int64_t filesize = avio_size(bc);

    int64_t *syncpoints;

    int8_t *has_keyframe;

    int ret = AVERROR_INVALIDDATA;



    avio_seek(bc, filesize - 12, SEEK_SET);

    avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);

    if (avio_rb64(bc) != INDEX_STARTCODE) {

        av_log(s, AV_LOG_ERROR, ""no index at the end\n"");

        return ret;

    }



    end  = get_packetheader(nut, bc, 1, INDEX_STARTCODE);

    end += avio_tell(bc);



    ffio_read_varlen(bc); // max_pts

    GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0);

    syncpoints   = av_malloc(sizeof(int64_t) *  syncpoint_count);

    has_keyframe = av_malloc(sizeof(int8_t)  * (syncpoint_count + 1));

    if (!syncpoints || !has_keyframe)

        return AVERROR(ENOMEM);

    for (i = 0; i < syncpoint_count; i++) {

        syncpoints[i] = ffio_read_varle",1,0,2,0,0,0,0,0,0,1,1,0,1,1,1
13667,qemu,1,"static inline void menelaus_rtc_stop(struct menelaus_s *s)

{

    qemu_del_timer(s->rtc.hz);

    s->rtc.next =- qemu_get_clock(rt_clock);

    if (s->rtc.next < 1)

        s->rtc.next = 1;

}
",0,0,1,0,0,0,1,1,1,1,1,1,1,0,0
13672,qemu,1,"int drive_init(struct drive_opt *arg, int snapshot, void *opaque)

{

    char buf[128];

    char file[1024];

    char devname[128];

    char serial[21];

    const char *mediastr = """";

    BlockInterfaceType type;

    enum { MEDIA_DISK, MEDIA_CDROM } media;

    int bus_id, unit_id;

    int cyls, heads, secs, translation;

    BlockDriverState *bdrv;

    BlockDriver *drv = NULL;

    QEMUMachine *machine = opaque;

    int max_devs;

    int index;

    int cache;

    int bdrv_flags, onerror;

    int drives_table_idx;

    char *str = arg->opt;

    static const char * const params[] = { ""bus"", ""unit"", ""if"", ""index"",

                                           ""cyls"", ""heads"", ""secs"", ""trans"",

                                           ""media"", ""snapshot"", ""file"",

                                           ""cache"", ""format"", ""serial"", ""werror"",

                                           NULL };



    if (check_params(params, str) < 0) {

         fprintf(stderr, ""qemu: unknown parameter '%s' in ",1,0,2,0,0,0,0,0,0,1,1,1,1,1,1
13706,qemu,1,"static void gic_complete_irq(gic_state * s, int cpu, int irq)

{

    int update = 0;

    int cm = 1 << cpu;

    DPRINTF(""EOI %d\n"", irq);

    if (s->running_irq[cpu] == 1023)

        return; /* No active IRQ.  */

    if (irq != 1023) {

        /* Mark level triggered interrupts as pending if they are still

           raised.  */

        if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)

                && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {

            DPRINTF(""Set %d pending mask %x\n"", irq, cm);

            GIC_SET_PENDING(irq, cm);

            update = 1;

        }

    }

    if (irq != s->running_irq[cpu]) {

        /* Complete an IRQ that is not currently running.  */

        int tmp = s->running_irq[cpu];

        while (s->last_active[tmp][cpu] != 1023) {

            if (s->last_active[tmp][cpu] == irq) {

                s->last_active[tmp][cpu] = s->last_active[irq][cpu];

                break;

            }

            tmp = s->last_active[tmp][cpu];

",0,0,6,0,0,1,0,1,1,1,0,0,1,1,1
13712,FFmpeg,0,"static void init_dequant8_coeff_table(H264Context *h){

    int i,q,x;

    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly

    h->dequant8_coeff[0] = h->dequant8_buffer[0];

    h->dequant8_coeff[1] = h->dequant8_buffer[1];



    for(i=0; i<2; i++ ){

        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){

            h->dequant8_coeff[1] = h->dequant8_buffer[0];

            break;

        }



        for(q=0; q<52; q++){

            int shift = div6[q];

            int idx = rem6[q];

            for(x=0; x<64; x++)

                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =

                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *

                    h->pps.scaling_matrix8[i][x]) << shift;

        }

    }

}
",3,0,3,0,0,0,0,0,0,1,0,0,1,0,0
13726,qemu,1,"char *vnc_display_local_addr(const char *id)

{

    VncDisplay *vs = vnc_display_find(id);




    return vnc_socket_local_addr(""%s:%s"", vs->lsock);

}",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
13728,qemu,1,"PPC_OP(set_T0)

{

    T0 = PARAM(1);

    RETURN();

}
",0,0,0,0,0,0,1,1,0,1,1,1,0,1,0
13734,qemu,1,"static void test_validate_fail_struct_nested(TestInputVisitorData *data,

                                              const void *unused)

{

    UserDefTwo *udp = NULL;

    Error *err = NULL;

    Visitor *v;



    v = validate_test_init(data, ""{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}"");



    visit_type_UserDefTwo(v, NULL, &udp, &err);

    error_free_or_abort(&err);

    qapi_free_UserDefTwo(udp);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
13736,qemu,1,"static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)

{

    QEMUFileSocket *s = opaque;

    ssize_t len;



    do {

        len = qemu_recv(s->fd, buf, size, 0);

    } while (len == -1 && socket_error() == EINTR);



    if (len == -1)

        len = -socket_error();



    return len;

}
",0,0,1,0,0,1,1,1,1,0,0,0,0,0,0
13739,qemu,1,"static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,

                                  size_t *count)

{

    GIOStatus status;

    OVERLAPPED ov = {0};

    BOOL ret;

    DWORD written;



    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    ret = WriteFile(c->handle, buf, size, &written, &ov);

    if (!ret) {

        if (GetLastError() == ERROR_IO_PENDING) {

            /* write is pending */

            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);

            if (!ret) {

                if (!GetLastError()) {

                    status = G_IO_STATUS_AGAIN;

                } else {

                    status = G_IO_STATUS_ERROR;


            } else {

                /* write is complete */

                status = G_IO_STATUS_NORMAL;

                *count = written;


        } else {

            status = G_IO_STATUS_ERROR;


    } else {

        /* write returned immediately */

        status = G_IO_STATUS_NORMAL;

        *count = written;
",0,0,4,0,0,0,1,1,1,0,0,0,1,1,1
13740,FFmpeg,1,"int ff_jni_exception_get_summary(JNIEnv *env, jthrowable exception, char **error, void *log_ctx)

{

    int ret = 0;



    AVBPrint bp;



    char *name = NULL;

    char *message = NULL;



    jclass class_class = NULL;

    jmethodID get_name_id = NULL;



    jclass exception_class = NULL;

    jmethodID get_message_id = NULL;



    jstring string;



    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);



    exception_class = (*env)->GetObjectClass(env, exception);

    if ((*env)->ExceptionCheck(env)) {

        (*env)->ExceptionClear(env);

        av_log(log_ctx, AV_LOG_ERROR, ""Could not find Throwable class\n"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    class_class = (*env)->GetObjectClass(env, exception_class);

    if ((*env)->ExceptionCheck(env)) {

        (*env)->ExceptionClear(env);

        av_log(log_ctx, AV_LOG_ERROR, ""Could not find Throwable class's class\n"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    get_name_id = (*env)->GetMethodID",0,2,2,0,0,0,1,0,0,1,1,1,0,0,0
13748,qemu,1,"static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag,

                                   uint32_t arg)

{

    VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent);

    vscsi_req *req = vscsi_find_req(s, tag);

    SCSIDevice *sdev;

    uint8_t *buf;

    int32_t res_in = 0, res_out = 0;

    int len, rc = 0;



    dprintf(""VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\n"",

            reason, tag, arg, req);

    if (req == NULL) {

        fprintf(stderr, ""VSCSI: Can't find request for tag 0x%x\n"", tag);

        return;

    }

    sdev = req->sdev;



    if (req->sensing) {

        if (reason == SCSI_REASON_DONE) {

            dprintf(""VSCSI: Sense done !\n"");

            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);

            vscsi_put_req(s, req);

        } else {

            uint8_t *buf = sdev->info->get_buf(sdev, tag);



            len = MIN(arg, SCSI_SENSE_BUF_SIZE);

            dprintf(""VSCSI: Sense data, %d bytes:\n"", len);

        ",1,0,3,0,0,0,0,0,0,1,1,1,1,1,1
13754,qemu,0,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,1,1
13768,qemu,0,"static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,

                                  unsigned size, bool is_write)

{

    return (size == 1) || (is_write && size == 2);

}
",0,0,0,0,0,0,0,1,0,0,0,0,0,1,0
13772,qemu,0,"sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,

                                   uint64_t bus_offset,

                                   uint32_t page_shift,

                                   uint32_t nb_table,

                                   bool vfio_accel)

{

    sPAPRTCETable *tcet;

    char tmp[64];



    if (spapr_tce_find_by_liobn(liobn)) {

        fprintf(stderr, ""Attempted to create TCE table with duplicate""

                "" LIOBN 0x%x\n"", liobn);

        return NULL;

    }



    if (!nb_table) {

        return NULL;

    }



    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));

    tcet->liobn = liobn;

    tcet->bus_offset = bus_offset;

    tcet->page_shift = page_shift;

    tcet->nb_table = nb_table;

    tcet->vfio_accel = vfio_accel;



    snprintf(tmp, sizeof(tmp), ""tce-table-%x"", liobn);

    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);



    object_property_set_bool(OBJECT(tcet), true, ""realized"", NULL);



    ret",0,0,5,0,0,0,0,0,0,0,0,0,0,0,1
13784,qemu,1,"static void debug_print_fis(uint8_t *fis, int cmd_len)

{

#ifdef DEBUG_AHCI

    int i;



    fprintf(stderr, ""fis:"");

    for (i = 0; i < cmd_len; i++) {

        if ((i & 0xf) == 0) {

            fprintf(stderr, ""\n%02x:"",i);

        }

        fprintf(stderr, ""%02x "",fis[i]);

    }

    fprintf(stderr, ""\n"");

#endif

}
",1,0,3,0,0,0,1,1,1,0,1,0,1,1,1
13809,FFmpeg,0,"static av_cold int svc_encode_init(AVCodecContext *avctx)

{

    SVCContext *s = avctx->priv_data;

    SEncParamExt param = { 0 };

    int err = AVERROR_UNKNOWN;

    int log_level;

    WelsTraceCallback callback_function;

    AVCPBProperties *props;



    // Mingw GCC < 4.7 on x86_32 uses an incorrect/buggy ABI for the WelsGetCodecVersion

    // function (for functions returning larger structs), thus skip the check in those

    // configurations.

#if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7)

    OpenH264Version libver = WelsGetCodecVersion();

    if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) {

        av_log(avctx, AV_LOG_ERROR, ""Incorrect library version loaded\n"");

        return AVERROR(EINVAL);

    }

#endif



    if (WelsCreateSVCEncoder(&s->encoder)) {

        av_log(avctx, AV_LOG_ERROR, ""Unable to create encoder\n"");

        return AVERROR_UNKNOWN;

    }



    // Pass all libopenh264 messages to our callback, to allow ourselves",0,0,4,0,0,0,0,0,0,0,0,0,1,0,0
13829,qemu,0,"static void sm501_disp_ctrl_write(void *opaque, hwaddr addr,

                                  uint64_t value, unsigned size)

{

    SM501State *s = (SM501State *)opaque;

    SM501_DPRINTF(""sm501 disp ctrl regs : write addr=%x, val=%x\n"",

                  (unsigned)addr, (unsigned)value);



    switch (addr) {

    case SM501_DC_PANEL_CONTROL:

        s->dc_panel_control = value & 0x0FFF73FF;

        break;

    case SM501_DC_PANEL_PANNING_CONTROL:

        s->dc_panel_panning_control = value & 0xFF3FFF3F;

        break;

    case SM501_DC_PANEL_FB_ADDR:

        s->dc_panel_fb_addr = value & 0x8FFFFFF0;

        break;

    case SM501_DC_PANEL_FB_OFFSET:

        s->dc_panel_fb_offset = value & 0x3FF03FF0;

        break;

    case SM501_DC_PANEL_FB_WIDTH:

        s->dc_panel_fb_width = value & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_FB_HEIGHT:

        s->dc_panel_fb_height = value & 0x0FFF0FFF;

        break;

    case SM501_DC_PANEL_TL_LOC:

        s->dc_panel_tl_location = value ",0,0,0,0,1,0,1,1,0,1,1,0,1,1,1
13855,FFmpeg,0,"void rgb15to16(const uint8_t *src,uint8_t *dst,uint32_t src_size)

{

#ifdef HAVE_MMX

  register const char* s=src+src_size;

  register char* d=dst+src_size;

  register int offs=-src_size;

  __asm __volatile(PREFETCH""	%0""::""m""(*(s+offs)):""memory"");

  __asm __volatile(

	""movq	%0, %%mm4\n\t""

	""movq	%1, %%mm5""

	::""m""(mask15b), ""m""(mask15rg):""memory"");

  while(offs<0)

  {

	__asm __volatile(

		PREFETCH""	32%1\n\t""

		""movq	%1, %%mm0\n\t""

		""movq	8%1, %%mm2\n\t""

		""movq	%%mm0, %%mm1\n\t""

		""movq	%%mm2, %%mm3\n\t""

		""pand	%%mm4, %%mm0\n\t""

		""pand	%%mm5, %%mm1\n\t""

		""pand	%%mm4, %%mm2\n\t""

		""pand	%%mm5, %%mm3\n\t""

		""psllq	$1, %%mm1\n\t""

		""psllq	$1, %%mm3\n\t""

		""por	%%mm1, %%mm0\n\t""

		""por	%%mm3, %%mm2\n\t""

		MOVNTQ""	%%mm0, %0\n\t""

		MOVNTQ""	%%mm2, 8%0""

		:""=m""(*(d+offs))

		:""m""(*(s+offs))

		:""memory"");

	offs+=16;

  }

  __asm __volatile(SFENCE:::""memory"");

  __asm __volatile(EMMS:::""memory"");

#else

   const uint16_t *s1=( uint16_t * )src;

   uint16_t *d1=( uint16_t * )dst;

   ",0,0,1,0,0,1,1,1,1,1,1,1,0,0,0
13859,FFmpeg,1,"static int rle_unpack(const unsigned char *src, unsigned char *dest,

    int src_len, int dest_len)

{

    const unsigned char *ps;

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;



    ps = src;

    pd = dest;

    if (src_len & 1)

        *pd++ = *ps++;



    src_len >>= 1;

    i = 0;

    do {

        l = *ps++;

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end)

                return ps - src;

            memcpy(pd, ps, l);

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end)

                return ps - src;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }

            ps += 2;

        }

        i += l;

    } while (i < src_len);



    return ps - src;

}
",1,0,4,0,0,1,0,0,0,0,0,0,0,0,0
13867,FFmpeg,0,"void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,

                                           src - (stride * 2) +

                                           sizeof(uint8_t), stride,

                                           dst, stride);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
13888,FFmpeg,1,"static int vorbis_parse(AVCodecParserContext *s1, AVCodecContext *avctx,

                        const uint8_t **poutbuf, int *poutbuf_size,

                        const uint8_t *buf, int buf_size)

{

    VorbisParseContext *s = s1->priv_data;

    int duration;



    if (!s->vp && avctx->extradata && avctx->extradata_size) {

        s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);

        if (!s->vp)

            goto end;

    }



    if ((duration = av_vorbis_parse_frame(s->vp, buf, buf_size)) >= 0)

        s1->duration = duration;



end:

    /* always return the full packet. this parser isn't doing any splitting or

       combining, only packet analysis */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
",0,1,3,0,0,0,0,0,0,1,1,0,0,0,0
13890,qemu,1,"static void xen_ram_init(PCMachineState *pcms,

                         ram_addr_t ram_size, MemoryRegion **ram_memory_p)

{

    MemoryRegion *sysmem = get_system_memory();

    ram_addr_t block_len;

    uint64_t user_lowmem = object_property_get_int(qdev_get_machine(),

                                                   PC_MACHINE_MAX_RAM_BELOW_4G,

                                                   &error_abort);



    /* Handle the machine opt max-ram-below-4g.  It is basically doing

     * min(xen limit, user limit).

     */

    if (HVM_BELOW_4G_RAM_END <= user_lowmem) {

        user_lowmem = HVM_BELOW_4G_RAM_END;

    }



    if (ram_size >= user_lowmem) {

        pcms->above_4g_mem_size = ram_size - user_lowmem;

        pcms->below_4g_mem_size = user_lowmem;

    } else {

        pcms->above_4g_mem_size = 0;

        pcms->below_4g_mem_size = ram_size;

    }

    if (!pcms->above_4g_mem_size) {

        block_len = ram_size;

    } else {

        /*

         * Xen does not allocate the me",0,0,3,0,0,0,1,1,1,1,1,1,0,0,0
13897,qemu,1,"static void pci_spapr_set_irq(void *opaque, int irq_num, int level)

{

    /*

     * Here we use the number returned by pci_spapr_map_irq to find a

     * corresponding qemu_irq.

     */

    sPAPRPHBState *phb = opaque;



    trace_spapr_pci_lsi_set(phb->busname, irq_num, phb->lsi_table[irq_num].irq);

    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);

}
",0,0,0,0,0,0,0,1,1,0,1,0,1,1,1
13899,FFmpeg,1,"static int alloc_sequence_buffers(DiracContext *s)

{

    int sbwidth  = DIVRNDUP(s->source.width,  4);

    int sbheight = DIVRNDUP(s->source.height, 4);

    int i, w, h, top_padding;



    /* todo: think more about this / use or set Plane here */

    for (i = 0; i < 3; i++) {

        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);

        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);

        w = s->source.width  >> (i ? s->chroma_x_shift : 0);

        h = s->source.height >> (i ? s->chroma_y_shift : 0);



        /* we allocate the max we support here since num decompositions can

         * change from frame to frame. Stride is aligned to 16 for SIMD, and

         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding

         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that

         * on each side */

        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);

        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Shoul",3,0,5,0,0,0,0,1,1,0,1,0,1,1,1
13905,FFmpeg,1,"static int hevc_handle_packet(AVFormatContext *ctx, PayloadContext *rtp_hevc_ctx,

                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,

                              const uint8_t *buf, int len, uint16_t seq,

                              int flags)

{

    const uint8_t *rtp_pl = buf;

    int tid, lid, nal_type;

    int first_fragment, last_fragment, fu_type;

    uint8_t new_nal_header[2];

    int res = 0;



    /* sanity check for size of input packet: 1 byte payload at least */

    if (len < RTP_HEVC_PAYLOAD_HEADER_SIZE + 1) {

        av_log(ctx, AV_LOG_ERROR, ""Too short RTP/HEVC packet, got %d bytes\n"", len);

        return AVERROR_INVALIDDATA;

    }



    /*

     * decode the HEVC payload header according to section 4 of draft version 6:

     *

     *    0                   1

     *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5

     *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

     *   |F|   Type    |  LayerId  | TID |

     *   +-------------+-----------------+

     *

     *",0,0,1,0,0,0,1,1,1,1,1,1,0,0,0
13906,FFmpeg,1,"int avpriv_lock_avformat(void)

{

    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))

            return -1;

    }

    return 0;

}
",2,0,2,0,0,0,0,0,0,0,1,0,1,1,1
13915,FFmpeg,1,"static int libschroedinger_encode_close(AVCodecContext *avctx)

{

    SchroEncoderParams *p_schro_params = avctx->priv_data;



    /* Close the encoder. */

    schro_encoder_free(p_schro_params->encoder);



    /* Free data in the output frame queue. */

    ff_schro_queue_free(&p_schro_params->enc_frame_queue,

                        libschroedinger_free_frame);





    /* Free the encoder buffer. */

    if (p_schro_params->enc_buf_size)

        av_freep(&p_schro_params->enc_buf);



    /* Free the video format structure. */

    av_freep(&p_schro_params->format);



    return 0;

}
",1,0,1,0,0,0,0,0,1,1,0,1,1,1,1
13943,FFmpeg,0,"static int cinepak_decode_frame(AVCodecContext *avctx,

                                void *data, int *got_frame,

                                AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int ret = 0, buf_size = avpkt->size;

    CinepakContext *s = avctx->priv_data;



    s->data = buf;

    s->size = buf_size;



    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)

        return ret;



    if (s->palette_video) {

        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);

        if (pal) {

            s->frame->palette_has_changed = 1;

            memcpy(s->pal, pal, AVPALETTE_SIZE);

        }

    }



    if ((ret = cinepak_decode(s)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""cinepak_decode failed\n"");

    }



    if (s->palette_video)

        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);



    if ((ret = av_frame_ref(data, s->frame)) < 0)

        return ret;



    *got_frame = 1;



    /* report that the buffer was completely",0,0,6,0,0,0,0,1,1,1,1,1,0,1,0
13951,qemu,0,"static void taihu_405ep_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *kernel_filename = machine->kernel_filename;

    const char *initrd_filename = machine->initrd_filename;

    char *filename;

    qemu_irq *pic;

    MemoryRegion *sysmem = get_system_memory();

    MemoryRegion *bios;

    MemoryRegion *ram_memories = g_malloc(2 * sizeof(*ram_memories));

    MemoryRegion *ram = g_malloc0(sizeof(*ram));

    hwaddr ram_bases[2], ram_sizes[2];

    long bios_size;

    target_ulong kernel_base, initrd_base;

    long kernel_size, initrd_size;

    int linux_boot;

    int fl_idx, fl_sectors;

    DriveInfo *dinfo;



    /* RAM is soldered to the board so the size cannot be changed */

    ram_size = 0x08000000;

    memory_region_allocate_system_memory(ram, NULL, ""taihu_405ep.ram"",

                                         ram_size);



    ram_bases[0] = 0;

    ram_sizes[0] = 0x04000000;

    memory_region_init_alias(&ram_memories[0], NULL,

              ",0,0,0,0,0,0,1,0,1,0,0,0,0,0,0
13969,FFmpeg,1,"static void *ff_avio_child_next(void *obj, void *prev)

{

    AVIOContext *s = obj;

    AVIOInternal *internal = s->opaque;

    return prev ? NULL : internal->h;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
13988,qemu,1,"static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,

                            uint64_t *data)

{

    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);

    uint32_t val;



    switch(addr) {

    case 0x00:

        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);

        break;

    case 0x02:

        val = s->ar.pm1.evt.en;

        break;

    case 0x04:

        val = s->ar.pm1.cnt.cnt;

        break;

    case 0x08:

        val = acpi_pm_tmr_get(&s->ar);

        break;

    default:

        val = 0;

        break;

    }

    PIIX4_DPRINTF(""PM readw port=0x%04x val=0x%04x\n"", (unsigned int)addr, val);

    *data = val;

}
",0,0,0,0,1,0,1,0,1,0,1,1,1,1,1
14014,FFmpeg,1,"static int update_dimensions(VP8Context *s, int width, int height)

{

    if (width  != s->avctx->width ||

        height != s->avctx->height) {

        if (av_image_check_size(width, height, 0, s->avctx))

            return AVERROR_INVALIDDATA;



        vp8_decode_flush_impl(s->avctx, 1, 0, 1);



        avcodec_set_dimensions(s->avctx, width, height);

    }



    s->mb_width  = (s->avctx->coded_width +15) / 16;

    s->mb_height = (s->avctx->coded_height+15) / 16;



    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));

    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));

    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);

    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));

    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));



    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||

        !s->top_nnz || !s->top_border)",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
14022,qemu,1,"int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp)

{

    int ret;

    const char *type;



    ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp);

    if (ret <= 0) {

        return ret;

    }



    be32_to_cpus(&reply->magic);



    switch (reply->magic) {

    case NBD_SIMPLE_REPLY_MAGIC:

        ret = nbd_receive_simple_reply(ioc, &reply->simple, errp);

        if (ret < 0) {

            break;

        }



        trace_nbd_receive_simple_reply(reply->simple.error,

                                       nbd_err_lookup(reply->simple.error),

                                       reply->handle);

        if (reply->simple.error == NBD_ESHUTDOWN) {

            /* This works even on mingw which lacks a native ESHUTDOWN */

            error_setg(errp, ""server shutting down"");

            return -EINVAL;

        }

        break;

    case NBD_STRUCTURED_REPLY_MAGIC:

        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);

        if",0,0,4,0,1,0,0,0,1,1,0,0,0,0,0
14023,qemu,1,"static void ne2000_receive(void *opaque, const uint8_t *buf, int size)

{

    NE2000State *s = opaque;

    uint8_t *p;

    int total_len, next, avail, len, index, mcast_idx;

    uint8_t buf1[60];

    static const uint8_t broadcast_macaddr[6] = 

        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

    

#if defined(DEBUG_NE2000)

    printf(""NE2000: received len=%d\n"", size);

#endif



    if (!ne2000_can_receive(s))

        return;

    

    /* XXX: check this */

    if (s->rxcr & 0x10) {

        /* promiscuous: receive all */

    } else {

        if (!memcmp(buf,  broadcast_macaddr, 6)) {

            /* broadcast address */

            if (!(s->rxcr & 0x04))

                return;

        } else if (buf[0] & 0x01) {

            /* multicast */

            if (!(s->rxcr & 0x08))

                return;

            mcast_idx = compute_mcast_idx(buf);

            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))

                return;

        } else if (s->mem[0] == buf[0] &&

     ",0,0,10,0,0,0,0,0,0,1,0,0,0,0,0
14024,FFmpeg,1,"static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)

{

    int16_t tmp[146 + 60], *ptr0, *ptr1;

    const int16_t *filter;

    int i, t, off;



    t = dec->offset2[quart];

    if(t == 127){

        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));

        return;

    }

    for(i = 0; i < 146; i++)

        tmp[i] = dec->filtbuf[i];

    off = (t / 25) + dec->offset1[quart >> 1] + 18;


    ptr0 = tmp + 145 - off;

    ptr1 = tmp + 146;

    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;

    for(i = 0; i < 60; i++){

        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;

        ptr0++;

        dec->newvec[i] = t;

        ptr1[i] = t;

    }

}",2,0,1,0,0,0,0,0,0,1,0,1,0,0,0
14025,qemu,1,"static void scsi_disk_purge_requests(SCSIDiskState *s)

{

    SCSIDiskReq *r;



    while (!QTAILQ_EMPTY(&s->qdev.requests)) {

        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));

        if (r->req.aiocb) {

            bdrv_aio_cancel(r->req.aiocb);

        }

        scsi_remove_request(r);

    }

}
",0,0,1,0,0,1,1,1,1,1,0,1,1,1,1
14031,qemu,1,"static int net_slirp_init(VLANState *vlan)

{

    if (!slirp_inited) {

        slirp_inited = 1;

        slirp_init();

    }

    slirp_vc = qemu_new_vlan_client(vlan, 

                                    slirp_receive, NULL);

    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");

    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
14056,FFmpeg,1,"static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){

    char buf1[32], tuple_type[32];

    int h, w, depth, maxval;;



    pnm_get(s, buf1, sizeof(buf1));

    if (!strcmp(buf1, ""P4"")) {

        avctx->pix_fmt = PIX_FMT_MONOWHITE;

    } else if (!strcmp(buf1, ""P5"")) {

        if (avctx->codec_id == CODEC_ID_PGMYUV) 

            avctx->pix_fmt = PIX_FMT_YUV420P;

        else

            avctx->pix_fmt = PIX_FMT_GRAY8;

    } else if (!strcmp(buf1, ""P6"")) {

        avctx->pix_fmt = PIX_FMT_RGB24;

    } else if (!strcmp(buf1, ""P7"")) {

        w = -1;

        h = -1;

        maxval = -1;

        depth = -1;

        tuple_type[0] = '\0';

        for(;;) {

            pnm_get(s, buf1, sizeof(buf1));

            if (!strcmp(buf1, ""WIDTH"")) {

                pnm_get(s, buf1, sizeof(buf1));

                w = strtol(buf1, NULL, 10);

            } else if (!strcmp(buf1, ""HEIGHT"")) {

                pnm_get(s, buf1, sizeof(buf1));

                h = strtol(buf1, NULL, 10)",1,0,7,0,0,0,1,1,1,0,0,0,0,0,0
14076,qemu,0,"void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,

                            int len, int is_write)

{

    return address_space_rw(&address_space_memory, addr, buf, len, is_write);

}
",0,0,0,0,0,0,0,1,0,1,1,0,1,1,0
14090,qemu,0,"static void v9fs_link(void *opaque)

{

    V9fsPDU *pdu = opaque;

    V9fsState *s = pdu->s;

    int32_t dfid, oldfid;

    V9fsFidState *dfidp, *oldfidp;

    V9fsString name;

    size_t offset = 7;

    int err = 0;



    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name);

    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);



    dfidp = get_fid(pdu, dfid);

    if (dfidp == NULL) {

        err = -ENOENT;

        goto out_nofid;

    }



    oldfidp = get_fid(pdu, oldfid);

    if (oldfidp == NULL) {

        err = -ENOENT;

        goto out;

    }

    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);

    if (!err) {

        err = offset;

    }

out:

    put_fid(pdu, dfidp);

out_nofid:

    v9fs_string_free(&name);

    complete_pdu(s, pdu, err);

}
",0,2,3,0,0,0,0,0,0,0,0,0,0,1,0
14108,FFmpeg,0,"int dxva2_init(AVCodecContext *s)

{

    InputStream *ist = s->opaque;

    int loglevel = (ist->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR;

    DXVA2Context *ctx;

    int ret;



    if (!ist->hwaccel_ctx) {

        ret = dxva2_alloc(s);

        if (ret < 0)

            return ret;

    }

    ctx = ist->hwaccel_ctx;



    if (s->codec_id == AV_CODEC_ID_H264 &&

        (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) {

        av_log(NULL, loglevel, ""Unsupported H.264 profile for DXVA2 HWAccel: %d\n"", s->profile);

        return AVERROR(EINVAL);

    }



    if (s->codec_id == AV_CODEC_ID_HEVC &&

        s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) {

        av_log(NULL, loglevel, ""Unsupported HEVC profile for DXVA2 HWAccel: %d\n"", s->profile);

        return AVERROR(EINVAL);

    }



    av_buffer_unref(&ctx->hw_frames_ctx);



    ret = dxva2_create_decoder(s);

    if (ret < 0) {

        av_log(NULL, loglevel, ""Error creat",2,0,5,0,0,0,0,1,1,1,1,1,1,1,1
14126,qemu,0,"static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *s,

                                         XenPTRegInfo *reg)

{

    PCIDevice *d = &s->dev;

    XenPTRegion *region = NULL;

    PCIIORegion *r;

    int index = 0;



    /* check 64bit BAR */

    index = xen_pt_bar_offset_to_index(reg->offset);

    if ((0 < index) && (index < PCI_ROM_SLOT)) {

        int type = s->real_device.io_regions[index - 1].type;



        if ((type & XEN_HOST_PCI_REGION_TYPE_MEM)

            && (type & XEN_HOST_PCI_REGION_TYPE_MEM_64)) {

            region = &s->bases[index - 1];

            if (region->bar_flag != XEN_PT_BAR_FLAG_UPPER) {

                return XEN_PT_BAR_FLAG_UPPER;

            }

        }

    }



    /* check unused BAR */

    r = &d->io_regions[index];

    if (!xen_pt_get_bar_size(r)) {

        return XEN_PT_BAR_FLAG_UNUSED;

    }



    /* for ExpROM BAR */

    if (index == PCI_ROM_SLOT) {

        return XEN_PT_BAR_FLAG_MEM;

    }



    /* check BAR I/O indicator */

    i",0,0,5,0,0,0,1,1,0,1,1,1,0,0,0
14141,FFmpeg,1,"static av_cold int g726_encode_init(AVCodecContext *avctx)

{

    G726Context* c = avctx->priv_data;



    if (avctx->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL &&

        avctx->sample_rate != 8000) {

        av_log(avctx, AV_LOG_ERROR, ""Sample rates other than 8kHz are not ""

               ""allowed when the compliance level is higher than unofficial. ""

               ""Resample or reduce the compliance level.\n"");

        return AVERROR(EINVAL);

    }

    if (avctx->sample_rate <= 0) {

        av_log(avctx, AV_LOG_ERROR, ""Samplerate is invalid\n"");

        return -1;

    }



    if(avctx->channels != 1){

        av_log(avctx, AV_LOG_ERROR, ""Only mono is supported\n"");

        return -1;

    }



    if (avctx->bit_rate % avctx->sample_rate) {

        av_log(avctx, AV_LOG_ERROR, ""Bitrate - Samplerate combination is invalid\n"");

        return AVERROR(EINVAL);

    }

    c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;

    if (c->code_size < 2 || c->code_s",0,0,5,0,0,0,1,1,1,1,1,0,0,0,0
14144,FFmpeg,1,"static int dv_read_seek(AVFormatContext *s, int stream_index,

                       int64_t timestamp, int flags)

{

    RawDVContext *r   = s->priv_data;

    DVDemuxContext *c = r->dv_demux;

    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);



    dv_offset_reset(c, offset / c->sys->frame_size);



    offset = avio_seek(s->pb, offset, SEEK_SET);

    return (offset < 0) ? offset : 0;

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
14162,qemu,1,"static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,

                                     DeviceState *plugged_dev, Error **errp)

{

    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));

    PCIDevice *pdev = PCI_DEVICE(plugged_dev);

    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);

    Error *local_err = NULL;



    /* if DR is disabled we don't need to do anything in the case of

     * hotplug or coldplug callbacks

     */

    if (!phb->dr_enabled) {

        /* if this is a hotplug operation initiated by the user

         * we need to let them know it's not enabled

         */

        if (plugged_dev->hotplugged) {

            error_setg(errp, QERR_BUS_NO_HOTPLUG,

                       object_get_typename(OBJECT(phb)));

        }

        return;

    }



    g_assert(drc);



    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (plugged_dev->hotpl",0,0,6,0,0,0,1,1,1,1,1,1,0,0,0
14168,FFmpeg,0,"av_cold int ff_dvvideo_init(AVCodecContext *avctx)

{

    DVVideoContext *s = avctx->priv_data;

    DSPContext dsp;

    static int done = 0;

    int i, j;



    if (!done) {

        VLC dv_vlc;

        uint16_t new_dv_vlc_bits[NB_DV_VLC*2];

        uint8_t  new_dv_vlc_len[NB_DV_VLC*2];

        uint8_t  new_dv_vlc_run[NB_DV_VLC*2];

        int16_t  new_dv_vlc_level[NB_DV_VLC*2];



        done = 1;



        /* it's faster to include sign bit in a generic VLC parsing scheme */

        for (i = 0, j = 0; i < NB_DV_VLC; i++, j++) {

            new_dv_vlc_bits[j]  = dv_vlc_bits[i];

            new_dv_vlc_len[j]   = dv_vlc_len[i];

            new_dv_vlc_run[j]   = dv_vlc_run[i];

            new_dv_vlc_level[j] = dv_vlc_level[i];



            if (dv_vlc_level[i]) {

                new_dv_vlc_bits[j] <<= 1;

                new_dv_vlc_len[j]++;



                j++;

                new_dv_vlc_bits[j]  = (dv_vlc_bits[i] << 1) | 1;

                new_dv_vlc_len[j]   =  dv_vlc_len[i] + 1;

    ",1,0,2,0,0,0,0,0,0,0,0,0,1,1,1
14199,FFmpeg,1,"static int libquvi_read_header(AVFormatContext *s)

{

    int i, ret;

    quvi_t q;

    quvi_media_t m;

    QUVIcode rc;

    LibQuviContext *qc = s->priv_data;

    char *media_url, *pagetitle;



    rc = quvi_init(&q);

    if (rc != QUVI_OK)

        goto quvi_fail;



    quvi_setopt(q, QUVIOPT_FORMAT, qc->format);



    rc = quvi_parse(q, s->filename, &m);

    if (rc != QUVI_OK)

        goto quvi_fail;



    rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &media_url);

    if (rc != QUVI_OK)

        goto quvi_fail;



    av_assert0(!qc->fmtctx->codec_whitelist && !qc->fmtctx->format_whitelist);

    qc->fmtctx-> codec_whitelist = av_strdup(s->codec_whitelist);

    qc->fmtctx->format_whitelist = av_strdup(s->format_whitelist);



    ret = avformat_open_input(&qc->fmtctx, media_url, NULL, NULL);

    if (ret < 0)

        goto end;



    rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle);

    if (rc == QUVI_OK)

        av_dict_set(&s->metadata, ""title"", pagetitle, 0);



    for (i = 0; i < qc->f",6,4,5,0,0,0,0,1,0,1,1,0,1,1,0
14220,qemu,0,"static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{

    if (base_filename) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (base_fmt) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
",5,0,4,0,0,0,0,1,1,1,1,1,0,0,0
14228,qemu,0,"void qemu_flush_queued_packets(VLANClientState *vc)

{

    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {

        VLANPacket *packet;

        int ret;



        packet = TAILQ_FIRST(&vc->vlan->send_queue);

        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);



        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);

        if (ret == 0 && packet->sent_cb != NULL) {

            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);

            break;

        }



        if (packet->sent_cb)

            packet->sent_cb(packet->sender, ret);



        qemu_free(packet);

    }

}
",0,0,2,0,0,1,0,0,0,0,0,0,0,0,0
14248,FFmpeg,1,"LF_FUNC (h,  luma,         sse2)

LF_IFUNC(h,  luma_intra,   sse2)

LF_FUNC (v,  luma,         sse2)

LF_IFUNC(v,  luma_intra,   sse2)



/***********************************/

/* weighted prediction */



#define H264_WEIGHT(W, H, OPT) \

void ff_h264_weight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \

    int stride, int log2_denom, int weight, int offset);



#define H264_BIWEIGHT(W, H, OPT) \

void ff_h264_biweight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \

    uint8_t *src, int stride, int log2_denom, int weightd, \

    int weights, int offset);



#define H264_BIWEIGHT_MMX(W,H) \

H264_WEIGHT  (W, H, mmx2) \

H264_BIWEIGHT(W, H, mmx2)



#define H264_BIWEIGHT_MMX_SSE(W,H) \

H264_BIWEIGHT_MMX(W, H) \

H264_WEIGHT      (W, H, sse2) \

H264_BIWEIGHT    (W, H, sse2) \

H264_BIWEIGHT    (W, H, ssse3)



H264_BIWEIGHT_MMX_SSE(16, 16)

H264_BIWEIGHT_MMX_SSE(16,  8)

H264_BIWEIGHT_MMX_SSE( 8, 16)

H264_BIWEIGHT_MMX_SSE( 8,  8)

H264_BIWEIGHT_MMX_SSE( 8,  4)

H264_BIWEIGHT_MMX    ( 4,  8)

H264_BIWEIGHT_MMX ",0,0,0,0,0,0,1,1,1,0,0,1,0,0,0
14263,FFmpeg,0,"static int decode_band_hdr(IVI45DecContext *ctx, IVIBandDesc *band,

                           AVCodecContext *avctx)

{

    int plane, band_num, indx, transform_id, scan_indx;

    int i;



    plane    = get_bits(&ctx->gb, 2);

    band_num = get_bits(&ctx->gb, 4);

    if (band->plane != plane || band->band_num != band_num) {

        av_log(avctx, AV_LOG_ERROR, ""Invalid band header sequence!\n"");

        return AVERROR_INVALIDDATA;

    }



    band->is_empty = get_bits1(&ctx->gb);

    if (!band->is_empty) {

        int old_blk_size = band->blk_size;

        /* skip header size

         * If header size is not given, header size is 4 bytes. */

        if (get_bits1(&ctx->gb))

            skip_bits(&ctx->gb, 16);



        band->is_halfpel = get_bits(&ctx->gb, 2);

        if (band->is_halfpel >= 2) {

            av_log(avctx, AV_LOG_ERROR, ""Invalid/unsupported mv resolution: %d!\n"",

                   band->is_halfpel);

            return AVERROR_INVALIDDATA;

        }

#if IVI4_STREAM_ANA",1,0,5,0,0,0,0,0,0,1,0,1,0,0,0
14289,qemu,0,"long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3, 

                long arg4, long arg5, long arg6)

{

    long ret;

    struct stat st;

    struct kernel_statfs *stfs;

    

#ifdef DEBUG

    gemu_log(""syscall %d\n"", num);

#endif

    switch(num) {

    case TARGET_NR_exit:

#ifdef HAVE_GPROF

        _mcleanup();

#endif

        _exit(arg1);

        ret = 0; /* avoid warning */

        break;

    case TARGET_NR_read:

        ret = get_errno(read(arg1, (void *)arg2, arg3));

        break;

    case TARGET_NR_write:

        ret = get_errno(write(arg1, (void *)arg2, arg3));

        break;

    case TARGET_NR_open:

        ret = get_errno(open((const char *)arg1, arg2, arg3));

        break;

    case TARGET_NR_close:

        ret = get_errno(close(arg1));

        break;

    case TARGET_NR_brk:

        ret = do_brk((char *)arg1);

        break;

    case TARGET_NR_fork:

        ret = get_errno(fork());

        break;

    case TARGET_NR_waitpid:

        {

         ",2,0,4,0,1,0,0,0,0,0,0,0,0,1,0
14300,qemu,1,"static int rebuild_refcount_structure(BlockDriverState *bs,

                                      BdrvCheckResult *res,

                                      void **refcount_table,

                                      int64_t *nb_clusters)

{

    BDRVQcow2State *s = bs->opaque;

    int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0;

    int64_t refblock_offset, refblock_start, refblock_index;

    uint32_t reftable_size = 0;

    uint64_t *on_disk_reftable = NULL;

    void *on_disk_refblock;

    int ret = 0;

    struct {

        uint64_t reftable_offset;

        uint32_t reftable_clusters;

    } QEMU_PACKED reftable_offset_and_clusters;



    qcow2_cache_empty(bs, s->refcount_block_cache);



write_refblocks:

    for (; cluster < *nb_clusters; cluster++) {

        if (!s->get_refcount(*refcount_table, cluster)) {

            continue;

        }



        refblock_index = cluster >> s->refcount_block_bits;

        refblock_start = refblock_index << s->refcount_block_bits;



",1,0,1,0,0,0,1,0,1,1,1,1,0,0,0
14306,FFmpeg,0,"static int synchronize_audio(VideoState *is, short *samples,

                             int samples_size1, double pts)

{

    int n, samples_size;

    double ref_clock;



    n = 2 * is->audio_st->codec->channels;

    samples_size = samples_size1;



    /* if not master, then we try to remove or add samples to correct the clock */

    if (((is->av_sync_type == AV_SYNC_VIDEO_MASTER && is->video_st) ||

         is->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) {

        double diff, avg_diff;

        int wanted_size, min_size, max_size, nb_samples;



        ref_clock = get_master_clock(is);

        diff = get_audio_clock(is) - ref_clock;



        if (diff < AV_NOSYNC_THRESHOLD) {

            is->audio_diff_cum = diff + is->audio_diff_avg_coef * is->audio_diff_cum;

            if (is->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) {

                /* not enough measures to have a correct estimate */

                is->audio_diff_avg_count++;

            } else {

                /* estimate the A-V",0,0,13,0,0,0,0,0,0,0,0,0,1,1,1
14308,FFmpeg,1,"av_cold int ff_ivi_init_planes(IVIPlaneDesc *planes, const IVIPicConfig *cfg,

                               int is_indeo4)

{

    int p, b;

    uint32_t b_width, b_height, align_fac, width_aligned,

             height_aligned, buf_size;

    IVIBandDesc *band;



    ivi_free_buffers(planes);



    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||

        cfg->luma_bands < 1 || cfg->chroma_bands < 1)

        return AVERROR_INVALIDDATA;



    /* fill in the descriptor of the luminance plane */

    planes[0].width     = cfg->pic_width;

    planes[0].height    = cfg->pic_height;

    planes[0].num_bands = cfg->luma_bands;



    /* fill in the descriptors of the chrominance planes */

    planes[1].width     = planes[2].width     = (cfg->pic_width  + 3) >> 2;

    planes[1].height    = planes[2].height    = (cfg->pic_height + 3) >> 2;

    planes[1].num_bands = planes[2].num_bands = cfg->chroma_bands;



    for (p = 0; p < 3; p++) {

        planes[p].bands = av_mallocz_array(p",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
14309,FFmpeg,1,"static av_cold int seqvideo_decode_init(AVCodecContext *avctx)
{
    SeqVideoContext *seq = avctx->priv_data;
    seq->avctx = avctx;
    avctx->pix_fmt = AV_PIX_FMT_PAL8;
    seq->frame = av_frame_alloc();
    if (!seq->frame)
        return AVERROR(ENOMEM);
    return 0;
}",0,0,1,0,0,0,1,1,1,1,1,1,1,1,0
14324,qemu,1,"static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,

                                         int64_t sector_num,

                                         QEMUIOVector *qiov,

                                         int nb_sectors,

                                         BdrvRequestFlags flags,

                                         BlockCompletionFunc *cb,

                                         void *opaque,

                                         bool is_write)

{

    Coroutine *co;

    BlockAIOCBCoroutine *acb;



    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);

    acb->child = child;

    acb->need_bh = true;

    acb->req.error = -EINPROGRESS;

    acb->req.sector = sector_num;

    acb->req.nb_sectors = nb_sectors;

    acb->req.qiov = qiov;

    acb->req.flags = flags;

    acb->is_write = is_write;



    co = qemu_coroutine_create(bdrv_co_do_rw);

    qemu_coroutine_enter(co, acb);



    bdrv_co_maybe_schedule_bh(acb);

    return &acb->common;

}
",0,0,0,0,0,0,0,1,0,0,0,0,1,1,1
14350,FFmpeg,1,"static int standard_decode_picture_secondary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0, index;



    switch (v->s.pict_type)

    {

    case P_TYPE: status = decode_p_picture_secondary_header(v); break;

    case B_TYPE: status = decode_b_picture_secondary_header(v); break;

    case BI_TYPE:

    case I_TYPE: break; //Nothing needed as it's done in the epilog

    }

    if (status < 0) return FRAME_SKIPED;



    /* AC Syntax */

    v->ac_table_level = decode012(gb);

    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)

    {

        v->ac2_table_level = decode012(gb);

    }

    /* DC Syntax */

    index = decode012(gb);

    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];

    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];

   

    return 0;

}
",0,0,2,0,1,0,0,0,0,1,0,1,0,1,0
14356,qemu,1,"static void ccw_machine_class_init(ObjectClass *oc, void *data)

{

    MachineClass *mc = MACHINE_CLASS(oc);

    NMIClass *nc = NMI_CLASS(oc);

    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->ri_allowed = true;

    s390mc->cpu_model_allowed = true;

    s390mc->css_migration_enabled = true;

    s390mc->gs_allowed = true;

    mc->init = ccw_init;

    mc->reset = s390_machine_reset;

    mc->hot_add_cpu = s390_hot_add_cpu;

    mc->block_default_type = IF_VIRTIO;

    mc->no_cdrom = 1;

    mc->no_floppy = 1;

    mc->no_serial = 1;

    mc->no_parallel = 1;

    mc->no_sdcard = 1;

    mc->use_sclp = 1;

    mc->max_cpus = S390_MAX_CPUS;

    mc->has_hotpluggable_cpus = true;

    mc->get_hotplug_handler = s390_get_hotplug_handler;

    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;

    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;

    /* it is overridden with 'host' cpu *in kvm_arch_init* */

    m",0,0,0,0,0,0,0,0,0,1,0,0,0,1,0
14359,FFmpeg,1,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
",0,0,0,0,0,0,0,1,0,1,1,1,0,0,0
14362,FFmpeg,1,"static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)

{

    ParseContext1 *pc = s->priv_data;



    pc->enc = av_mallocz(sizeof(MpegEncContext));

    if (!pc->enc)

        return -1;

    pc->first_picture = 1;


    return 0;

}",0,0,1,0,0,0,0,0,0,1,0,0,1,0,1
14366,FFmpeg,1,"const AVOption *av_opt_next(void *obj, const AVOption *last)

{

    AVClass *class = *(AVClass**)obj;

    if (!last && class->option[0].name) return class->option;

    if (last && last[1].name)           return ++last;

    return NULL;

}
",0,0,2,0,0,0,0,0,1,0,0,0,0,0,0
14372,FFmpeg,1,"static void do_audio_out(AVFormatContext *s, OutputStream *ost,

                         InputStream *ist, AVFrame *decoded_frame)

{

    uint8_t *buftmp;



    int size_out, frame_bytes, resample_changed, ret;

    AVCodecContext *enc = ost->st->codec;

    AVCodecContext *dec = ist->st->codec;

    int osize = av_get_bytes_per_sample(enc->sample_fmt);

    int isize = av_get_bytes_per_sample(dec->sample_fmt);

    uint8_t *buf = decoded_frame->data[0];

    int size     = decoded_frame->nb_samples * dec->channels * isize;

    int out_linesize = 0;

    int buf_linesize = decoded_frame->linesize[0];



    get_default_channel_layouts(ost, ist);



    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples, &out_linesize) < 0) {

        av_log(NULL, AV_LOG_FATAL, ""Error allocating audio buffer\n"");

        exit_program(1);

    }



    if (audio_sync_method > 1                      ||

        enc->channels       != dec->channels       ||

        enc->channel_layout != dec->channel_layout ||

",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
14376,qemu,1,"static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)

{

    switch (shiftop) {

    case 0: /* LSL */

        if (shift != 0) {

            if (flags)

                shifter_out_im(var, 32 - shift);

            tcg_gen_shli_i32(var, var, shift);

        }

        break;

    case 1: /* LSR */

        if (shift == 0) {

            if (flags) {

                tcg_gen_shri_i32(var, var, 31);

                gen_set_CF(var);

            }

            tcg_gen_movi_i32(var, 0);

        } else {

            if (flags)

                shifter_out_im(var, shift - 1);

            tcg_gen_shri_i32(var, var, shift);

        }

        break;

    case 2: /* ASR */

        if (shift == 0)

            shift = 32;

        if (flags)

            shifter_out_im(var, shift - 1);

        if (shift == 32)

          shift = 31;

        tcg_gen_sari_i32(var, var, shift);

        break;

    case 3: /* ROR/RRX */

        if (shift != 0) {

            if (flags)

            ",0,0,30,0,1,0,0,0,0,0,1,0,0,0,0
14379,qemu,1,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    int i;



    /* Copy configuration from shared memory */

    VMXNET3_READ_DRV_SHARED(s->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            s->vlan_table,

                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
",2,0,1,0,0,0,0,0,1,1,1,1,0,0,0
14387,qemu,0,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t limit;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }

    ptimer_set_limit(s->timer, limit, reload);

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,1,0
14388,qemu,0,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
14393,qemu,0,"int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)

{

        return kvm_dirty_pages_log_change(phys_addr, size,

                                          KVM_MEM_LOG_DIRTY_PAGES,

                                          KVM_MEM_LOG_DIRTY_PAGES);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,1
14413,qemu,0,"static void do_log(int argc, const char **argv)

{

    int mask;

    

    if (argc != 2)

        goto help;

    if (!strcmp(argv[1], ""none"")) {

        mask = 0;

    } else {

        mask = cpu_str_to_log_mask(argv[1]);

        if (!mask) {

        help:

            help_cmd(argv[0]);

            return;

        }

    }

    cpu_set_log(mask);

}
",0,1,3,0,0,0,0,1,0,0,0,0,0,0,0
14442,FFmpeg,0,"static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)

{

    HEVCContext *s  = avctxt->priv_data;

    int ctb_size    = 1 << s->sps->log2_ctb_size;

    int more_data   = 1;

    int x_ctb       = 0;

    int y_ctb       = 0;

    int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];



    if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {

        av_log(s->avctx, AV_LOG_ERROR, ""Impossible initial tile.\n"");

        return AVERROR_INVALIDDATA;

    }



    if (s->sh.dependent_slice_segment_flag) {

        int prev_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts - 1];

        if (s->tab_slice_address[prev_rs] == -1) {

            av_log(s->avctx, AV_LOG_ERROR, ""Previous slice segment missing\n"");

            return AVERROR_INVALIDDATA;

        }

    }



    while (more_data && ctb_addr_ts < s->sps->ctb_size) {

        int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts];



        x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb",0,0,3,0,0,1,0,0,0,1,0,1,1,1,0
14459,FFmpeg,1,"static int decode_header(MPADecodeContext *s, UINT32 header)

{

    int sample_rate, frame_size, mpeg25, padding;

    int sample_rate_index, bitrate_index;

    if (header & (1<<20)) {

        s->lsf = (header & (1<<19)) ? 0 : 1;

        mpeg25 = 0;

    } else {

        s->lsf = 1;

        mpeg25 = 1;

    }

    

    s->layer = 4 - ((header >> 17) & 3);

    /* extract frequency */

    sample_rate_index = (header >> 10) & 3;

    sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);

    if (sample_rate == 0)

        return 1;

    sample_rate_index += 3 * (s->lsf + mpeg25);

    s->sample_rate_index = sample_rate_index;

    s->error_protection = ((header >> 16) & 1) ^ 1;



    bitrate_index = (header >> 12) & 0xf;

    padding = (header >> 9) & 1;

    //extension = (header >> 8) & 1;

    s->mode = (header >> 6) & 3;

    s->mode_ext = (header >> 4) & 3;

    //copyright = (header >> 3) & 1;

    //original = (header >> 2) & 1;

    //emphasis = header & 3;



    if (s->mode == M",0,0,3,0,0,0,0,0,0,1,1,1,1,1,1
14469,FFmpeg,1,"static av_cold int init(AVFilterContext *ctx, const char *args)

{

    GradFunContext *gf = ctx->priv;

    float thresh = 1.2;

    int radius = 16;



    if (args)

        sscanf(args, ""%f:%d"", &thresh, &radius);



    thresh = av_clipf(thresh, 0.51, 255);

    gf->thresh = (1 << 15) / thresh;

    gf->radius = av_clip((radius + 1) & ~1, 4, 32);



    gf->blur_line = ff_gradfun_blur_line_c;

    gf->filter_line = ff_gradfun_filter_line_c;



    if (ARCH_X86)

        ff_gradfun_init_x86(gf);



    av_log(ctx, AV_LOG_VERBOSE, ""threshold:%.2f radius:%d\n"", thresh, gf->radius);



    return 0;

}
",0,0,2,0,0,0,1,1,1,1,0,1,0,1,0
14476,qemu,0,"static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,

				    int enable)

{

	return kvm_set_migration_log(enable);

}
",0,0,0,0,0,0,0,0,0,1,0,1,0,0,0
14499,FFmpeg,0,"static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t timestamp, int flags)

{

    RTMP *r = s->priv_data;



    if (flags & AVSEEK_FLAG_BYTE)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(r, timestamp))

        return -1;

    return timestamp;

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
14508,FFmpeg,0,"static av_cold int mace_decode_init(AVCodecContext * avctx)

{

    MACEContext *ctx = avctx->priv_data;



    if (avctx->channels > 2)

        return -1;

    avctx->sample_fmt = AV_SAMPLE_FMT_S16;



    avcodec_get_frame_defaults(&ctx->frame);

    avctx->coded_frame = &ctx->frame;



    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
14521,qemu,1,"float16 float32_to_float16(float32 a, flag ieee STATUS_PARAM)

{

    flag aSign;

    int_fast16_t aExp;

    uint32_t aSig;

    uint32_t mask;

    uint32_t increment;

    int8 roundingMode;

    a = float32_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat32Frac( a );

    aExp = extractFloat32Exp( a );

    aSign = extractFloat32Sign( a );

    if ( aExp == 0xFF ) {

        if (aSig) {

            /* Input is a NaN */

            float16 r = commonNaNToFloat16( float32ToCommonNaN( a STATUS_VAR ) STATUS_VAR );

            if (!ieee) {

                return packFloat16(aSign, 0, 0);

            }

            return r;

        }

        /* Infinity */

        if (!ieee) {

            float_raise(float_flag_invalid STATUS_VAR);

            return packFloat16(aSign, 0x1f, 0x3ff);

        }

        return packFloat16(aSign, 0x1f, 0);

    }

    if (aExp == 0 && aSig == 0) {

        return packFloat16(aSign, 0, 0);

    }

    /* Decimal point between bits 22 and 23.  */

    aSi",0,0,5,0,0,0,0,0,1,1,1,0,0,1,1
14531,qemu,0,"int virtqueue_avail_bytes(VirtQueue *vq, int in_bytes, int out_bytes)

{

    unsigned int idx;

    unsigned int total_bufs, in_total, out_total;



    idx = vq->last_avail_idx;



    total_bufs = in_total = out_total = 0;

    while (virtqueue_num_heads(vq, idx)) {

        unsigned int max, num_bufs, indirect = 0;

        target_phys_addr_t desc_pa;

        int i;



        max = vq->vring.num;

        num_bufs = total_bufs;

        i = virtqueue_get_head(vq, idx++);

        desc_pa = vq->vring.desc;



        if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_INDIRECT) {

            if (vring_desc_len(desc_pa, i) % sizeof(VRingDesc)) {

                error_report(""Invalid size for indirect buffer table"");

                exit(1);

            }



            /* If we've got too many, that implies a descriptor loop. */

            if (num_bufs >= max) {

                error_report(""Looped descriptor"");

                exit(1);

            }



            /* loop over the indirect descripto",1,0,3,0,0,1,1,0,0,1,1,1,0,1,0
14557,qemu,0,"static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)

{

    CharDriverState *chr;

    FDCharDriver *s;



    chr = g_malloc0(sizeof(CharDriverState));

    s = g_malloc0(sizeof(FDCharDriver));

    s->fd_in = io_channel_from_fd(fd_in);

    s->fd_out = io_channel_from_fd(fd_out);

    fcntl(fd_out, F_SETFL, O_NONBLOCK);

    s->chr = chr;

    chr->opaque = s;

    chr->chr_add_watch = fd_chr_add_watch;

    chr->chr_write = fd_chr_write;

    chr->chr_update_read_handler = fd_chr_update_read_handler;

    chr->chr_close = fd_chr_close;



    qemu_chr_be_generic_open(chr);



    return chr;

}
",0,0,0,0,0,0,0,0,0,0,0,1,1,1,1
14566,FFmpeg,0,"static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                             const AVFrame *frame, int *got_packet_ptr)

{

    G722Context *c = avctx->priv_data;

    const int16_t *samples = (const int16_t *)frame->data[0];

    int nb_samples, out_size, ret;



    out_size = (frame->nb_samples + 1) / 2;

    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))

        return ret;



    nb_samples = frame->nb_samples - (frame->nb_samples & 1);



    if (avctx->trellis)

        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);

    else

        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);



    /* handle last frame with odd frame_size */

    if (nb_samples < frame->nb_samples) {

        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };

        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);

    }



    if (frame->pts != AV_NOPTS_VALUE)

        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx,",0,0,4,0,0,0,0,0,0,0,0,0,1,0,0
14588,FFmpeg,0,"static int gif_image_write_image(AVCodecContext *avctx,

                                 uint8_t **bytestream, uint8_t *end,

                                 const uint32_t *palette,

                                 const uint8_t *buf, const int linesize,

                                 AVPacket *pkt)

{

    GIFContext *s = avctx->priv_data;

    int len = 0, height = avctx->height, width = avctx->width, x, y;

    int x_start = 0, y_start = 0, trans = s->transparent_index;

    int honor_transparency = (s->flags & GF_TRANSDIFF) && s->last_frame;

    const uint8_t *ptr;



    /* Crop image */

    if ((s->flags & GF_OFFSETTING) && s->last_frame && !palette) {

        const uint8_t *ref = s->last_frame->data[0];

        const int ref_linesize = s->last_frame->linesize[0];

        int x_end = avctx->width  - 1,

            y_end = avctx->height - 1;



        /* skip common lines */

        while (y_start < y_end) {

            if (memcmp(ref + y_start*ref_linesize, buf + y_start*linesize, width)",0,0,3,0,0,1,0,0,0,0,0,0,1,1,1
14589,qemu,0,"static int openfile(char *name, int flags)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;



	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		bs = NULL;

		return 1;

	}



	return 0;

}
",0,0,3,0,0,0,1,1,1,1,1,0,0,0,0
14591,qemu,0,"static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)

{

    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);

    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),

                                  ""/e500-ccsr""));



    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);

    d->config[PCI_HEADER_TYPE] =

        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |

        PCI_HEADER_TYPE_BRIDGE;



    memory_region_init_alias(&b->bar0, OBJECT(ccsr), ""e500-pci-bar0"", &ccsr->ccsr_space,

                             0, int128_get64(ccsr->ccsr_space.size));

    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
14599,FFmpeg,1,"void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)

{

    int i;



    for (i=0; i < in->n; i++) {

        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);




        do {

            out[x] = 0.0;

            x += in->pitch_lag;

        } while (x < size && repeats);

    }

}",1,0,0,0,0,1,0,0,0,0,0,0,0,0,0
14612,FFmpeg,1,"static int film_read_header(AVFormatContext *s,

                            AVFormatParameters *ap)

{

    FilmDemuxContext *film = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st;

    unsigned char scratch[256];

    int i;

    unsigned int data_offset;

    unsigned int audio_frame_counter;



    film->sample_table = NULL;

    film->stereo_buffer = NULL;

    film->stereo_buffer_size = 0;



    /* load the main FILM header */

    if (avio_read(pb, scratch, 16) != 16)

        return AVERROR(EIO);

    data_offset = AV_RB32(&scratch[4]);

    film->version = AV_RB32(&scratch[8]);



    /* load the FDSC chunk */

    if (film->version == 0) {

        /* special case for Lemmings .film files; 20-byte header */

        if (avio_read(pb, scratch, 20) != 20)

            return AVERROR(EIO);

        /* make some assumptions about the audio parameters */

        film->audio_type = CODEC_ID_PCM_S8;

        film->audio_samplerate = 22050;

        film->audio_channels = 1;

        film->",0,0,3,0,0,0,1,1,1,1,1,1,0,0,0
14639,FFmpeg,1,"static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)

{

    int16_t *block = ctx->dct_block;

    unsigned int pos;



    ctx->bdsp.clear_block(block);



    block[0] = get_bits(&ctx->gb, 8) << 3;



    for (pos = 1; pos < num_coeffs; pos++) {

        uint32_t vlc, num_bits;

        int value;

        int coeff;



        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);

        if (!vlc) /* end-of-block code */

            return 0;

        if (vlc == -1)

            return AVERROR_INVALIDDATA;



        /* pos_add and num_bits are coded in the vlc code */

        pos     += vlc & 15; // pos_add

        num_bits = vlc >> 4; // num_bits



        if (pos >= 64)

            return AVERROR_INVALIDDATA;



        value = get_bits(&ctx->gb, num_bits);



        /* FFmpeg's IDCT behaves somewhat different from the original code, so

         * a factor of 4 was added to the input */



        coeff = vlcdec_lookup[num_bits][value];

        if (pos < 3)

        ",1,0,5,0,0,0,0,0,0,1,0,1,0,0,1
14654,FFmpeg,0,"static int svq3_decode_frame(AVCodecContext *avctx,

                             void *data, int *data_size,

                             AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    MpegEncContext *const s = avctx->priv_data;

    H264Context *const h = avctx->priv_data;

    int m, mb_type;



    /* special case for last picture */

    if (buf_size == 0) {

        if (s->next_picture_ptr && !s->low_delay) {

            *(AVFrame *) data = *(AVFrame *) &s->next_picture;

            s->next_picture_ptr = NULL;

            *data_size = sizeof(AVFrame);

        }

        return 0;

    }



    init_get_bits (&s->gb, buf, 8*buf_size);



    s->mb_x = s->mb_y = h->mb_xy = 0;



    if (svq3_decode_slice_header(h))

        return -1;



    s->pict_type = h->slice_type;

    s->picture_number = h->slice_num;



    if (avctx->debug&FF_DEBUG_PICT_INFO){

        av_log(h->s.avctx, AV_LOG_DEBUG, ""%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\n"",

  ",0,0,4,0,0,0,1,1,1,0,0,1,1,1,1
14658,FFmpeg,1,"static av_cold int rl2_decode_init(AVCodecContext *avctx)

{

    Rl2Context *s = avctx->priv_data;

    int back_size;

    int i;

    s->avctx = avctx;

    avctx->pix_fmt = AV_PIX_FMT_PAL8;

    avcodec_get_frame_defaults(&s->frame);



    /** parse extra data */

    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){

        av_log(avctx, AV_LOG_ERROR, ""invalid extradata size\n"");

        return -1;

    }



    /** get frame_offset */

    s->video_base = AV_RL16(&avctx->extradata[0]);

    s->clr_count = AV_RL32(&avctx->extradata[2]);



    if(s->video_base >= avctx->width * avctx->height){

        av_log(avctx, AV_LOG_ERROR, ""invalid video_base\n"");

        return -1;

    }



    /** initialize palette */

    for(i=0;i<AVPALETTE_COUNT;i++)

        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);



    /** decode background frame if present */

    back_size = avctx->extradata_size - EXTRADATA1_SIZE;



    if(back_size > 0){

        unsigned char* back_fr",1,0,4,0,0,0,0,0,1,1,1,1,0,1,0
14665,FFmpeg,1,"static void picmemset(PicContext *s, AVFrame *frame, int value, int run,

                      int *x, int *y, int *plane, int bits_per_plane)

{

    uint8_t *d;

    int shift = *plane * bits_per_plane;

    int mask  = ((1 << bits_per_plane) - 1) << shift;

    value   <<= shift;



    while (run > 0) {

        int j;

        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {

            d = frame->data[0] + *y * frame->linesize[0];

            d[*x] |= (value >> j) & mask;

            *x += 1;

            if (*x == s->width) {

                *y -= 1;

                *x = 0;

                if (*y < 0) {

                   *y = s->height - 1;

                   *plane += 1;

                   if (*plane >= s->nb_planes)

                       return;

                   value <<= bits_per_plane;

                   mask  <<= bits_per_plane;

                }

            }

        }

        run--;

    }

}
",1,0,6,0,0,1,1,1,1,1,1,1,0,0,0
14673,FFmpeg,0,"static inline void silk_stabilize_lsf(int16_t nlsf[16], int order, const uint16_t min_delta[17])

{

    int pass, i;

    for (pass = 0; pass < 20; pass++) {

        int k, min_diff = 0;

        for (i = 0; i < order+1; i++) {

            int low  = i != 0     ? nlsf[i-1] : 0;

            int high = i != order ? nlsf[i]   : 32768;

            int diff = (high - low) - (min_delta[i]);



            if (diff < min_diff) {

                min_diff = diff;

                k = i;



                if (pass == 20)

                    break;

            }

        }

        if (min_diff == 0) /* no issues; stabilized */

            return;



        /* wiggle one or two LSFs */

        if (k == 0) {

            /* repel away from lower bound */

            nlsf[0] = min_delta[0];

        } else if (k == order) {

            /* repel away from higher bound */

            nlsf[order-1] = 32768 - min_delta[order];

        } else {

            /* repel away from current position */

            in",2,0,12,0,0,0,0,0,0,1,0,1,0,0,0
14679,qemu,1,"static void pci_unin_main_config_writel (void *opaque, target_phys_addr_t addr,

                                         uint32_t val)

{

    UNINState *s = opaque;



    UNIN_DPRINTF(""config_writel addr "" TARGET_FMT_plx "" val %x\n"", addr, val);

#ifdef TARGET_WORDS_BIGENDIAN

    val = bswap32(val);

#endif



    s->config_reg = val;

}
",0,0,2,0,0,0,1,1,0,0,0,0,1,1,1
14680,qemu,1,"vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)
{
    struct vhost_vring_addr *vra = &vmsg->payload.addr;
    unsigned int index = vra->index;
    VubrVirtq *vq = &dev->vq[index];
    DPRINT(""vhost_vring_addr:\n"");
    DPRINT(""    index:  %d\n"", vra->index);
    DPRINT(""    flags:  %d\n"", vra->flags);
    DPRINT(""    desc_user_addr:   0x%016llx\n"", vra->desc_user_addr);
    DPRINT(""    used_user_addr:   0x%016llx\n"", vra->used_user_addr);
    DPRINT(""    avail_user_addr:  0x%016llx\n"", vra->avail_user_addr);
    DPRINT(""    log_guest_addr:   0x%016llx\n"", vra->log_guest_addr);
    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);
    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);
    vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);
    vq->log_guest_addr = vra->log_guest_addr;
    DPRINT(""Setting virtq addresses:\n"");
    DPRINT(""    vring_desc  at %p\n"", vq->desc);
    DPRINT(""    vring_used  at %p\n"",",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
14694,FFmpeg,1,"void ff_get_unscaled_swscale(SwsContext *c)

{

    const enum PixelFormat srcFormat = c->srcFormat;

    const enum PixelFormat dstFormat = c->dstFormat;

    const int flags = c->flags;

    const int dstH = c->dstH;

    int needsDither;



    needsDither = isAnyRGB(dstFormat) &&

            c->dstFormatBpp < 24 &&

           (c->dstFormatBpp < c->srcFormatBpp || (!isAnyRGB(srcFormat)));



    /* yv12_to_nv12 */

    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) &&

        (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21)) {

        c->swScale = planarToNv12Wrapper;

    }

    /* yuv2bgr */

    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUV422P ||

         srcFormat == PIX_FMT_YUVA420P) && isAnyRGB(dstFormat) &&

        !(flags & SWS_ACCURATE_RND) && !(dstH & 1)) {

        c->swScale = ff_yuv2rgb_get_func_ptr(c);

    }



    if (srcFormat == PIX_FMT_YUV410P &&

        (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) &&

        !(flag",0,0,3,0,0,0,1,1,1,1,1,1,1,1,1
14716,qemu,0,"static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br)

{

    PCIDevice *pd = PCI_DEVICE(br);

    PCIBus *parent = pd->bus;

    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);

    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);



    pci_bridge_init_alias(br, &w->alias_pref_mem,

                          PCI_BASE_ADDRESS_MEM_PREFETCH,

                          ""pci_bridge_pref_mem"",

                          &br->address_space_mem,

                          parent->address_space_mem,

                          cmd & PCI_COMMAND_MEMORY);

    pci_bridge_init_alias(br, &w->alias_mem,

                          PCI_BASE_ADDRESS_SPACE_MEMORY,

                          ""pci_bridge_mem"",

                          &br->address_space_mem,

                          parent->address_space_mem,

                          cmd & PCI_COMMAND_MEMORY);

    pci_bridge_init_alias(br, &w->alias_io,

                          PCI_BASE_ADDRESS_SPACE_IO,

                          ""pci_bridge_io"",

   ",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
14723,FFmpeg,0,"static void hls_transform_tree(HEVCContext *s, int x0, int y0,

                               int xBase, int yBase, int cb_xBase, int cb_yBase,

                               int log2_cb_size, int log2_trafo_size,

                               int trafo_depth, int blk_idx)

{

    HEVCLocalContext *lc = &s->HEVClc;

    uint8_t split_transform_flag;



    if (trafo_depth > 0 && log2_trafo_size == 2) {

        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =

            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase);

        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =

            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase);

    } else {

        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =

        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = 0;

    }



    if (lc->cu.intra_split_flag) {

        if (trafo_depth == 1)

            lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx];

    } else {

        lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mo",2,0,3,0,0,0,0,1,1,1,1,1,1,1,1
14741,FFmpeg,1,"static void aw_pulse_set2(WMAVoiceContext *s, GetBitContext *gb,

                          int block_idx, AMRFixed *fcb)

{

    uint16_t use_mask_mem[9]; // only 5 are used, rest is padding

    uint16_t *use_mask = use_mask_mem + 2;

    /* in this function, idx is the index in the 80-bit (+ padding) use_mask

     * bit-array. Since use_mask consists of 16-bit values, the lower 4 bits

     * of idx are the position of the bit within a particular item in the

     * array (0 being the most significant bit, and 15 being the least

     * significant bit), and the remainder (>> 4) is the index in the

     * use_mask[]-array. This is faster and uses less memory than using a

     * 80-byte/80-int array. */

    int pulse_off = s->aw_first_pulse_off[block_idx],

        pulse_start, n, idx, range, aidx, start_off = 0;



    /* set offset of first pulse to within this block */

    if (s->aw_n_pulses[block_idx] > 0)

        while (pulse_off + s->aw_pulse_range < 1)

            pulse_off += fcb->pitch_lag;
",0,0,3,0,0,1,1,1,1,1,1,1,0,1,1
14745,FFmpeg,1,"static void asf_build_simple_index(AVFormatContext *s, int stream_index)

{

    ff_asf_guid g;

    ASFContext *asf     = s->priv_data;

    int64_t current_pos = avio_tell(s->pb);

    int i;



    avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET);

    ff_get_guid(s->pb, &g);



    /* the data object can be followed by other top-level objects,

     * skip them until the simple index object is reached */

    while (ff_guidcmp(&g, &index_guid)) {

        int64_t gsize = avio_rl64(s->pb);

        if (gsize < 24 || s->pb->eof_reached) {

            avio_seek(s->pb, current_pos, SEEK_SET);

            return;

        }

        avio_skip(s->pb, gsize - 24);

        ff_get_guid(s->pb, &g);

    }



    {

        int64_t itime, last_pos = -1;

        int pct, ict;

        int64_t av_unused gsize = avio_rl64(s->pb);

        ff_get_guid(s->pb, &g);

        itime = avio_rl64(s->pb);

        pct   = avio_rl32(s->pb);

        ict   = avio_rl32(s->pb);

        av_log(s, AV_L",0,0,1,0,0,1,0,1,1,1,1,1,0,0,0
14750,qemu,1,"static void bdrv_qed_drain(BlockDriverState *bs)

{

    BDRVQEDState *s = bs->opaque;



    /* Cancel timer and start doing I/O that were meant to happen as if it

     * fired, that way we get bdrv_drain() taking care of the ongoing requests

     * correctly. */

    qed_cancel_need_check_timer(s);

    qed_plug_allocating_write_reqs(s);

    bdrv_aio_flush(s->bs, qed_clear_need_check, s);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,0,0
14774,qemu,1,"static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",0,0,0,0,0,0,0,1,1,0,0,1,1,0,0
14775,qemu,1,"static int check_bind(const char *hostname, bool *has_proto)

{

    int fd = -1;

    struct addrinfo ai, *res = NULL;

    int rc;

    int ret = -1;



    memset(&ai, 0, sizeof(ai));

    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;

    ai.ai_family = AF_UNSPEC;

    ai.ai_socktype = SOCK_STREAM;



    /* lookup */

    rc = getaddrinfo(hostname, NULL, &ai, &res);

    if (rc != 0) {

        if (rc == EAI_ADDRFAMILY ||

            rc == EAI_FAMILY) {

            *has_proto = false;

            goto done;

        }

        goto cleanup;

    }



    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);

    if (fd < 0) {

        goto cleanup;

    }



    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {

        if (errno == EADDRNOTAVAIL) {

            *has_proto = false;

            goto done;

        }

        goto cleanup;

    }



    *has_proto = true;

 done:

    ret = 0;



 cleanup:

    if (fd != -1) {

        close(fd);

    }

    if (res) {

   ",0,5,7,0,0,0,0,0,0,1,1,1,1,0,0
14777,qemu,1,"static bool run_poll_handlers(AioContext *ctx, int64_t max_ns)

{

    bool progress = false;

    int64_t end_time;



    assert(ctx->notify_me);

    assert(ctx->walking_handlers > 0);

    assert(ctx->poll_disable_cnt == 0);



    trace_run_poll_handlers_begin(ctx, max_ns);



    end_time = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + max_ns;



    do {

        AioHandler *node;



        QLIST_FOREACH(node, &ctx->aio_handlers, node) {

            if (!node->deleted && node->io_poll &&

                node->io_poll(node->opaque)) {

                progress = true;

            }



            /* Caller handles freeing deleted nodes.  Don't do it here. */

        }

    } while (!progress && qemu_clock_get_ns(QEMU_CLOCK_REALTIME) < end_time);



    trace_run_poll_handlers_end(ctx, progress);



    return progress;

}
",0,0,2,0,0,1,0,1,1,1,0,0,0,0,0
14813,FFmpeg,0,"static int screenpresso_decode_frame(AVCodecContext *avctx, void *data,

                                     int *got_frame, AVPacket *avpkt)

{

    ScreenpressoContext *ctx = avctx->priv_data;

    AVFrame *frame = data;

    int keyframe;

    int ret;



    /* Size check */

    if (avpkt->size < 3) {

        av_log(avctx, AV_LOG_ERROR, ""Packet too small (%d)\n"", avpkt->size);

        return AVERROR_INVALIDDATA;

    }



    /* Basic sanity check, but not really harmful */

    if ((avpkt->data[0] != 0x73 && avpkt->data[0] != 0x72) ||

        avpkt->data[1] != 8) { // bpp probably

        av_log(avctx, AV_LOG_WARNING, ""Unknown header 0x%02X%02X\n"",

               avpkt->data[0], avpkt->data[1]);

    }

    keyframe = (avpkt->data[0] == 0x73);



    /* Resize deflate buffer and frame on resolution change */

    if (ctx->inflated_size != avctx->width * avctx->height * 3) {

        av_frame_unref(ctx->current);

        ret = ff_get_buffer(avctx, ctx->current, AV_GET_BUFFER_FLAG_REF);

        if",0,0,4,0,0,0,0,0,1,0,1,1,1,1,1
14814,qemu,1,"static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return var;

}
",0,0,0,0,0,0,1,0,0,1,1,0,0,0,0
14816,qemu,1,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}
",0,0,0,0,0,0,1,0,0,1,1,0,1,1,0
14822,qemu,1,"static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}
",0,0,6,0,0,0,0,0,0,1,0,0,0,0,0
14823,qemu,1,"static void start_tco(const TestData *d)

{

    uint32_t val;



    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);

    val &= ~TCO_TMR_HLT;

    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);

}
",0,0,0,0,0,0,0,1,1,0,1,0,0,0,0
14840,qemu,0,"void memory_global_dirty_log_stop(void)

{

    global_dirty_log = false;



    /* Refresh DIRTY_LOG_MIGRATION bit.  */

    memory_region_transaction_begin();

    memory_region_update_pending = true;

    memory_region_transaction_commit();



    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
14842,qemu,0,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
",0,0,0,0,0,0,0,0,1,0,0,0,0,0,0
14846,qemu,0,"static void cmd_get_event_status_notification(IDEState *s,

                                              uint8_t *buf)

{

    const uint8_t *packet = buf;



    struct {

        uint8_t opcode;

        uint8_t polled;        /* lsb bit is polled; others are reserved */

        uint8_t reserved2[2];

        uint8_t class;

        uint8_t reserved3[2];

        uint16_t len;

        uint8_t control;

    } __attribute__((packed)) *gesn_cdb;



    struct {

        uint16_t len;

        uint8_t notification_class;

        uint8_t supported_events;

    } __attribute((packed)) *gesn_event_header;



    enum notification_class_request_type {

        NCR_RESERVED1 = 1 << 0,

        NCR_OPERATIONAL_CHANGE = 1 << 1,

        NCR_POWER_MANAGEMENT = 1 << 2,

        NCR_EXTERNAL_REQUEST = 1 << 3,

        NCR_MEDIA = 1 << 4,

        NCR_MULTI_HOST = 1 << 5,

        NCR_DEVICE_BUSY = 1 << 6,

        NCR_RESERVED2 = 1 << 7,

    };

    enum event_notification_class_field {

        ENC_NO_EVENTS = 0,

",0,0,4,0,0,0,0,0,1,1,1,1,0,0,0
14848,FFmpeg,0,"static int decode_plane(UtvideoContext *c, int plane_no,

                        uint8_t *dst, int step, ptrdiff_t stride,

                        int width, int height,

                        const uint8_t *src, int use_pred)

{

    int i, j, slice, pix;

    int sstart, send;

    VLC vlc;

    GetBitContext gb;

    int prev, fsym;

    const int cmask = c->interlaced ? ~(1 + 2 * (!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P)) : ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);



    if (build_huff(src, &vlc, &fsym)) {

        av_log(c->avctx, AV_LOG_ERROR, ""Cannot build Huffman codes\n"");

        return AVERROR_INVALIDDATA;

    }

    if (fsym >= 0) { // build_huff reported a symbol to fill slices with

        send = 0;

        for (slice = 0; slice < c->slices; slice++) {

            uint8_t *dest;



            sstart = send;

            send   = (height * (slice + 1) / c->slices) & cmask;

            dest   = dst + sstart * stride;



            prev = 0x80;

            ",1,0,3,0,0,0,0,0,0,0,0,0,0,0,0
14865,FFmpeg,0,"static int ogg_buffer_data(AVFormatContext *s, AVStream *st,

                           uint8_t *data, unsigned size, int64_t granule,

                           int header)

{

    OGGStreamContext *oggstream = st->priv_data;

    OGGContext *ogg = s->priv_data;

    int total_segments = size / 255 + 1;

    uint8_t *p = data;

    int i, segments, len, flush = 0;



    // Handles VFR by flushing page because this frame needs to have a timestamp

    // For theora, keyframes also need to have a timestamp to correctly mark

    // them as such, otherwise seeking will not work correctly at the very

    // least with old libogg versions.

    // Do not try to flush header packets though, that will create broken files.

    if (st->codec->codec_id == AV_CODEC_ID_THEORA && !header &&

        (ogg_granule_to_timestamp(oggstream, granule) >

         ogg_granule_to_timestamp(oggstream, oggstream->last_granule) + 1 ||

         ogg_key_granule(oggstream, granule))) {

        if (oggstream->page.granule != -1)
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
14872,FFmpeg,0,"void mpeg4_encode_picture_header(MpegEncContext * s, int picture_number)

{

    int time_incr;

    int time_div, time_mod;



    if(s->pict_type==AV_PICTURE_TYPE_I){

        if(!(s->flags&CODEC_FLAG_GLOBAL_HEADER)){

            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT) //HACK, the reference sw is buggy

                mpeg4_encode_visual_object_header(s);

            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number==0) //HACK, the reference sw is buggy

                mpeg4_encode_vol_header(s, 0, 0);

        }

        if(!(s->workaround_bugs & FF_BUG_MS))

            mpeg4_encode_gop_header(s);

    }



    s->partitioned_frame= s->data_partitioning && s->pict_type!=AV_PICTURE_TYPE_B;



    put_bits(&s->pb, 16, 0);                /* vop header */

    put_bits(&s->pb, 16, VOP_STARTCODE);    /* vop header */

    put_bits(&s->pb, 2, s->pict_type - 1);  /* pict type: I = 0 , P = 1 */



    assert(s->time>=0);

    time_div= s->time/s->avctx->time_base.den;
",0,0,5,0,0,0,0,1,1,1,1,1,0,0,1
14884,FFmpeg,0,"static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, 

                      int nb_codes)

{

    uint8_t huff_size[256];

    uint16_t huff_code[256];



    memset(huff_size, 0, sizeof(huff_size));

    build_huffman_codes(huff_size, huff_code, bits_table, val_table);

    

    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,1,1
14904,qemu,0,"void qemu_coroutine_adjust_pool_size(int n)

{

    qemu_mutex_lock(&pool_lock);



    pool_max_size += n;



    /* Callers should never take away more than they added */

    assert(pool_max_size >= POOL_DEFAULT_SIZE);



    /* Trim oversized pool down to new max */

    while (pool_size > pool_max_size) {

        Coroutine *co = QSLIST_FIRST(&pool);

        QSLIST_REMOVE_HEAD(&pool, pool_next);

        pool_size--;

        qemu_coroutine_delete(co);

    }



    qemu_mutex_unlock(&pool_lock);

}
",0,0,0,0,0,1,0,0,0,0,0,1,0,0,0
14911,qemu,0,"static void rndis_clear_responsequeue(USBNetState *s)

{

    struct rndis_response *r;



    while ((r = s->rndis_resp.tqh_first)) {

        TAILQ_REMOVE(&s->rndis_resp, r, entries);

        qemu_free(r);

    }

}
",0,0,0,0,0,1,1,1,1,1,1,1,0,0,0
14913,FFmpeg,0,"av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)

{

#if HAVE_YASM

    int mm_flags = av_get_cpu_flags();



    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {

#if ARCH_X86_32

        if (mm_flags & AV_CPU_FLAG_MMX) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;

        }

#endif



        if (mm_flags & AV_CPU_FLAG_SSE2) {

            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;

        }

    }

#endif

}
",0,0,7,0,0,0,1,1,0,1,1,1,1,1,1
14936,qemu,0,"int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,

                              int is_user, int is_softmmu)

{

    uint32_t physical;

    int prot;

    int exception = 0, error_code = 0;

    int access_type;

    int ret = 0;



//    printf(""%s 0\n"", __func__);

    access_type = env->access_type;

    if (env->user_mode_only) {

        /* user mode only emulation */

        ret = -2;

        goto do_fault;

    }

    /* NASTY BUG workaround */

    if (access_type == ACCESS_CODE && rw) {

	printf(""%s: ERROR WRITE CODE ACCESS\n"", __func__);

	access_type = ACCESS_INT;

    }

    ret = get_physical_address(env, &physical, &prot,

                               address, rw, access_type);

    if (ret == 0) {

	ret = tlb_set_page(env, address & ~0xFFF, physical, prot,

			   is_user, is_softmmu);

    } else if (ret < 0) {

    do_fault:

#if defined (DEBUG_MMU)

	if (loglevel > 0)

	    cpu_ppc_dump_state(env, logfile, 0);

#endif

        if (access_type == ACCESS_CODE) {

    ",0,1,8,0,0,0,0,0,0,0,0,0,0,0,0
14942,FFmpeg,1,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
",1,0,4,0,0,0,0,0,0,0,0,0,1,1,1
14951,qemu,0,"static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    unsigned int datalen;



    if (offset < s->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        return fd;

    }



    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);

    s->inode.vdi_size = offset;

    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    close(fd);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
",0,0,4,0,0,0,0,1,1,1,0,1,1,1,1
14982,qemu,0,"static int rndis_parse(USBNetState *s, uint8_t *data, int length)

{

    uint32_t msg_type;

    le32 *tmp = (le32 *) data;



    msg_type = le32_to_cpup(tmp);



    switch (msg_type) {

    case RNDIS_INITIALIZE_MSG:

        s->rndis_state = RNDIS_INITIALIZED;

        return rndis_init_response(s, (rndis_init_msg_type *) data);



    case RNDIS_HALT_MSG:

        s->rndis_state = RNDIS_UNINITIALIZED;

        return 0;



    case RNDIS_QUERY_MSG:

        return rndis_query_response(s, (rndis_query_msg_type *) data, length);



    case RNDIS_SET_MSG:

        return rndis_set_response(s, (rndis_set_msg_type *) data, length);



    case RNDIS_RESET_MSG:

        rndis_clear_responsequeue(s);

        s->out_ptr = s->in_ptr = s->in_len = 0;

        return rndis_reset_response(s, (rndis_reset_msg_type *) data);



    case RNDIS_KEEPALIVE_MSG:

        /* For USB: host does this every 5 seconds */

        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);

    }



    return USB_",0,0,0,0,1,0,0,0,0,0,0,0,0,1,1
15001,FFmpeg,1,"static int sap_write_header(AVFormatContext *s)

{

    struct SAPState *sap = s->priv_data;

    char host[1024], path[1024], url[1024], announce_addr[50] = """";

    char *option_list;

    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;

    AVFormatContext **contexts = NULL;

    int ret = 0;

    struct sockaddr_storage localaddr;

    socklen_t addrlen = sizeof(localaddr);

    int udp_fd;

    AVDictionaryEntry* title = av_dict_get(s->metadata, ""title"", NULL, 0);



    if (!ff_network_init())

        return AVERROR(EIO);



    /* extract hostname and port */

    av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,

                 path, sizeof(path), s->filename);

    if (base_port < 0)

        base_port = 5004;



    /* search for options */

    option_list = strrchr(path, '?');

    if (option_list) {

        char buf[50];

        if (av_find_info_tag(buf, sizeof(buf), ""announce_port"", option_list)) {

            port = strtol(buf, NULL, 10);

        }

",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
15002,FFmpeg,1,"static void hls_prediction_unit(HEVCContext *s, int x0, int y0,

                                int nPbW, int nPbH,

                                int log2_cb_size, int partIdx, int idx)

{

#define POS(c_idx, x, y)                                                              \

    &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \

                           (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)]

    HEVCLocalContext *lc = s->HEVClc;

    int merge_idx = 0;

    struct MvField current_mv = {{{ 0 }}};



    int min_pu_width = s->sps->min_pu_width;



    MvField *tab_mvf = s->ref->tab_mvf;

    RefPicList  *refPicList = s->ref->refPicList;

    HEVCFrame *ref0, *ref1;

    uint8_t *dst0 = POS(0, x0, y0);

    uint8_t *dst1 = POS(1, x0, y0);

    uint8_t *dst2 = POS(2, x0, y0);

    int log2_min_cb_size = s->sps->log2_min_cb_size;

    int min_cb_width     = s->sps->min_cb_width;

    int x_cb             = x0 >> log2_min_cb_size;

    int y_cb        ",0,0,3,0,0,0,0,0,0,0,1,0,0,0,0
15016,qemu,0,"static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)

{

    VirtIOBlock *s = VIRTIO_BLK(vdev);

    VirtIOBlockReq *req;

    MultiReqBuffer mrb = {};



    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start

     * dataplane here instead of waiting for .set_status().

     */

    if (s->dataplane) {

        virtio_blk_data_plane_start(s->dataplane);

        return;

    }



    blk_io_plug(s->blk);



    while ((req = virtio_blk_get_request(s))) {

        virtio_blk_handle_request(req, &mrb);

    }



    if (mrb.num_reqs) {

        virtio_blk_submit_multireq(s->blk, &mrb);

    }



    blk_io_unplug(s->blk);

}
",2,0,2,0,0,1,1,1,1,1,1,1,0,1,1
15051,FFmpeg,0,"static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]];

        tc[1] = tc0_table[index_a][bS[1]];

        tc[2] = tc0_table[index_a][bS[2]];

        tc[3] = tc0_table[index_a][bS[3]];

        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);

    }

}
",0,0,2,0,0,0,1,1,1,1,1,1,0,0,1
15055,qemu,0,"static void realize(DeviceState *d, Error **errp)

{

    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);

    Object *root_container;

    char link_name[256];

    gchar *child_name;

    Error *err = NULL;



    trace_spapr_drc_realize(spapr_drc_index(drc));

    /* NOTE: we do this as part of realize/unrealize due to the fact

     * that the guest will communicate with the DRC via RTAS calls

     * referencing the global DRC index. By unlinking the DRC

     * from DRC_CONTAINER_PATH/<drc_index> we effectively make it

     * inaccessible by the guest, since lookups rely on this path

     * existing in the composition tree

     */

    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);

    snprintf(link_name, sizeof(link_name), ""%x"", spapr_drc_index(drc));

    child_name = object_get_canonical_path_component(OBJECT(drc));

    trace_spapr_drc_realize_child(spapr_drc_index(drc), child_name);

    object_property_add_alias(root_container, link_name,

                              d",0,0,0,0,0,0,0,0,0,1,1,1,1,1,1
15061,qemu,0,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,

                       int insn, int size, int sign)

{

    TCGv_i32 r_asi, r_size, r_sign;



    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(size);

    r_sign = tcg_const_i32(sign);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);

        tcg_gen_trunc_i64_tl(dst, t64);

        tcg_temp_free_i64(t64);

    }

#endif

    tcg_temp_free_i32(r_sign);

    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(r_asi);

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
15066,qemu,0,"static inline float64 ucf64_itod(uint64_t i)

{

    union {

        uint64_t i;

        float64 d;

    } v;



    v.i = i;

    return v.d;

}
",0,0,0,0,0,0,1,1,1,0,1,1,0,0,0
15067,qemu,0,"int tcg_gen_code(TCGContext *s, tcg_insn_unit *gen_code_buf)

{

    int i, oi, oi_next, num_insns;



#ifdef CONFIG_PROFILER

    {

        int n;



        n = s->gen_last_op_idx + 1;

        s->op_count += n;

        if (n > s->op_count_max) {

            s->op_count_max = n;

        }



        n = s->nb_temps;

        s->temp_count += n;

        if (n > s->temp_count_max) {

            s->temp_count_max = n;

        }

    }

#endif



#ifdef DEBUG_DISAS

    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP))) {

        qemu_log(""OP:\n"");

        tcg_dump_ops(s);

        qemu_log(""\n"");

    }

#endif



#ifdef CONFIG_PROFILER

    s->opt_time -= profile_getclock();

#endif



#ifdef USE_TCG_OPTIMIZATIONS

    tcg_optimize(s);

#endif



#ifdef CONFIG_PROFILER

    s->opt_time += profile_getclock();

    s->la_time -= profile_getclock();

#endif



    tcg_liveness_analysis(s);



#ifdef CONFIG_PROFILER

    s->la_time += profile_getclock();

#endif



#ifdef DEBUG_DISAS

    if (unlikely(qemu",0,0,17,0,0,0,1,0,1,0,0,0,1,1,1
15077,qemu,0,"static int ehci_process_itd(EHCIState *ehci,

                            EHCIitd *itd)

{

    USBPort *port;

    USBDevice *dev;

    int ret;

    uint32_t i, j, len, pid, dir, devaddr, endp;

    uint32_t pg, off, ptr1, ptr2, max, mult;



    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);

    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);

    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);

    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);

    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);



    for(i = 0; i < 8; i++) {

        if (itd->transact[i] & ITD_XACT_ACTIVE) {

            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);

            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;

            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);

            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);

            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);



            if (len > max * mult) {

                len = max * mult;

            }



            if (l",1,0,3,0,0,0,0,0,0,0,0,0,1,1,0
15082,qemu,0,"static void qmp_input_pop(Visitor *v, void **obj)

{

    QmpInputVisitor *qiv = to_qiv(v);

    StackObject *tos = QSLIST_FIRST(&qiv->stack);



    assert(tos && tos->qapi == obj);

    QSLIST_REMOVE_HEAD(&qiv->stack, node);

    qmp_input_stack_object_free(tos);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
15094,FFmpeg,1,"static int vmd_read_header(AVFormatContext *s,

                           AVFormatParameters *ap)

{

    VmdDemuxContext *vmd = (VmdDemuxContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    AVStream *st;

    unsigned int toc_offset;

    unsigned char *raw_frame_table;

    int raw_frame_table_size;

    offset_t current_offset;

    int i, j;

    unsigned int total_frames;

    int64_t video_pts_inc = 0;

    int64_t current_video_pts = 0;

    unsigned char chunk[BYTES_PER_FRAME_RECORD];

    int lastframe = 0;



    /* fetch the main header, including the 2 header length bytes */

    url_fseek(pb, 0, SEEK_SET);

    if (get_buffer(pb, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE)

        return AVERROR_IO;



    vmd->audio_sample_counter = 0;

    vmd->audio_frame_divisor = 1;

    vmd->audio_block_align = 1;



    /* start up the decoders */

    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR_NOMEM;

    av_set_pts_info(st, 33, 1, 90000);

    vmd->video_stream_i",0,0,2,0,0,0,0,0,0,1,0,0,0,1,1
15106,FFmpeg,0,"void dsputil_init_arm(DSPContext* c, AVCodecContext *avctx)

{

    int idct_algo= avctx->idct_algo;



    ff_put_pixels_clamped = c->put_pixels_clamped;

    ff_add_pixels_clamped = c->add_pixels_clamped;



    if (avctx->lowres == 0) {

        if(idct_algo == FF_IDCT_AUTO){

#if   HAVE_IPP

            idct_algo = FF_IDCT_IPP;

#elif HAVE_NEON

            idct_algo = FF_IDCT_SIMPLENEON;

#elif HAVE_ARMV6

            idct_algo = FF_IDCT_SIMPLEARMV6;

#elif HAVE_ARMV5TE

            idct_algo = FF_IDCT_SIMPLEARMV5TE;

#else

            idct_algo = FF_IDCT_ARM;

#endif

        }



        if(idct_algo==FF_IDCT_ARM){

            c->idct_put= j_rev_dct_ARM_put;

            c->idct_add= j_rev_dct_ARM_add;

            c->idct    = j_rev_dct_ARM;

            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;

        } else if (idct_algo==FF_IDCT_SIMPLEARM){

            c->idct_put= simple_idct_ARM_put;

            c->idct_add= simple_idct_ARM_add;

            c->idct    = simple_idct_ARM;

           ",0,0,9,0,0,0,0,0,1,1,0,0,1,1,1
15108,FFmpeg,0,"av_cold void ff_h264_free_context(H264Context *h)

{

    int i;



    ff_h264_free_tables(h);



    if (h->DPB) {

        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)

            ff_h264_unref_picture(h, &h->DPB[i]);

        av_freep(&h->DPB);

    }



    h->cur_pic_ptr = NULL;



    for (i = 0; i < h->nb_slice_ctx; i++)

        av_freep(&h->slice_ctx[i].rbsp_buffer);

    av_freep(&h->slice_ctx);

    h->nb_slice_ctx = 0;



    for (i = 0; i < MAX_SPS_COUNT; i++)

        av_freep(h->sps_buffers + i);



    for (i = 0; i < MAX_PPS_COUNT; i++)

        av_freep(h->pps_buffers + i);

}
",4,0,1,0,0,0,0,0,0,0,0,0,0,0,0
15115,qemu,1,"bool aio_poll(AioContext *ctx, bool blocking)

{

    AioHandler *node;

    int i, ret;

    bool progress;

    int64_t timeout;



    aio_context_acquire(ctx);

    progress = false;



    /* aio_notify can avoid the expensive event_notifier_set if

     * everything (file descriptors, bottom halves, timers) will

     * be re-evaluated before the next blocking poll().  This is

     * already true when aio_poll is called with blocking == false;

     * if blocking == true, it is only true after poll() returns,

     * so disable the optimization now.

     */

    if (blocking) {

        atomic_add(&ctx->notify_me, 2);

    }



    ctx->walking_handlers++;



    assert(npfd == 0);



    /* fill pollfds */



    if (!aio_epoll_enabled(ctx)) {

        QLIST_FOREACH(node, &ctx->aio_handlers, node) {

            if (!node->deleted && node->pfd.events

                && aio_node_check(ctx, node->is_external)) {

                add_pollfd(node);

            }

        }

    }



    timeout = block",1,0,8,0,0,0,0,0,0,0,0,0,1,1,1
15124,FFmpeg,1,"int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)

{

    av_assert0(0);


}",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
15125,FFmpeg,1,"static int latm_write_packet(AVFormatContext *s, AVPacket *pkt)

{

    AVIOContext *pb = s->pb;

    PutBitContext bs;

    int i, len;

    uint8_t loas_header[] = ""\x56\xe0\x00"";

    uint8_t *buf = NULL;



    if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM)

        return ff_raw_write_packet(s, pkt);



    if (pkt->size > 2 && pkt->data[0] == 0xff && (pkt->data[1] >> 4) == 0xf) {

        av_log(s, AV_LOG_ERROR, ""ADTS header detected - ADTS will not be incorrectly muxed into LATM\n"");

        return AVERROR_INVALIDDATA;

    }

    if (pkt->size > 0x1fff)

        goto too_large;



    buf = av_malloc(pkt->size+1024);

    if (!buf)

        return AVERROR(ENOMEM);



    init_put_bits(&bs, buf, pkt->size+1024);



    latm_write_frame_header(s, &bs);



    /* PayloadLengthInfo() */

    for (i = 0; i <= pkt->size-255; i+=255)

        put_bits(&bs, 8, 255);



    put_bits(&bs, 8, pkt->size-i);



    /* The LATM payload is written unaligned */



    /* PayloadMux() */

    if (pkt->size ",1,1,5,0,0,0,1,1,1,1,1,1,0,1,1
15132,qemu,1,"static void aio_read_done(void *opaque, int ret)

{

    struct aio_ctx *ctx = opaque;

    struct timeval t2;



    gettimeofday(&t2, NULL);



    if (ret < 0) {

        printf(""readv failed: %s\n"", strerror(-ret));

        goto out;

    }



    if (ctx->Pflag) {

        void *cmp_buf = g_malloc(ctx->qiov.size);



        memset(cmp_buf, ctx->pattern, ctx->qiov.size);

        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {

            printf(""Pattern verification failed at offset %""

                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);

        }

        g_free(cmp_buf);

    }



    if (ctx->qflag) {

        goto out;

    }



    if (ctx->vflag) {

        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);

    }



    /* Finally, report back -- -C gives a parsable format */

    t2 = tsub(t2, ctx->t1);

    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,

                 ctx->qiov.size, 1, ctx->Cflag);

out:

    qemu_io_free(ctx->buf);


    g_free(ctx);

}",0,2,6,0,0,0,1,1,1,0,0,0,0,0,0
15133,FFmpeg,1,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
",1,0,1,0,0,0,0,0,1,0,1,1,0,0,0
15136,qemu,1,"target_phys_addr_t cpu_get_phys_page_debug(CPUState *env, target_ulong addr)

{

    target_ulong pde_addr, pte_addr;

    uint64_t pte;

    target_phys_addr_t paddr;

    uint32_t page_offset;

    int page_size;



    if (env->cr[4] & CR4_PAE_MASK) {

        target_ulong pdpe_addr;

        uint64_t pde, pdpe;



#ifdef TARGET_X86_64

        if (env->hflags & HF_LMA_MASK) {

            uint64_t pml4e_addr, pml4e;

            int32_t sext;



            /* test virtual address sign extension */

            sext = (int64_t)addr >> 47;

            if (sext != 0 && sext != -1)

                return -1;



            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &

                env->a20_mask;

            pml4e = ldq_phys(pml4e_addr);

            if (!(pml4e & PG_PRESENT_MASK))

                return -1;



            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &

                env->a20_mask;

            pdpe = ldq_phys(pdpe_addr);

            if (!",0,0,6,0,0,0,1,0,0,1,0,1,1,1,1
15147,qemu,1,"void spapr_pci_rtas_init(void)

{

    spapr_rtas_register(""read-pci-config"", rtas_read_pci_config);

    spapr_rtas_register(""write-pci-config"", rtas_write_pci_config);

    spapr_rtas_register(""ibm,read-pci-config"", rtas_ibm_read_pci_config);

    spapr_rtas_register(""ibm,write-pci-config"", rtas_ibm_write_pci_config);

    if (msi_supported) {

        spapr_rtas_register(""ibm,query-interrupt-source-number"",

                            rtas_ibm_query_interrupt_source_number);

        spapr_rtas_register(""ibm,change-msi"", rtas_ibm_change_msi);

    }

}
",0,0,1,0,0,0,0,1,1,0,1,0,1,1,1
15173,qemu,0,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)

{

    CompareState *s = container_of(sec_rs, CompareState, sec_rs);



    if (packet_enqueue(s, SECONDARY_IN)) {

        trace_colo_compare_main(""secondary: unsupported packet in"");

    } else {

        /* compare connection */

        g_queue_foreach(&s->conn_list, colo_compare_connection, s);

    }

}
",1,0,1,0,0,0,0,0,0,0,0,0,0,1,1
15201,qemu,1,"FDCtrl *fdctrl_init_isa(DriveInfo **fds)

{

    ISADevice *dev;



    dev = isa_create(""isa-fdc"");

    if (fds[0]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveA"", fds[0]->bdrv);

    }

    if (fds[1]) {

        qdev_prop_set_drive_nofail(&dev->qdev, ""driveB"", fds[1]->bdrv);

    }

    if (qdev_init(&dev->qdev) < 0)

        return NULL;

    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);

}
",0,0,3,0,0,0,1,1,1,1,0,1,1,1,1
15206,FFmpeg,1,"static int asf_read_picture(AVFormatContext *s, int len)

{

    ASFContext *asf       = s->priv_data;

    AVPacket pkt          = { 0 };

    const CodecMime *mime = ff_id3v2_mime_tags;

    enum  AVCodecID id    = AV_CODEC_ID_NONE;

    char mimetype[64];

    uint8_t  *desc = NULL;

    AVStream   *st = NULL;

    int ret, type, picsize, desc_len;

    ASFStream *asf_st;



    /* type + picsize + mime + desc */

    if (len < 1 + 4 + 2 + 2) {

        av_log(s, AV_LOG_ERROR, ""Invalid attached picture size: %d.\n"", len);

        return AVERROR_INVALIDDATA;

    }



    /* picture type */

    type = avio_r8(s->pb);

    len--;

    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {

        av_log(s, AV_LOG_WARNING, ""Unknown attached picture type: %d.\n"", type);

        type = 0;

    }



    /* picture data size */

    picsize = avio_rl32(s->pb);

    len    -= 4;



    /* picture MIME type */

    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));

    while (mime->id ",0,0,2,0,0,1,1,1,1,1,1,1,0,0,0
15209,qemu,1,"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();",0,0,0,0,1,0,1,1,1,0,0,0,0,0,0
15239,qemu,1,"static char *scsibus_get_dev_path(DeviceState *dev)

{

    SCSIDevice *d = DO_UPCAST(SCSIDevice, qdev, dev);

    DeviceState *hba = dev->parent_bus->parent;

    char *id = NULL;



    if (hba && hba->parent_bus && hba->parent_bus->info->get_dev_path) {

        id = hba->parent_bus->info->get_dev_path(hba);

    }

    if (id) {

        return g_strdup_printf(""%s/%d:%d:%d"", id, d->channel, d->id, d->lun);

    } else {

        return g_strdup_printf(""%d:%d:%d"", d->channel, d->id, d->lun);

    }

}
",0,0,2,0,0,0,1,1,1,1,1,0,1,0,0
15249,FFmpeg,0,"static int eval_lpc_coeffs(const float *in, float *tgt, int n)

{

    int x, y;

    double f0, f1, f2;



    if (in[n] == 0)

        return 0;



    if ((f0 = *in) <= 0)

        return 0;



    in--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= n; x++) {

        f1 = in[x+1];



        for (y=0; y < x - 1; y++)

            f1 += in[x-y]*tgt[y];



        tgt[x-1] = f2 = -f1/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = tgt[y] + tgt[x-y-2]*f2;

            tgt[x-y-2] += tgt[y]*f2;

            tgt[y] = temp;

        }

        if ((f0 += f1*f2) < 0)

            return 0;

    }



    return 1;

}
",3,0,3,0,0,0,0,0,0,1,0,0,1,1,1
15252,FFmpeg,0,"int swr_init(struct SwrContext *s){

    s->in_buffer_index= 0;

    s->in_buffer_count= 0;

    s->resample_in_constraint= 0;

    free_temp(&s->postin);

    free_temp(&s->midbuf);

    free_temp(&s->preout);

    free_temp(&s->in_buffer);

    free_temp(&s->dither);

    swri_audio_convert_free(&s-> in_convert);

    swri_audio_convert_free(&s->out_convert);

    swri_audio_convert_free(&s->full_convert);

    swri_rematrix_free(s);



    s->flushed = 0;



    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){

        av_log(s, AV_LOG_ERROR, ""Requested input sample format %d is invalid\n"", s->in_sample_fmt);

        return AVERROR(EINVAL);

    }

    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){

        av_log(s, AV_LOG_ERROR, ""Requested output sample format %d is invalid\n"", s->out_sample_fmt);

        return AVERROR(EINVAL);

    }



    //FIXME should we allow/support using FLT on material that doesnt need it ?

    if(av_get_planar_sample_fmt(s->in_sample_fmt) <= AV_SAMPLE_FMT_S16P || s->int_sample_fmt==A",2,0,3,0,0,0,0,1,0,1,1,0,1,1,1
15260,qemu,1,"void pc_hot_add_cpu(const int64_t id, Error **errp)
{
    DeviceState *icc_bridge;
    int64_t apic_id = x86_cpu_apic_id_from_index(id);
    if (cpu_exists(apic_id)) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", it already exists"", id);
    if (id >= max_cpus) {
        error_setg(errp, ""Unable to add CPU: %"" PRIi64
                   "", max allowed: %d"", id, max_cpus - 1);
    icc_bridge = DEVICE(object_resolve_path_type(""icc-bridge"",
                                                 TYPE_ICC_BRIDGE, NULL));
    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);",0,0,2,0,0,0,0,0,0,1,1,1,1,1,1
15288,qemu,1,"static void xlnx_ep108_init(MachineState *machine)

{

    XlnxEP108 *s = g_new0(XlnxEP108, 1);

    Error *err = NULL;



    object_initialize(&s->soc, sizeof(s->soc), TYPE_XLNX_ZYNQMP);

    object_property_add_child(OBJECT(machine), ""soc"", OBJECT(&s->soc),

                              &error_abort);



    object_property_set_bool(OBJECT(&s->soc), true, ""realized"", &err);

    if (err) {

        error_report(""%s"", error_get_pretty(err));

        exit(1);

    }



    if (machine->ram_size > EP108_MAX_RAM_SIZE) {

        error_report(""WARNING: RAM size "" RAM_ADDR_FMT "" above max supported, ""

                     ""reduced to %llx"", machine->ram_size, EP108_MAX_RAM_SIZE);

        machine->ram_size = EP108_MAX_RAM_SIZE;

    }



    if (machine->ram_size <= 0x08000000) {

        qemu_log(""WARNING: RAM size "" RAM_ADDR_FMT "" is small for EP108"",

                 machine->ram_size);

    }



    memory_region_allocate_system_memory(&s->ddr_ram, NULL, ""ddr-ram"",

                                      ",1,0,3,0,0,0,1,1,1,1,0,1,1,1,0
15290,FFmpeg,1,"static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,

                        AVFilterInOut **open_outputs, AVClass *log_ctx)

{

    int pad = 0;



    while (**buf == '[') {

        char *name = parse_link_name(buf, log_ctx);

        AVFilterInOut *match;



        if (!name)

            return AVERROR(EINVAL);



        /* First check if the label is not in the open_outputs list */

        match = extract_inout(name, open_outputs);



        if (match) {

            av_free(name);

        } else {

            /* Not in the list, so add it as an input */

            match = av_mallocz(sizeof(AVFilterInOut));

            match->name    = name;

            match->pad_idx = pad;

        }



        insert_inout(curr_inputs, match);



        *buf += strspn(*buf, WHITESPACES);

        pad++;

    }



    return pad;

}
",0,0,2,0,0,1,0,0,0,1,1,1,0,1,0
15301,FFmpeg,1,"void vp8_mc_chroma(VP8Context *s, VP8ThreadData *td, uint8_t *dst1, uint8_t *dst2,

                   ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off,

                   int block_w, int block_h, int width, int height, int linesize,

                   vp8_mc_func mc_func[3][3])

{

    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];



    if (AV_RN32A(mv)) {

        int mx = mv->x&7, mx_idx = subpel_idx[0][mx];

        int my = mv->y&7, my_idx = subpel_idx[0][my];



        x_off += mv->x >> 3;

        y_off += mv->y >> 3;



        // edge emulation

        src1 += y_off * linesize + x_off;

        src2 += y_off * linesize + x_off;

        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 3, 0);

        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||

            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {

            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src1 - my_idx * linesize - mx_idx, linesize",0,0,2,0,0,0,0,0,0,0,0,0,0,0,1
15321,FFmpeg,0,"static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, y;

    int r, g, b;

    uint8_t *lum, *cb, *cr;

    const uint8_t *p;



    lum = dst->data[0];

    cb = dst->data[1];

    cr = dst->data[2];



    src_wrap = src->linesize[0] - width * BPP;

    p = src->data[0];

    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, p);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);

            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);

            cb++;

            cr++;

            lum++;

        }

        p += src_wrap;

        lum += dst->linesize[0] - width;

        cb += dst->linesize[1] - width;

        cr += dst->linesize[2] - width;

    }

}
",2,0,0,0,0,0,0,0,0,0,0,0,1,1,1
15341,qemu,0,"static char *pcibus_get_fw_dev_path(DeviceState *dev)

{

    PCIDevice *d = (PCIDevice *)dev;

    char path[50], name[33];

    int off;



    off = snprintf(path, sizeof(path), ""%s@%x"",

                   pci_dev_fw_name(dev, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(path);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
15368,qemu,1,"static int qio_channel_websock_handshake_send_response(QIOChannelWebsock *ioc,

                                                       const char *key,

                                                       Error **errp)

{

    char combined_key[QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +

                      QIO_CHANNEL_WEBSOCK_GUID_LEN + 1];

    char *accept = NULL, *response = NULL;

    size_t responselen;



    g_strlcpy(combined_key, key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1);

    g_strlcat(combined_key, QIO_CHANNEL_WEBSOCK_GUID,

              QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +

              QIO_CHANNEL_WEBSOCK_GUID_LEN + 1);



    /* hash and encode it */

    if (qcrypto_hash_base64(QCRYPTO_HASH_ALG_SHA1,

                            combined_key,

                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +

                            QIO_CHANNEL_WEBSOCK_GUID_LEN,

                            &accept,

                            errp) < 0) {

        return -1;

    }



    response = g",0,0,1,0,0,0,1,1,1,1,1,1,1,0,1
15373,qemu,1,"void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,

                  int dst_x, int dst_y, int w, int h)

{

    DisplayState *s = con->ds;

    DisplayChangeListener *dcl;



    if (!qemu_console_is_visible(con)) {

        return;

    }

    QLIST_FOREACH(dcl, &s->listeners, next) {

        if (con != (dcl->con ? dcl->con : active_console)) {

            continue;

        }

        if (dcl->ops->dpy_gfx_copy) {

            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);

        } else { /* TODO */

            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);

        }

    }

}
",0,0,3,0,0,0,1,1,1,1,1,1,1,0,1
15388,qemu,1,"static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr,
                                    TCGArg *args, TCGOpDef *tcg_op_defs)
{
    int i, nb_ops, op_index, nb_temps, nb_globals, nb_call_args;
    TCGOpcode op;
    const TCGOpDef *def;
    TCGArg *gen_args;
    TCGArg tmp;
    TCGCond cond;
    /* Array VALS has an element for each temp.
       If this temp holds a constant then its value is kept in VALS' element.
       If this temp is a copy of other ones then the other copies are
       available through the doubly linked circular list. */
    nb_temps = s->nb_temps;
    nb_globals = s->nb_globals;
    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
    nb_ops = tcg_opc_ptr - gen_opc_buf;
    gen_args = args;
    for (op_index = 0; op_index < nb_ops; op_index++) {
        op = gen_opc_buf[op_index];
        def = &tcg_op_defs[op];
        /* Do copy propagation */
        if (op == INDEX_op_call) {
            int nb_oargs = args[0] >> 16;
            int nb_iargs = args[0] ",2,0,1,0,0,0,0,0,0,0,0,0,0,0,0
15389,qemu,1,"static void vnc_connect(VncDisplay *vd, int csock,

                        bool skipauth, bool websocket)

{

    VncState *vs = g_malloc0(sizeof(VncState));

    int i;



    vs->csock = csock;

    vs->vd = vd;



    if (skipauth) {

	vs->auth = VNC_AUTH_NONE;

	vs->subauth = VNC_AUTH_INVALID;

    } else {

        if (websocket) {

            vs->auth = vd->ws_auth;

            vs->subauth = VNC_AUTH_INVALID;

        } else {

            vs->auth = vd->auth;

            vs->subauth = vd->subauth;

        }

    }

    VNC_DEBUG(""Client sock=%d ws=%d auth=%d subauth=%d\n"",

              csock, websocket, vs->auth, vs->subauth);



    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));

    for (i = 0; i < VNC_STAT_ROWS; ++i) {

        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));

    }



    VNC_DEBUG(""New client on socket %d\n"", csock);

    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);

    qemu_set_nonblock(vs->csock);

    if (webs",1,0,3,0,0,0,0,0,0,0,1,0,1,1,1
15401,FFmpeg,0,"static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;



  fail:

    av_free(res);

    return AVERROR(EIO);

}
",1,2,5,0,0,0,0,0,0,1,1,0,0,1,0
15411,qemu,0,"int qemu_opts_print(QemuOpts *opts, void *dummy)

{

    QemuOpt *opt;



    fprintf(stderr, ""%s: %s:"", opts->list->name,

            opts->id ? opts->id : ""<noid>"");

    TAILQ_FOREACH(opt, &opts->head, next) {

        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);

    }

    fprintf(stderr, ""\n"");

    return 0;

}
",0,0,0,0,0,0,0,0,0,1,0,1,0,0,0
15420,FFmpeg,0,"static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,

                                AVFrame *picture)

{

    int compno, reslevelno, bandno;

    int x, y;



    uint8_t *line;

    Jpeg2000T1Context t1;



    /* Loop on tile components */

    for (compno = 0; compno < s->ncomponents; compno++) {

        Jpeg2000Component *comp     = tile->comp + compno;

        Jpeg2000CodingStyle *codsty = tile->codsty + compno;



        /* Loop on resolution levels */

        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {

            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;

            /* Loop on bands */

            for (bandno = 0; bandno < rlevel->nbands; bandno++) {

                int nb_precincts, precno;

                Jpeg2000Band *band = rlevel->band + bandno;

                int cblkno = 0, bandpos;



                bandpos = bandno + (reslevelno > 0);



                if (band->coord[0][0] == band->coord[0][1] ||

      ",3,0,1,0,0,0,0,0,0,1,0,1,1,1,1
15434,qemu,0,"void qemu_run_all_timers(void)

{

    alarm_timer->pending = 0;



    /* rearm timer, if not periodic */

    if (alarm_timer->expired) {

        alarm_timer->expired = 0;

        qemu_rearm_alarm_timer(alarm_timer);

    }



    /* vm time timers */

    qemu_run_timers(vm_clock);

    qemu_run_timers(rt_clock);

    qemu_run_timers(host_clock);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,0
15449,qemu,0,"static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,

                                           struct XenDevOps *ops)

{

    struct XenDevice *xendev;



    xendev = xen_be_find_xendev(type, dom, dev);

    if (xendev) {

        return xendev;

    }



    /* init new xendev */

    xendev = g_malloc0(ops->size);

    xendev->type  = type;

    xendev->dom   = dom;

    xendev->dev   = dev;

    xendev->ops   = ops;



    snprintf(xendev->be, sizeof(xendev->be), ""backend/%s/%d/%d"",

             xendev->type, xendev->dom, xendev->dev);

    snprintf(xendev->name, sizeof(xendev->name), ""%s-%d"",

             xendev->type, xendev->dev);



    xendev->debug      = debug;

    xendev->local_port = -1;



    xendev->evtchndev = xen_xc_evtchn_open(NULL, 0);

    if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) {

        xen_be_printf(NULL, 0, ""can't open evtchn device\n"");

        g_free(xendev);

        return NULL;

    }

    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD,",0,0,2,0,0,0,0,0,0,0,0,0,1,0,1
15457,qemu,0,"static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y)

{

    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);

    QDict *dict;



    if (type == JSON_OPERATOR) {

        switch (qstring_get_str(token)[0]) {

        case '{':

            parser->brace_count++;

            break;

        case '}':

            parser->brace_count--;

            break;

        case '[':

            parser->bracket_count++;

            break;

        case ']':

            parser->bracket_count--;

            break;

        default:

            break;

        }

    }



    dict = qdict_new();

    qdict_put(dict, ""type"", qint_from_int(type));

    QINCREF(token);

    qdict_put(dict, ""token"", token);

    qdict_put(dict, ""x"", qint_from_int(x));

    qdict_put(dict, ""y"", qint_from_int(y));



    parser->token_size += token->length;



    qlist_append(parser->tokens, dict);



    if (type == JSON_ERROR) {

        goto out_emit_bad;",0,1,2,0,1,0,0,0,0,0,0,0,1,1,1
15482,qemu,0,"static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size)

{

    uint64_t sz;

    const char *mem_str;

    const char *maxmem_str, *slots_str;

    const ram_addr_t default_ram_size = (ram_addr_t)DEFAULT_RAM_SIZE *

                                        1024 * 1024;

    QemuOpts *opts = qemu_find_opts_singleton(""memory"");



    sz = 0;

    mem_str = qemu_opt_get(opts, ""size"");

    if (mem_str) {

        if (!*mem_str) {

            error_report(""missing 'size' option value"");

            exit(EXIT_FAILURE);

        }



        sz = qemu_opt_get_size(opts, ""size"", ram_size);



        /* Fix up legacy suffix-less format */

        if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {

            uint64_t overflow_check = sz;



            sz <<= 20;

            if ((sz >> 20) != overflow_check) {

                error_report(""too large 'size' option value"");

                exit(EXIT_FAILURE);

            }

        }

    }



    /* backward compatibility behaviour for",1,0,4,0,0,0,0,0,0,0,0,0,0,0,0
15486,qemu,0,"static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)

{

    /* We don't actually refresh here, but just return data queried in

     * iscsi_open(): iscsi targets don't change their limits. */



    IscsiLun *iscsilun = bs->opaque;

    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;



    bs->request_alignment = iscsilun->block_size;



    if (iscsilun->bl.max_xfer_len) {

        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);

    }



    if (max_xfer_len * iscsilun->block_size < INT_MAX) {

        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;

    }



    if (iscsilun->lbp.lbpu) {

        if (iscsilun->bl.max_unmap < 0xffffffff) {

            bs->bl.max_discard =

                sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);

        }

        bs->bl.discard_alignment =

            sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);

    } else {

        bs->bl.discard_alignment = iscsilun->block_size >> BD",1,0,4,0,0,0,0,0,0,0,0,1,0,0,0
15492,qemu,0,"static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)

{

    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
15495,qemu,0,"void ide_atapi_cmd(IDEState *s)

{

    uint8_t *buf;



    buf = s->io_buffer;

#ifdef DEBUG_IDE_ATAPI

    {

        int i;

        printf(""ATAPI limit=0x%x packet:"", s->lcyl | (s->hcyl << 8));

        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {

            printf("" %02x"", buf[i]);

        }

        printf(""\n"");

    }

#endif

    /*

     * If there's a UNIT_ATTENTION condition pending, only command flagged with

     * ALLOW_UA are allowed to complete. with other commands getting a CHECK

     * condition response unless a higher priority status, defined by the drive

     * here, is pending.

     */

    if (s->sense_key == UNIT_ATTENTION &&

        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {

        ide_atapi_cmd_check_status(s);

        return;

    }

    /*

     * When a CD gets changed, we have to report an ejected state and

     * then a loaded state to guests so that they detect tray

     * open/close and media change events.  Guests that do not use

     * GET_EVENT_STATU",1,0,3,0,0,0,0,0,0,0,0,0,0,0,0
15515,FFmpeg,1,"void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,

                                int nPbH, int log2_cb_size, int part_idx,

                                int merge_idx, MvField *mv)

{

    int singleMCLFlag = 0;

    int nCS = 1 << log2_cb_size;

    LOCAL_ALIGNED(4, MvField, mergecand_list, [MRG_MAX_NUM_CANDS]);

    int nPbW2 = nPbW;

    int nPbH2 = nPbH;

    HEVCLocalContext *lc = &s->HEVClc;



    memset(mergecand_list, 0, MRG_MAX_NUM_CANDS * sizeof(*mergecand_list));



    if (s->pps->log2_parallel_merge_level > 2 && nCS == 8) {

        singleMCLFlag = 1;

        x0            = lc->cu.x;

        y0            = lc->cu.y;

        nPbW          = nCS;

        nPbH          = nCS;

        part_idx      = 0;

    }



    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);

    derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,

                                    singleMCLFlag, part_idx,

                                    merge_idx, mergecand_l",0,0,1,0,0,0,0,0,1,1,1,1,1,0,0
15517,qemu,1,"int s390_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs,

                              int cpuid, void *opaque)

{

    S390CPU *cpu = S390_CPU(cs);

    return s390x_write_all_elf64_notes(""CORE"", f, cpu, cpuid, opaque);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
15520,FFmpeg,0,"static void encode_clnpass(Jpeg2000T1Context *t1, int width, int height, int bandno, int *nmsedec, int bpno)

{

    int y0, x, y, mask = 1 << (bpno + NMSEDEC_FRACBITS);

    for (y0 = 0; y0 < height; y0 += 4)

        for (x = 0; x < width; x++){

            if (y0 + 3 < height && !(

            (t1->flags[y0+1][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||

            (t1->flags[y0+2][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||

            (t1->flags[y0+3][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||

            (t1->flags[y0+4][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG))))

            {

                // aggregation mode

                int rlen;

                for (rlen = 0; rlen < 4; rlen++)

                    if (t1->data[y0+rlen][x] & mask)

                        break;

                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_RL, rlen != 4);

                if (rlen == 4)

              ",3,0,3,0,0,0,1,0,1,0,0,0,1,1,1
15521,qemu,0,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,

                                       target_ulong *pte1p,

                                       int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & HPTE64_R_R)) {

        /* Update accessed flag */

        *pte1p |= HPTE64_R_R;

        store = 1;

    }

    if (!(*pte1p & HPTE64_R_C)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= HPTE64_R_C;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,1,1
15524,qemu,0,"BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,

                           QEMUSGList *sg, uint64_t sector,

                           void (*cb)(void *opaque, int ret), void *opaque)

{

    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,

                       DMA_DIRECTION_TO_DEVICE);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
15530,qemu,0,"static int discard_single_l2(BlockDriverState *bs, uint64_t offset,

    unsigned int nb_clusters, enum qcow2_discard_type type, bool full_discard)

{

    BDRVQcow2State *s = bs->opaque;

    uint64_t *l2_table;

    int l2_index;

    int ret;

    int i;



    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);

    if (ret < 0) {

        return ret;

    }



    /* Limit nb_clusters to one L2 table */

    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);



    for (i = 0; i < nb_clusters; i++) {

        uint64_t old_l2_entry;



        old_l2_entry = be64_to_cpu(l2_table[l2_index + i]);



        /*

         * If full_discard is false, make sure that a discarded area reads back

         * as zeroes for v3 images (we cannot do it for v2 without actually

         * writing a zero-filled buffer). We can skip the operation if the

         * cluster is already marked as zero, or if it's unallocated and we

         * don't have a backing file.

         *

         * TODO We might want ",3,0,3,0,0,0,0,0,0,1,0,0,0,0,0
15534,qemu,0,"static int64_t qemu_archipelago_getlength(BlockDriverState *bs)

{

    int64_t ret;

    BDRVArchipelagoState *s = bs->opaque;



    ret = archipelago_volume_info(s);

    return ret;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
15535,qemu,0,"static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,

                                    sPAPRMachineState *spapr,

                                    uint32_t token, uint32_t nargs,

                                    target_ulong args, uint32_t nret,

                                    target_ulong rets)

{

    sPAPRPHBState *sphb;

    sPAPRPHBClass *spc;

    PCIDevice *pdev;

    uint32_t addr, option;

    uint64_t buid;

    int ret;



    if ((nargs != 4) || (nret != 1)) {

        goto param_error_exit;

    }



    buid = rtas_ldq(args, 1);

    addr = rtas_ld(args, 0);

    option = rtas_ld(args, 3);



    sphb = spapr_pci_find_phb(spapr, buid);

    if (!sphb) {

        goto param_error_exit;

    }



    pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus,

                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);

    if (!pdev || !object_dynamic_cast(OBJECT(pdev), ""vfio-pci"")) {

        goto param_error_exit;

    }



    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);

    if",0,3,4,0,0,0,0,0,0,0,0,0,1,1,1
15537,qemu,0,"int qemu_acl_remove(qemu_acl *acl,

                    const char *match)

{

    qemu_acl_entry *entry;

    int i = 0;



    TAILQ_FOREACH(entry, &acl->entries, next) {

        i++;

        if (strcmp(entry->match, match) == 0) {

            TAILQ_REMOVE(&acl->entries, entry, next);

            return i;

        }

    }

    return -1;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
15549,qemu,0,"static void ac97_initfn (PCIDevice *dev)

{

    PCIAC97LinkState *d = DO_UPCAST (PCIAC97LinkState, dev, dev);

    AC97LinkState *s = &d->ac97;

    uint8_t *c = d->dev.config;



    s->pci_dev = &d->dev;

    pci_config_set_vendor_id (c, PCI_VENDOR_ID_INTEL); /* ro */

    pci_config_set_device_id (c, PCI_DEVICE_ID_INTEL_82801AA_5); /* ro */



    c[0x04] = 0x00;      /* pcicmd pci command rw, ro */

    c[0x05] = 0x00;



    c[0x06] = 0x80;      /* pcists pci status rwc, ro */

    c[0x07] = 0x02;



    c[0x08] = 0x01;      /* rid revision ro */

    c[0x09] = 0x00;      /* pi programming interface ro */

    pci_config_set_class (c, PCI_CLASS_MULTIMEDIA_AUDIO); /* ro */

    c[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; /* headtyp header type ro */



    c[0x10] = 0x01;      /* nabmar native audio mixer base

                            address rw */

    c[0x11] = 0x00;

    c[0x12] = 0x00;

    c[0x13] = 0x00;



    c[0x14] = 0x01;      /* nabmbar native audio bus mastering

                       ",0,0,0,0,0,0,1,1,1,0,0,0,1,0,0
15552,FFmpeg,0,"static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    CookParseContext *s = s1->priv_data;



    if (s->duration)

        s1->duration = s->duration;

    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)

        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
15555,FFmpeg,0,"static void add_codec(FFServerStream *stream, AVCodecContext *av,

                      FFServerConfig *config)

{

    AVStream *st;

    AVDictionary **opts, *recommended = NULL;

    char *enc_config;



    if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams))

        return;



    opts = av->codec_type == AVMEDIA_TYPE_AUDIO ?

           &config->audio_opts : &config->video_opts;

    av_dict_copy(&recommended, *opts, 0);

    av_opt_set_dict2(av->priv_data, opts, AV_OPT_SEARCH_CHILDREN);

    av_opt_set_dict2(av, opts, AV_OPT_SEARCH_CHILDREN);

    if (av_dict_count(*opts))

        av_log(NULL, AV_LOG_WARNING,

               ""Something is wrong, %d options are not set!\n"", av_dict_count(*opts));



    if (config->stream_use_defaults) {

    //TODO: reident

    /* compute default parameters */

    switch(av->codec_type) {

    case AVMEDIA_TYPE_AUDIO:

        if (av->bit_rate == 0) {

            av->bit_rate = 64000;

            av_dict_set_int(&recommended, ""ab"", av->bit_rate, 0);

      ",0,0,4,0,1,0,0,0,0,1,1,0,1,0,1
15582,qemu,1,"static void qmp_output_end_struct(Visitor *v, Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    QObject *value = qmp_output_pop(qov);

    assert(qobject_type(value) == QTYPE_QDICT);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
15589,FFmpeg,1,"void compute_images_mse_16bit(PSNRContext *s,

                        const uint8_t *main_data[4], const int main_linesizes[4],

                        const uint8_t *ref_data[4], const int ref_linesizes[4],

                        int w, int h, double mse[4])

{

    int i, c, j;



    for (c = 0; c < s->nb_components; c++) {

        const int outw = s->planewidth[c];

        const int outh = s->planeheight[c];

        const uint16_t *main_line = (uint16_t *)main_data[c];

        const uint16_t *ref_line = (uint16_t *)ref_data[c];

        const int ref_linesize = ref_linesizes[c] / 2;

        const int main_linesize = main_linesizes[c] / 2;

        uint64_t m = 0;



        for (i = 0; i < outh; i++) {

            for (j = 0; j < outw; j++)

                m += pow2(main_line[j] - ref_line[j]);

            ref_line += ref_linesize;

            main_line += main_linesize;

        }

        mse[c] = m / (double)(outw * outh);

    }

}
",3,0,0,0,0,0,0,1,1,0,0,0,1,0,1
15594,qemu,1,"putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)

{

    uint32_t sum;



    if (cse && cse < n)

        n = cse + 1;

    if (sloc < n-1) {

        sum = net_checksum_add(n-css, data+css);

        stw_be_p(data + sloc, net_checksum_finish(sum));

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
15615,qemu,0,"uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,

                       uint32_t r3)

{

    uintptr_t ra = GETPC();

    uint64_t destlen = get_length(env, r1 + 1);

    uint64_t dest = get_address(env, r1);

    uint64_t srclen = get_length(env, r3 + 1);

    uint64_t src = get_address(env, r3);

    uint8_t pad = a2 & 0xff;

    uint32_t cc = 0;



    if (!(destlen || srclen)) {

        return cc;

    }



    if (srclen > destlen) {

        srclen = destlen;

    }



    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {

        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;

        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;

        if (v1 != v2) {

            cc = (v1 < v2) ? 1 : 2;

            break;

        }

    }



    set_length(env, r1 + 1, destlen);

    /* can't use srclen here, we trunc'ed it */

    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);

    set_address(env, r1, dest);

    set_address(env",1,0,3,0,0,0,0,0,0,0,0,0,0,0,0
15634,qemu,0,"void *bios_linker_loader_cleanup(GArray *linker)

{

    return g_array_free(linker, false);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
15644,qemu,0,"const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,

                                             hwaddr ptex, int n)

{

    ppc_hash_pte64_t *hptes = NULL;

    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;



    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {

        /*

         * HTAB is controlled by KVM. Fetch into temporary buffer

         */

        hptes = g_malloc(HASH_PTEG_SIZE_64);

        kvmppc_read_hptes(hptes, ptex, n);

    } else if (cpu->env.external_htab) {

        /*

         * HTAB is controlled by QEMU. Just point to the internally

         * accessible PTEG.

         */

        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);

    } else if (cpu->env.htab_base) {

        hwaddr plen = n * HASH_PTE_SIZE_64;

        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,

                                 &plen, false);

        if (plen < (n * HASH_PTE_SIZE_64)) {

            hw_error(""%s: Unable to map all requested H",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
15653,qemu,0,"static inline bool regime_translation_disabled(CPUARMState *env,

                                               ARMMMUIdx mmu_idx)

{

    if (arm_feature(env, ARM_FEATURE_M)) {

        switch (env->v7m.mpu_ctrl &

                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {

        case R_V7M_MPU_CTRL_ENABLE_MASK:

            /* Enabled, but not for HardFault and NMI */

            return mmu_idx == ARMMMUIdx_MNegPri ||

                mmu_idx == ARMMMUIdx_MSNegPri;

        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:

            /* Enabled for all cases */

            return false;

        case 0:

        default:

            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but

             * we warned about that in armv7m_nvic.c when the guest set it.

             */

            return true;

        }

    }



    if (mmu_idx == ARMMMUIdx_S2NS) {

        return (env->cp15.hcr_el2 & HCR_VM) == 0;

    }

    return (regime_sctlr(env, mmu_idx) & SCTLR_",0,0,2,0,1,0,0,0,0,0,0,0,0,0,0
15654,qemu,0,"static void build_processor_devices(Aml *sb_scope, unsigned acpi_cpus,

                                    AcpiCpuInfo *cpu, AcpiPmInfo *pm)

{

    int i;

    Aml *dev;

    Aml *crs;

    Aml *pkg;

    Aml *field;

    Aml *ifctx;

    Aml *method;



    /* The current AML generator can cover the APIC ID range [0..255],

     * inclusive, for VCPU hotplug. */

    QEMU_BUILD_BUG_ON(ACPI_CPU_HOTPLUG_ID_LIMIT > 256);

    g_assert(acpi_cpus <= ACPI_CPU_HOTPLUG_ID_LIMIT);



    /* create PCI0.PRES device and its _CRS to reserve CPU hotplug MMIO */

    dev = aml_device(""PCI0."" stringify(CPU_HOTPLUG_RESOURCE_DEVICE));

    aml_append(dev, aml_name_decl(""_HID"", aml_eisaid(""PNP0A06"")));

    aml_append(dev,

        aml_name_decl(""_UID"", aml_string(""CPU Hotplug resources""))

    );

    /* device present, functioning, decoding, not shown in UI */

    aml_append(dev, aml_name_decl(""_STA"", aml_int(0xB)));

    crs = aml_resource_template();

    aml_append(crs,

        aml_io(AML_DECODE16, pm->cpu_hp_io_base",1,0,2,0,0,0,1,1,0,0,0,0,1,1,0
15655,qemu,0,"e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)

{

    E1000State *s = opaque;

    unsigned int index = (addr & 0x1ffff) >> 2;



    if (index < NREADOPS && macreg_readops[index])

    {

        return macreg_readops[index](s, index);

    }

    DBGOUT(UNKNOWN, ""MMIO unknown read addr=0x%08x\n"", index<<2);

    return 0;

}
",0,0,1,0,0,0,0,0,0,0,1,0,1,1,1
15664,qemu,1,"static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)

{

    uint32_t len;



    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {

        DPRINTF(s, 1,

                ""usb-ccid: not sending apdu to client, no card connected\n"");

        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);

        return;

    }

    len = le32_to_cpu(recv->hdr.dwLength);

    DPRINTF(s, 1, ""%s: seq %d, len %d\n"", __func__,

                recv->hdr.bSeq, len);

    ccid_add_pending_answer(s, (CCID_Header *)recv);

    if (s->card) {

        ccid_card_apdu_from_guest(s->card, recv->abData, len);

    } else {

        DPRINTF(s, D_WARN, ""warning: discarded apdu\n"");

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
15679,FFmpeg,0,"void ff_h264_pred_init_x86(H264PredContext *h, int codec_id)

{

    mm_flags = mm_support();



#if HAVE_YASM

    if (mm_flags & FF_MM_MMX) {

        h->pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_mmx;

        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_mmx;

        h->pred8x8  [VERT_PRED8x8] = ff_pred8x8_vertical_mmx;

        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmx;

        if (codec_id == CODEC_ID_VP8) {

            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_mmx;

            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_mmx;

            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_mmx;

        }

    }



    if (mm_flags & FF_MM_MMX2) {

        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_mmxext;

        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_mmxext;

        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmxext;

        h->pred4x4  [DC_PRED     ] = ff_pred4x4_dc_mmxext;

        if (codec_id == CODEC_ID_VP8) {

            h->pred16x1",0,0,5,0,0,0,0,1,1,1,1,0,0,0,1
15690,qemu,1,"static inline abi_long target_to_host_timespec(struct timespec *host_ts,

                                               abi_ulong target_addr)

{

    struct target_timespec *target_ts;



    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))

        return -TARGET_EFAULT;

    host_ts->tv_sec = tswapal(target_ts->tv_sec);

    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);

    unlock_user_struct(target_ts, target_addr, 0);

    return 0;

}
",0,0,1,0,0,0,1,1,1,1,1,1,0,0,1
15696,qemu,0,"void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)

{

}
",0,0,0,0,0,0,0,0,0,0,1,0,1,1,1
15723,FFmpeg,0,"static void decode_delta_l(uint8_t *dst,

                           const uint8_t *buf, const uint8_t *buf_end,

                           int w, int flag, int bpp, int dst_size)

{

    GetByteContext off0, off1, dgb, ogb;

    PutByteContext pb;

    unsigned poff0, poff1;

    int i, k, dstpitch;

    int planepitch_byte = (w + 7) / 8;

    int planepitch = ((w + 15) / 16) * 2;

    int pitch = planepitch * bpp;



    if (buf_end - buf <= 64)

        return;



    bytestream2_init(&off0, buf, buf_end - buf);

    bytestream2_init(&off1, buf + 32, buf_end - (buf + 32));

    bytestream2_init_writer(&pb, dst, dst_size);



    dstpitch = flag ? (((w + 7) / 8) * bpp): 2;



    for (k = 0; k < bpp; k++) {

        poff0 = bytestream2_get_be32(&off0);

        poff1 = bytestream2_get_be32(&off1);



        if (!poff0)

            continue;



        if (2LL * poff0 >= buf_end - buf)

            return;



        if (2LL * poff1 >= buf_end - buf)

            return;



        bytestream2_init(&dgb, ",1,0,4,0,0,0,0,0,0,0,1,0,0,0,0
15728,qemu,0,"static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    intel_hda_reg_write(d, reg, val, 0xff);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
15775,qemu,0,"void serial_realize_core(SerialState *s, Error **errp)

{

    if (!qemu_chr_fe_backend_connected(&s->chr)) {

        error_setg(errp, ""Can't create serial device, empty char device"");

        return;

    }



    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);



    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);

    qemu_register_reset(serial_reset, s);



    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,

                             serial_event, NULL, s, NULL, true);

    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);

    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);

    serial_reset(s);

}
",0,0,7,0,0,0,0,0,0,0,0,0,0,0,0
15779,qemu,0,"static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,

                                target_ulong eaddr, int rw, int access_type)

{

    int ret;



#if 0

    qemu_log(""%s\n"", __func__);

#endif

    if ((access_type == ACCESS_CODE && msr_ir == 0) ||

        (access_type != ACCESS_CODE && msr_dr == 0)) {

        if (env->mmu_model == POWERPC_MMU_BOOKE) {

            /* The BookE MMU always performs address translation. The

               IS and DS bits only affect the address space.  */

            ret = mmubooke_get_physical_address(env, ctx, eaddr,

                                                rw, access_type);

        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {

            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,

                                                   access_type);

        } else {

            /* No address translation.  */

            ret = check_physical(env, ctx, eaddr, rw);

        }

    } else {

        ret = -1;

        switch ",1,0,5,0,1,0,0,0,0,0,0,0,0,1,1
15788,qemu,0,"static uint8_t eeprom24c0x_read(void)

{

    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",

        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);

    return eeprom.sda;

}
",0,0,0,0,0,0,1,1,1,0,1,1,0,0,0
15791,qemu,0,"static void blockdev_do_action(int kind, void *data, Error **errp)

{

    TransactionAction action;

    TransactionActionList list;



    action.kind = kind;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
15804,FFmpeg,0,"static void h263_h_loop_filter_mmx(uint8_t *src, int stride, int qscale)

{

    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {

        const int strength = ff_h263_loop_filter_strength[qscale];

        DECLARE_ALIGNED(8, uint64_t, temp)[4];

        uint8_t *btemp = (uint8_t*)temp;



        src -= 2;



        transpose4x4(btemp,     src,              8, stride);

        transpose4x4(btemp + 4, src + 4 * stride, 8, stride);

        __asm__ volatile (

            H263_LOOP_FILTER // 5 3 4 6



            : ""+m""(temp[0]),

              ""+m""(temp[1]),

              ""+m""(temp[2]),

              ""+m""(temp[3])

            : ""g""(2 * strength), ""m""(ff_pb_FC)

            );



        __asm__ volatile (

            ""movq      %%mm5, %%mm1         \n\t""

            ""movq      %%mm4, %%mm0         \n\t""

            ""punpcklbw %%mm3, %%mm5         \n\t""

            ""punpcklbw %%mm6, %%mm4         \n\t""

            ""punpckhbw %%mm3, %%mm1         \n\t""

            ""punpckhbw %%mm6, %%mm0         \n",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
15811,qemu,0,"static void bootp_reply(struct bootp_t *bp)

{

    BOOTPClient *bc;

    struct mbuf *m;

    struct bootp_t *rbp;

    struct sockaddr_in saddr, daddr;

    struct in_addr dns_addr;

    int dhcp_msg_type, val;

    uint8_t *q;



    /* extract exact DHCP msg type */

    dhcp_decode(bp->bp_vend, DHCP_OPT_LEN, &dhcp_msg_type);

    dprintf(""bootp packet op=%d msgtype=%d\n"", bp->bp_op, dhcp_msg_type);



    if (dhcp_msg_type == 0)

        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */



    if (dhcp_msg_type != DHCPDISCOVER &&

        dhcp_msg_type != DHCPREQUEST)

        return;

    /* XXX: this is a hack to get the client mac address */

    memcpy(client_ethaddr, bp->bp_hwaddr, 6);



    if ((m = m_get()) == NULL)

        return;

    m->m_data += IF_MAXLINKHDR;

    rbp = (struct bootp_t *)m->m_data;

    m->m_data += sizeof(struct udpiphdr);

    memset(rbp, 0, sizeof(struct bootp_t));



    if (dhcp_msg_type == DHCPDISCOVER) {

    new_addr:

        bc = get_new_addr(&d",0,0,4,0,0,0,0,0,0,0,0,0,1,1,0
15818,qemu,0,"static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)

{

    switch (drc->state) {

    case SPAPR_DRC_STATE_PHYSICAL_POWERON:

        return RTAS_OUT_SUCCESS; /* Nothing to do */

    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:

        break; /* see below */

    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:

        return RTAS_OUT_PARAM_ERROR; /* not allowed */

    default:

        g_assert_not_reached();

    }



    /* if the guest is configuring a device attached to this DRC, we

     * should reset the configuration state at this point since it may

     * no longer be reliable (guest released device and needs to start

     * over, or unplug occurred so the FDT is no longer valid)

     */

    g_free(drc->ccs);

    drc->ccs = NULL;



    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;



    if (drc->unplug_requested) {

        uint32_t drc_index = spapr_drc_index(drc);

        trace_spapr_drc_set_isolation_state_finalizing(drc_index);

        spapr_drc_detach(drc);

    }



    return RTAS",0,0,2,0,1,0,1,0,1,1,0,0,0,0,1
15823,qemu,0,"static void input_linux_event_mouse(void *opaque)

{

    InputLinux *il = opaque;

    struct input_event event;

    int rc;



    for (;;) {

        rc = read(il->fd, &event, sizeof(event));

        if (rc != sizeof(event)) {

            if (rc < 0 && errno != EAGAIN) {

                fprintf(stderr, ""%s: read: %s\n"", __func__, strerror(errno));

                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);

                close(il->fd);

            }

            break;

        }



        input_linux_handle_mouse(il, &event);

    }

}
",1,0,2,0,0,0,0,1,0,0,0,0,1,1,1
15833,qemu,0,"int float64_eq( float64 a, float64 b STATUS_PARAM )

{



    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )

         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )

       ) {

        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {

            float_raise( float_flag_invalid STATUS_VAR);

        }

        return 0;

    }

    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );



}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
15840,qemu,0,"static always_inline void gen_cmp(TCGCond cond,

                                  int ra, int rb, int rc,

                                  int islit, uint8_t lit)

{

    int l1, l2;

    TCGv tmp;



    if (unlikely(rc == 31))

    return;



    l1 = gen_new_label();

    l2 = gen_new_label();



    if (ra != 31) {

        tmp = tcg_temp_new(TCG_TYPE_I64);

        tcg_gen_mov_i64(tmp, cpu_ir[ra]);

    } else

        tmp = tcg_const_i64(0);

    if (islit)

        tcg_gen_brcondi_i64(cond, tmp, lit, l1);

    else

        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);



    tcg_gen_movi_i64(cpu_ir[rc], 0);

    tcg_gen_br(l2);

    gen_set_label(l1);

    tcg_gen_movi_i64(cpu_ir[rc], 1);

    gen_set_label(l2);

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
15846,qemu,1,"static int virtio_scsi_device_exit(DeviceState *qdev)

{

    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,1,1
15879,qemu,0,"static int pci_vpb_init(SysBusDevice *dev)

{

    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);

    PCIBus *bus;

    int i;



    for (i = 0; i < 4; i++) {

        sysbus_init_irq(dev, &s->irq[i]);

    }

    bus = pci_register_bus(&dev->qdev, ""pci"",

                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,

                           get_system_memory(), get_system_io(),

                           PCI_DEVFN(11, 0), 4);



    /* ??? Register memory space.  */



    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,

                          ""pci-vpb-selfconfig"", 0x1000000);

    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,

                          ""pci-vpb-config"", 0x1000000);

    if (s->realview) {

        isa_mmio_setup(&s->isa, 0x0100000);

    }



    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);



    pci_create_simple(bus, -1, ""versatile_pci_host"");

    return 0;

}
",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
15883,qemu,0,"static void rng_random_set_filename(Object *obj, const char *filename,

                                 Error **errp)

{

    RngBackend *b = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (b->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (s->filename) {

        g_free(s->filename);

    }



    s->filename = g_strdup(filename);

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,1,1
15885,qemu,0,"static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,

                                           sPAPRMachineState *spapr,

                                           uint32_t token, uint32_t nargs,

                                           target_ulong args, uint32_t nret,

                                           target_ulong rets)

{

    sPAPRPHBState *sphb;

    PCIDevice *pdev;

    uint32_t addr, option;

    uint64_t buid;



    if ((nargs != 4) || (nret != 2)) {

        goto param_error_exit;

    }



    buid = rtas_ldq(args, 1);

    sphb = spapr_pci_find_phb(spapr, buid);

    if (!sphb) {

        goto param_error_exit;

    }



    if (!spapr_phb_eeh_available(sphb)) {

        goto param_error_exit;

    }



    /*

     * We always have PE address of form ""00BB0001"". ""BB""

     * represents the bus number of PE's primary bus.

     */

    option = rtas_ld(args, 3);

    switch (option) {

    case RTAS_GET_PE_ADDR:

        addr = rtas_ld(args, 0);

        pdev = spapr_pci_fi",1,3,3,0,1,0,1,1,1,1,0,0,1,1,1
15890,qemu,0,"static void migrate_fd_completed(MigrationState *s)

{

    DPRINTF(""setting completed state\n"");

    migrate_fd_cleanup(s);

    if (s->state == MIG_STATE_ACTIVE) {

        s->state = MIG_STATE_COMPLETED;

        runstate_set(RUN_STATE_POSTMIGRATE);

    }

    notifier_list_notify(&migration_state_notifiers, s);

}
",0,0,4,0,0,0,0,0,0,0,0,0,1,0,0
15897,qemu,0,"static unsigned int dec_adds_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZVC);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	/* Size can only be qi or hi.  */

	t_gen_sext(t0, cpu_R[dc->op1], size);

	cris_alu(dc, CC_OP_ADD,

		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
15906,FFmpeg,0,"static void create_map(vorbis_context *vc, unsigned floor_number)

{

    vorbis_floor *floors = vc->floors;

    vorbis_floor0 *vf;

    int idx;

    int blockflag, n;

    int32_t *map;



    for (blockflag = 0; blockflag < 2; ++blockflag) {

        n = vc->blocksize[blockflag] / 2;

        floors[floor_number].data.t0.map[blockflag] =

            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel



        map =  floors[floor_number].data.t0.map[blockflag];

        vf  = &floors[floor_number].data.t0;



        for (idx = 0; idx < n; ++idx) {

            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *

                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));

            if (vf->bark_map_size-1 < map[idx])

                map[idx] = vf->bark_map_size - 1;

        }

        map[n] = -1;

        vf->map_size[blockflag] = n;

    }



    for (idx = 0; idx <= n; ++idx) {

        av_dlog(NULL, ""floor0 map: map at pos %d is %d\n"", idx, map[idx]);

    }

}
",3,0,1,0,0,0,0,0,0,0,0,0,0,0,0
15911,qemu,0,"static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,

                                  VirtIOSCSIReq *req)

{

    assert(req->elem.out_num && req->elem.in_num);

    req->vq = vq;

    req->dev = s;

    req->sreq = NULL;

    req->req.buf = req->elem.out_sg[0].iov_base;

    req->resp.buf = req->elem.in_sg[0].iov_base;



    if (req->elem.out_num > 1) {

        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],

                               &req->elem.out_addr[1],

                               req->elem.out_num - 1);

    } else {

        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],

                               &req->elem.in_addr[1],

                               req->elem.in_num - 1);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,0
15924,qemu,0,"static void usb_uas_task(UASDevice *uas, uas_ui *ui)

{

    uint16_t tag = be16_to_cpu(ui->hdr.tag);

    uint64_t lun64 = be64_to_cpu(ui->task.lun);

    SCSIDevice *dev = usb_uas_get_dev(uas, lun64);

    int lun = usb_uas_get_lun(lun64);

    UASRequest *req;

    uint16_t task_tag;



    req = usb_uas_find_request(uas, be16_to_cpu(ui->hdr.tag));

    if (req) {

        goto overlapped_tag;

    }



    switch (ui->task.function) {

    case UAS_TMF_ABORT_TASK:

        task_tag = be16_to_cpu(ui->task.task_tag);

        trace_usb_uas_tmf_abort_task(uas->dev.addr, tag, task_tag);

        if (dev == NULL) {

            goto bad_target;

        }

        if (dev->lun != lun) {

            goto incorrect_lun;

        }

        req = usb_uas_find_request(uas, task_tag);

        if (req && req->dev == dev) {

            scsi_req_cancel(req->req);

        }

        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);

        break;



    case UAS_TMF_LOGICAL_UNIT_RESET:

        trace_usb_u",0,3,4,0,1,0,1,1,0,0,0,0,0,0,0
15929,qemu,0,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)

{

    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);

    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);

    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);



    if (!dev->conf.dinfo) {

        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);

        goto err;

    }

    if (dev->unit == -1) {

        dev->unit = bus->master ? 1 : 0;

    }

    switch (dev->unit) {

    case 0:

        if (bus->master) {

            fprintf(stderr, ""ide: tried to assign master twice\n"");

            goto err;

        }

        bus->master = dev;

        break;

    case 1:

        if (bus->slave) {

            fprintf(stderr, ""ide: tried to assign slave twice\n"");

            goto err;

        }

        bus->slave = dev;

        break;

    default:

        goto err;

    }

    return info->init(dev);



err:

    return -1;

}
",0,4,5,0,1,0,0,0,0,1,1,1,1,1,1
15943,qemu,0,"static int tcg_match_ori(TCGType type, tcg_target_long val)

{

    if (facilities & FACILITY_EXT_IMM) {

        if (type == TCG_TYPE_I32) {

            /* All 32-bit ORs can be performed with 1 48-bit insn.  */

            return 1;

        }

    }



    /* Look for negative values.  These are best to load with LGHI.  */

    if (val < 0) {

        if (val == (int16_t)val) {

            return 0;

        }

        if (facilities & FACILITY_EXT_IMM) {

            if (val == (int32_t)val) {

                return 0;

            }

        }

    }



    return 1;

}
",0,0,6,0,0,0,0,0,0,1,0,0,1,1,1
15962,qemu,0,"void OPPROTO op_addq_EDI_T0(void)

{

    EDI = (EDI + T0);

}
",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
15965,qemu,0,"static void hypercall_register_types(void)

{

    /* hcall-pft */

    spapr_register_hypercall(H_ENTER, h_enter);

    spapr_register_hypercall(H_REMOVE, h_remove);

    spapr_register_hypercall(H_PROTECT, h_protect);

    spapr_register_hypercall(H_READ, h_read);



    /* hcall-bulk */

    spapr_register_hypercall(H_BULK_REMOVE, h_bulk_remove);



    /* hcall-dabr */

    spapr_register_hypercall(H_SET_DABR, h_set_dabr);



    /* hcall-splpar */

    spapr_register_hypercall(H_REGISTER_VPA, h_register_vpa);

    spapr_register_hypercall(H_CEDE, h_cede);



    /* processor register resource access h-calls */

    spapr_register_hypercall(H_SET_SPRG0, h_set_sprg0);

    spapr_register_hypercall(H_SET_MODE, h_set_mode);



    /* ""debugger"" hcalls (also used by SLOF). Note: We do -not- differenciate

     * here between the ""CI"" and the ""CACHE"" variants, they will use whatever

     * mapping attributes qemu is using. When using KVM, the kernel will

     * enforce the attributes more strongly

     */

",1,0,1,0,0,0,0,0,0,0,0,0,1,0,1
15977,qemu,0,"static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)

{

    VirtIOBlock *s = VIRTIO_BLK(vdev);

    BlockConf *conf = &s->conf.conf;

    struct virtio_blk_config blkcfg;

    uint64_t capacity;

    int blk_size = conf->logical_block_size;



    bdrv_get_geometry(s->bs, &capacity);

    memset(&blkcfg, 0, sizeof(blkcfg));

    virtio_stq_p(vdev, &blkcfg.capacity, capacity);

    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);

    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);

    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);

    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);

    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);

    blkcfg.heads = conf->heads;

    /*

     * We must ensure that the block device capacity is a multiple of

     * the logical block size. If that is not the case, let's use

     * sector_mask to adopt the geometry to have a correct picture.

     * For those devices where the capacity is ok for the give",1,0,0,0,0,0,0,0,0,0,1,0,1,1,1
15980,qemu,0,"static void decode_opc (CPUMIPSState *env, DisasContext *ctx)

{

    int32_t offset;

    int rs, rt, rd, sa;

    uint32_t op, op1;

    int16_t imm;



    /* make sure instructions are on a word boundary */

    if (ctx->pc & 0x3) {

        env->CP0_BadVAddr = ctx->pc;

        generate_exception(ctx, EXCP_AdEL);

        return;

    }



    /* Handle blikely not taken case */

    if ((ctx->hflags & MIPS_HFLAG_BMASK_BASE) == MIPS_HFLAG_BL) {

        int l1 = gen_new_label();



        MIPS_DEBUG(""blikely condition ("" TARGET_FMT_lx "")"", ctx->pc + 4);

        tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);

        tcg_gen_movi_i32(hflags, ctx->hflags & ~MIPS_HFLAG_BMASK);

        gen_goto_tb(ctx, 1, ctx->pc + 4);

        gen_set_label(l1);

    }



    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {

        tcg_gen_debug_insn_start(ctx->pc);

    }



    op = MASK_OP_MAJOR(ctx->opcode);

    rs = (ctx->opcode >> 21) & 0x1f;

    rt = (ctx->opcode >> 16) & 0x1f;

    rd = (",0,1,3,0,0,0,1,1,0,1,1,1,0,0,0
15985,qemu,0,"bool blk_dev_is_tray_open(BlockBackend *blk)

{

    if (blk->dev_ops && blk->dev_ops->is_tray_open) {

        return blk->dev_ops->is_tray_open(blk->dev_opaque);

    }

    return false;

}
",0,0,1,0,0,0,0,0,0,1,0,0,1,1,1
15987,FFmpeg,1,"static av_cold int tdsc_init(AVCodecContext *avctx)

{

    TDSCContext *ctx = avctx->priv_data;

    const AVCodec *codec;

    int ret;



    avctx->pix_fmt = AV_PIX_FMT_BGR24;



    /* These needs to be set to estimate buffer and frame size */

    if (!(avctx->width && avctx->height)) {

        av_log(avctx, AV_LOG_ERROR, ""Video size not set.\n"");

        return AVERROR_INVALIDDATA;

    }



    /* This value should be large enough for a RAW-only frame plus headers */

    ctx->deflatelen = avctx->width * avctx->height * (3 + 1);

    ret = av_reallocp(&ctx->deflatebuffer, ctx->deflatelen);

    if (ret < 0)

        return ret;



    /* Allocate reference and JPEG frame */

    ctx->refframe = av_frame_alloc();

    ctx->jpgframe = av_frame_alloc();

    if (!ctx->refframe || !ctx->jpgframe)

        return AVERROR(ENOMEM);



    /* Prepare everything needed for JPEG decoding */

    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);

    if (!codec)

        return AVERROR_BUG;

    ctx->jpeg_avctx",0,0,4,0,0,0,1,1,1,1,0,1,0,0,1
15999,qemu,1,"int hvf_vcpu_exec(CPUState *cpu)

{

    X86CPU *x86_cpu = X86_CPU(cpu);

    CPUX86State *env = &x86_cpu->env;

    int ret = 0;

    uint64_t rip = 0;



    cpu->halted = 0;



    if (hvf_process_events(cpu)) {

        return EXCP_HLT;

    }



    do {

        if (cpu->vcpu_dirty) {

            hvf_put_registers(cpu);

            cpu->vcpu_dirty = false;

        }



        if (hvf_inject_interrupts(cpu)) {

            return EXCP_INTERRUPT;

        }

        vmx_update_tpr(cpu);



        qemu_mutex_unlock_iothread();

        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {

            qemu_mutex_lock_iothread();

            return EXCP_HLT;

        }



        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);

        assert_hvf_ok(r);



        /* handle VMEXIT */

        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);

        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);

        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,

                             ",0,0,4,0,0,0,1,1,1,1,1,1,0,1,0
16020,FFmpeg,0,"int intel_h263_decode_picture_header(MpegEncContext *s)

{

    int format;



    /* picture header */

    if (get_bits_long(&s->gb, 22) != 0x20) {

        av_log(s->avctx, AV_LOG_ERROR, ""Bad picture start code\n"");

        return -1;

    }

    s->picture_number = get_bits(&s->gb, 8); /* picture timestamp */



    if (get_bits1(&s->gb) != 1) {

        av_log(s->avctx, AV_LOG_ERROR, ""Bad marker\n"");

        return -1;	/* marker */

    }

    if (get_bits1(&s->gb) != 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""Bad H263 id\n"");

        return -1;	/* h263 id */

    }

    skip_bits1(&s->gb);	/* split screen off */

    skip_bits1(&s->gb);	/* camera  off */

    skip_bits1(&s->gb);	/* freeze picture release off */



    format = get_bits(&s->gb, 3);

    if (format != 7) {

        av_log(s->avctx, AV_LOG_ERROR, ""Intel H263 free format not supported\n"");

        return -1;

    }

    s->h263_plus = 0;



    s->pict_type = I_TYPE + get_bits1(&s->gb);

    

    s->unrestricted_mv = get_bits1(&s->g",4,0,4,0,0,0,0,1,1,0,0,0,1,1,1
16047,qemu,1,"int bdrv_pwrite(BlockDriverState *bs, int64_t offset,

                const void *buf1, int count1)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;

    if (!drv->bdrv_pwrite)

        return bdrv_pwrite_em(bs, offset, buf1, count1);

    if (bdrv_wr_badreq_bytes(bs, offset, count1))

        return -EDOM;

    return drv->bdrv_pwrite(bs, offset, buf1, count1);

}
",0,0,3,0,0,0,0,0,0,0,1,0,0,0,0
16057,qemu,1,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *buffer;

    int ret;

    char *path = fs_path->data;



    buffer = rpath(ctx, path);

    ret = truncate(buffer, size);

    g_free(buffer);

    return ret;

}
",0,0,0,0,0,0,0,0,0,1,0,1,0,0,0
16068,qemu,0,"void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,1
16083,qemu,0,"static int stellaris_enet_can_receive(void *opaque)

{

    stellaris_enet_state *s = (stellaris_enet_state *)opaque;



    if ((s->rctl & SE_RCTL_RXEN) == 0)

        return 1;



    return (s->np < 31);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
16089,qemu,0,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,

                           DeviceState *dev, Error **errp)

{

    MemStatus *mdev;



    mdev = acpi_memory_slot_status(mem_st, dev, errp);

    if (!mdev) {

        return;

    }



    /* nvdimm device hot unplug is not supported yet. */

    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));

    mdev->is_enabled = false;

    mdev->dimm = NULL;

}
",0,0,1,0,0,0,0,0,0,0,0,1,1,0,0
16090,qemu,0,"alloc_f(int argc, char **argv)

{

	int64_t offset;

	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;

	}



	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);

	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));



	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	return 0;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
16093,qemu,1,"static void hmp_cont_cb(void *opaque, int err)

{

    if (!err) {

        qmp_cont(NULL);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
16112,qemu,1,"static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)

{

    PCIDevice *pci_dev = PCI_DEVICE(s);

    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);

    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);

    struct mfi_ctrl_info info;

    size_t dcmd_size = sizeof(info);

    BusChild *kid;

    int num_pd_disks = 0;



    memset(&info, 0x0, cmd->iov_size);

    if (cmd->iov_size < dcmd_size) {

        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,

                                            dcmd_size);

        return MFI_STAT_INVALID_PARAMETER;

    }



    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);

    info.pci.device = cpu_to_le16(pci_class->device_id);

    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);

    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);



    /*

     * For some reason the firmware supports

     * only up to 8 device ports.

     * Despite supporting a far larger number

     * of devic",0,0,1,0,0,0,1,1,0,1,1,1,1,1,1
16135,FFmpeg,1,"int ff_thread_video_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *got_packet_ptr){

    ThreadContext *c = avctx->internal->frame_thread_encoder;

    Task task;

    int ret;



    av_assert1(!*got_packet_ptr);



    if(frame){

        if(!(avctx->flags & CODEC_FLAG_INPUT_PRESERVED)){

            AVFrame *new = avcodec_alloc_frame();

            if(!new)

                return AVERROR(ENOMEM);

            pthread_mutex_lock(&c->buffer_mutex);

            ret = c->parent_avctx->get_buffer(c->parent_avctx, new);

            pthread_mutex_unlock(&c->buffer_mutex);

            if(ret<0)

                return ret;

            new->pts = frame->pts;

            new->quality = frame->quality;

            new->pict_type = frame->pict_type;

            av_image_copy(new->data, new->linesize, (const uint8_t **)frame->data, frame->linesize,

                          avctx->pix_fmt, avctx->width, avctx->height);

            frame = new;

        }



        task.index =",0,0,4,0,0,0,0,0,0,0,0,0,1,0,1
16147,qemu,0,"int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,

                       void *opaque, int version_id)

{

    VMStateField *field = vmsd->fields;



    if (version_id > vmsd->version_id) {

        return -EINVAL;

    }

    if (version_id < vmsd->minimum_version_id_old) {

        return -EINVAL;

    }

    if  (version_id < vmsd->minimum_version_id) {

        return vmsd->load_state_old(f, opaque, version_id);

    }

    while(field->name) {

        if (field->version_id <= version_id) {

            void *base_addr = opaque + field->offset;

            int ret, i, n_elems = 1;



            if (field->flags & VMS_ARRAY) {

                n_elems = field->num;

            } else if (field->flags & VMS_VARRAY) {

                n_elems = *(size_t *)(opaque+field->num_offset);

            }

            if (field->flags & VMS_POINTER) {

                base_addr = *(void **)base_addr;

            }

            for (i = 0; i < n_elems; i++) {

                void *addr = bas",1,0,7,0,0,1,0,0,0,1,1,1,1,1,1
16155,qemu,0,"static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,

                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)

{

    TCGReg tmp0 = TCG_TMP0;

    TCGReg tmp1 = ret;



    assert(ret != TCG_TMP0);

    if (ret == ah || ret == bh) {

        assert(ret != TCG_TMP1);

        tmp1 = TCG_TMP1;

    }



    switch (cond) {

    case TCG_COND_EQ:

    case TCG_COND_NE:

        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);

        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);

        break;



    default:

        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);

        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);

        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);

        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);

        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);

        break;

    }

}
",0,0,1,0,1,0,0,0,0,0,0,0,0,0,0
16163,qemu,0,"static void display_mouse_define(DisplayChangeListener *dcl,

                                 QEMUCursor *c)

{

    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);



    qemu_mutex_lock(&ssd->lock);

    if (c) {

        cursor_get(c);

    }

    cursor_put(ssd->cursor);

    ssd->cursor = c;

    ssd->hot_x = c->hot_x;

    ssd->hot_y = c->hot_y;

    g_free(ssd->ptr_move);

    ssd->ptr_move = NULL;

    g_free(ssd->ptr_define);

    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);

    qemu_mutex_unlock(&ssd->lock);

}
",0,0,1,0,0,0,0,0,0,0,1,0,0,0,1
16164,qemu,0,"static inline void stw_phys_internal(hwaddr addr, uint32_t val,

                                     enum device_endian endian)

{

    uint8_t *ptr;

    MemoryRegionSection *section;



    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);



    if (!memory_region_is_ram(section->mr) || section->readonly) {

        addr = memory_region_section_addr(section, addr);

        if (memory_region_is_ram(section->mr)) {

            section = &phys_sections[phys_section_rom];

        }

#if defined(TARGET_WORDS_BIGENDIAN)

        if (endian == DEVICE_LITTLE_ENDIAN) {

            val = bswap16(val);

        }

#else

        if (endian == DEVICE_BIG_ENDIAN) {

            val = bswap16(val);

        }

#endif

        io_mem_write(section->mr, addr, val, 2);

    } else {

        unsigned long addr1;

        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)

            + memory_region_section_addr(section, addr);

        /* RAM case */

        ptr = q",0,0,6,0,0,0,0,0,0,1,0,1,0,1,0
16177,FFmpeg,1,"static void compute_scale_factors(unsigned char scale_code[SBLIMIT],

                                  unsigned char scale_factors[SBLIMIT][3], 

                                  int sb_samples[3][12][SBLIMIT],

                                  int sblimit)

{

    int *p, vmax, v, n, i, j, k, code;

    int index, d1, d2;

    unsigned char *sf = &scale_factors[0][0];

    

    for(j=0;j<sblimit;j++) {

        for(i=0;i<3;i++) {

            /* find the max absolute value */

            p = &sb_samples[i][0][j];

            vmax = abs(*p);

            for(k=1;k<12;k++) {

                p += SBLIMIT;

                v = abs(*p);

                if (v > vmax)

                    vmax = v;

            }

            /* compute the scale factor index using log 2 computations */

            if (vmax > 0) {

                n = av_log2(vmax);

                /* n is the position of the MSB of vmax. now 

                   use at most 2 compares to find the index */

                index = (21 - n",3,0,2,0,0,0,0,0,1,1,1,0,1,1,0
16183,FFmpeg,0,"static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
",0,0,5,0,0,0,0,1,1,0,0,1,0,0,1
16190,FFmpeg,1,"static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int srcStride)

{

	unsigned y;

	const unsigned chromWidth= width>>1;

	for(y=0; y<height; y+=2)

	{

#ifdef HAVE_MMX

		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	\n\t""

			""pcmpeqw %%mm7, %%mm7		\n\t""

			""psrlw $8, %%mm7		\n\t"" // FF,00,FF,00...

			"".balign 16			\n\t""

			""1:				\n\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	\n\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	\n\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1\n\t"" // YUYV YUYV(4)

			""movq %%mm0, %%mm2		\n\t"" // YUYV YUYV(0)

			""movq %%mm1, %%mm3		\n\t"" // YUYV YUYV(4)

			""psrlw $8, %%mm0		\n\t"" // U0V0 U0V0(0)

			""psrlw $8, %%mm1		\n\t"" // U0V0 U0V0(4)

			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm3		\n\t"" // Y0Y0 Y0Y0(4)

			""packuswb %%mm1, %%mm0		\n\t"" // UVUV UVUV(0)

			""packuswb %%mm3, %%mm2		\n\t"" // YYYY YYYY(0)



			MOVNTQ"" %%mm2, (%",1,0,1,0,0,0,0,1,0,1,1,1,0,0,0
16197,FFmpeg,1,"static int huf_uncompress(GetByteContext *gb,

                          uint16_t *dst, int dst_size)

{

    int32_t src_size, im, iM;

    uint32_t nBits;

    uint64_t *freq;

    HufDec *hdec;

    int ret, i;



    src_size = bytestream2_get_le32(gb);

    im = bytestream2_get_le32(gb);

    iM = bytestream2_get_le32(gb);

    bytestream2_skip(gb, 4);

    nBits = bytestream2_get_le32(gb);

    if (im < 0 || im >= HUF_ENCSIZE ||

        iM < 0 || iM >= HUF_ENCSIZE ||

        src_size < 0)

        return AVERROR_INVALIDDATA;



    bytestream2_skip(gb, 4);



    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));

    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));

    if (!freq || !hdec) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }



    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)

        goto fail;



    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {

        ret = AVERROR_INVALIDDATA;

        goto fail;

    }



    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) <",0,3,5,0,0,0,0,0,0,0,0,0,1,1,0
16203,FFmpeg,1,"static int hevc_frame_start(HEVCContext *s)

{

    HEVCLocalContext *lc = &s->HEVClc;

    int ret;



    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));

    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));

    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);

    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);



    lc->start_of_tiles_x = 0;

    s->is_decoded        = 0;




    if (s->pps->tiles_enabled_flag)

        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;



    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,

                              s->poc);

    if (ret < 0)

        goto fail;



    ret = ff_hevc_frame_rps(s);

    if (ret < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""Error constructing the frame RPS.\n"");

        goto fail;

    }



    ret = set_side_data(s);

    if (ret < 0)

        goto fail;



    av_frame_unref(s->output_frame);",0,3,4,0,0,0,0,0,0,0,0,0,1,1,1
16204,qemu,1,"static int local_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,

                       int flags, FsCred *credp, V9fsFidOpenState *fs)

{

    char *path;

    int fd = -1;

    int err = -1;

    int serrno = 0;

    V9fsString fullname;

    char *buffer;



    /*

     * Mark all the open to not follow symlinks

     */

    flags |= O_NOFOLLOW;



    v9fs_string_init(&fullname);

    v9fs_string_sprintf(&fullname, ""%s/%s"", dir_path->data, name);

    path = fullname.data;



    /* Determine the security model */

    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {

        buffer = rpath(fs_ctx, path);

        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);

        if (fd == -1) {

            g_free(buffer);

            err = fd;

            goto out;

        }

        credp->fc_mode = credp->fc_mode|S_IFREG;

        /* Set cleint credentials in xattr */

        err = local_set_xattr(buffer, credp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

",0,2,3,0,0,0,0,1,0,1,0,1,1,1,1
16205,FFmpeg,1,"static void fix_coding_method_array (int sb, int channels, sb_int8_array coding_method)

{

    int j,k;

    int ch;

    int run, case_val;

    int switchtable[23] = {0,5,1,5,5,5,5,5,2,5,5,5,5,5,5,5,3,5,5,5,5,5,4};



    for (ch = 0; ch < channels; ch++) {

        for (j = 0; j < 64; ) {

            if((coding_method[ch][sb][j] - 8) > 22) {

                run = 1;

                case_val = 8;

            } else {

                switch (switchtable[coding_method[ch][sb][j]]) {

                    case 0: run = 10; case_val = 10; break;

                    case 1: run = 1; case_val = 16; break;

                    case 2: run = 5; case_val = 24; break;

                    case 3: run = 3; case_val = 30; break;

                    case 4: run = 1; case_val = 30; break;

                    case 5: run = 1; case_val = 8; break;

                    default: run = 1; case_val = 8; break;

                }

            }

            for (k = 0; k < run; k++)

                if (j + k < 128)

  ",3,0,2,0,3,0,0,0,1,0,1,0,1,1,1
16207,qemu,1,"static void gen_mtdcrx(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

        return;

    }

    /* NIP cannot be restored if the memory exception comes from an helper */

    gen_update_nip(ctx, ctx->nip - 4);

    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],

                         cpu_gpr[rS(ctx->opcode)]);

    /* Note: Rc update flag set leads to undefined state of Rc0 */

#endif

}
",0,0,3,0,0,0,1,1,1,1,1,1,0,1,1
16211,qemu,1,"int usb_packet_map(USBPacket *p, QEMUSGList *sgl)

{

    int is_write = (p->pid == USB_TOKEN_IN);

    target_phys_addr_t len;

    void *mem;

    int i;



    for (i = 0; i < sgl->nsg; i++) {

        len = sgl->sg[i].len;

        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,

                                      is_write);

        if (!mem) {

            goto err;

        }

        qemu_iovec_add(&p->iov, mem, len);

        if (len != sgl->sg[i].len) {

            goto err;

        }

    }

    return 0;



err:

    usb_packet_unmap(p);

    return -1;

}
",1,2,2,0,0,0,1,1,1,1,1,1,1,1,0
16216,qemu,1,"static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}
",0,0,1,0,0,0,0,0,0,1,0,1,0,1,1
16227,FFmpeg,0,"void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])

{

    int i;

    if (s->chroma_format == CHROMA_444) {

        encode_block(s, block[0], 0);

        encode_block(s, block[2], 2);

        encode_block(s, block[4], 4);

        encode_block(s, block[8], 8);

        encode_block(s, block[5], 5);

        encode_block(s, block[9], 9);



        if (16*s->mb_x+8 < s->width) {

            encode_block(s, block[1], 1);

            encode_block(s, block[3], 3);

            encode_block(s, block[6], 6);

            encode_block(s, block[10], 10);

            encode_block(s, block[7], 7);

            encode_block(s, block[11], 11);

        }

    } else {

        for(i=0;i<5;i++) {

            encode_block(s, block[i], i);

        }

        if (s->chroma_format == CHROMA_420) {

            encode_block(s, block[5], 5);

        } else {

            encode_block(s, block[6], 6);

            encode_block(s, block[5], 5);

            encode_block(s, block[7], 7);

        }

    }
",3,0,3,0,0,0,1,1,1,0,1,0,0,0,0
16237,qemu,0,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,

                     int ret, int rw)

{

    int store = 0;



    /* Update page flags */

    if (!(*pte1p & 0x00000100)) {

        /* Update accessed flag */

        *pte1p |= 0x00000100;

        store = 1;

    }

    if (!(*pte1p & 0x00000080)) {

        if (rw == 1 && ret == 0) {

            /* Update changed flag */

            *pte1p |= 0x00000080;

            store = 1;

        } else {

            /* Force page fault for first write access */

            ctx->prot &= ~PAGE_WRITE;

        }

    }



    return store;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
16246,qemu,0,"static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)

{

    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);

}
",0,0,0,0,0,0,0,0,1,0,0,0,1,1,1
16255,FFmpeg,0,"void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,

                                 ptrdiff_t stride)

{

    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,

                                           stride, dst, stride, 16, 0);

}
",0,0,1,0,0,0,1,1,1,1,1,0,0,0,0
16256,FFmpeg,0,"int av_parse_color(uint8_t *rgba_color, const char *color_string, int slen,

                   void *log_ctx)

{

    char *tail, color_string2[128];

    const ColorEntry *entry;

    int len, hex_offset = 0;



    if (color_string[0] == '#') {

        hex_offset = 1;

    } else if (!strncmp(color_string, ""0x"", 2))

        hex_offset = 2;



    if (slen < 0)

        slen = strlen(color_string);

    av_strlcpy(color_string2, color_string + hex_offset,

               FFMIN(slen-hex_offset+1, sizeof(color_string2)));

    if ((tail = strchr(color_string2, ALPHA_SEP)))

        *tail++ = 0;

    len = strlen(color_string2);

    rgba_color[3] = 255;



    if (!av_strcasecmp(color_string2, ""random"") || !av_strcasecmp(color_string2, ""bikeshed"")) {

        int rgba = av_get_random_seed();

        rgba_color[0] = rgba >> 24;

        rgba_color[1] = rgba >> 16;

        rgba_color[2] = rgba >> 8;

        rgba_color[3] = rgba;

    } else if (hex_offset ||

               strspn(color_string2, ""012345678",0,0,6,0,0,0,0,0,0,0,0,0,1,0,1
16274,qemu,0,"static int raw_inactivate(BlockDriverState *bs)

{

    int ret;

    uint64_t perm = 0;

    uint64_t shared = BLK_PERM_ALL;



    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);

    if (ret) {

        return ret;

    }

    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);

    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,1
16276,qemu,0,"static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,

                                Error **errp)

{

    QmpOutputVisitor *qov = to_qov(v);

    qobject_incref(*obj);

    qmp_output_add_obj(qov, name, *obj);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
16281,qemu,0,"static int setup_sigcontext(struct target_sigcontext *sc,

                            CPUSH4State *regs, unsigned long mask)

{

    int err = 0;

    int i;



#define COPY(x)         __put_user(regs->x, &sc->sc_##x)

    COPY(gregs[0]); COPY(gregs[1]);

    COPY(gregs[2]); COPY(gregs[3]);

    COPY(gregs[4]); COPY(gregs[5]);

    COPY(gregs[6]); COPY(gregs[7]);

    COPY(gregs[8]); COPY(gregs[9]);

    COPY(gregs[10]); COPY(gregs[11]);

    COPY(gregs[12]); COPY(gregs[13]);

    COPY(gregs[14]); COPY(gregs[15]);

    COPY(gbr); COPY(mach);

    COPY(macl); COPY(pr);

    COPY(sr); COPY(pc);

#undef COPY



    for (i=0; i<16; i++) {

        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);

    }

    __put_user(regs->fpscr, &sc->sc_fpscr);

    __put_user(regs->fpul, &sc->sc_fpul);



    /* non-iBCS2 extensions.. */

    __put_user(mask, &sc->oldmask);



    return err;

}
",1,0,0,0,0,0,0,0,0,1,0,1,0,0,0
16293,qemu,1,"static void vfio_unmap_bar(VFIODevice *vdev, int nr)

{

    VFIOBAR *bar = &vdev->bars[nr];



    if (!bar->size) {

        return;

    }



    vfio_bar_quirk_teardown(vdev, nr);



    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);

    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));




    if (vdev->msix && vdev->msix->table_bar == nr) {

        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);

        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));


    }



    memory_region_destroy(&bar->mem);

}",0,0,2,0,0,0,0,0,0,1,0,0,1,0,1
16318,qemu,0,"static bool ept_emulation_fault(uint64_t ept_qual)

{

    int read, write;



    /* EPT fault on an instruction fetch doesn't make sense here */

    if (ept_qual & EPT_VIOLATION_INST_FETCH) {

        return false;

    }



    /* EPT fault must be a read fault or a write fault */

    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;

    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;

    if ((read | write) == 0) {

        return false;

    }



    /*

     * The EPT violation must have been caused by accessing a

     * guest-physical address that is a translation of a guest-linear

     * address.

     */

    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||

        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {

        return false;

    }



    return true;

}
",0,0,3,0,0,0,0,0,0,1,0,1,0,0,0
16335,FFmpeg,0,"yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,

                       const int32_t **lumSrc, int lumFilterSize,

                       const int16_t *chrFilter, const int32_t **chrUSrc,

                       const int32_t **chrVSrc, int chrFilterSize,

                       const int32_t **alpSrc, uint16_t *dest, int dstW,

                       int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)

{

    int i;

    int A = 0xffff<<14;



    for (i = 0; i < dstW; i++) {

        int j;

        int Y  = -0x40000000;

        int U  = -128 << 23; // 19

        int V  = -128 << 23;

        int R, G, B;



        for (j = 0; j < lumFilterSize; j++) {

            Y += lumSrc[j][i]  * (unsigned)lumFilter[j];

        }

        for (j = 0; j < chrFilterSize; j++) {;

            U += chrUSrc[j][i] * (unsigned)chrFilter[j];

            V += chrVSrc[j][i] * (unsigned)chrFilter[j];

        }



        if (hasAlpha) {

            A = -0x40000000;

            for (j =",4,0,1,0,0,0,0,0,0,0,0,0,0,0,0
16352,qemu,1,"static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args,

                            int opc)

{

    int addr_regl, addr_reg1, addr_meml;

    int data_regl, data_regh, data_reg1, data_reg2;

    int mem_index, s_bits;

#if defined(CONFIG_SOFTMMU)

    void *label1_ptr, *label2_ptr;

    int sp_args;

#endif

#if TARGET_LONG_BITS == 64

# if defined(CONFIG_SOFTMMU)

    uint8_t *label3_ptr;

# endif

    int addr_regh, addr_reg2, addr_memh;

#endif

    data_regl = *args++;

    if (opc == 3)

        data_regh = *args++;

    else

        data_regh = 0;

    addr_regl = *args++;

#if TARGET_LONG_BITS == 64

    addr_regh = *args++;

#endif

    mem_index = *args;

    s_bits = opc & 3;



    if (opc == 3) {

#if defined(TCG_TARGET_WORDS_BIGENDIAN)

        data_reg1 = data_regh;

        data_reg2 = data_regl;

#else

        data_reg1 = data_regl;

        data_reg2 = data_regh;

#endif

    } else {

        data_reg1 = data_regl;

        data_reg2 = 0;

    }

#if TARGET_LONG_BITS == 64

# if d",0,0,14,0,0,0,1,1,0,1,1,1,1,1,0
16360,qemu,1,"static void dec_calc(DisasContext *dc, uint32_t insn)

{

    uint32_t op0, op1, op2;

    uint32_t ra, rb, rd;

    op0 = extract32(insn, 0, 4);

    op1 = extract32(insn, 8, 2);

    op2 = extract32(insn, 6, 2);

    ra = extract32(insn, 16, 5);

    rb = extract32(insn, 11, 5);

    rd = extract32(insn, 21, 5);



    switch (op0) {

    case 0x0000:

        switch (op1) {

        case 0x00:    /* l.add */

            LOG_DIS(""l.add r%d, r%d, r%d\n"", rd, ra, rb);

            {

                TCGLabel *lab = gen_new_label();

                TCGv_i64 ta = tcg_temp_new_i64();

                TCGv_i64 tb = tcg_temp_new_i64();

                TCGv_i64 td = tcg_temp_local_new_i64();

                TCGv_i32 res = tcg_temp_local_new_i32();

                TCGv_i32 sr_ove = tcg_temp_local_new_i32();

                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);

                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);

                tcg_gen_add_i64(td, ta, tb);

                tcg_gen_extrl_i64_i32(res, td);

   ",0,0,0,0,2,0,1,1,1,1,1,1,1,0,1
16365,qemu,1,"int qemu_calculate_timeout(void)

{

#ifndef CONFIG_IOTHREAD

    int timeout;



    if (!vm_running)

        timeout = 5000;

    else {

     /* XXX: use timeout computed from timers */

        int64_t add;

        int64_t delta;

        /* Advance virtual time to the next event.  */

	delta = qemu_icount_delta();

        if (delta > 0) {

            /* If virtual time is ahead of real time then just

               wait for IO.  */

            timeout = (delta + 999999) / 1000000;

        } else {

            /* Wait for either IO to occur or the next

               timer event.  */

            add = qemu_next_deadline();

            /* We advance the timer before checking for IO.

               Limit the amount we advance so that early IO

               activity won't get the guest too far ahead.  */

            if (add > 10000000)

                add = 10000000;

            delta += add;

            qemu_icount += qemu_icount_round (add);

            timeout = delta / 1000000;

      ",4,0,4,0,0,0,0,0,0,0,0,0,0,0,0
16370,FFmpeg,1,"static int ftp_abort(URLContext *h)

{

    static const char *command = ""ABOR\r\n"";

    int err;

    static const int abor_codes[] = {225, 226, 0};

    FTPContext *s = h->priv_data;



    /* According to RCF 959:

       ""ABOR command tells the server to abort the previous FTP

       service command and any associated transfer of data.""



       There are FTP server implementations that don't response

       to any commands during data transfer in passive mode (including ABOR).



       This implementation closes data connection by force.

    */



    if (ftp_send_command(s, command, NULL, NULL) < 0) {

        ftp_close_both_connections(s);

        if ((err = ftp_connect_control_connection(h)) < 0) {

            av_log(h, AV_LOG_ERROR, ""Reconnect failed.\n"");

            return err;

        }

    } else {

        ftp_close_data_connection(s);

    }



    if (ftp_status(s, NULL, abor_codes) < 225) {

        /* wu-ftpd also closes control connection after data connection closing */

       ",1,0,3,0,0,0,1,1,1,0,0,1,1,1,1
16385,FFmpeg,1,"static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,
                                      int chunk_size, RTMPPacket **prev_pkt_ptr,
                                      int *nb_prev_pkt, uint8_t hdr)
{
    uint8_t buf[16];
    int channel_id, timestamp, size;
    uint32_t ts_field; // non-extended timestamp or delta field
    uint32_t extra = 0;
    enum RTMPPacketType type;
    int written = 0;
    int ret, toread;
    RTMPPacket *prev_pkt;
    written++;
    channel_id = hdr & 0x3F;
    if (channel_id < 2) { //special case for channel number >= 64
        buf[1] = 0;
        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)
            return AVERROR(EIO);
        written += channel_id + 1;
        channel_id = AV_RL16(buf) + 64;
    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,
                                         channel_id)) < 0)
        return ret;
    prev_pkt = *prev_pkt_ptr;
    size  = prev_pkt[channel_id].size;
    type  = prev_pkt[channel_id",0,0,3,0,0,0,1,1,1,1,1,1,1,1,1
16406,qemu,0,"void eeprom93xx_write(eeprom_t *eeprom, int eecs, int eesk, int eedi)

{

    uint8_t tick = eeprom->tick;

    uint8_t eedo = eeprom->eedo;

    uint16_t address = eeprom->address;

    uint8_t command = eeprom->command;



    logout(""CS=%u SK=%u DI=%u DO=%u, tick = %u\n"",

           eecs, eesk, eedi, eedo, tick);



    if (! eeprom->eecs && eecs) {

        /* Start chip select cycle. */

        logout(""Cycle start, waiting for 1st start bit (0)\n"");

        tick = 0;

        command = 0x0;

        address = 0x0;

    } else if (eeprom->eecs && ! eecs) {

        /* End chip select cycle. This triggers write / erase. */

        if (eeprom->writable) {

            uint8_t subcommand = address >> (eeprom->addrbits - 2);

            if (command == 0 && subcommand == 2) {

                /* Erase all. */

                for (address = 0; address < eeprom->size; address++) {

                    eeprom->contents[address] = 0xffff;

                }

            } else if (command == 3) {

          ",2,0,5,0,0,0,0,0,0,0,0,0,0,0,0
16410,qemu,0,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
",0,0,0,0,0,2,1,1,1,0,0,0,0,0,0
16412,FFmpeg,0,"static av_cold int encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
16415,qemu,0,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    int64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);



    mr = host_memory_backend_get_memory(dimm->hostmem, errp);

    value = memory_region_size(mr);



    visit_type_int(v, name, &value, errp);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
16419,qemu,0,"pflash_t *pflash_cfi02_register(target_phys_addr_t base, ram_addr_t off,

                                BlockDriverState *bs, uint32_t sector_len,

                                int nb_blocs, int nb_mappings, int width,

                                uint16_t id0, uint16_t id1,

                                uint16_t id2, uint16_t id3,

                                uint16_t unlock_addr0, uint16_t unlock_addr1)

{

    pflash_t *pfl;

    int32_t chip_len;



    chip_len = sector_len * nb_blocs;

    /* XXX: to be fixed */

#if 0

    if (total_len != (8 * 1024 * 1024) && total_len != (16 * 1024 * 1024) &&

        total_len != (32 * 1024 * 1024) && total_len != (64 * 1024 * 1024))

        return NULL;

#endif

    pfl = qemu_mallocz(sizeof(pflash_t));

    /* FIXME: Allocate ram ourselves.  */

    pfl->storage = qemu_get_ram_ptr(off);

    pfl->fl_mem = cpu_register_io_memory(pflash_read_ops, pflash_write_ops,

                                         pfl);

    pfl->off = off;

    pfl->base = ",0,0,3,0,0,0,0,0,0,0,0,0,1,1,0
16422,qemu,0,"static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)

{

    return s->ops->chmod(&s->ctx, path->data, mode);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
16431,qemu,1,"static int check_physical (CPUState *env, mmu_ctx_t *ctx,

                           target_ulong eaddr, int rw)

{

    int in_plb, ret;



    ctx->raddr = eaddr;

    ctx->prot = PAGE_READ;

    ret = 0;

    switch (env->mmu_model) {

    case POWERPC_MMU_32B:

    case POWERPC_MMU_SOFT_6xx:

    case POWERPC_MMU_SOFT_74xx:

    case POWERPC_MMU_601:

    case POWERPC_MMU_SOFT_4xx:

    case POWERPC_MMU_REAL_4xx:

    case POWERPC_MMU_BOOKE:

        ctx->prot |= PAGE_WRITE;

        break;

#if defined(TARGET_PPC64)

    case POWERPC_MMU_64B:

    case POWERPC_MMU_64BRIDGE:

        /* Real address are 60 bits long */

        ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL;

        ctx->prot |= PAGE_WRITE;

        break;

#endif

    case POWERPC_MMU_SOFT_4xx_Z:

        if (unlikely(msr_pe != 0)) {

            /* 403 family add some particular protections,

             * using PBL/PBU registers for accesses with no translation.

             */

            in_plb =

                /* Check PLB validity */

",1,0,3,0,1,0,0,0,0,0,0,1,1,1,1
16437,FFmpeg,1,"void ff_xvmc_field_end(MpegEncContext *s)

{

    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];

    assert(render);



    if (render->filled_mv_blocks_num > 0)

        ff_mpeg_draw_horiz_band(s, 0, 0);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
16449,qemu,1,"void set_system_memory_map(MemoryRegion *mr)

{

    memory_region_transaction_begin();

    address_space_memory.root = mr;

    memory_region_transaction_commit();

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
16452,FFmpeg,0,"pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality)

{

    char temp[GET_MODE_BUFFER_SIZE];

    char *p= temp;

    static const char filterDelimiters[] = "",/"";

    static const char optionDelimiters[] = "":"";

    struct PPMode *ppMode;

    char *filterToken;



    ppMode= av_malloc(sizeof(PPMode));



    ppMode->lumMode= 0;

    ppMode->chromMode= 0;

    ppMode->maxTmpNoise[0]= 700;

    ppMode->maxTmpNoise[1]= 1500;

    ppMode->maxTmpNoise[2]= 3000;

    ppMode->maxAllowedY= 234;

    ppMode->minAllowedY= 16;

    ppMode->baseDcDiff= 256/8;

    ppMode->flatnessThreshold= 56-16-1;

    ppMode->maxClippedThreshold= 0.01;

    ppMode->error=0;



    memset(temp, 0, GET_MODE_BUFFER_SIZE);

    av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);



    av_log(NULL, AV_LOG_DEBUG, ""pp: %s\n"", name);



    for(;;){

        char *filterName;

        int q= 1000000; //PP_QUALITY_MAX;

        int chrom=-1;

        int luma=-1;

        char *option;

        char *options[OPTIONS_ARRAY",1,0,1,0,0,0,1,1,1,0,0,0,0,0,0
16465,qemu,1,"int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    ret = qcow2_pre_write_overlap_check(bs,

            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,

            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",1,0,2,0,0,0,1,1,0,0,0,0,0,0,0
16483,qemu,0,"static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)

{

    uintptr_t host_start, host_map_start, host_end;



    last_bss = TARGET_PAGE_ALIGN(last_bss);



    /* ??? There is confusion between qemu_real_host_page_size and

       qemu_host_page_size here and elsewhere in target_mmap, which

       may lead to the end of the data section mapping from the file

       not being mapped.  At least there was an explicit test and

       comment for that here, suggesting that ""the file size must

       be known"".  The comment probably pre-dates the introduction

       of the fstat system call in target_mmap which does in fact

       find out the size.  What isn't clear is if the workaround

       here is still actually needed.  For now, continue with it,

       but merge it with the ""normal"" mmap that would allocate the bss.  */



    host_start = (uintptr_t) g2h(elf_bss);

    host_end = (uintptr_t) g2h(last_bss);

    host_map_start = (host_start + qemu_real_host_page_size - 1);

    ho",1,0,1,0,0,0,0,0,0,1,0,1,0,0,0
16498,FFmpeg,0,"static void avc_biwgt_4x4multiple_msa(uint8_t *src,

                                      int32_t src_stride,

                                      uint8_t *dst,

                                      int32_t dst_stride,

                                      int32_t height,

                                      int32_t log2_denom,

                                      int32_t src_weight,

                                      int32_t dst_weight,

                                      int32_t offset_in)

{

    uint8_t cnt;

    uint32_t load0, load1, load2, load3;

    v16i8 src_wgt, dst_wgt, wgt;

    v16i8 src0, src1, src2, src3;

    v16i8 dst0, dst1, dst2, dst3;

    v8i16 temp0, temp1, temp2, temp3;

    v8i16 denom, offset, add_val;

    int32_t val = 128 * (src_weight + dst_weight);



    offset_in = ((offset_in + 1) | 1) << log2_denom;



    src_wgt = __msa_fill_b(src_weight);

    dst_wgt = __msa_fill_b(dst_weight);

    offset = __msa_fill_h(offset_in);

    denom = __msa_fill_h(log2_denom + ",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
16501,qemu,0,"static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,

                              TCGReg arg1, intptr_t arg2)

{

    int opi, opx;



    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);

    if (type == TCG_TYPE_I32) {

        opi = LWZ, opx = LWZX;

    } else {

        opi = LD, opx = LDX;

    }

    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);

}
",0,0,1,0,0,0,0,1,0,0,1,1,1,0,0
16507,qemu,0,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
",0,0,3,0,0,2,0,1,0,1,0,1,1,0,0
16521,qemu,0,"void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *prop;



    QTAILQ_FOREACH(prop, &obj->properties, node) {

        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = g_malloc0(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
",0,0,1,0,0,0,0,0,1,0,0,0,0,0,0
16524,qemu,0,"static void collie_init(MachineState *machine)

{

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    StrongARMState *s;

    DriveInfo *dinfo;

    MemoryRegion *sysmem = get_system_memory();



    if (!cpu_model) {

        cpu_model = ""sa1110"";

    }



    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);



    dinfo = drive_get(IF_PFLASH, 0, 0);

    pflash_cfi01_register(SA_CS0, NULL, ""collie.fl1"", 0x02000000,

                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);



    dinfo = drive_get(IF_PFLASH, 0, 1);

    pflash_cfi01_register(SA_CS1, NULL, ""collie.fl2"", 0x02000000,

                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);



    sysbus_c",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
16536,FFmpeg,0,"void avg_pixels16_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)

{

POWERPC_TBL_DECLARE(altivec_avg_pixels16_num, 1);

#ifdef ALTIVEC_USE_REFERENCE_C_CODE

    int i;



POWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);



    for(i=0; i<h; i++) {

      op_avg(*((uint32_t*)(block)),(((const struct unaligned_32 *)(pixels))->l));

      op_avg(*((uint32_t*)(block+4)),(((const struct unaligned_32 *)(pixels+4))->l));

      op_avg(*((uint32_t*)(block+8)),(((const struct unaligned_32 *)(pixels+8))->l));

      op_avg(*((uint32_t*)(block+12)),(((const struct unaligned_32 *)(pixels+12))->l));

      pixels+=line_size;

      block +=line_size;

    }



POWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);



#else /* ALTIVEC_USE_REFERENCE_C_CODE */

    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;

    register vector unsigned char perm = vec_lvsl(0, pixels);

    int i;



POWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);



    for(i=0; i<h; i++) {

      pixel",2,0,1,0,0,0,1,1,1,1,1,1,0,0,1
16542,qemu,0,"static void blk_send_response_all(struct XenBlkDev *blkdev)

{

    struct ioreq *ioreq;

    int send_notify = 0;



    while (!LIST_EMPTY(&blkdev->finished)) {

        ioreq = LIST_FIRST(&blkdev->finished);

	send_notify += blk_send_response_one(ioreq);

	ioreq_release(ioreq);

    }

    if (send_notify)

	xen_be_send_notify(&blkdev->xendev);

}
",0,0,5,0,0,1,1,1,1,0,0,0,0,0,1
16566,qemu,0,"static int interface_client_monitors_config(QXLInstance *sin,

                                        VDAgentMonitorsConfig *monitors_config)

{

    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);

    QXLRom *rom = memory_region_get_ram_ptr(&qxl->rom_bar);

    int i;

    unsigned max_outputs = ARRAY_SIZE(rom->client_monitors_config.heads);



    if (qxl->revision < 4) {

        trace_qxl_client_monitors_config_unsupported_by_device(qxl->id,

                                                               qxl->revision);

        return 0;

    }

    /*

     * Older windows drivers set int_mask to 0 when their ISR is called,

     * then later set it to ~0. So it doesn't relate to the actual interrupts

     * handled. However, they are old, so clearly they don't support this

     * interrupt

     */

    if (qxl->ram->int_mask == 0 || qxl->ram->int_mask == ~0 ||

        !(qxl->ram->int_mask & QXL_INTERRUPT_CLIENT_MONITORS_CONFIG)) {

        trace_qxl_client_monitors_config_unsupporte",0,0,2,0,0,0,1,1,0,0,0,0,0,0,0
16585,qemu,0,"static void virtio_pci_realize(PCIDevice *pci_dev, Error **errp)

{

    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);

    VirtioPCIClass *k = VIRTIO_PCI_GET_CLASS(pci_dev);



    /*

     * virtio pci bar layout used by default.

     * subclasses can re-arrange things if needed.

     *

     *   region 0   --  virtio legacy io bar

     *   region 1   --  msi-x bar

     *   region 4+5 --  virtio modern memory (64bit) bar

     *

     */

    proxy->legacy_io_bar  = 0;

    proxy->msix_bar       = 1;

    proxy->modern_io_bar  = 2;

    proxy->modern_mem_bar = 4;



    proxy->common.offset = 0x0;

    proxy->common.size = 0x1000;

    proxy->common.type = VIRTIO_PCI_CAP_COMMON_CFG;



    proxy->isr.offset = 0x1000;

    proxy->isr.size = 0x1000;

    proxy->isr.type = VIRTIO_PCI_CAP_ISR_CFG;



    proxy->device.offset = 0x2000;

    proxy->device.size = 0x1000;

    proxy->device.type = VIRTIO_PCI_CAP_DEVICE_CFG;



    proxy->notify.offset = 0x3000;

    proxy->notify.size =

        QEMU_VIRTIO_PCI_",0,0,3,0,0,0,0,1,0,0,0,1,0,1,1
16602,FFmpeg,0,"static int cdxl_decode_frame(AVCodecContext *avctx, void *data,

                             int *data_size, AVPacket *pkt)

{

    CDXLVideoContext *c = avctx->priv_data;

    AVFrame * const p = &c->frame;

    int ret, w, h, encoding, format, buf_size = pkt->size;

    const uint8_t *buf = pkt->data;



    if (buf_size < 32)

        return AVERROR_INVALIDDATA;

    encoding        = buf[1] & 7;

    format          = buf[1] & 0xE0;

    w               = AV_RB16(&buf[14]);

    h               = AV_RB16(&buf[16]);

    c->bpp          = buf[19];

    c->palette_size = AV_RB16(&buf[20]);

    c->palette      = buf + 32;

    c->video        = c->palette + c->palette_size;

    c->video_size   = buf_size - c->palette_size - 32;



    if (c->palette_size > 512)

        return AVERROR_INVALIDDATA;

    if (buf_size < c->palette_size + 32)

        return AVERROR_INVALIDDATA;

    if (c->bpp < 1)

        return AVERROR_INVALIDDATA;

    if (c->bpp > 8) {

        av_log_ask_for_sample(avctx, ""unsupported ",3,0,5,0,0,0,0,0,1,0,0,0,0,0,0
16614,FFmpeg,1,"static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code)

{

    uint32_t opcode_size, offset;

    uint8_t *dst, *dend, mask = 0, color = 0;

    const uint8_t *src, *send, *opcodes;

    int i, j, op = 0;



    i = bytestream2_get_byte(&c->gb);

    if (i) {

        if (code & 0x10) {

            int align;



            align = bytestream2_tell(&c->gb) & 3;

            if (align)

                bytestream2_skip(&c->gb, 4 - align);

        }

        do {

            int page, val, x, y;

            val    = bytestream2_get_be16(&c->gb);

            page   = val >> 14;

            x      = (val & 0x7F) * 2;

            y      = ((val >> 7) & 0x7F) * 2;

            dst    = c->frame[page] + x + y * c->width;

            dend   = c->frame[page] + c->frame_size;

            offset = (x & 0x7F) * 2;

            j      = bytestream2_get_le16(&c->gb) + offset;

            do {

                offset++;

                if (dst + 3 * c->width + 4 > dend)

                    return",0,0,4,0,0,0,0,0,0,1,0,0,0,0,0
16628,qemu,0,"static void save_native_fp_fsave(CPUState *env)

{

    int fptag, i, j;

    uint16_t fpuc;

    struct fpstate fp1, *fp = &fp1;



    asm volatile (""fsave %0"" : : ""m"" (*fp));

    env->fpuc = fp->fpuc;

    env->fpstt = (fp->fpus >> 11) & 7;

    env->fpus = fp->fpus & ~0x3800;

    fptag = fp->fptag;

    for(i = 0;i < 8; i++) {

        env->fptags[i] = ((fptag & 3) == 3);

        fptag >>= 2;

    }

    j = env->fpstt;

    for(i = 0;i < 8; i++) {

        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);

        j = (j + 1) & 7;

    }

    /* we must restore the default rounding state */

    fpuc = 0x037f | (env->fpuc & (3 << 10));

    asm volatile(""fldcw %0"" : : ""m"" (fpuc));

}
",2,0,0,0,0,0,0,0,0,0,0,0,1,0,0
16651,FFmpeg,0,"static int decode_thread(void *arg)

{

    VideoState *is = arg;

    AVFormatContext *ic;

    int err, i, ret, video_index, audio_index, subtitle_index;

    AVPacket pkt1, *pkt = &pkt1;

    AVFormatParameters params, *ap = &params;



    video_index = -1;

    audio_index = -1;

    subtitle_index = -1;

    is->video_stream = -1;

    is->audio_stream = -1;

    is->subtitle_stream = -1;



    global_video_state = is;

    url_set_interrupt_cb(decode_interrupt_cb);



    memset(ap, 0, sizeof(*ap));



    ap->width = frame_width;

    ap->height= frame_height;

    ap->time_base= (AVRational){1, 25};

    ap->pix_fmt = frame_pix_fmt;



    err = av_open_input_file(&ic, is->filename, is->iformat, 0, ap);

    if (err < 0) {

        print_error(is->filename, err);

        ret = -1;

        goto fail;

    }

    is->ic = ic;



    if(genpts)

        ic->flags |= AVFMT_FLAG_GENPTS;



    err = av_find_stream_info(ic);

    if (err < 0) {

        fprintf(stderr, ""%s: could not find codec paramete",1,1,4,0,0,0,0,0,0,0,0,0,0,0,0
16664,FFmpeg,1,"static int adpcm_decode_frame(AVCodecContext *avctx, void *data,
                              int *got_frame_ptr, AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    ADPCMDecodeContext *c = avctx->priv_data;
    ADPCMChannelStatus *cs;
    int n, m, channel, i;
    short *samples;
    const uint8_t *src;
    int st; /* stereo */
    int count1, count2;
    int nb_samples, coded_samples, ret;
    nb_samples = get_nb_samples(avctx, buf, buf_size, &coded_samples);
    if (nb_samples <= 0) {
        av_log(avctx, AV_LOG_ERROR, ""invalid number of samples in packet\n"");
    }
    /* get output buffer */
    c->frame.nb_samples = nb_samples;
    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
        return ret;
    }
    samples = (short *)c->frame.data[0];
    /* use coded_samples when applicable */
    /* it is always <= nb_samples, so the output buffer will be large enough */
    if (coded_samples) {
  ",0,0,3,0,0,0,1,1,1,1,1,1,0,0,0
16666,qemu,1,"static void cpu_ioreq_pio(ioreq_t *req)

{

    int i, sign;



    sign = req->df ? -1 : 1;



    if (req->dir == IOREQ_READ) {

        if (!req->data_is_ptr) {

            req->data = do_inp(req->addr, req->size);

        } else {

            uint32_t tmp;



            for (i = 0; i < req->count; i++) {

                tmp = do_inp(req->addr, req->size);

                cpu_physical_memory_write(

                        req->data + (sign * i * (int64_t)req->size),

                        (uint8_t *) &tmp, req->size);

            }

        }

    } else if (req->dir == IOREQ_WRITE) {

        if (!req->data_is_ptr) {

            do_outp(req->addr, req->size, req->data);

        } else {

            for (i = 0; i < req->count; i++) {

                uint32_t tmp = 0;



                cpu_physical_memory_read(

                        req->data + (sign * i * (int64_t)req->size),

                        (uint8_t*) &tmp, req->size);

                do_outp(req->addr, req->size, tmp);

      ",2,0,4,0,0,0,1,1,1,1,0,1,0,0,0
16693,FFmpeg,1,"static char *choose_pixel_fmts(OutputStream *ost)

{

    if (ost->keep_pix_fmt) {

        if (ost->filter)

            avfilter_graph_set_auto_convert(ost->filter->graph->graph,

                                            AVFILTER_AUTO_CONVERT_NONE);

        if (ost->st->codec->pix_fmt == PIX_FMT_NONE)

            return NULL;

        ost->pix_fmts[0] = ost->st->codec->pix_fmt;

        return ost->pix_fmts;

    }

    if (ost->st->codec->pix_fmt != PIX_FMT_NONE) {

        return av_strdup(av_get_pix_fmt_name(choose_pixel_fmt(ost->st, ost->enc, ost->st->codec->pix_fmt)));

    } else if (ost->enc->pix_fmts) {

        const enum PixelFormat *p;

        AVIOContext *s = NULL;

        uint8_t *ret;

        int len;



        if (avio_open_dyn_buf(&s) < 0)

            exit_program(1);



        p = ost->enc->pix_fmts;

        if (ost->st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {

            if (ost->st->codec->codec_id == CODEC_ID_MJPEG) {

                p = (const enum Pixe",0,0,8,0,0,0,0,0,0,0,0,0,1,0,0
16700,FFmpeg,1,"static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)

{

    char buffer[32];

    if (time) {

        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */

        strftime(buffer, sizeof(buffer), ""%Y-%m-%d %H:%M:%S"", gmtime(&time));

        av_metadata_set2(metadata, ""creation_time"", buffer, 0);

    }

}
",0,0,1,0,0,0,1,0,1,1,1,1,1,1,1
16708,qemu,1,"static uint32_t hpet_ram_readl(void *opaque, target_phys_addr_t addr)

{

    HPETState *s = (HPETState *)opaque;

    uint64_t cur_tick, index;



    DPRINTF(""qemu: Enter hpet_ram_readl at %"" PRIx64 ""\n"", addr);

    index = addr;

    /*address range of all TN regs*/

    if (index >= 0x100 && index <= 0x3ff) {

        uint8_t timer_id = (addr - 0x100) / 0x20;

        if (timer_id > HPET_NUM_TIMERS - 1) {

            printf(""qemu: timer id out of range\n"");

            return 0;

        }

        HPETTimer *timer = &s->timer[timer_id];



        switch ((addr - 0x100) % 0x20) {

            case HPET_TN_CFG:

                return timer->config;

            case HPET_TN_CFG + 4: // Interrupt capabilities

                return timer->config >> 32;

            case HPET_TN_CMP: // comparator register

                return timer->cmp;

            case HPET_TN_CMP + 4:

                return timer->cmp >> 32;

            case HPET_TN_ROUTE:

                return timer->fsb >> 32;

          ",0,0,2,0,1,0,1,1,1,0,0,0,0,1,1
16717,qemu,1,"void usb_claim_port(USBDevice *dev, Error **errp)

{

    USBBus *bus = usb_bus_from_device(dev);

    USBPort *port;



    assert(dev->port == NULL);



    if (dev->port_path) {

        QTAILQ_FOREACH(port, &bus->free, next) {

            if (strcmp(port->path, dev->port_path) == 0) {

                break;

            }

        }

        if (port == NULL) {

            error_setg(errp, ""usb port %s (bus %s) not found (in use?)"",

                       dev->port_path, bus->qbus.name);

            return;

        }

    } else {

        if (bus->nfree == 1 && strcmp(object_get_typename(OBJECT(dev)), ""usb-hub"") != 0) {

            /* Create a new hub and chain it on */

            usb_create_simple(bus, ""usb-hub"");

        }

        if (bus->nfree == 0) {

            error_setg(errp, ""tried to attach usb device %s to a bus ""

                       ""with no free ports"", dev->product_desc);

            return;

        }

        port = QTAILQ_FIRST(&bus->free);

    }

    trace_usb_port_cla",0,0,5,0,0,0,0,0,0,0,0,0,1,1,1
16723,qemu,0,"static void vmxnet3_update_features(VMXNET3State *s)

{

    uint32_t guest_features;

    int rxcso_supported;



    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,

                                               devRead.misc.uptFeatures);



    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);

    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);

    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);



    VMW_CFPRN(""Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d"",

              s->lro_supported, rxcso_supported,

              s->rx_vlan_stripping);

    if (s->peer_has_vhdr) {

        qemu_peer_set_offload(qemu_get_queue(s->nic),

                        rxcso_supported,

                        s->lro_supported,

                        s->lro_supported,

                        0,

                        0);

    }

}
",0,0,1,0,0,0,0,1,0,0,1,0,0,0,0
16724,qemu,0,"static int virtio_blk_exit_pci(PCIDevice *pci_dev)

{

    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);



    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);

    return virtio_exit_pci(pci_dev);

}
",0,0,0,0,0,0,1,1,1,1,1,0,1,0,0
16727,FFmpeg,0,"yuv2rgba64_full_1_c_template(SwsContext *c, const int32_t *buf0,

                       const int32_t *ubuf[2], const int32_t *vbuf[2],

                       const int32_t *abuf0, uint16_t *dest, int dstW,

                       int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)

{

    const int32_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];

    int i;

    int A = 0xffff<<14;



    if (uvalpha < 2048) {

        for (i = 0; i < dstW; i++) {

            int Y  = (buf0[i]) >> 2;

            int U  = (ubuf0[i] + (-128 << 11)) >> 2;

            int V  = (vbuf0[i] + (-128 << 11)) >> 2;

            int R, G, B;



            Y -= c->yuv2rgb_y_offset;

            Y *= c->yuv2rgb_y_coeff;

            Y += 1 << 13;



            if (hasAlpha) {

                A = abuf0[i] << 11;



                A += 1 << 13;

            }



            R = V * c->yuv2rgb_v2r_coeff;

            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;

            B =                           ",1,0,2,0,0,0,0,0,0,0,0,0,1,1,1
16728,qemu,0,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
",0,0,0,0,0,0,0,0,0,1,0,1,1,1,1
16735,qemu,0,"static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int n;

    TCGv t0, t1;



    for (n = 0; n < q + 1; n += 2) {

        t0 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}
",1,0,0,0,1,0,1,1,1,1,1,0,0,0,0
16752,qemu,0,"static void parse_numa_distance(NumaDistOptions *dist, Error **errp)

{

    uint16_t src = dist->src;

    uint16_t dst = dist->dst;

    uint8_t val = dist->val;



    if (src >= MAX_NODES || dst >= MAX_NODES) {

        error_setg(errp,

                   ""Invalid node %"" PRIu16

                   "", max possible could be %"" PRIu16,

                   MAX(src, dst), MAX_NODES);

        return;

    }



    if (!numa_info[src].present || !numa_info[dst].present) {

        error_setg(errp, ""Source/Destination NUMA node is missing. ""

                   ""Please use '-numa node' option to declare it first."");

        return;

    }



    if (val < NUMA_DISTANCE_MIN) {

        error_setg(errp, ""NUMA distance (%"" PRIu8 "") is invalid, ""

                   ""it shouldn't be less than %d."",

                   val, NUMA_DISTANCE_MIN);

        return;

    }



    if (src == dst && val != NUMA_DISTANCE_MIN) {

        error_setg(errp, ""Local distance of node %d should be %d."",

                   src, NU",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
16755,FFmpeg,1,"static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,

                         uint32_t *pal, int colors)

{

    int i;



    for (i = 0; i <= colors; i++) {

        uint8_t r, g, b;

        unsigned int idx = bytestream2_get_be16(gbc); /* color index */

        if (idx > 255) {

            av_log(avctx, AV_LOG_WARNING,

                   ""Palette index out of range: %u\n"", idx);

            bytestream2_skip(gbc, 6);

            continue;

        }

        r = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        g = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        b = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        pal[idx] = (r << 16) | (g << 8) | b;

    }

    return 0;

}
",1,0,1,0,0,0,0,0,1,0,0,1,1,1,0
16767,FFmpeg,1,"static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
",0,0,0,0,0,0,0,0,0,0,1,1,0,0,0
16771,qemu,1,"uint32_t kvm_arch_get_supported_cpuid(CPUState *env, uint32_t function,

                                      uint32_t index, int reg)

{

    struct kvm_cpuid2 *cpuid;

    int i, max;

    uint32_t ret = 0;

    uint32_t cpuid_1_edx;



    if (!kvm_check_extension(env->kvm_state, KVM_CAP_EXT_CPUID)) {

        return -1U;

    }



    max = 1;

    while ((cpuid = try_get_cpuid(env->kvm_state, max)) == NULL) {

        max *= 2;

    }



    for (i = 0; i < cpuid->nent; ++i) {

        if (cpuid->entries[i].function == function &&

            cpuid->entries[i].index == index) {

            switch (reg) {

            case R_EAX:

                ret = cpuid->entries[i].eax;

                break;

            case R_EBX:

                ret = cpuid->entries[i].ebx;

                break;

            case R_ECX:

                ret = cpuid->entries[i].ecx;

                break;

            case R_EDX:

                ret = cpuid->entries[i].edx;

                switch (function) {

          ",1,0,2,0,2,1,0,0,0,0,0,0,0,1,1
16780,qemu,0,"static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,

                          uint8_t **bufptr, DumpState *s)

{

    GuestPhysBlock *block = *blockptr;

    hwaddr addr;

    uint8_t *buf;



    /* block == NULL means the start of the iteration */

    if (!block) {

        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);

        *blockptr = block;

        assert(block->target_start % s->page_size == 0);

        assert(block->target_end % s->page_size == 0);

        *pfnptr = paddr_to_pfn(block->target_start);

        if (bufptr) {

            *bufptr = block->host_addr;

        }

        return true;

    }



    *pfnptr = *pfnptr + 1;

    addr = pfn_to_paddr(*pfnptr);



    if ((addr >= block->target_start) &&

        (addr + s->page_size <= block->target_end)) {

        buf = block->host_addr + (addr - block->target_start);

    } else {

        /* the next page is in the next block */

        block = QTAILQ_NEXT(block, next);

        *blockptr = block;

        if (",0,0,4,0,0,0,0,0,1,0,0,0,0,0,0
16783,qemu,0,"static coroutine_fn int qcow2_co_writev(BlockDriverState *bs,

                           int64_t sector_num,

                           int remaining_sectors,

                           QEMUIOVector *qiov)

{

    BDRVQcowState *s = bs->opaque;

    int index_in_cluster;

    int n_end;

    int ret;

    int cur_nr_sectors; /* number of sectors in current iteration */

    uint64_t cluster_offset;

    QEMUIOVector hd_qiov;

    uint64_t bytes_done = 0;

    uint8_t *cluster_data = NULL;

    QCowL2Meta *l2meta;



    trace_qcow2_writev_start_req(qemu_coroutine_self(), sector_num,

                                 remaining_sectors);



    qemu_iovec_init(&hd_qiov, qiov->niov);



    s->cluster_cache_offset = -1; /* disable compressed cache */



    qemu_co_mutex_lock(&s->lock);



    while (remaining_sectors != 0) {



        l2meta = NULL;



        trace_qcow2_writev_start_part(qemu_coroutine_self());

        index_in_cluster = sector_num & (s->cluster_sectors - 1);

        n_end = index_in_cl",0,0,0,0,0,1,0,0,0,0,0,0,0,0,0
16787,qemu,0,"int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)

{

    const USBDesc *desc = dev->info->usb_desc;

    uint8_t buf[256];

    uint8_t type = value >> 8;

    uint8_t index = value & 0xff;

    int ret = -1;



    switch(type) {

    case USB_DT_DEVICE:

        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));

        trace_usb_desc_device(dev->addr, len, ret);

        break;

    case USB_DT_CONFIG:

        if (index < desc->full->bNumConfigurations) {

            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));

        }

        trace_usb_desc_config(dev->addr, index, len, ret);

        break;

    case USB_DT_STRING:

        ret = usb_desc_string(dev, index, buf, sizeof(buf));

        trace_usb_desc_string(dev->addr, index, len, ret);

        break;

    default:

        fprintf(stderr, ""%s: %d unknown type %d (len %zd)\n"", __FUNCTION__,

                dev->addr, type, len);

        break;

    }



    if (ret > 0) {

     ",0,0,2,0,1,0,0,0,0,0,0,0,0,1,1
16792,qemu,0,"static void connex_init(MachineState *machine)

{

    PXA2xxState *cpu;

    DriveInfo *dinfo;

    int be;

    MemoryRegion *address_space_mem = get_system_memory();



    uint32_t connex_rom = 0x01000000;

    uint32_t connex_ram = 0x04000000;



    cpu = pxa255_init(address_space_mem, connex_ram);



    dinfo = drive_get(IF_PFLASH, 0, 0);

    if (!dinfo && !qtest_enabled()) {

        fprintf(stderr, ""A flash image must be given with the ""

                ""'pflash' parameter\n"");

        exit(1);

    }



#ifdef TARGET_WORDS_BIGENDIAN

    be = 1;

#else

    be = 0;

#endif

    if (!pflash_cfi01_register(0x00000000, NULL, ""connext.rom"", connex_rom,

                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,

                               sector_len, connex_rom / sector_len,

                               2, 0, 0, 0, 0, be)) {

        fprintf(stderr, ""qemu: Error registering flash memory.\n"");

        exit(1);

    }



    /* Interrupt line of NIC is connected to GPIO ",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
16794,qemu,0,"void aio_set_event_notifier(AioContext *ctx,

                            EventNotifier *notifier,

                            bool is_external,

                            EventNotifierHandler *io_read,

                            AioPollFn *io_poll)

{

    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,

                       (IOHandler *)io_read, NULL, io_poll, notifier);

}
",0,0,7,0,0,0,0,0,0,1,0,0,0,0,0
16795,FFmpeg,0,"void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,

                   uint8_t *iv, int decrypt)

{

    int i;



    while (count > 0) {

        if (decrypt) {

            xtea_crypt_ecb(ctx, dst, src, decrypt);



            if (iv) {

                for (i = 0; i < 8; i++)

                    dst[i] = dst[i] ^ iv[i];

                memcpy(iv, src, 8);

            }

        } else {

            if (iv) {

                for (i = 0; i < 8; i++)

                    dst[i] = src[i] ^ iv[i];

                xtea_crypt_ecb(ctx, dst, dst, decrypt);

                memcpy(iv, dst, 8);

            } else {

                xtea_crypt_ecb(ctx, dst, src, decrypt);

            }

        }



        src   += 8;

        dst   += 8;

        count -= 8;

    }

}
",2,0,3,0,0,1,0,0,0,0,0,0,0,0,0
16808,FFmpeg,0,"static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)

{

    AVRational time_base = {1, 1000};

    uint32_t start, end;

    AVChapter *chapter;

    uint8_t *dst = NULL;

    int taglen;

    char tag[5];



    decode_str(s, pb, 0, &dst, &len);

    if (len < 16)

        return;



    start = avio_rb32(pb);

    end   = avio_rb32(pb);

    avio_skip(pb, 8);



    chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);

    if (!chapter) {

        av_free(dst);

        return;

    }



    len -= 16;

    while (len > 10) {

        avio_read(pb, tag, 4);

        tag[4] = 0;

        taglen = avio_rb32(pb);

        avio_skip(pb, 2);

        len -= 10;

        if (taglen < 0 || taglen > len) {

            av_free(dst);

            return;

        }

        if (tag[0] == 'T')

            read_ttag(s, pb, taglen, &chapter->metadata, tag);

        else

            avio_skip(pb, taglen);

        len -= taglen;

",0,0,4,0,0,1,0,1,1,1,1,1,0,0,0
16812,qemu,0,"void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr)

{

    unsigned long page_index;

    int ret;

#ifdef _WIN32

    DWORD temp;

#endif



    page_index = ram_addr >> TARGET_PAGE_BITS;

    if (!modified_ram_pages_table[page_index]) {

#if 0

        printf(""%d: modify_page=%08lx\n"", nb_modified_ram_pages, ram_addr);

#endif

        modified_ram_pages_table[page_index] = 1;

        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;

        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {

            /* flush */

#ifdef _WIN32

            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,

                                  &nb_modified_ram_pages,

                                  sizeof(nb_modified_ram_pages),

                                  NULL, 0, &temp, NULL);

#else

            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,

                        &nb_modified_ram_pages);

#endif

            kqemu_reset_modified_ram_pages();

        }

    }

}
",0,0,20,0,0,0,0,0,0,0,0,0,1,1,1
16829,qemu,0,"static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,

                                 unsigned npfd, int64_t timeout)

{

    if (!ctx->epoll_available) {

        return false;

    }

    if (aio_epoll_enabled(ctx)) {

        return true;

    }

    if (npfd >= EPOLL_ENABLE_THRESHOLD) {

        if (aio_epoll_try_enable(ctx)) {

            return true;

        } else {

            aio_epoll_disable(ctx);

        }

    }

    return false;

}
",0,0,4,0,0,0,0,1,0,0,0,0,0,0,0
16842,qemu,0,"static void aarch64_cpu_register_types(void)

{

    int i;



    type_register_static(&aarch64_cpu_type_info);

    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {

        aarch64_cpu_register(&aarch64_cpus[i]);

    }

}
",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
16862,qemu,0,"static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,

                               uint64_t value, unsigned size)

{

    musicpal_lcd_state *s = opaque;



    switch (offset) {

    case MP_LCD_IRQCTRL:

        s->irqctrl = value;

        break;



    case MP_LCD_SPICTRL:

        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {

            s->mode = value;

        } else {

            s->mode = MP_LCD_SPI_INVALID;

        }

        break;



    case MP_LCD_INST:

        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {

            s->page = value - MP_LCD_INST_SETPAGE0;

            s->page_off = 0;

        }

        break;



    case MP_LCD_DATA:

        if (s->mode == MP_LCD_SPI_CMD) {

            if (value >= MP_LCD_INST_SETPAGE0 &&

                value <= MP_LCD_INST_SETPAGE7) {

                s->page = value - MP_LCD_INST_SETPAGE0;

                s->page_off = 0;

            }

        } else if (s->mode == MP_LCD_SPI_DATA) {

 ",0,0,5,0,1,0,0,0,0,0,0,1,0,0,0
16870,qemu,0,"static inline uint32_t nvic_gprio_mask(NVICState *s)

{

    return ~0U << (s->prigroup + 1);

}
",0,0,0,0,0,0,0,1,1,0,1,0,0,0,0
16879,qemu,0,"int qemu_eventfd(int fds[2])

{

#ifdef CONFIG_EVENTFD

    int ret;



    ret = eventfd(0, 0);

    if (ret >= 0) {

        fds[0] = ret;

        qemu_set_cloexec(ret);

        if ((fds[1] = dup(ret)) == -1) {

            close(ret);

            return -1;

        }

        qemu_set_cloexec(fds[1]);

        return 0;

    }



    if (errno != ENOSYS) {

        return -1;

    }

#endif



    return qemu_pipe(fds);

}
",0,0,5,0,0,0,0,0,0,0,1,0,0,0,0
16888,qemu,0,"static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)

{

    return -ENOTSUP;

}
",0,0,0,0,0,0,0,1,1,1,0,0,1,1,1
16890,qemu,0,"void HELPER(wsr_ibreakenable)(uint32_t v)

{

    uint32_t change = v ^ env->sregs[IBREAKENABLE];

    unsigned i;



    for (i = 0; i < env->config->nibreak; ++i) {

        if (change & (1 << i)) {

            tb_invalidate_phys_page_range(

                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);

        }

    }

    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);

}
",1,0,1,0,0,0,0,1,0,1,0,0,0,1,0
16924,qemu,1,"static void openrisc_cpu_class_init(ObjectClass *oc, void *data)

{

    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(occ);

    DeviceClass *dc = DEVICE_CLASS(oc);



    occ->parent_realize = dc->realize;

    dc->realize = openrisc_cpu_realizefn;



    occ->parent_reset = cc->reset;

    cc->reset = openrisc_cpu_reset;



    cc->class_by_name = openrisc_cpu_class_by_name;

    cc->has_work = openrisc_cpu_has_work;

    cc->do_interrupt = openrisc_cpu_do_interrupt;

    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;

    cc->dump_state = openrisc_cpu_dump_state;

    cc->set_pc = openrisc_cpu_set_pc;

    cc->gdb_read_register = openrisc_cpu_gdb_read_register;

    cc->gdb_write_register = openrisc_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;

#else

    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;

    dc->vmsd = &vmstate_openrisc_cpu;

#endif

    cc->gdb_num_core_regs = 32 + 3;



    /",0,0,2,0,0,0,0,0,0,1,0,0,0,0,0
16930,qemu,1,"static void tcp_accept_incoming_migration(void *opaque)

{

    struct sockaddr_in addr;

    socklen_t addrlen = sizeof(addr);

    int s = (intptr_t)opaque;

    QEMUFile *f;

    int c;



    do {

        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);

    } while (c == -1 && socket_error() == EINTR);

    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);

    closesocket(s);



    DPRINTF(""accepted migration\n"");



    if (c == -1) {

        fprintf(stderr, ""could not accept migration connection\n"");

        goto out;

    }



    f = qemu_fopen_socket(c, ""rb"");

    if (f == NULL) {

        fprintf(stderr, ""could not qemu_fopen socket\n"");

        goto out;

    }



    process_incoming_migration(f);

    return;



out:

    closesocket(c);

}
",0,2,2,0,0,1,0,1,1,1,1,1,1,1,1
16933,qemu,1,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)

{

    int i;

    assert(dest->niov == source->niov);

    assert(dest->size == source->size);

    for (i = 0; i < source->niov; i++) {

        assert(dest->iov[i].iov_len == source->iov[i].iov_len);

        memcpy(dest->iov[i].iov_base,

               source->iov[i].iov_base,

               source->iov[i].iov_len);

    }

}
",1,0,0,0,0,0,1,1,1,1,1,1,0,0,0
16984,FFmpeg,0,"static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)

{

    const uint8_t *src_end = src + src_size;

    int x = 0, y = 0;



#define INC_XY(n) \

    x += n; \

    if (x >= width) { \

        y++; \

        if (y >= height) \

            return 0; \

        x = 0; \

    }



    while (src_end - src >= 2) {

        uint8_t v = *src++;

        if (v > 0 && v < 0xC0) {

            do {

                int length = FFMIN(v, width - x);

                memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length);

                INC_XY(length);

                v   -= length;

            } while (v > 0);

            src++;

        } else if (v >= 0xC1) {

            v -= 0xC0;

            do {

                int length = FFMIN3(v, width - x, src_end - src);

                if (src_end - src < length)

                    break;

                memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length);

          ",0,0,5,0,0,2,1,1,1,1,0,0,1,0,1
16986,FFmpeg,0,"static int hls_read_seek(AVFormatContext *s, int stream_index,

                               int64_t timestamp, int flags)

{

    HLSContext *c = s->priv_data;

    int i;

    int64_t seek_timestamp;

    int valid_for = -1;



    if ((flags & AVSEEK_FLAG_BYTE) || !c->variants[0]->playlists[0]->finished)

        return AVERROR(ENOSYS);



    seek_timestamp = stream_index < 0 ? timestamp :

                     av_rescale_rnd(timestamp, AV_TIME_BASE,

                                    s->streams[stream_index]->time_base.den,

                                    flags & AVSEEK_FLAG_BACKWARD ?

                                    AV_ROUND_DOWN : AV_ROUND_UP);



    if (s->duration < seek_timestamp)

        return AVERROR(EIO);



    for (i = 0; i < c->n_playlists; i++) {

        /* check first that the timestamp is valid for some playlist */

        struct playlist *pls = c->playlists[i];

        int seq_no;

        if (find_timestamp_in_playlist(c, pls, seek_timestamp, &seq_no)) {

            /",2,0,3,0,0,0,1,1,1,1,1,1,1,1,1
16999,qemu,0,"static int assigned_initfn(struct PCIDevice *pci_dev)

{

    AssignedDevice *dev = DO_UPCAST(AssignedDevice, dev, pci_dev);

    uint8_t e_intx;

    int r;

    Error *local_err = NULL;



    if (!kvm_enabled()) {

        error_report(""pci-assign: error: requires KVM support"");

        return -1;

    }



    if (!dev->host.domain && !dev->host.bus && !dev->host.slot &&

        !dev->host.function) {

        error_report(""pci-assign: error: no host device specified"");

        return -1;

    }



    /*

     * Set up basic config space access control. Will be further refined during

     * device initialization.

     */

    assigned_dev_emulate_config_read(dev, 0, PCI_CONFIG_SPACE_SIZE);

    assigned_dev_direct_config_read(dev, PCI_STATUS, 2);

    assigned_dev_direct_config_read(dev, PCI_REVISION_ID, 1);

    assigned_dev_direct_config_read(dev, PCI_CLASS_PROG, 3);

    assigned_dev_direct_config_read(dev, PCI_CACHE_LINE_SIZE, 1);

    assigned_dev_direct_config_read(dev, PCI_LATENCY_TIMER, 1);
",0,0,3,0,0,0,0,0,1,1,1,0,0,0,0
17004,qemu,0,"int xen_be_send_notify(struct XenDevice *xendev)

{

    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,1,0
17009,FFmpeg,0,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
",0,0,3,0,0,0,0,0,0,0,0,1,0,1,1
17012,qemu,0,"static void ide_atapi_cmd_reply_end(IDEState *s)

{

    int byte_count_limit, size, ret;

#ifdef DEBUG_IDE_ATAPI

    printf(""reply: tx_size=%d elem_tx_size=%d index=%d\n"",

           s->packet_transfer_size,

           s->elementary_transfer_size,

           s->io_buffer_index);

#endif

    if (s->packet_transfer_size <= 0) {

        /* end of transfer */

        ide_transfer_stop(s);

        s->status = READY_STAT;

        s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;

        ide_set_irq(s);

#ifdef DEBUG_IDE_ATAPI

        printf(""status=0x%x\n"", s->status);

#endif

    } else {

        /* see if a new sector must be read */

        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {

            ret = cd_read_sector(s->bs, s->lba, s->io_buffer, s->cd_sector_size);

            if (ret < 0) {

                ide_transfer_stop(s);

                ide_atapi_io_error(s, ret);

                return;

            }

            s->lba++;

            s->",0,0,7,0,0,0,1,1,1,1,1,0,0,0,0
17021,qemu,0,"static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,

                                  uint32_t val)

{

    MiscState *s = opaque;

    uint32_t saddr;



    saddr = addr & LED_MAXADDR;

    MISC_DPRINTF(""Write diagnostic LED reg 0x"" TARGET_FMT_plx "" =  %x\n"", addr,

                 val);

    switch (saddr) {

    case 0:

        s->leds = val;

        break;

    default:

        break;

    }

}
",0,0,0,0,1,0,0,0,0,1,1,0,1,1,1
17030,qemu,0,"int coroutine_fn bdrv_co_discard(BlockDriverState *bs, int64_t sector_num,

                                 int nb_sectors)

{

    int max_discard;



    if (!bs->drv) {

        return -ENOMEDIUM;

    } else if (bdrv_check_request(bs, sector_num, nb_sectors)) {

        return -EIO;

    } else if (bs->read_only) {

        return -EROFS;

    }



    bdrv_reset_dirty(bs, sector_num, nb_sectors);



    /* Do nothing if disabled.  */

    if (!(bs->open_flags & BDRV_O_UNMAP)) {

        return 0;

    }



    if (!bs->drv->bdrv_co_discard && !bs->drv->bdrv_aio_discard) {

        return 0;

    }



    max_discard = bs->bl.max_discard ?  bs->bl.max_discard : MAX_DISCARD_DEFAULT;

    while (nb_sectors > 0) {

        int ret;

        int num = nb_sectors;



        /* align request */

        if (bs->bl.discard_alignment &&

            num >= bs->bl.discard_alignment &&

            sector_num % bs->bl.discard_alignment) {

            if (num > bs->bl.discard_alignment) {

                num = b",0,0,7,0,0,1,1,1,1,1,0,1,0,0,0
17043,qemu,0,"static void xlnx_ep108_machine_init(MachineClass *mc)

{

    mc->desc = ""Xilinx ZynqMP EP108 board"";

    mc->init = xlnx_ep108_init;

    mc->block_default_type = IF_IDE;

    mc->units_per_default_bus = 1;

    mc->ignore_memory_transaction_failures = true;

}
",0,0,0,0,0,0,0,0,1,0,0,1,0,0,0
17048,qemu,0,"static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,

                             TCGReg rd, TCGReg rn, uint64_t limm)

{

    unsigned h, l, r, c;



    assert(is_limm(limm));



    h = clz64(limm);

    l = ctz64(limm);

    if (l == 0) {

        r = 0;                  /* form 0....01....1 */

        c = ctz64(~limm) - 1;

        if (h == 0) {

            r = clz64(~limm);   /* form 1..10..01..1 */

            c += r;

        }

    } else {

        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */

        c = r - h - 1;

    }

    if (ext == TCG_TYPE_I32) {

        r &= 31;

        c &= 31;

    }



    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,0,0
17072,qemu,0,"void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,

                  bool smm_enabled,

                  qemu_irq sci_irq)

{

    memory_region_init(&pm->io, OBJECT(lpc_pci), ""ich9-pm"", ICH9_PMIO_SIZE);

    memory_region_set_enabled(&pm->io, false);

    memory_region_add_subregion(pci_address_space_io(lpc_pci),

                                0, &pm->io);



    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);

    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);

    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->disable_s3, pm->disable_s4,

                      pm->s4_val);



    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);

    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,

                          ""acpi-gpe0"", ICH9_PMIO_GPE0_LEN);

    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);



    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,

                          ""acpi-smi"", 8);

",0,0,0,0,0,0,1,1,1,0,0,1,1,1,1
17082,qemu,0,"static void handle_sys(DisasContext *s, uint32_t insn, bool isread,

                       unsigned int op0, unsigned int op1, unsigned int op2,

                       unsigned int crn, unsigned int crm, unsigned int rt)

{

    const ARMCPRegInfo *ri;

    TCGv_i64 tcg_rt;



    ri = get_arm_cp_reginfo(s->cp_regs,

                            ENCODE_AA64_CP_REG(CP_REG_ARM64_SYSREG_CP,

                                               crn, crm, op0, op1, op2));



    if (!ri) {

        /* Unknown register; this might be a guest error or a QEMU

         * unimplemented feature.

         */

        qemu_log_mask(LOG_UNIMP, ""%s access to unsupported AArch64 ""

                      ""system register op0:%d op1:%d crn:%d crm:%d op2:%d\n"",

                      isread ? ""read"" : ""write"", op0, op1, crn, crm, op2);

        unallocated_encoding(s);

        return;

    }



    /* Check access permissions */

    if (!cp_access_ok(s->current_el, ri, isread)) {

        unallocated_encoding(s);

        return",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
17085,qemu,0,"static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,

                                            const char *json_string)

{

    return visitor_input_test_init_internal(data, json_string, NULL);

}
",0,0,0,0,0,0,0,0,0,1,1,1,0,1,1
17092,qemu,0,"static void do_info_version(Monitor *mon)

{

    monitor_printf(mon, ""%s\n"", QEMU_VERSION);

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
17101,qemu,1,"static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,

                                    const uint8_t *key, size_t nkey,

                                    Error **errp)

{

    uint8_t *salt;

    size_t nhash;

    size_t nsalt;

    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);



    /* Not necessarily the same as nkey */

    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);



    nhash = qcrypto_hash_digest_len(ivgen->hash);

    /* Salt must be larger of hash size or key size */

    salt = g_new0(uint8_t, MAX(nhash, nsalt));



    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,

                           &salt, &nhash,

                           errp) < 0) {

        g_free(essiv);


        return -1;

    }



    /* Now potentially truncate salt to match cipher key len */

    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,

                                       QCRYPTO_CIPHER_MODE_ECB,

                                       salt, MIN(nhash, nsalt),

      ",0,0,1,0,0,0,1,1,1,1,1,1,0,0,0
17113,FFmpeg,1,"static void mpeg1_encode_sequence_header(MpegEncContext *s)

{

        unsigned int vbv_buffer_size;

        unsigned int fps, v;

        int n;

        UINT64 time_code;

        

        if ((s->picture_number % s->gop_size) == 0) {

            /* mpeg1 header repeated every gop */

            put_header(s, SEQ_START_CODE);

            

            /* search closest frame rate */

            {

                int i, dmin, d;

                s->frame_rate_index = 0;

                dmin = 0x7fffffff;

                for(i=1;i<9;i++) {

                    d = abs(s->frame_rate - frame_rate_tab[i]);

                    if (d < dmin) {

                        dmin = d;

                        s->frame_rate_index = i;

                    }

                }

            }

 

            put_bits(&s->pb, 12, s->width);

            put_bits(&s->pb, 12, s->height);

            put_bits(&s->pb, 4, 1); /* 1/1 aspect ratio */

            put_bits(&s->pb, 4, s->frame_rate_index);

            v ",1,0,2,0,0,0,1,1,1,1,0,1,1,1,0
17118,FFmpeg,0,"void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_4w_msa(src + stride - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 4);

}
",0,0,1,0,0,0,0,1,0,0,0,0,0,1,1
17120,FFmpeg,0,"static av_cold int mpeg_mux_init(AVFormatContext *ctx)

{

    MpegMuxContext *s = ctx->priv_data;

    int bitrate, i, mpa_id, mpv_id, h264_id, mps_id, ac3_id, dts_id, lpcm_id, j;

    AVStream *st;

    StreamInfo *stream;

    int audio_bitrate;

    int video_bitrate;



    s->packet_number = 0;

    s->is_vcd   =  (CONFIG_MPEG1VCD_MUXER  && ctx->oformat == &ff_mpeg1vcd_muxer);

    s->is_svcd  =  (CONFIG_MPEG2SVCD_MUXER && ctx->oformat == &ff_mpeg2svcd_muxer);

    s->is_mpeg2 = ((CONFIG_MPEG2VOB_MUXER  && ctx->oformat == &ff_mpeg2vob_muxer) ||

                   (CONFIG_MPEG2DVD_MUXER  && ctx->oformat == &ff_mpeg2dvd_muxer) ||

                   (CONFIG_MPEG2SVCD_MUXER && ctx->oformat == &ff_mpeg2svcd_muxer));

    s->is_dvd   =  (CONFIG_MPEG2DVD_MUXER  && ctx->oformat == &ff_mpeg2dvd_muxer);



    if (ctx->packet_size) {

        if (ctx->packet_size < 20 || ctx->packet_size > (1 << 23) + 10) {

            av_log(ctx, AV_LOG_ERROR, ""Invalid packet size %d\n"",

                   ctx->packet_size);",6,0,2,0,0,0,1,1,0,1,0,0,0,1,1
17124,FFmpeg,0,"static void dsputil_init_mmx2(DSPContext *c, AVCodecContext *avctx,

                              int mm_flags)

{

    const int bit_depth      = avctx->bits_per_raw_sample;

    const int high_bit_depth = bit_depth > 8;



    c->prefetch = prefetch_mmx2;



    if (!high_bit_depth) {

        c->put_pixels_tab[0][1] = put_pixels16_x2_mmx2;

        c->put_pixels_tab[0][2] = put_pixels16_y2_mmx2;



        c->avg_pixels_tab[0][0] = avg_pixels16_mmx2;

        c->avg_pixels_tab[0][1] = avg_pixels16_x2_mmx2;

        c->avg_pixels_tab[0][2] = avg_pixels16_y2_mmx2;



        c->put_pixels_tab[1][1] = put_pixels8_x2_mmx2;

        c->put_pixels_tab[1][2] = put_pixels8_y2_mmx2;



        c->avg_pixels_tab[1][0] = avg_pixels8_mmx2;

        c->avg_pixels_tab[1][1] = avg_pixels8_x2_mmx2;

        c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;

    }



    if (!(avctx->flags & CODEC_FLAG_BITEXACT)) {

        if (!high_bit_depth) {

            c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_mmx2;

   ",0,0,3,0,0,0,1,1,1,1,1,1,0,0,0
17128,FFmpeg,0,"static int vaapi_encode_h264_init_sequence_params(AVCodecContext *avctx)

{

    VAAPIEncodeContext                 *ctx = avctx->priv_data;

    VAEncSequenceParameterBufferH264  *vseq = ctx->codec_sequence_params;

    VAEncPictureParameterBufferH264   *vpic = ctx->codec_picture_params;

    VAAPIEncodeH264Context            *priv = ctx->priv_data;

    VAAPIEncodeH264MiscSequenceParams *mseq = &priv->misc_sequence_params;

    int i;



    {

        vseq->seq_parameter_set_id = 0;



        vseq->level_idc = avctx->level;



        vseq->max_num_ref_frames = 2;



        vseq->picture_width_in_mbs  = priv->mb_width;

        vseq->picture_height_in_mbs = priv->mb_height;



        vseq->seq_fields.bits.chroma_format_idc = 1;

        vseq->seq_fields.bits.frame_mbs_only_flag = 1;

        vseq->seq_fields.bits.direct_8x8_inference_flag = 1;

        vseq->seq_fields.bits.log2_max_frame_num_minus4 = 4;

        vseq->seq_fields.bits.pic_order_cnt_type = 0;



        if (ctx->input_width  != ctx->alig",1,0,1,0,0,0,0,1,0,1,0,0,1,0,0
17133,qemu,0,"void if_start(Slirp *slirp)

{

    uint64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);

    bool from_batchq, next_from_batchq;

    struct mbuf *ifm, *ifm_next, *ifqt;



    DEBUG_CALL(""if_start"");



    if (slirp->if_start_busy) {

        return;

    }

    slirp->if_start_busy = true;



    if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {

        ifm_next = slirp->if_fastq.ifq_next;

        next_from_batchq = false;

    } else if (slirp->next_m != &slirp->if_batchq) {

        /* Nothing on fastq, pick up from batchq via next_m */

        ifm_next = slirp->next_m;

        next_from_batchq = true;

    } else {

        ifm_next = NULL;

    }



    while (ifm_next) {

        ifm = ifm_next;

        from_batchq = next_from_batchq;



        ifm_next = ifm->ifq_next;

        if (ifm_next == &slirp->if_fastq) {

            /* No more packets in fastq, switch to batchq */

            ifm_next = slirp->next_m;

            next_from_batchq = true;

        }

        if (ifm_next == &sli",0,0,31,0,0,1,1,1,1,1,1,1,0,0,0
17141,qemu,0,"static void handle_ti(ESPState *s)

{

    uint32_t dmalen, minlen;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_ti;

        return;

    }



    dmalen = s->rregs[ESP_TCLO];

    dmalen |= s->rregs[ESP_TCMID] << 8;

    dmalen |= s->rregs[ESP_TCHI] << 16;

    if (dmalen==0) {

      dmalen=0x10000;

    }

    s->dma_counter = dmalen;



    if (s->do_cmd)

        minlen = (dmalen < 32) ? dmalen : 32;

    else if (s->ti_size < 0)

        minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;

    else

        minlen = (dmalen < s->ti_size) ? dmalen : s->ti_size;

    trace_esp_handle_ti(minlen);

    if (s->dma) {

        s->dma_left = minlen;

        s->rregs[ESP_RSTAT] &= ~STAT_TC;

        esp_do_dma(s);

    }

    if (s->do_cmd) {

        trace_esp_handle_ti_cmd(s->cmdlen);

        s->ti_size = 0;

        s->cmdlen = 0;

        s->do_cmd = 0;

        do_cmd(s, s->cmdbuf);

    }

}
",0,0,6,0,0,0,0,0,0,0,0,0,1,1,1
17152,qemu,0,"static void lsi53c895a_register_devices(void)

{

    type_register_static(&lsi_info);

    type_register_static_alias(&lsi_info, ""lsi"");

}
",0,0,0,0,0,0,1,1,1,0,0,0,0,0,0
17172,qemu,1,"static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,

                                   int size)

{

    /* read data must fit into current buffer */

    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);



    /* put byte-stream from character layer into buffer */

    memcpy(&scon->iov[scon->iov_bs], buf, size);

    scon->iov_data_len += size;

    scon->iov_sclp_rest += size;

    scon->iov_bs += size;

    scon->event.event_pending = true;

}
",0,0,0,0,0,0,1,1,0,1,1,1,0,1,1
17199,qemu,1,"static void usbredir_do_attach(void *opaque)

{

    USBRedirDevice *dev = opaque;



    /* In order to work properly with XHCI controllers we need these caps */

    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(


                                    usb_redir_cap_ep_info_max_packet_size) &&




                                    usb_redir_cap_64bits_ids))) {

        ERROR(""usb-redir-host lacks capabilities needed for use with XHCI\n"");

        usbredir_reject_device(dev);

        return;

    }



    if (usb_device_attach(&dev->dev) != 0) {

        WARNING(""rejecting device due to speed mismatch\n"");

        usbredir_reject_device(dev);

    }

}",1,0,2,0,0,0,0,0,0,0,0,1,1,1,1
17203,FFmpeg,0,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;



    if (cutoff) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int fbw_coeffs;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
",1,0,3,0,0,0,0,0,0,1,1,0,0,0,0
17206,FFmpeg,0,"static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused)

{

#if COMPILE_TEMPLATE_MMX

    __asm__ volatile(

        ""movq ""MANGLE(bm01010101)"", %%mm4           \n\t""

        ""mov                    %0, %%""REG_a""       \n\t""

        ""1:                                         \n\t""

        ""movq    (%1, %%""REG_a"",4), %%mm0           \n\t""

        ""movq   8(%1, %%""REG_a"",4), %%mm1           \n\t""

        ""psrlw                  $8, %%mm0           \n\t""

        ""psrlw                  $8, %%mm1           \n\t""

        ""packuswb            %%mm1, %%mm0           \n\t""

        ""movq                %%mm0, %%mm1           \n\t""

        ""psrlw                  $8, %%mm0           \n\t""

        ""pand                %%mm4, %%mm1           \n\t""

        ""packuswb            %%mm0, %%mm0           \n\t""

        ""packuswb            %%mm1, %%mm1           \n\t""

        ""movd                %%mm0, (%3, %%""REG_a"") \n\t""

       ",0,0,1,0,0,0,0,1,0,1,1,1,0,0,0
17240,qemu,0,"static void xtensa_kc705_init(MachineState *machine)

{

    static const LxBoardDesc kc705_board = {

        .flash_base = 0xf0000000,

        .flash_size = 0x08000000,

        .flash_boot_base = 0x06000000,

        .flash_sector_size = 0x20000,

        .sram_size = 0x2000000,

    };

    lx_init(&kc705_board, machine);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
17242,qemu,0,"static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,

                               unsigned int len)

{

    unsigned int offset;

    int i;



    offset = 0;

    for (i = 0; i < elem->in_num; i++) {

        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);



        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,

                                  elem->in_sg[i].iov_len,

                                  1, size);



        offset += size;

    }



    for (i = 0; i < elem->out_num; i++)

        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,

                                  elem->out_sg[i].iov_len,

                                  0, elem->out_sg[i].iov_len);

}
",2,0,0,0,0,0,0,0,0,0,0,0,1,1,0
17246,qemu,0,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
",2,1,2,0,0,0,0,1,0,0,0,0,0,0,0
17258,qemu,0,"static inline void tcg_out_goto_label(TCGContext *s, int label_index)

{

    TCGLabel *l = &s->labels[label_index];



    if (!l->has_value) {

        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);

        tcg_out_goto_noaddr(s);

    } else {

        tcg_out_goto(s, l->u.value_ptr);

    }

}
",0,3,1,0,0,0,0,0,0,0,1,1,1,1,1
17266,qemu,0,"static void ac97_map (PCIDevice *pci_dev, int region_num,

                      uint32_t addr, uint32_t size, int type)

{

    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;

    AC97LinkState *s = &d->ac97;



    if (!region_num) {

        s->base[0] = addr;

        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);

        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);

        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);

        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);

        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);

        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);

    }

    else {

        s->base[1] = addr;

        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);

        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);

        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);

        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);

        register_ioport_write (addr, 64 * 2, 2, nabm_writew",0,0,1,0,0,0,0,0,0,0,0,0,1,0,0
17267,qemu,0,"void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,

                        void *opaque)

{

    SaveStateEntry *se, *new_se;



    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);

            if (se->compat) {

                g_free(se->compat);

            }

            g_free(se);

        }

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
17274,qemu,0,"static int xenfb_send_motion(struct XenInput *xenfb,

			     int rel_x, int rel_y, int rel_z)

{

    union xenkbd_in_event event;



    memset(&event, 0, XENKBD_IN_EVENT_SIZE);

    event.type = XENKBD_TYPE_MOTION;

    event.motion.rel_x = rel_x;

    event.motion.rel_y = rel_y;

#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207

    event.motion.rel_z = rel_z;

#endif



    return xenfb_kbd_event(xenfb, &event);

}
",0,0,2,0,0,0,1,1,1,0,1,0,0,0,1
17280,FFmpeg,1,"static int read_header(AVFormatContext *s,

                       AVFormatParameters *ap)

{

    JVDemuxContext *jv = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *vst, *ast;

    int64_t audio_pts = 0;

    int64_t offset;

    int i;



    avio_skip(pb, 80);



    ast = av_new_stream(s, 0);

    vst = av_new_stream(s, 1);

    if (!ast || !vst)

        return AVERROR(ENOMEM);



    vst->codec->codec_type  = CODEC_TYPE_VIDEO;

    vst->codec->codec_id    = CODEC_ID_JV;

    vst->codec->codec_tag   = 0; /* no fourcc */

    vst->codec->width       = avio_rl16(pb);

    vst->codec->height      = avio_rl16(pb);

    vst->nb_frames          =

    ast->nb_index_entries   = avio_rl16(pb);

    av_set_pts_info(vst, 64, avio_rl16(pb), 1000);



    avio_skip(pb, 4);



    ast->codec->codec_type  = CODEC_TYPE_AUDIO;

    ast->codec->codec_id    = CODEC_ID_PCM_U8;

    ast->codec->codec_tag   = 0; /* no fourcc */

    ast->codec->sample_rate = avio_rl16(pb);

    ast->codec->channels    = 1;

    ",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
17288,FFmpeg,0,"static int mov_write_colr_tag(AVIOContext *pb, MOVTrack *track)

{

    // Ref (MOV): https://developer.apple.com/library/mac/technotes/tn2162/_index.html#//apple_ref/doc/uid/DTS40013070-CH1-TNTAG9

    // Ref (MP4): ISO/IEC 14496-12:2012



    if (track->enc->color_primaries == AVCOL_PRI_UNSPECIFIED &&

        track->enc->color_trc == AVCOL_TRC_UNSPECIFIED &&

        track->enc->colorspace == AVCOL_SPC_UNSPECIFIED) {

        if ((track->enc->width >= 1920 && track->enc->height >= 1080)

          || (track->enc->width == 1280 && track->enc->height == 720)) {

            av_log(NULL, AV_LOG_WARNING, ""color primaries unspecified, assuming bt709\n"");

            track->enc->color_primaries = AVCOL_PRI_BT709;

        } else if (track->enc->width == 720 && track->height == 576) {

            av_log(NULL, AV_LOG_WARNING, ""color primaries unspecified, assuming bt470bg\n"");

            track->enc->color_primaries = AVCOL_PRI_BT470BG;

        } else if (track->enc->width == 720 &&

                   (track",0,0,6,0,0,0,1,0,1,0,1,1,0,0,0
17301,qemu,0,"static int slirp_socket_load(QEMUFile *f, struct socket *so)

{

    if (tcp_attach(so) < 0)

        return -ENOMEM;



    so->so_urgc = qemu_get_be32(f);

    so->so_ffamily = qemu_get_be16(f);

    switch (so->so_ffamily) {

    case AF_INET:

        so->so_faddr.s_addr = qemu_get_be32(f);

        so->so_fport = qemu_get_be16(f);

        break;

    default:

        error_report(

                ""so_ffamily unknown, unable to restore so_faddr and so_lport\n"");

    }

    so->so_lfamily = qemu_get_be16(f);

    switch (so->so_lfamily) {

    case AF_INET:

        so->so_laddr.s_addr = qemu_get_be32(f);

        so->so_lport = qemu_get_be16(f);

        break;

    default:

        error_report(

                ""so_ffamily unknown, unable to restore so_laddr and so_lport\n"");

    }

    so->so_iptos = qemu_get_byte(f);

    so->so_emu = qemu_get_byte(f);

    so->so_type = qemu_get_byte(f);

    so->so_state = qemu_get_be32(f);

    if (slirp_sbuf_load(f, &so->so_rcv) < 0)

        return -ENOMEM;",0,0,2,0,2,0,0,1,1,0,0,0,0,0,0
17307,qemu,0,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)

{

    int pos = 0;



    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",

                    info->name, info->bus_info->name);

    if (info->alias)

        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);

    if (info->desc)

        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);

    if (info->no_user)

        pos += snprintf(dest+pos, len-pos, "", no-user"");

    return pos;

}
",0,0,3,0,0,0,1,1,0,0,0,0,0,0,0
17308,FFmpeg,0,"static int get_last_needed_nal(H264Context *h, const uint8_t *buf, int buf_size)

{

    int next_avc    = h->is_avc ? 0 : buf_size;

    int nal_index   = 0;

    int buf_index   = 0;

    int nals_needed = 0;



    while(1) {

        int nalsize = 0;

        int dst_length, bit_length, consumed;

        const uint8_t *ptr;



        if (buf_index >= next_avc) {

            nalsize = get_avc_nalsize(h, buf, buf_size, &buf_index);

            if (nalsize < 0)

                break;

            next_avc = buf_index + nalsize;

        } else {

            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);

            if (buf_index >= buf_size)

                break;

        }



        ptr = ff_h264_decode_nal(h, buf + buf_index, &dst_length, &consumed,

                                 next_avc - buf_index);



        if (ptr == NULL || dst_length < 0)

            return AVERROR_INVALIDDATA;



        buf_index += consumed;



        bit_length = get_bit_length(h, buf, ptr, dst",0,0,4,0,0,1,1,0,0,0,0,0,1,0,0
17314,qemu,0,"e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,

                             const E1000E_RxRing *rxr,

                             const E1000E_RSSInfo *rss_info)

{

    PCIDevice *d = core->owner;

    dma_addr_t base;

    uint8_t desc[E1000_MAX_RX_DESC_LEN];

    size_t desc_size;

    size_t desc_offset = 0;

    size_t iov_ofs = 0;



    struct iovec *iov = net_rx_pkt_get_iovec(pkt);

    size_t size = net_rx_pkt_get_total_len(pkt);

    size_t total_size = size + e1000x_fcs_len(core->mac);

    const E1000E_RingInfo *rxi;

    size_t ps_hdr_len = 0;

    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);



    rxi = rxr->i;



    do {

        hwaddr ba[MAX_PS_BUFFERS];

        e1000e_ba_state bastate = { { 0 } };

        bool is_last = false;

        bool is_first = true;



        desc_size = total_size - desc_offset;



        if (desc_size > core->rx_desc_buf_size) {

            desc_size = core->rx_desc_buf_size;

        }



        base = e1000e_ring_head_descr(",0,0,1,0,0,0,0,1,0,0,0,0,0,0,0
17325,qemu,0,"static int cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)

{

    int sx = 0, sy = 0;

    int dx = 0, dy = 0;

    int depth = 0;

    int notify = 0;



    /* make sure to only copy if it's a plain copy ROP */

    if (*s->cirrus_rop == cirrus_bitblt_rop_fwd_src ||

        *s->cirrus_rop == cirrus_bitblt_rop_bkwd_src) {



        int width, height;



        depth = s->vga.get_bpp(&s->vga) / 8;

        if (!depth) {

            return 0;

        }

        s->vga.get_resolution(&s->vga, &width, &height);



        /* extra x, y */

        sx = (src % ABS(s->cirrus_blt_srcpitch)) / depth;

        sy = (src / ABS(s->cirrus_blt_srcpitch));

        dx = (dst % ABS(s->cirrus_blt_dstpitch)) / depth;

        dy = (dst / ABS(s->cirrus_blt_dstpitch));



        /* normalize width */

        w /= depth;



        /* if we're doing a backward copy, we have to adjust

           our x/y to be the upper left corner (instead of the lower

           right corner) */

        if (s->cirru",0,0,5,0,0,0,0,0,0,1,1,1,0,1,1
17328,qemu,1,"static int write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",1,0,1,0,0,0,1,1,1,1,1,1,0,0,0
17329,qemu,1,"int vhost_dev_init(struct vhost_dev *hdev, void *opaque,
                   VhostBackendType backend_type)
{
    uint64_t features;
    int i, r;
    if (vhost_set_backend_type(hdev, backend_type) < 0) {
        close((uintptr_t)opaque);
        return -1;
    }
    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {
        close((uintptr_t)opaque);
        return -errno;
    }
    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);
    if (r < 0) {
        goto fail;
    }
    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);
    if (r < 0) {
        goto fail;
    }
    for (i = 0; i < hdev->nvqs; ++i) {
        r = vhost_virtqueue_init(hdev, hdev->vqs + i, hdev->vq_index + i);
        if (r < 0) {
            goto fail_vq;
        }
    }
    hdev->features = features;
    hdev->memory_listener = (MemoryListener) {
        .begin = vhost_begin,
        .commit = vhost_commit,
        .region_add = vhost_region_add,
        .region_del = vhost_region_del,
        .reg",1,3,5,0,0,0,1,0,0,1,1,1,0,0,0
17337,qemu,1,"int bdrv_read(BlockDriverState *bs, int64_t sector_num,

              uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;





    if (drv->bdrv_pread) {

        int ret, len;

        len = nb_sectors * 512;

        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);

        if (ret < 0)

            return ret;

        else if (ret != len)

            return -EINVAL;

        else {

	    bs->rd_bytes += (unsigned) len;

	    bs->rd_ops ++;

            return 0;

	}

    } else {

        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);

    }

}",0,0,4,0,0,0,0,1,1,0,0,0,1,1,1
17341,FFmpeg,1,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
",0,0,0,0,0,0,1,1,0,1,1,1,0,0,0
17350,FFmpeg,1,"static AVFrame *do_psnr(AVFilterContext *ctx, AVFrame *main,

                        const AVFrame *ref)

{

    PSNRContext *s = ctx->priv;

    double comp_mse[4], mse = 0;

    int j, c;

    AVDictionary **metadata = avpriv_frame_get_metadatap(main);



    s->compute_mse(s, (const uint8_t **)main->data, main->linesize,

                      (const uint8_t **)ref->data, ref->linesize,

                       main->width, main->height, comp_mse);



    for (j = 0; j < s->nb_components; j++)

        mse += comp_mse[j] * s->planeweight[j];



    s->min_mse = FFMIN(s->min_mse, mse);

    s->max_mse = FFMAX(s->max_mse, mse);



    s->mse += mse;

    for (j = 0; j < s->nb_components; j++)

        s->mse_comp[j] += comp_mse[j];

    s->nb_frames++;



    for (j = 0; j < s->nb_components; j++) {

        c = s->is_rgb ? s->rgba_map[j] : j;

        set_meta(metadata, ""lavfi.psnr.mse."", s->comps[j], comp_mse[c]);

        set_meta(metadata, ""lavfi.psnr.psnr."", s->comps[j], get_psnr(comp_mse[c], 1, s->max[",3,0,0,0,0,0,0,1,1,1,1,1,0,0,0
17353,FFmpeg,1,"static void matroska_add_index_entries(MatroskaDemuxContext *matroska)

{

    EbmlList *index_list;

    MatroskaIndex *index;

    int index_scale = 1;

    int i, j;



    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)

        return;



    index_list = &matroska->index;

    index      = index_list->elem;

    if (index_list->nb_elem &&

        index[0].time > 1E14 / matroska->time_scale) {

        av_log(matroska->ctx, AV_LOG_WARNING, ""Working around broken index.\n"");

        index_scale = matroska->time_scale;

    }

    for (i = 0; i < index_list->nb_elem; i++) {

        EbmlList *pos_list    = &index[i].pos;

        MatroskaIndexPos *pos = pos_list->elem;

        for (j = 0; j < pos_list->nb_elem; j++) {

            MatroskaTrack *track = matroska_find_track_by_num(matroska,

                                                              pos[j].track);

            if (track && track->stream)

                av_add_index_entry(track->stream,

                                   pos[j].pos + ",2,0,3,0,0,0,0,0,0,0,0,0,0,0,1
17357,FFmpeg,0,"static inline void downmix_3f_2r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;

    }

}
",1,0,0,0,0,0,0,0,0,0,0,1,0,0,0
17362,qemu,1,"static bool vtd_decide_config(IntelIOMMUState *s, Error **errp)

{

    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);



    /* Currently Intel IOMMU IR only support ""kernel-irqchip={off|split}"" */

    if (x86_iommu->intr_supported && kvm_irqchip_in_kernel() &&

        !kvm_irqchip_is_split()) {

        error_setg(errp, ""Intel Interrupt Remapping cannot work with ""

                         ""kernel-irqchip=on, please use 'split|off'."");

        return false;

    }

    if (s->intr_eim == ON_OFF_AUTO_ON && !x86_iommu->intr_supported) {

        error_setg(errp, ""eim=on cannot be selected without intremap=on"");

        return false;

    }



    if (s->intr_eim == ON_OFF_AUTO_AUTO) {

        s->intr_eim = x86_iommu->intr_supported ?

                                              ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;

    }



    return true;

}
",0,0,3,0,0,0,0,0,0,0,1,1,0,1,1
17370,qemu,1,"static int no_init_in (HWVoiceIn *hw, struct audsettings *as)

{

    audio_pcm_init_info (&hw->info, as);

    hw->samples = 1024;

    return 0;

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,1,0
17381,FFmpeg,1,"static int nsv_read_chunk(AVFormatContext *s, int fill_header)

{

    NSVContext *nsv = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st[2] = {NULL, NULL};

    NSVStream *nst;

    AVPacket *pkt;

    int i, err = 0;

    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */

    uint32_t vsize;

    uint16_t asize;

    uint16_t auxsize;



    if (nsv->ahead[0].data || nsv->ahead[1].data)

        return 0; //-1; /* hey! eat what you've in your plate first! */



null_chunk_retry:

    if (pb->eof_reached)

        return -1;



    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)

        err = nsv_resync(s);

    if (err < 0)

        return err;

    if (nsv->state == NSV_FOUND_NSVS)

        err = nsv_parse_NSVs_header(s);

    if (err < 0)

        return err;

    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)

        return -1;



    auxcount = avio_r8(pb);

    vsize = avio_rl16(pb);

    asize = avio_rl16(pb);

 ",1,0,6,0,0,0,1,1,1,1,1,1,1,1,1
17411,qemu,1,"static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
",1,0,2,0,0,1,0,0,0,1,0,0,1,1,1
17412,FFmpeg,1,"matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,
                     int64_t pos, uint64_t cluster_time, uint64_t duration,
                     int is_keyframe, int is_bframe)
{
    int res = 0;
    int track;
    AVStream *st;
    AVPacket *pkt;
    uint8_t *origdata = data;
    int16_t block_time;
    uint32_t *lace_size = NULL;
    int n, flags, laces = 0;
    uint64_t num;
    int stream_index;
    /* first byte(s): tracknum */
    if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {
        av_log(matroska->ctx, AV_LOG_ERROR, ""EBML block data error\n"");
        av_free(origdata);
        return res;
    }
    data += n;
    size -= n;
    /* fetch track from num */
    track = matroska_find_track_by_num(matroska, num);
    if (size <= 3 || track < 0 || track >= matroska->num_tracks) {
        av_log(matroska->ctx, AV_LOG_INFO,
               ""Invalid stream %d or size %u\n"", track, size);
        av_free(origdata);
        return res;
    }
    stream_index = matroska->",0,0,2,0,0,0,0,0,0,1,1,1,0,0,0
17413,FFmpeg,1,"void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)

{

    c->high = 255;

    c->bits = -16;

    c->buffer = buf;

    c->end = buf + buf_size;

    c->code_word = bytestream_get_be24(&c->buffer);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,1,1
17428,qemu,1,"int vring_pop(VirtIODevice *vdev, Vring *vring,

              VirtQueueElement **p_elem)

{

    struct vring_desc desc;

    unsigned int i, head, found = 0, num = vring->vr.num;

    uint16_t avail_idx, last_avail_idx;

    VirtQueueElement *elem = NULL;

    int ret;



    /* If there was a fatal error then refuse operation */

    if (vring->broken) {

        ret = -EFAULT;

        goto out;

    }



    /* Check it isn't doing very strange things with descriptor numbers. */

    last_avail_idx = vring->last_avail_idx;

    avail_idx = vring->vr.avail->idx;

    barrier(); /* load indices now and not again later */



    if (unlikely((uint16_t)(avail_idx - last_avail_idx) > num)) {

        error_report(""Guest moved used index from %u to %u"",

                     last_avail_idx, avail_idx);

        ret = -EFAULT;

        goto out;

    }



    /* If there's nothing new since last we looked. */

    if (avail_idx == last_avail_idx) {

        ret = -EAGAIN;

        goto out;

    }



    /* Onl",0,3,3,0,0,0,1,1,0,1,1,0,1,1,1
17439,FFmpeg,0,"static int ftp_connect_control_connection(URLContext *h)

{

    char buf[CONTROL_BUFFER_SIZE], opts_format[20];

    int err;

    AVDictionary *opts = NULL;

    FTPContext *s = h->priv_data;

    const int connect_codes[] = {220, 0};



    s->conn_control_block_flag = 0;



    if (!s->conn_control) {

        ff_url_join(buf, sizeof(buf), ""tcp"", NULL,

                    s->hostname, s->server_control_port, NULL);

        if (s->rw_timeout != -1) {

            snprintf(opts_format, sizeof(opts_format), ""%d"", s->rw_timeout);

            av_dict_set(&opts, ""timeout"", opts_format, 0);

        } /* if option is not given, don't pass it and let tcp use its own default */

        err = ffurl_open(&s->conn_control, buf, AVIO_FLAG_READ_WRITE,

                         &s->conn_control_interrupt_cb, &opts);

        av_dict_free(&opts);

        if (err < 0) {

            av_log(h, AV_LOG_ERROR, ""Cannot open control connection\n"");

            return err;

        }



        /* consume all messages from",4,0,3,0,0,0,1,1,1,1,1,1,1,1,1
17449,qemu,1,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)

{

    uintptr_t addr = (uintptr_t)data;



    g_assert(addr >= QPCI_PIO_LIMIT);

    dev->bus->memread(dev->bus, addr, buf, len);

}
",0,0,0,0,0,0,0,0,1,1,1,0,1,1,0
17452,FFmpeg,0,"static int is_intra_more_likely(ERContext *s)

{

    int is_intra_likely, i, j, undamaged_count, skip_amount, mb_x, mb_y;



    if (!s->last_pic.f || !s->last_pic.f->data[0])

        return 1; // no previous frame available -> use spatial prediction



    undamaged_count = 0;

    for (i = 0; i < s->mb_num; i++) {

        const int mb_xy = s->mb_index2xy[i];

        const int error = s->error_status_table[mb_xy];

        if (!((error & ER_DC_ERROR) && (error & ER_MV_ERROR)))

            undamaged_count++;

    }



    if (s->avctx->codec_id == AV_CODEC_ID_H264 && s->ref_count <= 0)

        return 1;



    if (undamaged_count < 5)

        return 0; // almost all MBs damaged -> use temporal prediction



#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    // prevent dsp.sad() check, that requires access to the image

    if (CONFIG_MPEG_XVMC_DECODER    &&

        s->avctx->xvmc_acceleration &&

        s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I)

        return 1;

FF_ENABLE_DEPRECATION_WARNING",1,0,6,0,0,0,0,0,0,0,0,0,0,1,0
17480,FFmpeg,1,"void Release(void *ctx)

{

    ContextInfo *ci;

    ci = (ContextInfo *) ctx;



    if (ci->cache) {

        imlib_context_set_image(ci->cache->image);

        imlib_free_image();

        av_free(ci->cache);

    }

    if (ctx) {

        if (ci->imageOverlaid) {

            imlib_context_set_image(ci->imageOverlaid);

            imlib_free_image();

        }

        ff_eval_free(ci->expr_x);

        ff_eval_free(ci->expr_y);

        ff_eval_free(ci->expr_R);

        ff_eval_free(ci->expr_G);

        ff_eval_free(ci->expr_B);

        sws_freeContext(ci->toRGB_convert_ctx);

        sws_freeContext(ci->fromRGB_convert_ctx);

        av_free(ctx);

    }

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
17482,qemu,1,"void qemu_aio_flush(void)

{

    AioHandler *node;

    int ret;



    do {

        ret = 0;



	/*

	 * If there are pending emulated aio start them now so flush

	 * will be able to return 1.

	 */

        qemu_aio_wait();



        LIST_FOREACH(node, &aio_handlers, node) {

            ret |= node->io_flush(node->opaque);

        }

    } while (ret > 0);

}
",0,0,0,0,0,1,1,1,0,0,1,1,0,0,0
17513,FFmpeg,1,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
",1,0,2,0,0,0,1,0,0,1,0,0,1,0,0
17518,qemu,1,"static int xen_platform_initfn(PCIDevice *dev)
{
    PCIXenPlatformState *d = XEN_PLATFORM(dev);
    uint8_t *pci_conf;
    pci_conf = dev->config;
    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
    pci_config_set_prog_interface(pci_conf, 0);
    pci_conf[PCI_INTERRUPT_PIN] = 1;
    platform_ioport_bar_setup(d);
    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &d->bar);
    /* reserve 16MB mmio address for share memory*/
    platform_mmio_setup(d);
    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_MEM_PREFETCH,
                     &d->mmio_bar);
    platform_fixed_ioport_init(d);
    return 0;
}",5,0,0,0,0,0,0,1,0,1,0,0,0,0,0
17534,FFmpeg,0,"static void mmap_release_buffer(AVPacket *pkt)

{

    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
",0,0,2,0,0,0,1,0,0,1,0,0,0,1,0
17548,qemu,1,"static void coroutine_fn c1_fn(void *opaque)

{

    Coroutine *c2 = opaque;

    qemu_coroutine_enter(c2, NULL);

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,1,1
17553,qemu,1,"static int write_target_commit(BlockDriverState *bs, int64_t sector_num,

	const uint8_t* buffer, int nb_sectors) {

    BDRVVVFATState* s = bs->opaque;

    return try_commit(s);

}
",0,0,0,0,0,0,0,0,0,0,1,0,1,1,1
17554,FFmpeg,1,"static void show_packets(AVFormatContext *fmt_ctx)

{

    AVPacket pkt;



    av_init_packet(&pkt);

    probe_array_header(""packets"", 0);

    while (!av_read_frame(fmt_ctx, &pkt))

        show_packet(fmt_ctx, &pkt);

    probe_array_footer(""packets"", 0);

}
",0,0,0,0,0,1,1,1,1,0,0,0,0,0,0
17576,qemu,0,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
",1,0,4,0,0,0,0,0,0,0,0,0,0,0,0
17581,qemu,0,"static uint64_t omap_ulpd_pm_read(void *opaque, target_phys_addr_t addr,

                                  unsigned size)

{

    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;

    uint16_t ret;



    if (size != 2) {

        return omap_badwidth_read16(opaque, addr);

    }



    switch (addr) {

    case 0x14:	/* IT_STATUS */

        ret = s->ulpd_pm_regs[addr >> 2];

        s->ulpd_pm_regs[addr >> 2] = 0;

        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);

        return ret;



    case 0x18:	/* Reserved */

    case 0x1c:	/* Reserved */

    case 0x20:	/* Reserved */

    case 0x28:	/* Reserved */

    case 0x2c:	/* Reserved */

        OMAP_BAD_REG(addr);

    case 0x00:	/* COUNTER_32_LSB */

    case 0x04:	/* COUNTER_32_MSB */

    case 0x08:	/* COUNTER_HIGH_FREQ_LSB */

    case 0x0c:	/* COUNTER_HIGH_FREQ_MSB */

    case 0x10:	/* GAUGING_CTRL */

    case 0x24:	/* SETUP_ANALOG_CELL3_ULPD1 */

    case 0x30:	/* CLOCK_CTRL */

    case 0x34:	/* SOFT_REQ */

    case 0x38:	",0,0,1,0,1,0,0,0,0,0,0,0,0,0,0
17587,qemu,0,"static int milkymist_memcard_init(SysBusDevice *dev)

{

    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);

    DriveInfo *dinfo;

    BlockDriverState *bs;



    dinfo = drive_get_next(IF_SD);

    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;

    s->card = sd_init(bs, false);

    if (s->card == NULL) {

        return -1;

    }



    s->enabled = bs && bdrv_is_inserted(bs);



    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,

            ""milkymist-memcard"", R_MAX * 4);

    sysbus_init_mmio(dev, &s->regs_region);



    return 0;

}
",0,0,1,0,0,0,1,1,1,1,1,0,0,1,0
17596,qemu,0,"static void visitor_output_setup_internal(TestOutputVisitorData *data,

                                          bool human)

{

    data->human = human;

    data->sov = string_output_visitor_new(human);

    g_assert(data->sov);

    data->ov = string_output_get_visitor(data->sov);

    g_assert(data->ov);

}
",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
17597,FFmpeg,0,"static int get_riff(AVFormatContext *s, AVIOContext *pb)

{

    AVIContext *avi = s->priv_data;

    char header[8];

    int i;



    /* check RIFF header */

    avio_read(pb, header, 4);

    avi->riff_end = avio_rl32(pb);  /* RIFF chunk size */

    avi->riff_end += avio_tell(pb); /* RIFF chunk end */

    avio_read(pb, header+4, 4);



    for(i=0; avi_headers[i][0]; i++)

        if(!memcmp(header, avi_headers[i], 8))

            break;

    if(!avi_headers[i][0])

        return -1;



    if(header[7] == 0x19)

        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.\n"");



    return 0;

}
",1,0,6,0,0,0,0,0,0,0,0,0,0,0,0
17611,qemu,1,"_eth_get_rss_ex_src_addr(const struct iovec *pkt, int pkt_frags,

                        size_t dsthdr_offset,

                        struct ip6_ext_hdr *ext_hdr,

                        struct in6_address *src_addr)

{

    size_t bytes_left = (ext_hdr->ip6r_len + 1) * 8 - sizeof(*ext_hdr);

    struct ip6_option_hdr opthdr;

    size_t opt_offset = dsthdr_offset + sizeof(*ext_hdr);



    while (bytes_left > sizeof(opthdr)) {

        size_t input_size = iov_size(pkt, pkt_frags);

        size_t bytes_read, optlen;



        if (input_size < opt_offset) {

            return false;

        }



        bytes_read = iov_to_buf(pkt, pkt_frags, opt_offset,

                                &opthdr, sizeof(opthdr));



        if (bytes_read != sizeof(opthdr)) {

            return false;

        }



        optlen = (opthdr.type == IP6_OPT_PAD1) ? 1

                                               : (opthdr.len + sizeof(opthdr));



        if (optlen > bytes_left) {

            return false;

        }",0,0,3,0,0,1,1,1,1,1,1,0,0,1,1
17615,FFmpeg,0,"static int altivec_uyvy_rgb32 (SwsContext *c,

			       unsigned char **in, int *instrides,

			       int srcSliceY,	int srcSliceH,

			       unsigned char **oplanes, int *outstrides)

{

  int w = c->srcW;

  int h = srcSliceH;

  int i,j;

  vector unsigned char uyvy;

  vector signed   short Y,U,V;

  vector signed   short vx,ux,uvx;

  vector signed   short R0,G0,B0,R1,G1,B1;

  vector unsigned char  R,G,B;

  vector unsigned char *out;

  ubyte *img;



  img = in[0];

  out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]);



  for (i=0;i<h;i++) {

    for (j=0;j<w/16;j++) {

      uyvy = vec_ld (0, img);

      U = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_u);



      V = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_v);



      Y = (vector signed short)

	vec_perm (uyvy, (vector unsigned char)(0), demux_y);



      cvtyuvtoRGB (c, Y,U,V,&R0,&G0,&B0);



      uyvy = vec_ld (16, img);

      U = (vector signed short)

	vec_pe",2,0,0,0,0,0,1,1,1,1,1,0,1,1,1
17627,qemu,0,"static void inc_refcounts(BlockDriverState *bs,

                          BdrvCheckResult *res,

                          uint16_t *refcount_table,

                          int refcount_table_size,

                          int64_t offset, int64_t size)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t start, last, cluster_offset, k;



    if (size <= 0)

        return;



    start = start_of_cluster(s, offset);

    last = start_of_cluster(s, offset + size - 1);

    for(cluster_offset = start; cluster_offset <= last;

        cluster_offset += s->cluster_size) {

        k = cluster_offset >> s->cluster_bits;

        if (k >= refcount_table_size) {

            fprintf(stderr, ""Warning: cluster offset=0x%"" PRIx64 "" is after ""

                ""the end of the image file, can't properly check refcounts.\n"",

                cluster_offset);

            res->check_errors++;

        } else {

            if (++refcount_table[k] == 0) {

                fprintf(stderr, ""ERROR: overflow cluster offs",1,0,3,0,0,0,0,0,0,0,0,0,1,1,1
17641,qemu,0,"void stw_phys(target_phys_addr_t addr, uint32_t val)

{

    uint16_t v = tswap16(val);

    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);

}
",0,0,0,0,0,0,1,1,1,0,0,1,1,1,1
17653,qemu,0,"static void gen_branch(DisasContext *ctx, int insn_bytes)

{

    if (ctx->hflags & MIPS_HFLAG_BMASK) {

        int proc_hflags = ctx->hflags & MIPS_HFLAG_BMASK;

        /* Branches completion */

        ctx->hflags &= ~MIPS_HFLAG_BMASK;

        ctx->bstate = BS_BRANCH;

        save_cpu_state(ctx, 0);

        /* FIXME: Need to clear can_do_io.  */

        switch (proc_hflags & MIPS_HFLAG_BMASK_BASE) {

        case MIPS_HFLAG_FBNSLOT:

            MIPS_DEBUG(""forbidden slot"");

            gen_goto_tb(ctx, 0, ctx->pc + insn_bytes);

            break;

        case MIPS_HFLAG_B:

            /* unconditional branch */

            MIPS_DEBUG(""unconditional branch"");

            if (proc_hflags & MIPS_HFLAG_BX) {

                tcg_gen_xori_i32(hflags, hflags, MIPS_HFLAG_M16);

            }

            gen_goto_tb(ctx, 0, ctx->btarget);

            break;

        case MIPS_HFLAG_BL:

            /* blikely taken case */

            MIPS_DEBUG(""blikely branch taken"");

            gen_goto_tb(ctx",1,3,2,0,1,0,0,0,0,0,0,0,1,1,0
17664,qemu,0,"void slirp_cleanup(Slirp *slirp)

{

    TAILQ_REMOVE(&slirp_instances, slirp, entry);



    unregister_savevm(""slirp"", slirp);



    qemu_free(slirp->tftp_prefix);

    qemu_free(slirp->bootp_filename);

    qemu_free(slirp);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
17670,qemu,0,"void scsi_req_abort(SCSIRequest *req, int status)

{

    if (!req->enqueued) {

        return;

    }

    scsi_req_ref(req);

    scsi_req_dequeue(req);

    req->io_canceled = true;

    if (req->ops->cancel_io) {

        req->ops->cancel_io(req);

    }

    scsi_req_complete(req, status);

    scsi_req_unref(req);

}
",0,0,2,0,0,0,1,1,1,1,1,0,0,0,0
17678,FFmpeg,0,"rdt_free_extradata (PayloadContext *rdt)

{

    int i;



    for (i = 0; i < MAX_STREAMS; i++)

        if (rdt->rmst[i]) {

            ff_rm_free_rmstream(rdt->rmst[i]);

            av_freep(&rdt->rmst[i]);

        }

    if (rdt->rmctx)

        av_close_input_stream(rdt->rmctx);

    av_freep(&rdt->mlti_data);

    av_free(rdt);

}
",1,0,2,0,0,0,0,0,0,1,1,0,0,0,1
17682,qemu,0,"build_dsdt(GArray *table_data, GArray *linker,

           AcpiPmInfo *pm, AcpiMiscInfo *misc,

           PcPciInfo *pci, MachineState *machine)

{

    CrsRangeEntry *entry;

    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;

    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);

    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);

    PCMachineState *pcms = PC_MACHINE(machine);

    uint32_t nr_mem = machine->ram_slots;

    int root_bus_limit = 0xFF;

    PCIBus *bus = NULL;

    int i;



    dsdt = init_aml_allocator();



    /* Reserve space for header */

    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));



    build_dbg_aml(dsdt);

    if (misc->is_piix4) {

        sb_scope = aml_scope(""_SB"");

        dev = aml_device(""PCI0"");

        aml_append(dev, aml_name_decl(""_HID"", aml_eisaid(""PNP0A03"")));

        aml_append(dev, aml_name_decl(""_ADR"", aml_int(0)));

        aml_append(dev, aml_name_decl(""_UID"", aml_int(1)));

        am",0,0,1,0,0,0,1,0,0,0,0,0,0,0,0
17699,qemu,0,"static void arm_cpu_do_interrupt_aarch64(CPUState *cs)

{

    ARMCPU *cpu = ARM_CPU(cs);

    CPUARMState *env = &cpu->env;

    unsigned int new_el = env->exception.target_el;

    target_ulong addr = env->cp15.vbar_el[new_el];

    unsigned int new_mode = aarch64_pstate_mode(new_el, true);



    if (arm_current_el(env) < new_el) {

        if (env->aarch64) {

            addr += 0x400;

        } else {

            addr += 0x600;

        }

    } else if (pstate_read(env) & PSTATE_SP) {

        addr += 0x200;

    }



    switch (cs->exception_index) {

    case EXCP_PREFETCH_ABORT:

    case EXCP_DATA_ABORT:

        env->cp15.far_el[new_el] = env->exception.vaddress;

        qemu_log_mask(CPU_LOG_INT, ""...with FAR 0x%"" PRIx64 ""\n"",

                      env->cp15.far_el[new_el]);

        /* fall through */

    case EXCP_BKPT:

    case EXCP_UDEF:

    case EXCP_SWI:

    case EXCP_HVC:

    case EXCP_HYP_TRAP:

    case EXCP_SMC:

        env->cp15.esr_el[new_el] = env->exception.syndrome;

   ",0,0,3,0,1,0,0,0,0,0,0,0,1,1,0
17700,qemu,0,"static bool pc_machine_get_nvdimm(Object *obj, Error **errp)

{

    PCMachineState *pcms = PC_MACHINE(obj);



    return pcms->nvdimm;

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,1,1
17710,qemu,0,"build_header(GArray *linker, GArray *table_data,

             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,

             const char *oem_table_id)

{

    memcpy(&h->signature, sig, 4);

    h->length = cpu_to_le32(len);

    h->revision = rev;

    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);



    if (oem_table_id) {

        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));

    } else {

        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);

        memcpy(h->oem_table_id + 4, sig, 4);

    }



    h->oem_revision = cpu_to_le32(1);

    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);

    h->asl_compiler_revision = cpu_to_le32(1);

    h->checksum = 0;

    /* Checksum to be filled in by Guest linker */

    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,

                                    table_data->data, h, len, &h->checksum);

}
",0,0,1,0,0,0,0,1,1,0,1,0,0,0,0
17723,FFmpeg,0,"static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)

{

    int v;

    int i = 0;

    uint8_t state[CONTEXT_SIZE];



    memset(state, 128, sizeof(state));



    for (v = 0; i < 128; v++) {

        unsigned len = get_symbol(c, state, 0) + 1;



        if (len > 128 - i)

            return AVERROR_INVALIDDATA;



        while (len--) {

            quant_table[i] = scale * v;

            i++;

        }

    }



    for (i = 1; i < 128; i++)

        quant_table[256 - i] = -quant_table[i];

    quant_table[128] = -quant_table[127];



    return 2 * v - 1;

}
",2,0,1,0,0,1,0,0,0,1,0,0,1,0,0
17735,FFmpeg,0,"static int tb_unreliable(AVCodecContext *c)

{

    if (c->time_base.den >= 101L * c->time_base.num ||

        c->time_base.den <    5L * c->time_base.num ||

        // c->codec_tag == AV_RL32(""DIVX"") ||

        // c->codec_tag == AV_RL32(""XVID"") ||

        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||

        c->codec_id == AV_CODEC_ID_H264)

        return 1;

    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
17737,FFmpeg,1,"int swr_init(struct SwrContext *s){

    s->in_buffer_index= 0;

    s->in_buffer_count= 0;

    s->resample_in_constraint= 0;

    free_temp(&s->postin);

    free_temp(&s->midbuf);

    free_temp(&s->preout);

    free_temp(&s->in_buffer);

    swri_audio_convert_free(&s-> in_convert);

    swri_audio_convert_free(&s->out_convert);

    swri_audio_convert_free(&s->full_convert);



    s-> in.planar= av_sample_fmt_is_planar(s-> in_sample_fmt);

    s->out.planar= av_sample_fmt_is_planar(s->out_sample_fmt);

    s-> in_sample_fmt= av_get_alt_sample_fmt(s-> in_sample_fmt, 0);

    s->out_sample_fmt= av_get_alt_sample_fmt(s->out_sample_fmt, 0);



    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){

        av_log(s, AV_LOG_ERROR, ""Requested sample format %s is invalid\n"", av_get_sample_fmt_name(s->in_sample_fmt));

        return AVERROR(EINVAL);

    }

    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){

        av_log(s, AV_LOG_ERROR, ""Requested sample format %s is invalid\n"", av_get_sample_fmt_name(s->out_sample_fm",2,0,2,0,0,0,1,1,0,1,0,1,1,1,1
17742,FFmpeg,1,"static int svq1_decode_init(AVCodecContext *avctx)

{

    MpegEncContext *s = avctx->priv_data;

    int i;



    MPV_decode_defaults(s);



    s->avctx = avctx;

    s->width = (avctx->width+3)&~3;

    s->height = (avctx->height+3)&~3;

    s->codec_id= avctx->codec->id;

    avctx->pix_fmt = PIX_FMT_YUV410P;

    avctx->has_b_frames= 1; // not true, but DP frames and these behave like unidirectional b frames

    s->flags= avctx->flags;

    if (MPV_common_init(s) < 0) return -1;



    init_vlc(&svq1_block_type, 2, 4,

        &svq1_block_type_vlc[0][1], 2, 1,

        &svq1_block_type_vlc[0][0], 2, 1);



    init_vlc(&svq1_motion_component, 7, 33,

        &mvtab[0][1], 2, 1,

        &mvtab[0][0], 2, 1);



    for (i = 0; i < 6; i++) {

        init_vlc(&svq1_intra_multistage[i], 3, 8,

            &svq1_intra_multistage_vlc[i][0][1], 2, 1,

            &svq1_intra_multistage_vlc[i][0][0], 2, 1);

        init_vlc(&svq1_inter_multistage[i], 3, 8,

            &svq1_inter_multistage_vlc[i][0][1], 2,",1,0,1,0,0,0,0,0,0,0,0,0,1,1,1
17752,FFmpeg,1,"static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,

                                     AVStream *st, RMStream *ast, int read_all)

{

    char buf[256];

    uint32_t version;

    int ret;



    /* ra type header */

    version = avio_rb16(pb); /* version */

    if (version == 3) {

        unsigned bytes_per_minute;

        int header_size = avio_rb16(pb);

        int64_t startpos = avio_tell(pb);

        avio_skip(pb, 8);

        bytes_per_minute = avio_rb16(pb);

        avio_skip(pb, 4);

        rm_read_metadata(s, 0);

        if ((startpos + header_size) >= avio_tell(pb) + 2) {

            // fourcc (should always be ""lpcJ"")

            avio_r8(pb);

            get_str8(pb, buf, sizeof(buf));

        }

        // Skip extra header crap (this should never happen)

        if ((startpos + header_size) > avio_tell(pb))

            avio_skip(pb, header_size + startpos - avio_tell(pb));

        if (bytes_per_minute)

            st->codec->bit_rate = 8LL * bytes_per_m",0,0,4,0,0,0,0,0,1,1,0,1,0,1,0
17765,FFmpeg,1,"int show_license(void *optctx, const char *opt, const char *arg)

{

    printf(

#if CONFIG_NONFREE

    ""This version of %s has nonfree parts compiled in.\n""

    ""Therefore it is not legally redistributable.\n"",

    program_name

#elif CONFIG_GPLV3

    ""%s is free software; you can redistribute it and/or modify\n""

    ""it under the terms of the GNU General Public License as published by\n""

    ""the Free Software Foundation; either version 3 of the License, or\n""

    ""(at your option) any later version.\n""

    ""\n""

    ""%s is distributed in the hope that it will be useful,\n""

    ""but WITHOUT ANY WARRANTY; without even the implied warranty of\n""

    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""

    ""GNU General Public License for more details.\n""

    ""\n""

    ""You should have received a copy of the GNU General Public License\n""

    ""along with %s.  If not, see <http://www.gnu.org/licenses/>.\n"",

    program_name, program_name, program_name

#elif CONFIG_GPL

    ""%s is free",2,0,4,0,0,0,1,1,1,1,1,1,1,0,0
17766,FFmpeg,1,"int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,

                              int lower_transport, const char *real_challenge)

{

    RTSPState *rt = s->priv_data;

    int rtx = 0, j, i, err, interleave = 0, port_off;

    RTSPStream *rtsp_st;

    RTSPMessageHeader reply1, *reply = &reply1;

    char cmd[2048];

    const char *trans_pref;



    if (rt->transport == RTSP_TRANSPORT_RDT)

        trans_pref = ""x-pn-tng"";

    else

        trans_pref = ""RTP/AVP"";



    /* default timeout: 1 minute */

    rt->timeout = 60;



    /* for each stream, make the setup request */

    /* XXX: we assume the same server is used for the control of each

     * RTSP stream */



    /* Choose a random starting offset within the first half of the

     * port range, to allow for a number of ports to try even if the offset

     * happens to be at the end of the random range. */

    port_off = av_get_random_seed() % ((rt->rtp_port_max - rt->rtp_port_min)/2);

    /* even random offset",2,0,2,0,0,0,0,0,0,0,0,0,1,1,1
17786,FFmpeg,0,"static int parse_fmtp(AVFormatContext *s,

                      AVStream *stream, PayloadContext *data,

                      const char *attr, const char *value)

{

    AVCodecParameters *par = stream->codecpar;

    int res, i;



    if (!strcmp(attr, ""config"")) {

        res = parse_fmtp_config(par, value);



        if (res < 0)

            return res;

    }



    if (par->codec_id == AV_CODEC_ID_AAC) {

        /* Looking for a known attribute */

        for (i = 0; attr_names[i].str; ++i) {

            if (!av_strcasecmp(attr, attr_names[i].str)) {

                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {

                    *(int *)((char *)data+

                        attr_names[i].offset) = atoi(value);

                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)

                    *(char **)((char *)data+

                        attr_names[i].offset) = av_strdup(value);

            }

        }

    }

    return 0;

}
",1,0,6,0,0,0,0,0,0,1,0,0,0,1,0
17787,FFmpeg,0,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
",0,4,7,0,0,0,0,0,0,1,0,1,1,1,1
17792,FFmpeg,0,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    unsigned int tag;

    int64_t size;



    for (;;) {

        if (url_feof(pb))

            return AVERROR_EOF;

        size = next_tag(pb, &tag);

        if (tag == tag1)

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }

    return size;

}
",1,0,2,0,0,0,0,1,1,1,0,1,0,0,0
17803,FFmpeg,0,"av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp)

{

    int cpu_flags = av_get_cpu_flags();



#if HAVE_6REGS && HAVE_INLINE_ASM

    if (INLINE_AMD3DNOWEXT(cpu_flags)) {

        fdsp->vector_fmul_window  = vector_fmul_window_3dnowext;

    }

    if (INLINE_SSE(cpu_flags)) {

        fdsp->vector_fmul_window = vector_fmul_window_sse;

    }

#endif

    if (EXTERNAL_SSE(cpu_flags)) {

        fdsp->vector_fmul = ff_vector_fmul_sse;

        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;

        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;

        fdsp->vector_fmul_add    = ff_vector_fmul_add_sse;

        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;

        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;

        fdsp->butterflies_float   = ff_butterflies_float_sse;

    }

    if (EXTERNAL_SSE2(cpu_flags)) {

        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;

    }

    if (EXTERNAL_AVX(cpu_flags)) {

        fdsp->vector_fmul = ff_vector_fmul_",0,0,7,0,0,0,1,1,0,1,0,0,0,0,0
17805,qemu,1,"static uint64_t omap2_inth_read(void *opaque, target_phys_addr_t addr,

                                unsigned size)

{

    struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;

    int offset = addr;

    int bank_no, line_no;

    struct omap_intr_handler_bank_s *bank = NULL;



    if ((offset & 0xf80) == 0x80) {

        bank_no = (offset & 0x60) >> 5;

        if (bank_no < s->nbanks) {

            offset &= ~0x60;

            bank = &s->bank[bank_no];




        }

    }



    switch (offset) {

    case 0x00:	/* INTC_REVISION */

        return s->revision;



    case 0x10:	/* INTC_SYSCONFIG */

        return (s->autoidle >> 2) & 1;



    case 0x14:	/* INTC_SYSSTATUS */

        return 1;						/* RESETDONE */



    case 0x40:	/* INTC_SIR_IRQ */

        return s->sir_intr[0];



    case 0x44:	/* INTC_SIR_FIQ */

        return s->sir_intr[1];



    case 0x48:	/* INTC_CONTROL */

        return (!s->mask) << 2;					/* GLOBALMASK */



    case 0x4c:	/* INTC_PROTECTION */

",0,0,2,0,1,0,1,1,1,1,1,1,1,1,1
17807,FFmpeg,0,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    }

}
",1,0,4,0,0,0,1,0,0,1,1,0,1,0,0
17808,FFmpeg,0,"static int device_try_init(AVFormatContext *ctx,

                           enum AVPixelFormat pix_fmt,

                           int *width,

                           int *height,

                           uint32_t *desired_format,

                           enum AVCodecID *codec_id)

{

    int ret, i;



    *desired_format = avpriv_fmt_ff2v4l(pix_fmt, ctx->video_codec_id);



    if (*desired_format) {

        ret = device_init(ctx, width, height, *desired_format);

        if (ret < 0) {

            *desired_format = 0;

            if (ret != AVERROR(EINVAL))

                return ret;

        }

    }



    if (!*desired_format) {

        for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {

            if (ctx->video_codec_id == AV_CODEC_ID_NONE ||

                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {

                av_log(ctx, AV_LOG_DEBUG, ""Trying to set codec:%s pix_fmt:%s\n"",

                       avcodec_get_name(avpriv_fm",7,0,5,0,0,0,0,0,0,0,0,0,0,0,0
17833,qemu,1,"static void lsi_soft_reset(LSIState *s)

{

    lsi_request *p;



    DPRINTF(""Reset\n"");

    s->carry = 0;



    s->msg_action = 0;

    s->msg_len = 0;

    s->waiting = 0;

    s->dsa = 0;

    s->dnad = 0;

    s->dbc = 0;

    s->temp = 0;

    memset(s->scratch, 0, sizeof(s->scratch));

    s->istat0 = 0;

    s->istat1 = 0;

    s->dcmd = 0x40;

    s->dstat = LSI_DSTAT_DFE;

    s->dien = 0;

    s->sist0 = 0;

    s->sist1 = 0;

    s->sien0 = 0;

    s->sien1 = 0;

    s->mbox0 = 0;

    s->mbox1 = 0;

    s->dfifo = 0;

    s->ctest2 = LSI_CTEST2_DACK;

    s->ctest3 = 0;

    s->ctest4 = 0;

    s->ctest5 = 0;

    s->ccntl0 = 0;

    s->ccntl1 = 0;

    s->dsp = 0;

    s->dsps = 0;

    s->dmode = 0;

    s->dcntl = 0;

    s->scntl0 = 0xc0;

    s->scntl1 = 0;

    s->scntl2 = 0;

    s->scntl3 = 0;

    s->sstat0 = 0;

    s->sstat1 = 0;

    s->scid = 7;

    s->sxfer = 0;

    s->socl = 0;

    s->sdid = 0;

    s->ssid = 0;

    s->stest1 = 0;

    s->stest2 = 0;

    s->stest3 = 0;

   ",0,0,1,0,0,0,0,1,0,1,0,1,1,1,1
17877,FFmpeg,1,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
",3,0,1,0,0,0,0,0,0,0,0,0,0,0,0
17883,qemu,1,"static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)

{

    VncDisplay *vd = ds->opaque;

    VncState *vs = vd->clients;

    while (vs != NULL) {

        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))

            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);

        else /* TODO */

            vnc_update(vs, dst_x, dst_y, w, h);

        vs = vs->next;

    }

}
",0,0,1,0,0,1,0,0,0,1,0,1,0,0,0
17885,qemu,1,"static int emulated_exitfn(CCIDCardState *base)

{

    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);

    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);



    vevent_queue_vevent(vevent); /* stop vevent thread */

    qemu_mutex_lock(&card->apdu_thread_quit_mutex);

    card->quit_apdu_thread = 1; /* stop handle_apdu thread */

    qemu_cond_signal(&card->handle_apdu_cond);

    qemu_cond_wait(&card->apdu_thread_quit_cond,

                      &card->apdu_thread_quit_mutex);

    /* handle_apdu thread stopped, can destroy all of it's mutexes */

    qemu_cond_destroy(&card->handle_apdu_cond);

    qemu_cond_destroy(&card->apdu_thread_quit_cond);

    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);

    qemu_mutex_destroy(&card->handle_apdu_mutex);

    qemu_mutex_destroy(&card->vreader_mutex);

    qemu_mutex_destroy(&card->event_list_mutex);

    return 0;

}
",0,0,0,0,0,0,1,1,0,1,1,1,1,1,1
17893,FFmpeg,1,"static inline int get_chroma_qp(H264Context *h, int qscale){

    return h->pps.chroma_qp_table[qscale & 0xff];

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
17904,FFmpeg,1,"int AAC_RENAME(ff_ps_read_data)(AVCodecContext *avctx, GetBitContext *gb_host, PSContext *ps, int bits_left)

{

    int e;

    int bit_count_start = get_bits_count(gb_host);

    int header;

    int bits_consumed;

    GetBitContext gbc = *gb_host, *gb = &gbc;



    header = get_bits1(gb);

    if (header) {     //enable_ps_header

        ps->enable_iid = get_bits1(gb);

        if (ps->enable_iid) {

            int iid_mode = get_bits(gb, 3);

            if (iid_mode > 5) {

                av_log(avctx, AV_LOG_ERROR, ""iid_mode %d is reserved.\n"",

                       iid_mode);

                goto err;

            }

            ps->nr_iid_par    = nr_iidicc_par_tab[iid_mode];

            ps->iid_quant     = iid_mode > 2;

            ps->nr_ipdopd_par = nr_iidopd_par_tab[iid_mode];

        }

        ps->enable_icc = get_bits1(gb);

        if (ps->enable_icc) {

            ps->icc_mode = get_bits(gb, 3);

            if (ps->icc_mode > 5) {

                av_log(avctx, AV_LOG_ERROR, ""icc",0,1,5,0,0,0,0,0,0,0,1,0,1,1,1
17908,FFmpeg,1,"static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)

{

    if (pkt->size >= 7 &&

        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&

        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {

        uint8_t desc[256];

        int score      = AVPROBE_SCORE_EXTENSION, ret;

        AVIStream *ast = st->priv_data;

        AVInputFormat *sub_demuxer;

        AVRational time_base;

        int size;

        AVIOContext *pb = avio_alloc_context(pkt->data + 7,

                                             pkt->size - 7,

                                             0, NULL, NULL, NULL, NULL);

        AVProbeData pd;

        unsigned int desc_len = avio_rl32(pb);



        if (desc_len > pb->buf_end - pb->buf_ptr)

            goto error;



        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));

        avio_skip(pb, desc_len - ret);

        if (*desc)

            av_dict_set(&st->metadata, ""title"", desc, 0);



        avio_rl16(pb);   /* flags? */

      ",0,1,3,0,0,0,0,0,0,0,0,0,0,0,0
17909,qemu,1,"void qvirtio_pci_device_enable(QVirtioPCIDevice *d)

{

    qpci_device_enable(d->pdev);

    d->addr = qpci_iomap(d->pdev, 0, NULL);

    g_assert(d->addr != NULL);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
17913,FFmpeg,0,"static int movie_request_frame(AVFilterLink *outlink)

{

    AVFilterBufferRef *outpicref;

    MovieContext *movie = outlink->src->priv;

    int ret;



    if (movie->is_done)

        return AVERROR_EOF;

    if ((ret = movie_get_frame(outlink)) < 0)

        return ret;



    outpicref = avfilter_ref_buffer(movie->picref, ~0);

    ff_start_frame(outlink, outpicref);

    ff_draw_slice(outlink, 0, outlink->h, 1);

    ff_end_frame(outlink);

    avfilter_unref_buffer(movie->picref);

    movie->picref = NULL;



    return 0;

}
",0,0,2,0,0,0,0,0,0,0,1,0,1,0,0
17929,FFmpeg,1,"static void process_client(AVIOContext *client, const char *in_uri)

{

    AVIOContext *input = NULL;

    uint8_t buf[1024];

    int ret, n, reply_code;

    uint8_t *resource = NULL;

    while ((ret = avio_handshake(client)) > 0) {

        av_opt_get(client, ""resource"", AV_OPT_SEARCH_CHILDREN, &resource);

        // check for strlen(resource) is necessary, because av_opt_get()

        // may return empty string.

        if (resource && strlen(resource))

            break;


    }

    if (ret < 0)

        goto end;

    av_log(client, AV_LOG_TRACE, ""resource=%p\n"", resource);

    if (resource && resource[0] == '/' && !strcmp((resource + 1), in_uri)) {

        reply_code = 200;

    } else {

        reply_code = AVERROR_HTTP_NOT_FOUND;

    }

    if ((ret = av_opt_set_int(client, ""reply_code"", reply_code, AV_OPT_SEARCH_CHILDREN)) < 0) {

        av_log(client, AV_LOG_ERROR, ""Failed to set reply_code: %s.\n"", av_err2str(ret));

        goto end;

    }

    av_log(client, AV_LOG_TRACE, ""Set reply",0,2,4,0,0,1,0,0,0,0,0,0,0,1,0
17932,FFmpeg,1,"static inline void pred_direct_motion(H264Context * const h, int *mb_type){

    MpegEncContext * const s = &h->s;

    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;

    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;

    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;

    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];

    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];

    const int16_t (*l1mv1)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[1][b4_xy];

    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];

    const int8_t *l1ref1 = &h->ref_list[1][0].ref_index[1][b8_xy];

    const int is_b8x8 = IS_8X8(*mb_type);

    int sub_mb_type;

    int i8, i4;



    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){

        /* FIXME save sub mb types from previous frames (or derive from MVs)

         * so we know exactly what block size to use */

        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYP",0,0,1,0,0,0,0,1,0,1,1,0,0,0,0
17953,qemu,0,"static int bdrv_qed_open(BlockDriverState *bs, QDict *options, int flags,

                         Error **errp)

{

    BDRVQEDState *s = bs->opaque;

    QEDHeader le_header;

    int64_t file_size;

    int ret;



    s->bs = bs;

    QSIMPLEQ_INIT(&s->allocating_write_reqs);



    ret = bdrv_pread(bs->file, 0, &le_header, sizeof(le_header));

    if (ret < 0) {

        return ret;

    }

    qed_header_le_to_cpu(&le_header, &s->header);



    if (s->header.magic != QED_MAGIC) {

        error_setg(errp, ""Image not in QED format"");

        return -EINVAL;

    }

    if (s->header.features & ~QED_FEATURE_MASK) {

        /* image uses unsupported feature bits */

        char buf[64];

        snprintf(buf, sizeof(buf), ""%"" PRIx64,

            s->header.features & ~QED_FEATURE_MASK);

        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,

            bdrv_get_device_name(bs), ""QED"", buf);

        return -ENOTSUP;

    }

    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {

        r",1,0,4,0,0,0,0,0,0,0,0,0,1,0,1
17954,FFmpeg,0,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_8w_msa(src - 2,

                           src - (stride * 2) +

                           sizeof(uint8_t), stride, dst, stride, 8);

}
",0,0,1,0,0,0,1,1,1,0,0,0,1,1,1
17972,qemu,0,"static CharDriverState *qemu_chr_open_pipe(const char *id,

                                           ChardevBackend *backend,

                                           ChardevReturn *ret,

                                           Error **errp)

{

    ChardevHostdev *opts = backend->u.pipe;

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_new0(WinCharState, 1);

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename, errp) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
",0,0,1,0,0,0,0,0,0,1,0,0,0,0,0
17981,qemu,0,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
",1,0,0,0,0,0,1,0,0,0,0,0,0,0,0
18015,qemu,0,"static void kvm_get_fallback_smmu_info(PowerPCCPU *cpu,

                                       struct kvm_ppc_smmu_info *info)

{

    CPUPPCState *env = &cpu->env;

    CPUState *cs = CPU(cpu);



    memset(info, 0, sizeof(*info));



    /* We don't have the new KVM_PPC_GET_SMMU_INFO ioctl, so

     * need to ""guess"" what the supported page sizes are.

     *

     * For that to work we make a few assumptions:

     *

     * - If KVM_CAP_PPC_GET_PVINFO is supported we are running ""PR""

     *   KVM which only supports 4K and 16M pages, but supports them

     *   regardless of the backing store characteritics. We also don't

     *   support 1T segments.

     *

     *   This is safe as if HV KVM ever supports that capability or PR

     *   KVM grows supports for more page/segment sizes, those versions

     *   will have implemented KVM_CAP_PPC_GET_SMMU_INFO and thus we

     *   will not hit this fallback

     *

     * - Else we are running HV KVM. This means we only support page

     *   sizes th",1,0,1,0,0,0,0,0,0,0,0,0,1,1,1
18020,qemu,0,"void helper_iret_protected(int shift)

{

    helper_ret_protected(shift, 1, 0);

}
",0,0,2,0,0,0,0,0,0,0,1,0,1,0,0
18038,qemu,0,"void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *ctx;



    ctx = bh->ctx;

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (atomic_xchg(&bh->scheduled, 1) == 0) {

        aio_notify(ctx);

    }

}
",2,0,2,0,0,0,0,1,1,1,1,0,0,1,1
18044,qemu,0,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)

{

    SpiceTimer *timer;



    timer = qemu_mallocz(sizeof(*timer));

    timer->timer = qemu_new_timer(rt_clock, func, opaque);

    QTAILQ_INSERT_TAIL(&timers, timer, next);

    return timer;

}
",0,0,0,0,0,0,1,1,1,0,0,0,0,1,1
18067,qemu,0,"static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,

                                        unsigned int queue_no,

                                        unsigned int vector,

                                        MSIMessage msg)

{

    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);

    EventNotifier *n = virtio_queue_get_guest_notifier(vq);

    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];

    int ret;



    if (irqfd->users == 0) {

        ret = kvm_irqchip_add_msi_route(kvm_state, msg);

        if (ret < 0) {

            return ret;

        }

        irqfd->virq = ret;

    }

    irqfd->users++;



    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);

    if (ret < 0) {

        if (--irqfd->users == 0) {

            kvm_irqchip_release_virq(kvm_state, irqfd->virq);

        }

        return ret;

    }



    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);

    return 0;

}
",0,0,8,0,0,0,0,0,0,0,0,0,0,0,0
18077,FFmpeg,1,"static int output_packet(InputStream *ist,

                         OutputStream *ost_table, int nb_ostreams,

                         const AVPacket *pkt)

{

    int ret = 0, i;

    int got_output;

    int64_t pkt_pts = AV_NOPTS_VALUE;



    AVPacket avpkt;



    if (ist->next_dts == AV_NOPTS_VALUE)

        ist->next_dts = ist->dts;

    if (ist->next_pts == AV_NOPTS_VALUE)

        ist->next_pts = ist->pts;



    if (pkt == NULL) {

        /* EOF handling */

        av_init_packet(&avpkt);

        avpkt.data = NULL;

        avpkt.size = 0;

        goto handle_eof;

    } else {

        avpkt = *pkt;

    }



    if (pkt->dts != AV_NOPTS_VALUE) {

        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);

        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)

            ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);

    }

    if(pkt->pts != AV_NOPTS_VALUE)

        pkt_pts = av_res",0,1,6,0,0,0,1,1,1,1,1,1,0,0,0
18095,FFmpeg,0,"static void search_for_quantizers_anmr(AVCodecContext *avctx, AACEncContext *s,

                                       SingleChannelElement *sce,

                                       const float lambda)

{

    int q, w, w2, g, start = 0;

    int i, j;

    int idx;

    TrellisPath paths[TRELLIS_STAGES][TRELLIS_STATES];

    int bandaddr[TRELLIS_STAGES];

    int minq;

    float mincost;

    float q0f = FLT_MAX, q1f = 0.0f, qnrgf = 0.0f;

    int q0, q1, qcnt = 0;



    for (i = 0; i < 1024; i++) {

        float t = fabsf(sce->coeffs[i]);

        if (t > 0.0f) {

            q0f = FFMIN(q0f, t);

            q1f = FFMAX(q1f, t);

            qnrgf += t*t;

            qcnt++;

        }

    }



    if (!qcnt) {

        memset(sce->sf_idx, 0, sizeof(sce->sf_idx));

        memset(sce->zeroes, 1, sizeof(sce->zeroes));

        return;

    }



    //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped

    q0 = av_clip_uint8(log2(q0f)*4 - 69 + SCALE_ONE_PO",2,0,2,0,0,0,1,1,1,1,0,0,0,0,0
18138,qemu,0,"static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)

{

    int ret = -EIO;



    /* Add footer to total size */

    total_size += 512;

    if (ftruncate(fd, total_size) != 0) {

        ret = -errno;

        goto fail;

    }

    if (lseek(fd, -512, SEEK_END) < 0) {

        goto fail;

    }

    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {

        goto fail;

    }



    ret = 0;



 fail:

    return ret;

}
",0,3,3,0,0,0,0,0,0,1,0,0,1,1,1
18142,qemu,0,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *entry,

                           struct dirent **result)

{

    return readdir_r(fs->dir, entry, result);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
18150,qemu,0,"static int zrle_send_framebuffer_update(VncState *vs, int x, int y,

                                        int w, int h)

{

    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);

    size_t bytes;

    int zywrle_level;



    if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {

        if (!vs->vd->lossy || vs->tight.quality < 0 || vs->tight.quality == 9) {

            zywrle_level = 0;

            vs->zrle.type = VNC_ENCODING_ZRLE;

        } else if (vs->tight.quality < 3) {

            zywrle_level = 3;

        } else if (vs->tight.quality < 6) {

            zywrle_level = 2;

        } else {

            zywrle_level = 1;

        }

    } else {

        zywrle_level = 0;

    }



    vnc_zrle_start(vs);



    switch(vs->clientds.pf.bytes_per_pixel) {

    case 1:

        zrle_encode_8ne(vs, x, y, w, h, zywrle_level);

        break;



    case 2:

        if (vs->clientds.pf.gmax > 0x1F) {

            if (be) {

                zrle_encode_16be(vs, x, y, w, h, zywrle_level);

            }",0,0,6,0,1,0,0,0,1,0,0,0,0,1,1
18159,qemu,0,"static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,

                                     unsigned size)

{

    MMIOState *s= opaque;

    return ide_status_read(&s->bus, 0);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
18161,qemu,0,"void tlb_flush_page(CPUState *env, target_ulong addr)

{

    int i;



#if defined(DEBUG_TLB)

    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);

#endif

    /* must reset current TB so that interrupts cannot modify the

       links while we are modifying them */

    env->current_tb = NULL;



    addr &= TARGET_PAGE_MASK;

    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    tlb_flush_entry(&env->tlb_table[0][i], addr);

    tlb_flush_entry(&env->tlb_table[1][i], addr);

#if (NB_MMU_MODES >= 3)

    tlb_flush_entry(&env->tlb_table[2][i], addr);

#if (NB_MMU_MODES == 4)

    tlb_flush_entry(&env->tlb_table[3][i], addr);

#endif

#endif



    tlb_flush_jmp_cache(env, addr);



#ifdef USE_KQEMU

    if (env->kqemu_enabled) {

        kqemu_flush_page(env, addr);

    }

#endif

}
",0,0,11,0,0,1,0,0,1,1,1,0,0,0,0
18171,FFmpeg,0,"void ff_slice_thread_free(AVCodecContext *avctx)

{

    ThreadContext *c = avctx->thread_opaque;

    int i;



    pthread_mutex_lock(&c->current_job_lock);

    c->done = 1;

    pthread_cond_broadcast(&c->current_job_cond);

    pthread_mutex_unlock(&c->current_job_lock);



    for (i=0; i<avctx->thread_count; i++)

         pthread_join(c->workers[i], NULL);



    pthread_mutex_destroy(&c->current_job_lock);

    pthread_cond_destroy(&c->current_job_cond);

    pthread_cond_destroy(&c->last_job_cond);

    av_free(c->workers);

    av_freep(&avctx->thread_opaque);

}
",1,0,0,0,0,0,1,1,1,0,0,0,0,1,0
18175,FFmpeg,1,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,

                            AVPacket *avpkt)

{

    const char *ptr = avpkt->data;

    int len, size = avpkt->size;



    while (size > 0) {

        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);

        int duration = dialog->end - dialog->start;

        len = ff_ass_add_rect(data, ptr, 0, duration, 1);

        if (len < 0)

            return len;

        ptr  += len;

        size -= len;

    }



    *got_sub_ptr = avpkt->size > 0;

    return avpkt->size;

}
",0,0,1,0,0,1,1,1,1,1,1,1,1,1,1
18187,qemu,1,"static int init_blk_migration(QEMUFile *f)

{

    BlockDriverState *bs;

    BlkMigDevState *bmds;

    int64_t sectors;

    BdrvNextIterator it;

    int i, num_bs = 0;

    struct {

        BlkMigDevState *bmds;

        BlockDriverState *bs;

    } *bmds_bs;

    Error *local_err = NULL;

    int ret;



    block_mig_state.submitted = 0;

    block_mig_state.read_done = 0;

    block_mig_state.transferred = 0;

    block_mig_state.total_sector_sum = 0;

    block_mig_state.prev_progress = -1;

    block_mig_state.bulk_completed = 0;

    block_mig_state.zero_blocks = migrate_zero_blocks();



    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {

        num_bs++;

    }

    bmds_bs = g_malloc0(num_bs * sizeof(*bmds_bs));



    for (i = 0, bs = bdrv_first(&it); bs; bs = bdrv_next(&it), i++) {

        if (bdrv_is_read_only(bs)) {

            continue;

        }



        sectors = bdrv_nb_sectors(bs);

        if (sectors <= 0) {

            ret = sectors;


            goto out;

        }

",2,1,2,0,0,0,0,0,0,0,0,0,0,1,1
18194,qemu,1,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int h;



    for (h = 1; h < (vs->serverds.height - y); h++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);

    }



    return h;

}
",2,0,1,0,0,0,1,1,1,1,1,1,0,0,0
18195,qemu,1,"static void test_dispatch_cmd_failure(void)

{

    QDict *req = qdict_new();


    QObject *resp;



    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd2"")));



    resp = qmp_dispatch(QOBJECT(req));

    assert(resp != NULL);

    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(req);



    /* check that with extra arguments it throws an error */

    req = qdict_new();

    qdict_put(args, ""a"", qint_from_int(66));

    qdict_put(req, ""arguments"", args);



    qdict_put_obj(req, ""execute"", QOBJECT(qstring_from_str(""user_def_cmd"")));



    resp = qmp_dispatch(QOBJECT(req));

    assert(resp != NULL);

    assert(qdict_haskey(qobject_to_qdict(resp), ""error""));



    qobject_decref(resp);

    QDECREF(req);

}",0,0,0,0,0,0,1,0,0,1,1,0,1,0,1
18200,FFmpeg,0,"static void add_index_entry(AVStream *st,

                            int64_t pos, int64_t timestamp, int flags)

{

    AVIndexEntry *entries, *ie;

    

    entries = av_fast_realloc(st->index_entries,

                              &st->index_entries_allocated_size,

                              (st->nb_index_entries + 1) * 

                              sizeof(AVIndexEntry));

    if (entries) {

        st->index_entries = entries;

        ie = &entries[st->nb_index_entries++];

        ie->pos = pos;

        ie->timestamp = timestamp;

        ie->flags = flags;

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
18202,FFmpeg,1,"static int rv10_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,

                             AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    MpegEncContext *s = avctx->priv_data;

    AVFrame *pict = data;

    int i, ret;

    int slice_count;

    const uint8_t *slices_hdr = NULL;



    av_dlog(avctx, ""*****frame %d size=%d\n"", avctx->frame_number, buf_size);



    /* no supplementary picture */

    if (buf_size == 0) {

        return 0;

    }



    if (!avctx->slice_count) {

        slice_count = (*buf++) + 1;

        buf_size--;



        if (!slice_count || buf_size <= 8 * slice_count) {

            av_log(avctx, AV_LOG_ERROR, ""Invalid slice count: %d.\n"",

                   slice_count);

            return AVERROR_INVALIDDATA;

        }



        slices_hdr = buf + 4;

        buf       += 8 * slice_count;

        buf_size  -= 8 * slice_count;

    } else

        slice_count = avctx->slice_count;



    for (i = 0; i",1,0,3,0,0,0,0,0,0,0,0,0,0,0,0
18203,FFmpeg,1,"ff_rm_read_mdpr_codecdata (AVFormatContext *s, AVIOContext *pb,

                           AVStream *st, RMStream *rst, int codec_data_size)

{

    unsigned int v;

    int size;

    int64_t codec_pos;

    int ret;



    avpriv_set_pts_info(st, 64, 1, 1000);

    codec_pos = avio_tell(pb);

    v = avio_rb32(pb);

    if (v == MKTAG(0xfd, 'a', 'r', '.')) {

        /* ra type header */

        if (rm_read_audio_stream_info(s, pb, st, rst, 0))

            return -1;

    } else if (v == MKBETAG('L', 'S', 'D', ':')) {

        avio_seek(pb, -4, SEEK_CUR);

        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)

            return ret;



        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        st->codec->codec_tag  = AV_RL32(st->codec->extradata);

        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,

                                                st->codec->codec_tag);

    } else {

        int fps;

        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {

      ",0,0,5,0,0,0,0,1,0,1,0,0,0,0,0
18211,qemu,1,"static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}
",0,0,0,0,0,0,0,0,1,1,0,1,0,0,0
18220,qemu,0,"QJSON *qjson_new(void)

{

    QJSON *json = QJSON(object_new(TYPE_QJSON));

    return json;

}
",0,0,0,0,0,0,0,0,0,0,1,1,1,1,1
18231,qemu,0,"void kqemu_record_dump(void)

{

    PCRecord **pr, *r;

    int i, h;

    FILE *f;

    int64_t total, sum;



    pr = malloc(sizeof(PCRecord *) * nb_pc_records);

    i = 0;

    total = 0;

    for(h = 0; h < PC_REC_HASH_SIZE; h++) {

        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {

            pr[i++] = r;

            total += r->count;

        }

    }

    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);



    f = fopen(""/tmp/kqemu.stats"", ""w"");

    if (!f) {

        perror(""/tmp/kqemu.stats"");

        exit(1);

    }

    fprintf(f, ""total: %"" PRId64 ""\n"", total);

    sum = 0;

    for(i = 0; i < nb_pc_records; i++) {

        r = pr[i];

        sum += r->count;

        fprintf(f, ""%08lx: %"" PRId64 "" %0.2f%% %0.2f%%\n"",

                r->pc,

                r->count,

                (double)r->count / (double)total * 100.0,

                (double)sum / (double)total * 100.0);

    }

    fclose(f);

    free(pr);



    kqemu_record_flush();

}
",3,0,1,0,0,0,0,0,0,0,0,0,1,0,0
18254,qemu,0,"static void pcnet_receive(void *opaque, const uint8_t *buf, size_t size)

{

    PCNetState *s = opaque;

    int is_padr = 0, is_bcast = 0, is_ladr = 0;

    uint8_t buf1[60];

    int remaining;

    int crc_err = 0;



    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)

        return;



#ifdef PCNET_DEBUG

    printf(""pcnet_receive size=%d\n"", size);

#endif



    /* if too small buffer, then expand it */

    if (size < MIN_BUF_SIZE) {

        memcpy(buf1, buf, size);

        memset(buf1 + size, 0, MIN_BUF_SIZE - size);

        buf = buf1;

        size = MIN_BUF_SIZE;

    }



    if (CSR_PROM(s)

        || (is_padr=padr_match(s, buf, size))

        || (is_bcast=padr_bcast(s, buf, size))

        || (is_ladr=ladr_match(s, buf, size))) {



        pcnet_rdte_poll(s);



        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {

            struct pcnet_RMD rmd;

            int rcvrc = CSR_RCVRC(s)-1,i;

            target_phys_addr_t nrda;

            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc",1,0,6,0,0,0,1,0,0,0,0,0,0,0,0
18267,qemu,0,"static void nbd_reply_ready(void *opaque)

{

    NbdClientSession *s = opaque;

    uint64_t i;

    int ret;



    if (s->reply.handle == 0) {

        /* No reply already in flight.  Fetch a header.  It is possible

         * that another thread has done the same thing in parallel, so

         * the socket is not readable anymore.

         */

        ret = nbd_receive_reply(s->sock, &s->reply);

        if (ret == -EAGAIN) {

            return;

        }

        if (ret < 0) {

            s->reply.handle = 0;

            goto fail;

        }

    }



    /* There's no need for a mutex on the receive side, because the

     * handler acts as a synchronization point and ensures that only

     * one coroutine is called until the reply finishes.  */

    i = HANDLE_TO_INDEX(s, s->reply.handle);

    if (i >= MAX_NBD_REQUESTS) {

        goto fail;

    }



    if (s->recv_coroutine[i]) {

        qemu_coroutine_enter(s->recv_coroutine[i], NULL);

        return;

    }



fail:

    nbd_teardown_",1,2,5,0,0,0,0,0,0,0,0,0,0,1,1
18268,FFmpeg,0,"static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t pts, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, buf, len);



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->pts == 0)

                ffm->pts = pts;



            flush_packet(s);

        }

    }

}
",0,0,4,0,0,1,0,0,1,1,1,1,0,0,0
18272,qemu,0,"static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,

                struct vmsvga_cursor_definition_s *c)

{

    QEMUCursor *qc;

    int i, pixels;



    qc = cursor_alloc(c->width, c->height);

    qc->hot_x = c->hot_x;

    qc->hot_y = c->hot_y;

    switch (c->bpp) {

    case 1:

        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,

                        1, (void*)c->mask);

#ifdef DEBUG

        cursor_print_ascii_art(qc, ""vmware/mono"");

#endif

        break;

    case 32:

        /* fill alpha channel from mask, set color to zero */

        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,

                        1, (void*)c->mask);

        /* add in rgb values */

        pixels = c->width * c->height;

        for (i = 0; i < pixels; i++) {

            qc->data[i] |= c->image[i] & 0xffffff;

        }

#ifdef DEBUG

        cursor_print_ascii_art(qc, ""vmware/32bit"");

#endif

        break;

    default:

        fprintf(stderr, ""%s: unhandled bpp %d, using",1,0,4,0,1,0,1,1,1,0,1,0,0,0,1
18279,FFmpeg,0,"static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,

                                          ptrdiff_t stride)

{

    int i;

    pixel *pix = (pixel*)_pix;

    const dctcoef *block = (const dctcoef*)_block;

    stride >>= sizeof(pixel)-1;

    for(i=0; i<4; i++){

        pixel v = pix[-1];

        pix[0]= v += block[0];

        pix[1]= v += block[1];

        pix[2]= v += block[2];

        pix[3]= v +  block[3];

        pix+= stride;

        block+= 4;

    }

}
",1,0,1,0,0,0,1,0,1,0,1,1,0,0,0
18282,qemu,0,"static void set_proc_name(const char *s)

{

#ifdef __linux__

    char name[16];

    if (!s)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, s, sizeof(name));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    prctl(PR_SET_NAME, name);

#endif    	

}
",1,0,3,0,0,0,0,0,0,0,0,0,1,0,1
18285,qemu,1,"int nbd_client_session_co_flush(NbdClientSession *client)

{

    struct nbd_request request;

    struct nbd_reply reply;

    ssize_t ret;



    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {

        return 0;

    }



    request.type = NBD_CMD_FLUSH;

    if (client->nbdflags & NBD_FLAG_SEND_FUA) {

        request.type |= NBD_CMD_FLAG_FUA;

    }



    request.from = 0;

    request.len = 0;



    nbd_coroutine_start(client, &request);

    ret = nbd_co_send_request(client, &request, NULL, 0);

    if (ret < 0) {

        reply.error = -ret;

    } else {

        nbd_co_receive_reply(client, &request, &reply, NULL, 0);

    }

    nbd_coroutine_end(client, &request);

    return -reply.error;

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,0,1
18304,FFmpeg,0,"int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)

{

    cl_int status;

    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,

                                      CL_TRUE,CL_MAP_READ, 0, buf_size,

                                      0, NULL, NULL, &status);



    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not map OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    memcpy(dst_buf, mapped, buf_size);



    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);

    if (status != CL_SUCCESS) {

        av_log(&openclutils, AV_LOG_ERROR, ""Could not unmap OpenCL buffer: %s\n"", opencl_errstr(status));

        return AVERROR_EXTERNAL;

    }

    return 0;

}
",0,0,2,0,0,0,0,0,0,1,1,1,1,1,1
18311,FFmpeg,1,"static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;

    MOVStreamContext *sc;

    unsigned int i, entries;



    if (c->fc->nb_streams < 1)

        return 0;

    st = c->fc->streams[c->fc->nb_streams-1];

    sc = st->priv_data;



    avio_r8(pb); /* version */

    avio_rb24(pb); /* flags */



    entries = avio_rb32(pb);



    av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i\n"", c->fc->nb_streams-1, entries);



    if (!entries)

        return 0;

    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))

        return AVERROR_INVALIDDATA;

    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));

    if (!sc->stsc_data)

        return AVERROR(ENOMEM);



    for (i = 0; i < entries && !pb->eof_reached; i++) {

        sc->stsc_data[i].first = avio_rb32(pb);

        sc->stsc_data[i].count = avio_rb32(pb);

        sc->stsc_data[i].id = avio_rb32(pb);

        if (sc->stsc_data[i].id > sc->stsd_count)

            return AVERROR_INVALIDDATA;

",1,0,5,0,0,0,1,1,1,1,0,1,0,0,0
18323,FFmpeg,0,"static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,

                        uint32_t size)

{

    AVIOContext *pb = s->pb;

    char key[5]     = { 0 };

    char *value;



    size += (size & 1);



    if (size == UINT_MAX)

        return AVERROR(EINVAL);

    value = av_malloc(size + 1);

    if (!value)

        return AVERROR(ENOMEM);

    avio_read(pb, value, size);

    value[size] = 0;



    AV_WL32(key, tag);



    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,

                       AV_DICT_DONT_STRDUP_VAL);

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
18324,FFmpeg,0,"static void hybrid_analysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len)

{

    int i, j;

    for (i = 0; i < 5; i++) {

        for (j = 0; j < 38; j++) {

            in[i][j+6][0] = L[0][j][i];

            in[i][j+6][1] = L[1][j][i];

        }

    }

    if (is34) {

        hybrid4_8_12_cx(in[0], out,    f34_0_12, 12, len);

        hybrid4_8_12_cx(in[1], out+12, f34_1_8,   8, len);

        hybrid4_8_12_cx(in[2], out+20, f34_2_4,   4, len);

        hybrid4_8_12_cx(in[3], out+24, f34_2_4,   4, len);

        hybrid4_8_12_cx(in[4], out+28, f34_2_4,   4, len);

        for (i = 0; i < 59; i++) {

            for (j = 0; j < len; j++) {

                out[i+32][j][0] = L[0][j][i+5];

                out[i+32][j][1] = L[1][j][i+5];

            }

        }

    } else {

        hybrid6_cx(in[0], out, f20_0_8, len);

        hybrid2_re(in[1], out+6, g1_Q2, len, 1);

        hybrid2_re(in[2], out+8, g1_Q2, len, 0);

        for (i = 0; i < 61; i++) {

            fo",5,0,1,0,0,0,0,0,0,1,1,1,0,0,0
18326,qemu,1,"void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)

{

    f->xfer_limit = limit;

}
",0,0,0,0,0,0,0,0,1,1,1,0,1,1,1
18329,qemu,1,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
",0,0,2,0,0,0,1,1,1,0,1,0,1,1,0
18344,qemu,0,"int kvm_arch_get_registers(CPUState *cs)

{

    S390CPU *cpu = S390_CPU(cs);

    CPUS390XState *env = &cpu->env;

    struct kvm_one_reg reg;

    struct kvm_sregs sregs;

    struct kvm_regs regs;

    int i, r;



    /* get the PSW */

    env->psw.addr = cs->kvm_run->psw_addr;

    env->psw.mask = cs->kvm_run->psw_mask;



    /* the GPRS */

    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {

        for (i = 0; i < 16; i++) {

            env->regs[i] = cs->kvm_run->s.regs.gprs[i];

        }

    } else {

        r = kvm_vcpu_ioctl(cs, KVM_GET_REGS, &regs);

        if (r < 0) {

            return r;

        }

         for (i = 0; i < 16; i++) {

            env->regs[i] = regs.gprs[i];

        }

    }



    /* The ACRS and CRS */

    if (cap_sync_regs &&

        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&

        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {

        for (i = 0; i < 16; i++) {

            env->aregs[i] = cs->kvm_run->s.regs.acrs[i];

            en",3,0,3,0,0,0,0,0,0,0,0,0,1,1,1
18345,qemu,0,"int select_watchdog(const char *p)

{

    WatchdogTimerModel *model;

    QemuOpts *opts;



    /* -watchdog ? lists available devices and exits cleanly. */

    if (strcmp(p, ""?"") == 0) {

        LIST_FOREACH(model, &watchdog_list, entry) {

            fprintf(stderr, ""\t%s\t%s\n"",

                     model->wdt_name, model->wdt_description);

        }

        return 2;

    }



    LIST_FOREACH(model, &watchdog_list, entry) {

        if (strcasecmp(model->wdt_name, p) == 0) {

            /* add the device */

            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);

            qemu_opt_set(opts, ""driver"", p);

            return 0;

        }

    }



    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");

    LIST_FOREACH(model, &watchdog_list, entry) {

        fprintf(stderr, ""\t%s\t%s\n"",

                 model->wdt_name, model->wdt_description);

    }

    return 1;

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,1,1
18351,qemu,0,"static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)

{

    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);

    VirtQueueElement elem;

    MemoryRegionSection section;



    while (virtqueue_pop(vq, &elem)) {

        size_t offset = 0;

        uint32_t pfn;



        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {

            ram_addr_t pa;

            ram_addr_t addr;

            int p = virtio_ldl_p(vdev, &pfn);



            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;

            offset += 4;



            /* FIXME: remove get_system_memory(), but how? */

            section = memory_region_find(get_system_memory(), pa, 1);

            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))

                continue;



            trace_virtio_balloon_handle_output(memory_region_name(section.mr),

                                               pa);

            /* Using memory_region_get_ram_ptr is bending the rules a bit, but

         ",0,0,1,0,0,2,0,0,0,0,0,0,1,0,1
18371,FFmpeg,0,"static av_cold int vorbis_decode_init(AVCodecContext *avccontext)

{

    vorbis_context *vc = avccontext->priv_data;

    uint8_t *headers   = avccontext->extradata;

    int headers_len    = avccontext->extradata_size;

    uint8_t *header_start[3];

    int header_len[3];

    GetBitContext *gb = &vc->gb;

    int hdr_type, ret;



    vc->avccontext = avccontext;

    ff_dsputil_init(&vc->dsp, avccontext);

    ff_fmt_convert_init(&vc->fmt_conv, avccontext);



    if (avccontext->request_sample_fmt == AV_SAMPLE_FMT_FLT) {

        avccontext->sample_fmt = AV_SAMPLE_FMT_FLT;

        vc->scale_bias = 1.0f;

    } else {

        avccontext->sample_fmt = AV_SAMPLE_FMT_S16;

        vc->scale_bias = 32768.0f;

    }



    if (!headers_len) {

        av_log(avccontext, AV_LOG_ERROR, ""Extradata missing.\n"");

        return AVERROR_INVALIDDATA;

    }



    if ((ret = avpriv_split_xiph_headers(headers, headers_len, 30, header_start, header_len)) < 0) {

        av_log(avccontext, AV_LOG_ERROR, ""Extradata c",0,0,3,0,0,0,0,0,1,0,0,0,1,0,0
18384,qemu,1,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    len = strlen(bdrv_get_device_name(blk->bmds->bs));

    qemu_put_byte(f, len);

    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        return;

    }



    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);

}
",0,0,4,0,0,0,1,1,0,1,1,1,1,1,1
18409,qemu,1,"int64_t qmp_guest_fsfreeze_freeze(Error **err)

{

    int ret = 0, i = 0;

    FsMountList mounts;

    struct FsMount *mount;

    Error *local_err = NULL;

    int fd;



    slog(""guest-fsfreeze called"");



    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(err, local_err);

        return -1;

    }



    QTAILQ_INIT(&mounts);

    build_fs_mount_list(&mounts, &local_err);

    if (error_is_set(&local_err)) {

        error_propagate(err, local_err);

        return -1;

    }



    /* cannot risk guest agent blocking itself on a write in this state */

    ga_set_frozen(ga_state);



    QTAILQ_FOREACH(mount, &mounts, next) {

        fd = qemu_open(mount->dirname, O_RDONLY);

        if (fd == -1) {

            error_setg_errno(err, errno, ""failed to open %s"", mount->dirname);

            goto error;

        }



        /* we try to cull filesytems we know won't work in advance, but other

         * filesytems may not imple",0,1,3,0,0,0,0,0,1,1,1,0,0,0,0
18412,qemu,1,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
18426,FFmpeg,1,"static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,

                                         uint32_t *sums, int n, int pred_order)

{

    int i;

    int k, cnt, part;

    uint32_t all_bits;



    part     = (1 << porder);

    all_bits = 4 * part;



    cnt = (n >> porder) - pred_order;

    for (i = 0; i < part; i++) {

        k = find_optimal_param(sums[i], cnt);

        rc->params[i] = k;

        all_bits += rice_encode_count(sums[i], cnt, k);

        cnt = n >> porder;

    }



    rc->porder = porder;



    return all_bits;

}
",1,0,0,0,0,0,1,1,1,0,0,1,0,0,0
18437,qemu,1,"static void external_snapshot_commit(BlkActionState *common)

{

    ExternalSnapshotState *state =

                             DO_UPCAST(ExternalSnapshotState, common, common);



    bdrv_set_aio_context(state->new_bs, state->aio_context);



    /* This removes our old bs and adds the new bs */

    bdrv_append(state->new_bs, state->old_bs);

    /* We don't need (or want) to use the transactional

     * bdrv_reopen_multiple() across all the entries at once, because we

     * don't want to abort all of them if one of them fails the reopen */

    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,

                NULL);

}
",0,0,1,0,0,0,1,1,1,0,1,1,0,1,0
18438,FFmpeg,1,"int av_image_alloc(uint8_t *pointers[4], int linesizes[4],

                   int w, int h, enum PixelFormat pix_fmt, int align)

{

    int i, ret;

    uint8_t *buf;



    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)

        return ret;

    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)

        return ret;



    for (i = 0; i < 4; i++)

        linesizes[i] = FFALIGN(linesizes[i], align);



    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)

        return ret;

    buf = av_malloc(ret + align);

    if (!buf)

        return AVERROR(ENOMEM);

    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {

        av_free(buf);

        return ret;

    }

    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)

        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);



    return ret;

}
",1,0,6,0,0,0,0,0,0,0,0,0,0,0,1
18439,qemu,1,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}
",0,0,3,0,0,0,0,0,1,0,0,1,0,0,0
18447,qemu,1,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,

                                              VirtQueue *vq)

{

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;



    assert(s->ctx && s->dataplane_started);

    return virtio_scsi_handle_cmd_vq(s, vq);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
18457,qemu,1,"USBDevice *usb_host_device_open(const char *devname)

{

    struct usb_device_info bus_info, dev_info;

    USBDevice *d = NULL;

    USBHostDevice *dev;

    char ctlpath[PATH_MAX + 1];

    char buspath[PATH_MAX + 1];

    int bfd, dfd, bus, address, i;

    int ugendebug = UGEN_DEBUG_LEVEL;



    if (usb_host_find_device(&bus, &address, devname) < 0)

        return NULL;



    snprintf(buspath, PATH_MAX, ""/dev/usb%d"", bus);



    bfd = open(buspath, O_RDWR);

    if (bfd < 0) {

#ifdef DEBUG

        printf(""usb_host_device_open: failed to open usb bus - %s\n"",

               strerror(errno));

#endif

        return NULL;

    }



    bus_info.udi_addr = address;

    if (ioctl(bfd, USB_DEVICEINFO, &bus_info) < 0) {

#ifdef DEBUG

        printf(""usb_host_device_open: failed to grab bus information - %s\n"",

               strerror(errno));

#endif

        return NULL;

    }



#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)

    snprintf(ctlpath, PATH_MAX, ""/dev",1,0,8,0,0,0,1,1,1,0,0,0,0,0,0
18462,FFmpeg,0,"static av_cold int twin_decode_init(AVCodecContext *avctx)

{

    int ret;

    TwinContext *tctx = avctx->priv_data;

    int isampf, ibps;



    tctx->avctx       = avctx;

    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;



    if (!avctx->extradata || avctx->extradata_size < 12) {

        av_log(avctx, AV_LOG_ERROR, ""Missing or incomplete extradata\n"");

        return AVERROR_INVALIDDATA;

    }

    avctx->channels = AV_RB32(avctx->extradata    ) + 1;

    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;

    isampf          = AV_RB32(avctx->extradata + 8);



    if (isampf < 8 || isampf > 44) {

        av_log(avctx, AV_LOG_ERROR, ""Unsupported sample rate\n"");

        return AVERROR_INVALIDDATA;

    }

    switch (isampf) {

    case 44: avctx->sample_rate = 44100;         break;

    case 22: avctx->sample_rate = 22050;         break;

    case 11: avctx->sample_rate = 11025;         break;

    default: avctx->sample_rate = isampf * 1000; break;

    }



    if (avctx->channels <= 0 || avctx",0,0,3,0,1,0,1,1,0,0,1,0,0,0,0
18474,FFmpeg,1,"static int copy_chapters(InputFile *ifile, OutputFile *ofile, int copy_metadata)

{

    AVFormatContext *is = ifile->ctx;

    AVFormatContext *os = ofile->ctx;

    int i;



    for (i = 0; i < is->nb_chapters; i++) {

        AVChapter *in_ch = is->chapters[i], *out_ch;

        int64_t ts_off   = av_rescale_q(ofile->start_time - ifile->ts_offset,

                                       AV_TIME_BASE_Q, in_ch->time_base);

        int64_t rt       = (ofile->recording_time == INT64_MAX) ? INT64_MAX :

                           av_rescale_q(ofile->recording_time, AV_TIME_BASE_Q, in_ch->time_base);





        if (in_ch->end < ts_off)

            continue;

        if (rt != INT64_MAX && in_ch->start > rt + ts_off)

            break;



        out_ch = av_mallocz(sizeof(AVChapter));

        if (!out_ch)

            return AVERROR(ENOMEM);



        out_ch->id        = in_ch->id;

        out_ch->time_base = in_ch->time_base;

        out_ch->start     = FFMAX(0,  in_ch->start - ts_off);

        out_c",1,0,6,0,0,0,0,1,0,1,1,0,0,1,1
18477,qemu,1,"int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)

{

    unsigned int idx, rec_off, old_idx, new_idx;

    uint32_t rec_len = sizeof(TraceRecord) + datasize;

    uint64_t event_u64 = event;

    uint64_t timestamp_ns = get_clock();



    do {

        old_idx = g_atomic_int_get(&trace_idx);

        smp_rmb();

        new_idx = old_idx + rec_len;



        if (new_idx - writeout_idx > TRACE_BUF_LEN) {

            /* Trace Buffer Full, Event dropped ! */

            g_atomic_int_inc(&dropped_events);

            return -ENOSPC;

        }

    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));



    idx = old_idx % TRACE_BUF_LEN;



    rec_off = idx;

    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));

    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));

    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));

    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));



    ",0,0,1,0,0,1,1,1,1,1,1,1,0,0,1
18493,qemu,1,"static float64 roundAndPackFloat64( flag zSign, int16 zExp, uint64_t zSig STATUS_PARAM)

{

    int8 roundingMode;

    flag roundNearestEven;

    int16 roundIncrement, roundBits;

    flag isTiny;



    roundingMode = STATUS(float_rounding_mode);

    roundNearestEven = ( roundingMode == float_round_nearest_even );

    roundIncrement = 0x200;

    if ( ! roundNearestEven ) {

        if ( roundingMode == float_round_to_zero ) {

            roundIncrement = 0;

        }

        else {

            roundIncrement = 0x3FF;

            if ( zSign ) {

                if ( roundingMode == float_round_up ) roundIncrement = 0;

            }

            else {

                if ( roundingMode == float_round_down ) roundIncrement = 0;

            }

        }

    }

    roundBits = zSig & 0x3FF;

    if ( 0x7FD <= (uint16_t) zExp ) {

        if (    ( 0x7FD < zExp )

             || (    ( zExp == 0x7FD )

                  && ( (int64_t) ( zSig + roundIncrement ) < 0 ) )

           ) {

            fl",0,0,7,0,0,0,0,0,0,0,0,0,1,1,1
18512,qemu,1,"static void xen_remap_bucket(MapCacheEntry *entry,

                             hwaddr size,

                             hwaddr address_index)

{

    uint8_t *vaddr_base;

    xen_pfn_t *pfns;

    int *err;

    unsigned int i;

    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;



    trace_xen_remap_bucket(address_index);



    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));

    err = g_malloc0(nb_pfn * sizeof (int));



    if (entry->vaddr_base != NULL) {

        if (munmap(entry->vaddr_base, entry->size) != 0) {

            perror(""unmap fails"");

            exit(-1);

        }

    }

    g_free(entry->valid_mapping);

    entry->valid_mapping = NULL;



    for (i = 0; i < nb_pfn; i++) {

        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;

    }



    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,

                                     pfns, err, nb_pfn);

    if (vaddr_base == NULL) {

        perror(""xc_map_foreign_bulk"");

        exit(-1);

  ",3,0,3,0,0,0,0,0,0,1,1,1,0,1,0
18513,qemu,1,"void usb_packet_complete(USBDevice *dev, USBPacket *p)

{

    USBEndpoint *ep = p->ep;

    int ret;



    assert(p->state == USB_PACKET_ASYNC);

    assert(QTAILQ_FIRST(&ep->queue) == p);

    usb_packet_set_state(p, USB_PACKET_COMPLETE);

    QTAILQ_REMOVE(&ep->queue, p, queue);

    dev->port->ops->complete(dev->port, p);



    while (!QTAILQ_EMPTY(&ep->queue)) {

        p = QTAILQ_FIRST(&ep->queue);

        if (p->state == USB_PACKET_ASYNC) {

            break;

        }

        assert(p->state == USB_PACKET_QUEUED);

        ret = usb_process_one(p);

        if (ret == USB_RET_ASYNC) {

            usb_packet_set_state(p, USB_PACKET_ASYNC);

            break;

        }

        p->result = ret;

        usb_packet_set_state(p, USB_PACKET_COMPLETE);

        QTAILQ_REMOVE(&ep->queue, p, queue);

        dev->port->ops->complete(dev->port, p);

    }

}
",0,0,2,0,0,1,1,1,1,0,1,0,1,0,0
18518,FFmpeg,0,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;

    

    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;

    new_allocated_size = d->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);

        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        d->size = d->pos;

}
",0,0,4,0,0,1,0,0,0,0,0,0,0,1,1
18523,FFmpeg,0,"static inline int RENAME(yuv420_rgb24)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,

             int srcSliceH, uint8_t* dst[], int dstStride[]){

    int y, h_size;



    if(c->srcFormat == PIX_FMT_YUV422P){

	srcStride[1] *= 2;

	srcStride[2] *= 2;

    }



    h_size= (c->dstW+7)&~7;

    if(h_size*3 > dstStride[0]) h_size-=8;

    

    __asm__ __volatile__ (""pxor %mm4, %mm4;"" /* zero mm4 */ );



    for (y= 0; y<srcSliceH; y++ ) {

	uint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];

	uint8_t *_py = src[0] + y*srcStride[0];

	uint8_t *_pu = src[1] + (y>>1)*srcStride[1];

	uint8_t *_pv = src[2] + (y>>1)*srcStride[2];

	long index= -h_size/2;



	    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8

	       pixels in each iteration */

	    __asm__ __volatile__ (

	/* load data for start of next scan line */

		     ""movd (%2, %0), %%mm0;"" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */

		     ""movd (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */

	",1,0,2,0,0,0,0,1,1,0,0,0,0,0,0
18529,FFmpeg,0,"static int hex_to_data(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}
",1,0,5,0,0,0,0,0,0,1,1,0,1,1,0
18545,FFmpeg,0,"static int RENAME(dct_quantize)(MpegEncContext *s,

                            int16_t *block, int n,

                            int qscale, int *overflow)

{

    x86_reg last_non_zero_p1;

    int level=0, q; //=0 is because gcc says uninitialized ...

    const uint16_t *qmat, *bias;

    LOCAL_ALIGNED_16(int16_t, temp_block, [64]);



    av_assert2((7&(int)(&temp_block[0])) == 0); //did gcc align it correctly?



    //s->fdct (block);

    RENAME_FDCT(ff_fdct)(block); // cannot be anything else ...



    if(s->dct_error_sum)

        s->denoise_dct(s, block);



    if (s->mb_intra) {

        int dummy;

        if (n < 4){

            q = s->y_dc_scale;

            bias = s->q_intra_matrix16[qscale][1];

            qmat = s->q_intra_matrix16[qscale][0];

        }else{

            q = s->c_dc_scale;

            bias = s->q_chroma_intra_matrix16[qscale][1];

            qmat = s->q_chroma_intra_matrix16[qscale][0];

        }

        /* note: block[0] is assumed to be positive */

        if ",0,0,4,0,0,0,1,1,1,1,0,1,0,1,0
18556,FFmpeg,1,"static void qdm2_fft_decode_tones (QDM2Context *q, int duration, GetBitContext *gb, int b)

{

    int channel, stereo, phase, exp;

    int local_int_4,  local_int_8,  stereo_phase,  local_int_10;

    int local_int_14, stereo_exp, local_int_20, local_int_28;

    int n, offset;



    local_int_4 = 0;

    local_int_28 = 0;

    local_int_20 = 2;

    local_int_8 = (4 - duration);

    local_int_10 = 1 << (q->group_order - duration - 1);

    offset = 1;



    while (1) {

        if (q->superblocktype_2_3) {

            while ((n = qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2)) < 2) {

                offset = 1;

                if (n == 0) {

                    local_int_4 += local_int_10;

                    local_int_28 += (1 << local_int_8);

                } else {

                    local_int_4 += 8*local_int_10;

                    local_int_28 += (8 << local_int_8);

                }

            }

            offset += (n - 2);

        } else {

            offset += qd",0,0,2,0,0,2,0,0,0,0,0,0,1,0,1
18559,qemu,1,"static void cuda_receive_packet(CUDAState *s,

                                const uint8_t *data, int len)

{

    uint8_t obuf[16] = { CUDA_PACKET, 0, data[0] };

    int autopoll;

    uint32_t ti;



    switch(data[0]) {

    case CUDA_AUTOPOLL:

        autopoll = (data[1] != 0);

        if (autopoll != s->autopoll) {

            s->autopoll = autopoll;

            if (autopoll) {

                timer_mod(s->adb_poll_timer,

                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +

                               (get_ticks_per_sec() / CUDA_ADB_POLL_FREQ));

            } else {

                timer_del(s->adb_poll_timer);

            }

        }

        cuda_send_packet_to_host(s, obuf, 3);

        break;

    case CUDA_GET_6805_ADDR:

        cuda_send_packet_to_host(s, obuf, 3);

        break;

    case CUDA_SET_TIME:

        ti = (((uint32_t)data[1]) << 24) + (((uint32_t)data[2]) << 16) + (((uint32_t)data[3]) << 8) + data[4];

        s->tick_offset = ti - (qemu_clock_get_",0,0,2,0,1,0,0,0,0,1,1,1,0,0,0
18562,qemu,1,"static void bitmap_free(Qcow2Bitmap *bm)
{
    g_free(bm->name);
    g_free(bm);",0,0,0,0,0,0,1,1,1,1,1,0,0,0,1
18578,FFmpeg,1,"static int vp6_parse_coeff(VP56Context *s)

{

    VP56RangeCoder *c = s->ccp;

    VP56Model *model = s->modelp;

    uint8_t *permute = s->idct_scantable;

    uint8_t *model1, *model2, *model3;

    int coeff, sign, coeff_idx;

    int b, i, cg, idx, ctx;

    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */



    if (c->end >= c->buffer && c->bits >= 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""End of AC stream reached in vp6_parse_coeff\n"");

        return AVERROR_INVALIDDATA;

    }



    for (b=0; b<6; b++) {

        int ct = 1;    /* code type */

        int run = 1;



        if (b > 3) pt = 1;



        ctx = s->left_block[ff_vp56_b6to4[b]].not_null_dc

              + s->above_blocks[s->above_block_idx[b]].not_null_dc;

        model1 = model->coeff_dccv[pt];

        model2 = model->coeff_dcct[pt][ctx];



        coeff_idx = 0;

        for (;;) {

            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {

                /* parse a coeff */

            ",2,0,3,0,0,0,0,1,1,0,0,0,1,1,1
18583,FFmpeg,0,"static int ftp_passive_mode_epsv(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    static const char d = '|';

    static const char *command = ""EPSV\r\n"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '(') {

            start = res + i + 1;

        } else if (res[i] == ')') {

            end = res + i;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    s->server_data_port = atoi(start);

    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);



    av_free(res);

    return 0;



  fail:

    av_free(res);

    s->server_data_port = -1;

    return AVERROR(ENOSYS);

}
",1,4,6,0,0,0,1,1,1,1,1,1,1,1,1
18596,qemu,0,"static void qemu_enqueue_packet(VLANClientState *sender,

                                const uint8_t *buf, int size,

                                NetPacketSent *sent_cb)

{

    VLANPacket *packet;



    packet = qemu_malloc(sizeof(VLANPacket) + size);

    packet->sender = sender;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);



    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);

}
",0,0,0,0,0,0,1,0,0,0,0,0,0,0,0
18597,qemu,0,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)

{

    /* TO FIX */

    return 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
18598,qemu,0,"uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,

                             uint8_t *addrs, uint8_t *buf)

{

    uint32_t sum = 0;



    sum += net_checksum_add(length, buf);         // payload

    sum += net_checksum_add(8, addrs);            // src + dst address

    sum += proto + length;                        // protocol & length

    return net_checksum_finish(sum);

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,1,1
18614,qemu,0,"void cpu_loop_exit(CPUState *env1)

{

    env1->current_tb = NULL;

    longjmp(env1->jmp_env, 1);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,0
18619,qemu,0,"void ppc_hw_interrupt (CPUPPCState *env)

{

    int raised = 0;



#if 1

    if (loglevel & CPU_LOG_INT) {

        fprintf(logfile, ""%s: %p pending %08x req %08x me %d ee %d\n"",

                __func__, env, env->pending_interrupts,

                env->interrupt_request, msr_me, msr_ee);

    }

#endif

    /* Raise it */

    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {

        /* External reset / critical input */

        /* XXX: critical input should be handled another way.

         *      This code is not correct !

         */

        env->exception_index = EXCP_RESET;

        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);

        raised = 1;

    }

    if (raised == 0 && msr_me != 0) {

        /* Machine check exception */

        if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {

            env->exception_index = EXCP_MACHINE_CHECK;

            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);

            raised = 1;

        }

    }

    if (rais",0,0,7,0,0,0,0,0,0,0,0,0,0,0,0
18620,qemu,0,"gen_intermediate_code_internal(CPUState *env, TranslationBlock *tb,

                               int search_pc)

{

    uint16_t *gen_opc_end;

    uint32_t pc_start;

    int j, lj;

    struct DisasContext ctx;

    struct DisasContext *dc = &ctx;

    uint32_t next_page_start, org_flags;

    target_ulong npc;

    int num_insns;

    int max_insns;



    qemu_log_try_set_file(stderr);



    pc_start = tb->pc;

    dc->env = env;

    dc->tb = tb;

    org_flags = dc->synced_flags = dc->tb_flags = tb->flags;



    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;



    dc->is_jmp = DISAS_NEXT;

    dc->jmp = 0;

    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);

    dc->pc = pc_start;

    dc->singlestep_enabled = env->singlestep_enabled;

    dc->cpustate_changed = 0;

    dc->abort_at_next_insn = 0;

    dc->nr_nops = 0;



    if (pc_start & 3)

        cpu_abort(env, ""Microblaze: unaligned PC=%x\n"", pc_start);



    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {

#if !SIM_COMPAT

        qemu_log(""----",0,0,3,0,0,0,0,0,0,1,0,0,1,1,0
18624,FFmpeg,1,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
",2,0,0,0,0,0,0,0,0,1,1,1,1,1,0
18629,qemu,1,"static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,

                               BdrvCheckMode fix, bool *rebuild,

                               uint16_t **refcount_table, int64_t *nb_clusters)

{

    BDRVQcowState *s = bs->opaque;

    int64_t i;

    QCowSnapshot *sn;

    int ret;



    if (!*refcount_table) {

        int64_t old_size = 0;

        ret = realloc_refcount_array(s, refcount_table,

                                     &old_size, *nb_clusters);

        if (ret < 0) {

            res->check_errors++;

            return ret;

        }

    }



    /* header */

    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,

                        0, s->cluster_size);

    if (ret < 0) {

        return ret;

    }



    /* current L1 table */

    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,

                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);

    if (ret < 0) {

        return ret;

    }



    /* snapshots */
",0,0,4,0,0,0,1,1,1,1,1,0,1,0,0
18640,qemu,1,"static void ne2000_ioport_write(void *opaque, uint32_t addr, uint32_t val)

{

    NE2000State *s = opaque;

    int offset, page;



    addr &= 0xf;

#ifdef DEBUG_NE2000

    printf(""NE2000: write addr=0x%x val=0x%02x\n"", addr, val);

#endif

    if (addr == E8390_CMD) {

        /* control register */

        s->cmd = val;

        if (val & E8390_START) {

            s->isr &= ~ENISR_RESET;

            /* test specific case: zero length transfert */

            if ((val & (E8390_RREAD | E8390_RWRITE)) &&

                s->rcnt == 0) {

                s->isr |= ENISR_RDC;

                ne2000_update_irq(s);

            }

            if (val & E8390_TRANS) {

                qemu_send_packet(s->nd, s->mem + (s->tpsr << 8), s->tcnt);

                /* signal end of transfert */

                s->tsr = ENTSR_PTX;

                s->isr |= ENISR_TX;

                ne2000_update_irq(s);

            }

        }

    } else {

        page = s->cmd >> 6;

        offset = addr | (page << 4);
",0,0,6,0,0,0,1,1,1,1,1,0,0,0,0
18646,FFmpeg,0,"static int vc1_filter_line(uint8_t* src, int stride, int pq){

    int a0, a1, a2, a3, d, clip, filt3 = 0;

    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;



    a0     = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) >> 3;

    if(FFABS(a0) < pq){

        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;

        a2 = (2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) >> 3;

        a3 = FFMIN(FFABS(a1), FFABS(a2));

        if(a3 < FFABS(a0)){

            d = 5 * ((a0 >=0 ? a3 : -a3) - a0) / 8;

            clip = (src[-1*stride] - src[ 0*stride])/2;

            if(clip){

                filt3 = 1;

                if(clip > 0)

                    d = av_clip(d, 0, clip);

                else

                    d = av_clip(d, clip, 0);

                src[-1*stride] = cm[src[-1*stride] - d];

                src[ 0*stride] = cm[src[ 0*stride] + d];

            }

        }

    }

    return filt3;",0,0,4,0,0,0,1,1,1,1,1,1,0,0,0
18648,FFmpeg,0,"static int rle_unpack(const unsigned char *src, unsigned char *dest,

                      int src_count, int src_size, int dest_len)

{

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;

    GetByteContext gb;



    bytestream2_init(&gb, src, src_size);

    pd = dest;

    if (src_count & 1) {

        if (bytestream2_get_bytes_left(&gb) < 1)

            return 0;

        *pd++ = bytestream2_get_byteu(&gb);

    }



    src_count >>= 1;

    i = 0;

    do {

        if (bytestream2_get_bytes_left(&gb) < 1)

            break;

        l = bytestream2_get_byteu(&gb);

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)

                return bytestream2_tell(&gb);

            bytestream2_get_bufferu(&gb, pd, l);

            pd += l;

        } else {

            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)

                return bytestream2_tell(&gb);

            f",0,0,6,0,0,0,1,1,1,1,1,1,1,0,1
18649,FFmpeg,0,"static int recheck_discard_flags(AVFormatContext *s, int first)

{

    HLSContext *c = s->priv_data;

    int i, changed = 0;



    /* Check if any new streams are needed */

    for (i = 0; i < c->n_playlists; i++)

        c->playlists[i]->cur_needed = 0;



    for (i = 0; i < s->nb_streams; i++) {

        AVStream *st = s->streams[i];

        struct playlist *pls = c->playlists[s->streams[i]->id];

        if (st->discard < AVDISCARD_ALL)

            pls->cur_needed = 1;

    }

    for (i = 0; i < c->n_playlists; i++) {

        struct playlist *pls = c->playlists[i];

        if (pls->cur_needed && !pls->needed) {

            pls->needed = 1;

            changed = 1;

            pls->cur_seq_no = select_cur_seq_no(c, pls);

            pls->pb.eof_reached = 0;

            if (c->cur_timestamp != AV_NOPTS_VALUE) {

                /* catch up */

                pls->seek_timestamp = c->cur_timestamp;

                pls->seek_flags = AVSEEK_FLAG_ANY;

                pls->seek_stream_index = -",3,0,3,0,0,0,0,1,0,1,1,1,1,1,0
18673,qemu,0,"static int tpm_passthrough_unix_transfer(int tpm_fd,

                                         const TPMLocality *locty_data)

{

    return tpm_passthrough_unix_tx_bufs(tpm_fd,

                                        locty_data->w_buffer.buffer,

                                        locty_data->w_offset,

                                        locty_data->r_buffer.buffer,

                                        locty_data->r_buffer.size);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
18675,qemu,0,"void do_tw (int flags)

{

    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||

                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||

                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||

                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||

                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {

        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);

    }

}
",0,0,1,0,0,0,0,1,0,0,1,0,0,0,0
18696,qemu,1,"void sh4_translate_init(void)

{

    int i;

    static const char * const gregnames[24] = {

        ""R0_BANK0"", ""R1_BANK0"", ""R2_BANK0"", ""R3_BANK0"",

        ""R4_BANK0"", ""R5_BANK0"", ""R6_BANK0"", ""R7_BANK0"",

        ""R8"", ""R9"", ""R10"", ""R11"", ""R12"", ""R13"", ""R14"", ""R15"",

        ""R0_BANK1"", ""R1_BANK1"", ""R2_BANK1"", ""R3_BANK1"",

        ""R4_BANK1"", ""R5_BANK1"", ""R6_BANK1"", ""R7_BANK1""

    };

    static const char * const fregnames[32] = {

         ""FPR0_BANK0"",  ""FPR1_BANK0"",  ""FPR2_BANK0"",  ""FPR3_BANK0"",

         ""FPR4_BANK0"",  ""FPR5_BANK0"",  ""FPR6_BANK0"",  ""FPR7_BANK0"",

         ""FPR8_BANK0"",  ""FPR9_BANK0"", ""FPR10_BANK0"", ""FPR11_BANK0"",

        ""FPR12_BANK0"", ""FPR13_BANK0"", ""FPR14_BANK0"", ""FPR15_BANK0"",

         ""FPR0_BANK1"",  ""FPR1_BANK1"",  ""FPR2_BANK1"",  ""FPR3_BANK1"",

         ""FPR4_BANK1"",  ""FPR5_BANK1"",  ""FPR6_BANK1"",  ""FPR7_BANK1"",

         ""FPR8_BANK1"",  ""FPR9_BANK1"", ""FPR10_BANK1"", ""FPR11_BANK1"",

        ""FPR12_BANK1"", ""FPR13_BANK1"", ""FPR14_BANK1"", ""FPR15_BANK1"",

    };



    for (i = 0; i < ",1,0,0,0,0,0,1,1,0,0,1,1,0,0,0
18700,FFmpeg,1,"AVStream *add_audio_stream(AVFormatContext *oc, int codec_id)

{

    AVCodec *codec;

    AVCodecContext *c;

    AVStream *st;



    st = av_new_stream(oc, 1);

    if (!st) {

        fprintf(stderr, ""Could not alloc stream\n"");

        exit(1);

    }



    /* find the MP2 encoder */

    codec = avcodec_find_encoder(codec_id);

    if (!codec) {

        fprintf(stderr, ""codec not found\n"");

        exit(1);

    }

    c = &st->codec;

    c->codec_type = CODEC_TYPE_AUDIO;



    /* put sample parameters */

    c->bit_rate = 64000;

    c->sample_rate = 44100;

    c->channels = 2;



    /* open it */

    if (avcodec_open(c, codec) < 0) {

        fprintf(stderr, ""could not open codec\n"");

        exit(1);

    }



    /* init signal generator */

    t = 0;

    tincr = 2 * M_PI * 440.0 / c->sample_rate;



    audio_outbuf_size = 10000;

    audio_outbuf = malloc(audio_outbuf_size);



    /* ugly hack for PCM codecs (will be removed ASAP with new PCM

       support to compute the input fram",1,0,3,0,0,0,0,0,0,0,0,0,0,0,0
18719,FFmpeg,1,"static av_cold int libopenjpeg_encode_init(AVCodecContext *avctx)

{

    LibOpenJPEGContext *ctx = avctx->priv_data;

    int err = AVERROR(ENOMEM);



    opj_set_default_encoder_parameters(&ctx->enc_params);



    ctx->enc_params.cp_rsiz = ctx->profile;

    ctx->enc_params.mode = !!avctx->global_quality;

    ctx->enc_params.cp_cinema = ctx->cinema_mode;

    ctx->enc_params.prog_order = ctx->prog_order;

    ctx->enc_params.numresolution = ctx->numresolution;

    ctx->enc_params.cp_disto_alloc = ctx->disto_alloc;

    ctx->enc_params.cp_fixed_alloc = ctx->fixed_alloc;

    ctx->enc_params.cp_fixed_quality = ctx->fixed_quality;

    ctx->enc_params.tcp_numlayers = ctx->numlayers;

    ctx->enc_params.tcp_rates[0] = FFMAX(avctx->compression_level, 0) * 2;



    if (ctx->cinema_mode > 0) {

        cinema_parameters(&ctx->enc_params);

    }



    ctx->compress = opj_create_compress(ctx->format);

    if (!ctx->compress) {

        av_log(avctx, AV_LOG_ERROR, ""Error creating the compressor\n"");

       ",1,0,2,0,0,0,1,1,1,1,1,1,0,0,0
18724,qemu,0,"static inline unsigned int msi_nr_vectors(uint16_t flags)

{

    return 1U <<

        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));

}
",0,0,0,0,0,0,0,0,0,1,1,1,0,0,0
18727,qemu,0,"static void openrisc_sim_init(MachineState *machine)

{

    ram_addr_t ram_size = machine->ram_size;

    const char *cpu_model = machine->cpu_model;

    const char *kernel_filename = machine->kernel_filename;

    OpenRISCCPU *cpu = NULL;

    MemoryRegion *ram;

    int n;



    if (!cpu_model) {

        cpu_model = ""or1200"";

    }



    for (n = 0; n < smp_cpus; n++) {

        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));

        qemu_register_reset(main_cpu_reset, cpu);

        main_cpu_reset(cpu);

    }



    ram = g_malloc(sizeof(*ram));

    memory_region_init_ram(ram, NULL, ""openrisc.ram"", ram_size, &error_fatal);

    memory_region_add_subregion(get_system_memory(), 0, ram);



    cpu_openrisc_pic_init(cpu);

    cpu_openrisc_clock_init(cpu);



    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],

                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);



    if (nd_table[0].used) {

        openrisc_sim_net_init(get_system_memory(), 0x92",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
18741,qemu,0,"static void ohci_reset(void *opaque)

{

    OHCIState *ohci = opaque;

    OHCIPort *port;

    int i;



    ohci_bus_stop(ohci);

    ohci->ctl = 0;

    ohci->old_ctl = 0;

    ohci->status = 0;

    ohci->intr_status = 0;

    ohci->intr = OHCI_INTR_MIE;



    ohci->hcca = 0;

    ohci->ctrl_head = ohci->ctrl_cur = 0;

    ohci->bulk_head = ohci->bulk_cur = 0;

    ohci->per_cur = 0;

    ohci->done = 0;

    ohci->done_count = 7;



    /* FSMPS is marked TBD in OCHI 1.0, what gives ffs?

     * I took the value linux sets ...

     */

    ohci->fsmps = 0x2778;

    ohci->fi = 0x2edf;

    ohci->fit = 0;

    ohci->frt = 0;

    ohci->frame_number = 0;

    ohci->pstart = 0;

    ohci->lst = OHCI_LS_THRESH;



    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;

    ohci->rhdesc_b = 0x0; /* Impl. specific */

    ohci->rhstatus = 0;



    for (i = 0; i < ohci->num_ports; i++)

      {

        port = &ohci->rhport[i];

        port->ctrl = 0;

        if (port->port.dev) {

            usb_attach(&p",1,0,1,0,0,0,0,0,0,0,0,0,1,0,0
18744,qemu,0,"uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)

{

    CPU_DoubleU farg1, farg2;



    farg1.ll = arg1;

    farg2.ll = arg2;



    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&

                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {

        /* Magnitude subtraction of infinities */

        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);

    } else {

        if (unlikely(float64_is_signaling_nan(farg1.d) ||

                     float64_is_signaling_nan(farg2.d))) {

            /* sNaN subtraction */

            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);

        }

        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);

    }



    return farg1.ll;

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,1
18759,qemu,1,"static int net_socket_connect_init(NetClientState *peer,

                                   const char *model,

                                   const char *name,

                                   const char *host_str)

{

    NetSocketState *s;

    int fd, connected, ret;

    struct sockaddr_in saddr;



    if (parse_host_port(&saddr, host_str) < 0)

        return -1;



    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

    qemu_set_nonblock(fd);



    connected = 0;

    for(;;) {

        ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));

        if (ret < 0) {

            if (errno == EINTR || errno == EWOULDBLOCK) {

                /* continue */

            } else if (errno == EINPROGRESS ||

                       errno == EALREADY ||

                       errno == EINVAL) {

                break;

            } else {

                perror(""connect"");

                closesocket(fd);

                r",1,0,5,0,0,0,0,0,0,0,0,0,1,1,1
18773,qemu,1,"static int64_t load_kernel (void)

{

    int64_t kernel_entry, kernel_high;

    long initrd_size;

    ram_addr_t initrd_offset;

    int big_endian;

    uint32_t *prom_buf;

    long prom_size;

    int prom_index = 0;

    uint64_t (*xlate_to_kseg0) (void *opaque, uint64_t addr);



#ifdef TARGET_WORDS_BIGENDIAN

    big_endian = 1;

#else

    big_endian = 0;

#endif



    if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,

                 (uint64_t *)&kernel_entry, NULL, (uint64_t *)&kernel_high,

                 big_endian, ELF_MACHINE, 1) < 0) {

        fprintf(stderr, ""qemu: could not load kernel '%s'\n"",

                loaderparams.kernel_filename);

        exit(1);

    }



    /* Sanity check where the kernel has been linked */

    if (kvm_enabled()) {

        if (kernel_entry & 0x80000000ll) {

            error_report(""KVM guest kernels must be linked in useg. ""

                         ""Did you forget to enable CONFIG_KVM_GUEST?"");

            exit(1);

      ",1,0,5,0,0,0,1,1,1,1,1,1,1,1,1
18781,qemu,0,"static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *errp = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);

}
",0,0,0,0,0,0,0,1,1,1,1,0,0,0,0
18799,qemu,0,"static int vhost_virtqueue_init(struct vhost_dev *dev,

                                struct vhost_virtqueue *vq, int n)

{

    struct vhost_vring_file file = {

        .index = n,

    };

    int r = event_notifier_init(&vq->masked_notifier, 0);

    if (r < 0) {

        return r;

    }



    file.fd = event_notifier_get_fd(&vq->masked_notifier);

    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);

    if (r) {

        r = -errno;

        goto fail_call;

    }

    return 0;

fail_call:

    event_notifier_cleanup(&vq->masked_notifier);

    return r;

}
",0,1,8,0,0,0,0,0,0,0,0,0,0,0,0
18812,FFmpeg,1,"static int filter_frame(AVFilterLink *inlink, AVFrame *src_buffer)

{

    AVFilterContext  *ctx = inlink->dst;

    ATempoContext *atempo = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];



    int ret = 0;

    int n_in = src_buffer->nb_samples;

    int n_out = (int)(0.5 + ((double)n_in) / atempo->tempo);



    const uint8_t *src = src_buffer->data[0];

    const uint8_t *src_end = src + n_in * atempo->stride;



    while (src < src_end) {

        if (!atempo->dst_buffer) {

            atempo->dst_buffer = ff_get_audio_buffer(outlink, n_out);

            if (!atempo->dst_buffer)

                return AVERROR(ENOMEM);

            av_frame_copy_props(atempo->dst_buffer, src_buffer);



            atempo->dst = atempo->dst_buffer->data[0];

            atempo->dst_end = atempo->dst + n_out * atempo->stride;

        }



        yae_apply(atempo, &src, src_end, &atempo->dst, atempo->dst_end);



        if (atempo->dst == atempo->dst_end) {

            int n_samples = ((atempo->dst - atemp",0,0,3,0,0,1,0,1,1,0,0,0,1,1,1
18819,qemu,1,"struct vhost_net *vhost_net_init(VhostNetOptions *options)

{

    int r;

    bool backend_kernel = options->backend_type == VHOST_BACKEND_TYPE_KERNEL;

    struct vhost_net *net = g_malloc(sizeof *net);



    if (!options->net_backend) {

        fprintf(stderr, ""vhost-net requires net backend to be setup\n"");

        goto fail;

    }



    if (backend_kernel) {

        r = vhost_net_get_fd(options->net_backend);

        if (r < 0) {

            goto fail;

        }

        net->dev.backend_features = qemu_has_vnet_hdr(options->net_backend)

            ? 0 : (1ULL << VHOST_NET_F_VIRTIO_NET_HDR);

        net->backend = r;

    } else {

        net->dev.backend_features = 0;

        net->backend = -1;

    }

    net->nc = options->net_backend;



    net->dev.nvqs = 2;

    net->dev.vqs = net->vqs;

    net->dev.vq_index = net->nc->queue_index;



    r = vhost_dev_init(&net->dev, options->opaque,

                       options->backend_type, options->force);

    if (r < 0) {

        goto fai",1,3,4,0,0,0,0,0,0,0,1,1,1,1,1
18820,qemu,1,"static USBDevice *usb_msd_init(const char *filename)

{

    static int nr=0;

    char id[8];

    QemuOpts *opts;

    DriveInfo *dinfo;

    USBDevice *dev;

    int fatal_error;

    const char *p1;

    char fmt[32];



    /* parse -usbdevice disk: syntax into drive opts */

    snprintf(id, sizeof(id), ""usb%d"", nr++);

    opts = qemu_opts_create(&qemu_drive_opts, id, 0);



    p1 = strchr(filename, ':');

    if (p1++) {

        const char *p2;



        if (strstart(filename, ""format="", &p2)) {

            int len = MIN(p1 - p2, sizeof(fmt));

            pstrcpy(fmt, len, p2);

            qemu_opt_set(opts, ""format"", fmt);

        } else if (*filename != ':') {

            printf(""unrecognized USB mass-storage option %s\n"", filename);



        filename = p1;


    if (!*filename) {

        printf(""block device specification needed\n"");



    qemu_opt_set(opts, ""file"", filename);

    qemu_opt_set(opts, ""if"", ""none"");



    /* create host drive */

    dinfo = drive_init(opts, NULL, &fata",2,0,6,0,0,0,0,1,1,0,0,0,1,0,1
18830,FFmpeg,1,"static inline void rv34_mc(RV34DecContext *r, const int block_type,

                          const int xoff, const int yoff, int mv_off,

                          const int width, const int height, int dir,

                          const int thirdpel, int weighted,

                          qpel_mc_func (*qpel_mc)[16],

                          h264_chroma_mc_func (*chroma_mc))

{

    MpegEncContext *s = &r->s;

    uint8_t *Y, *U, *V, *srcY, *srcU, *srcV;

    int dxy, mx, my, umx, umy, lx, ly, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride + mv_off;

    int is16x16 = 1;



    if(thirdpel){

        int chroma_mx, chroma_my;

        mx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) / 3 - (1 << 24);

        my = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) / 3 - (1 << 24);

        lx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) % 3;

        ly = (s->current_picture_ptr->f.m",0,0,1,0,0,0,1,1,0,0,0,0,0,0,1
18833,qemu,1,"void migrate_fd_connect(MigrationState *s)

{

    s->state = MIG_STATE_SETUP;

    trace_migrate_set_state(MIG_STATE_SETUP);



    /* This is a best 1st approximation. ns to ms */

    s->expected_downtime = max_downtime/1000000;

    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);



    qemu_file_set_rate_limit(s->file,

                             s->bandwidth_limit / XFER_LIMIT_RATIO);



    qemu_thread_create(&s->thread, migration_thread, s,

                       QEMU_THREAD_JOINABLE);

    notifier_list_notify(&migration_state_notifiers, s);

}
",0,0,3,0,0,0,1,1,0,0,0,1,1,1,1
18838,qemu,1,"static void ppc405cr_clk_setup (ppc405cr_cpc_t *cpc)

{

    uint64_t VCO_out, PLL_out;

    uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;

    int M, D0, D1, D2;



    D0 = ((cpc->pllmr >> 26) & 0x3) + 1; /* CBDV */

    if (cpc->pllmr & 0x80000000) {

        D1 = (((cpc->pllmr >> 20) - 1) & 0xF) + 1; /* FBDV */

        D2 = 8 - ((cpc->pllmr >> 16) & 0x7); /* FWDVA */

        M = D0 * D1 * D2;

        VCO_out = cpc->sysclk * M;

        if (VCO_out < 400000000 || VCO_out > 800000000) {

            /* PLL cannot lock */

            cpc->pllmr &= ~0x80000000;

            goto bypass_pll;

        }

        PLL_out = VCO_out / D2;

    } else {

        /* Bypass PLL */

    bypass_pll:

        M = D0;

        PLL_out = cpc->sysclk * M;

    }

    CPU_clk = PLL_out;

    if (cpc->cr1 & 0x00800000)

        TMR_clk = cpc->sysclk; /* Should have a separate clock */

    else

        TMR_clk = CPU_clk;

    PLB_clk = CPU_clk / D0;

    SDRAM_clk = PLB_clk;

    D0 = ((cpc-",0,1,3,0,0,0,1,1,1,0,0,0,0,0,1
18853,qemu,0,"static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,

                                unsigned size)

{

    CMD646BAR *cmd646bar = opaque;



    if (addr != 2 || size != 1) {

        return ((uint64_t)1 << (size * 8)) - 1;

    }

    return ide_status_read(cmd646bar->bus, addr + 2);

}
",0,0,1,0,0,0,1,1,0,0,1,0,0,0,0
18892,qemu,0,"static uint64_t hpet_ram_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    HPETState *s = opaque;

    uint64_t cur_tick, index;



    DPRINTF(""qemu: Enter hpet_ram_readl at %"" PRIx64 ""\n"", addr);

    index = addr;

    /*address range of all TN regs*/

    if (index >= 0x100 && index <= 0x3ff) {

        uint8_t timer_id = (addr - 0x100) / 0x20;

        HPETTimer *timer = &s->timer[timer_id];



        if (timer_id > s->num_timers) {

            DPRINTF(""qemu: timer id out of range\n"");

            return 0;

        }



        switch ((addr - 0x100) % 0x20) {

        case HPET_TN_CFG:

            return timer->config;

        case HPET_TN_CFG + 4: // Interrupt capabilities

            return timer->config >> 32;

        case HPET_TN_CMP: // comparator register

            return timer->cmp;

        case HPET_TN_CMP + 4:

            return timer->cmp >> 32;

        case HPET_TN_ROUTE:

            return timer->fsb;

        case HPET_TN_ROUTE ",0,0,2,0,1,0,0,0,0,0,0,0,0,0,0
18893,qemu,0,"static void virtio_init_pci(VirtIOPCIProxy *proxy, VirtIODevice *vdev,

                            uint16_t vendor, uint16_t device,

                            uint16_t class_code, uint8_t pif)

{

    uint8_t *config;

    uint32_t size;



    proxy->vdev = vdev;



    config = proxy->pci_dev.config;

    pci_config_set_vendor_id(config, vendor);

    pci_config_set_device_id(config, device);



    config[0x08] = VIRTIO_PCI_ABI_VERSION;



    config[0x09] = pif;

    pci_config_set_class(config, class_code);



    config[0x2c] = vendor & 0xFF;

    config[0x2d] = (vendor >> 8) & 0xFF;

    config[0x2e] = vdev->device_id & 0xFF;

    config[0x2f] = (vdev->device_id >> 8) & 0xFF;



    config[0x3d] = 1;



    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {

        pci_register_bar(&proxy->pci_dev, 1,

                         msix_bar_size(&proxy->pci_dev),

                         PCI_BASE_ADDRESS_SPACE_MEMORY,

                         msix_mmio_map);

    } else

     ",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
18915,qemu,0,"static int usb_device_add(const char *devname, int is_hotplug)

{

    const char *p;

    USBDevice *dev;



    if (!free_usb_ports)

        return -1;



    if (strstart(devname, ""host:"", &p)) {

        dev = usb_host_device_open(p);

    } else if (!strcmp(devname, ""mouse"")) {

        dev = usb_mouse_init();

    } else if (!strcmp(devname, ""tablet"")) {

        dev = usb_tablet_init();

    } else if (!strcmp(devname, ""keyboard"")) {

        dev = usb_keyboard_init();

    } else if (strstart(devname, ""disk:"", &p)) {

        BlockDriverState *bs;



        dev = usb_msd_init(p, &bs);

        if (!dev)

            return -1;

        if (bdrv_key_required(bs)) {

            autostart = 0;

            if (is_hotplug && monitor_read_bdrv_key(bs) < 0) {

                dev->handle_destroy(dev);

                return -1;

            }

        }

    } else if (!strcmp(devname, ""wacom-tablet"")) {

        dev = usb_wacom_init();

    } else if (strstart(devname, ""serial:"", &p)) {

        dev = ",0,0,11,0,0,0,0,0,0,0,0,0,0,0,0
18931,qemu,0,"void ioinst_handle_msch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)

{

    int cssid, ssid, schid, m;

    SubchDev *sch;

    SCHIB schib;

    uint64_t addr;

    int ret = -ENODEV;

    int cc;

    CPUS390XState *env = &cpu->env;

    uint8_t ar;



    addr = decode_basedisp_s(env, ipb, &ar);

    if (addr & 3) {

        program_interrupt(env, PGM_SPECIFICATION, 2);

        return;

    }

    if (s390_cpu_virt_mem_read(cpu, addr, ar, &schib, sizeof(schib))) {

        return;

    }

    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||

        !ioinst_schib_valid(&schib)) {

        program_interrupt(env, PGM_OPERAND, 2);

        return;

    }

    trace_ioinst_sch_id(""msch"", cssid, ssid, schid);

    sch = css_find_subch(m, cssid, ssid, schid);

    if (sch && css_subch_visible(sch)) {

        ret = css_do_msch(sch, &schib);

    }

    switch (ret) {

    case -ENODEV:

        cc = 3;

        break;

    case -EBUSY:

        cc = 2;

        break;

    case 0:

        cc",0,0,4,0,1,0,0,0,0,0,0,0,0,0,0
18942,qemu,1,"int load_uimage(const char *filename, target_ulong *ep, target_ulong *loadaddr,

                int *is_linux)

{

    int fd;

    int size;

    uboot_image_header_t h;

    uboot_image_header_t *hdr = &h;

    uint8_t *data = NULL;

    int ret = -1;



    fd = open(filename, O_RDONLY | O_BINARY);

    if (fd < 0)

        return -1;



    size = read(fd, hdr, sizeof(uboot_image_header_t));

    if (size < 0)

        goto out;



    bswap_uboot_header(hdr);



    if (hdr->ih_magic != IH_MAGIC)

        goto out;



    /* TODO: Implement Multi-File images.  */

    if (hdr->ih_type == IH_TYPE_MULTI) {

        fprintf(stderr, ""Unable to load multi-file u-boot images\n"");

        goto out;

    }



    switch (hdr->ih_comp) {

    case IH_COMP_NONE:

    case IH_COMP_GZIP:

        break;

    default:

        fprintf(stderr,

                ""Unable to load u-boot images with compression type %d\n"",

                hdr->ih_comp);

        goto out;

    }



    /* TODO: Check CPU type.  */

    ",0,4,4,0,1,0,0,0,0,0,0,0,1,1,1
18963,FFmpeg,1,"static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    MPCContext *c = s->priv_data;

    int ret, size, size2, curbits, cur = c->curframe;

    int64_t tmp, pos;



    if (c->curframe >= c->fcount)

        return -1;



    if(c->curframe != c->lastframe + 1){

        url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);

        c->curbits = c->frames[c->curframe].skip;

    }

    c->lastframe = c->curframe;

    c->curframe++;

    curbits = c->curbits;

    pos = url_ftell(s->pb);

    tmp = get_le32(s->pb);

    if(curbits <= 12){

        size2 = (tmp >> (12 - curbits)) & 0xFFFFF;

    }else{

        tmp = (tmp << 32) | get_le32(s->pb);

        size2 = (tmp >> (44 - curbits)) & 0xFFFFF;

    }

    curbits += 20;

    url_fseek(s->pb, pos, SEEK_SET);



    size = ((size2 + curbits + 31) & ~31) >> 3;

    if(cur == c->frames_noted){

        c->frames[cur].pos = pos;

        c->frames[cur].size = size;

        c->frames[cur].skip = curbits - 20;

        av_add_index_entry(s->st",0,0,4,0,0,0,1,1,1,1,1,0,0,0,1
18969,qemu,1,"static void hpet_ram_writel(void *opaque, target_phys_addr_t addr,

                            uint32_t value)

{

    int i;

    HPETState *s = (HPETState *)opaque;

    uint64_t old_val, new_val, val, index;



    DPRINTF(""qemu: Enter hpet_ram_writel at %"" PRIx64 "" = %#x\n"", addr, value);

    index = addr;

    old_val = hpet_ram_readl(opaque, addr);

    new_val = value;



    /*address range of all TN regs*/

    if (index >= 0x100 && index <= 0x3ff) {

        uint8_t timer_id = (addr - 0x100) / 0x20;

        DPRINTF(""qemu: hpet_ram_writel timer_id = %#x \n"", timer_id);

        HPETTimer *timer = &s->timer[timer_id];



        if (timer_id > HPET_NUM_TIMERS - 1) {

            DPRINTF(""qemu: timer id out of range\n"");

            return;

        }

        switch ((addr - 0x100) % 0x20) {

            case HPET_TN_CFG:

                DPRINTF(""qemu: hpet_ram_writel HPET_TN_CFG\n"");

                val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);

                timer->config =",0,0,2,0,1,0,0,0,0,1,1,1,0,0,0
18988,qemu,0,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int flags)

{

    int i;



    cpu_fprintf(f, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
19003,qemu,0,"int net_init_socket(const NetClientOptions *opts, const char *name,

                    NetClientState *peer, Error **errp)

{

    /* FIXME error_setg(errp, ...) on failure */

    Error *err = NULL;

    const NetdevSocketOptions *sock;



    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_SOCKET);

    sock = opts->socket;



    if (sock->has_fd + sock->has_listen + sock->has_connect + sock->has_mcast +

        sock->has_udp != 1) {

        error_report(""exactly one of fd=, listen=, connect=, mcast= or udp=""

                     "" is required"");

        return -1;

    }



    if (sock->has_localaddr && !sock->has_mcast && !sock->has_udp) {

        error_report(""localaddr= is only valid with mcast= or udp="");

        return -1;

    }



    if (sock->has_fd) {

        int fd;



        fd = monitor_fd_param(cur_mon, sock->fd, &err);

        if (fd == -1) {

            error_report_err(err);

            return -1;

        }

        qemu_set_nonblock(fd);

        if (!net_socket_fd_init(peer,",0,0,5,0,0,0,0,0,0,0,0,0,0,1,1
19005,qemu,1,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
19011,FFmpeg,0,"static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)

{

    int d;

    for( d = 0; d < 8; d++ ) {

        const int p0 = pix[-1*xstride];

        const int p1 = pix[-2*xstride];

        const int q0 = pix[0];

        const int q1 = pix[1*xstride];



        if( FFABS( p0 - q0 ) < alpha &&

            FFABS( p1 - p0 ) < beta &&

            FFABS( q1 - q0 ) < beta ) {



            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */

            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */

        }

        pix += ystride;

    }

}
",1,0,1,0,0,0,1,1,0,0,0,0,1,0,1
19023,qemu,1,"static int protocol_version(VncState *vs, uint8_t *version, size_t len)

{

    char local[13];



    memcpy(local, version, 12);

    local[12] = 0;



    if (sscanf(local, ""RFB %03d.%03d\n"", &vs->major, &vs->minor) != 2) {

        VNC_DEBUG(""Malformed protocol version %s\n"", local);

        vnc_client_error(vs);

        return 0;

    }

    VNC_DEBUG(""Client request protocol version %d.%d\n"", vs->major, vs->minor);

    if (vs->major != 3 ||

        (vs->minor != 3 &&

         vs->minor != 4 &&

         vs->minor != 5 &&

         vs->minor != 7 &&

         vs->minor != 8)) {

        VNC_DEBUG(""Unsupported client version\n"");

        vnc_write_u32(vs, VNC_AUTH_INVALID);

        vnc_flush(vs);

        vnc_client_error(vs);

        return 0;

    }

    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated

     * as equivalent to v3.3 by servers

     */

    if (vs->minor == 4 || vs->minor == 5)

        vs->minor = 3;



    if (vs->minor == 3) {

        if (vs->auth",1,0,5,0,0,0,0,1,1,0,1,0,1,0,0
19027,qemu,1,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)

{

    struct pxa2xx_pic_state_s *s;

    int iomemtype;

    qemu_irq *qi;



    s = (struct pxa2xx_pic_state_s *)

            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));

    if (!s)

        return NULL;



    s->cpu_env = env;

    s->base = base;



    s->int_pending[0] = 0;

    s->int_pending[1] = 0;

    s->int_enabled[0] = 0;

    s->int_enabled[1] = 0;

    s->is_fiq[0] = 0;

    s->is_fiq[1] = 0;



    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);



    /* Enable IC memory-mapped registers access.  */

    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,

                    pxa2xx_pic_writefn, s);

    cpu_register_physical_memory(base, 0x000fffff, iomemtype);



    /* Enable IC coprocessor access.  */

    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);



    register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);



    return qi;

}
",0,0,1,0,0,0,1,1,1,1,1,1,0,0,0
19041,FFmpeg,1,"static int mp_decode_frame(MPADecodeContext *s, OUT_INT **samples,

                           const uint8_t *buf, int buf_size)

{

    int i, nb_frames, ch, ret;

    OUT_INT *samples_ptr;



    init_get_bits(&s->gb, buf + HEADER_SIZE, (buf_size - HEADER_SIZE) * 8);



    /* skip error protection field */

    if (s->error_protection)

        skip_bits(&s->gb, 16);



    switch(s->layer) {

    case 1:

        s->avctx->frame_size = 384;

        nb_frames = mp_decode_layer1(s);

        break;

    case 2:

        s->avctx->frame_size = 1152;

        nb_frames = mp_decode_layer2(s);

        break;

    case 3:

        s->avctx->frame_size = s->lsf ? 576 : 1152;

    default:

        nb_frames = mp_decode_layer3(s);



        if (nb_frames < 0)

            return nb_frames;



        s->last_buf_size=0;

        if (s->in_gb.buffer) {

            align_get_bits(&s->gb);

            i = get_bits_left(&s->gb)>>3;

            if (i >= 0 && i <= BACKSTEP_SIZE) {

                memmove(s->last_",0,0,4,0,1,0,0,0,0,0,0,1,0,1,1
19075,qemu,1,"static InetSocketAddress *ssh_config(QDict *options, Error **errp)

{

    InetSocketAddress *inet = NULL;

    QDict *addr = NULL;

    QObject *crumpled_addr = NULL;

    Visitor *iv = NULL;

    Error *local_error = NULL;



    qdict_extract_subqdict(options, &addr, ""server."");

    if (!qdict_size(addr)) {

        error_setg(errp, ""SSH server address missing"");

        goto out;

    }



    crumpled_addr = qdict_crumple(addr, errp);

    if (!crumpled_addr) {

        goto out;

    }











    iv = qobject_input_visitor_new(crumpled_addr);

    visit_type_InetSocketAddress(iv, NULL, &inet, &local_error);

    if (local_error) {

        error_propagate(errp, local_error);

        goto out;

    }



out:

    QDECREF(addr);

    qobject_decref(crumpled_addr);

    visit_free(iv);

    return inet;

}",0,3,3,0,0,0,0,1,1,1,1,1,0,1,1
19082,qemu,1,"sdhci_buff_access_is_sequential(SDHCIState *s, unsigned byte_num)

{

    if ((s->data_count & 0x3) != byte_num) {

        ERRPRINT(""Non-sequential access to Buffer Data Port register""

                ""is prohibited\n"");

        return false;

    }

    return true;

}
",0,0,1,0,0,0,0,1,0,0,0,0,0,0,0
19090,qemu,0,"static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)

{

    ssize_t ret;

    guint watch;



    assert(qemu_in_coroutine());

    /* Negotiation are always in main loop. */

    watch = qio_channel_add_watch(ioc,

                                  G_IO_OUT,

                                  nbd_negotiate_continue,

                                  qemu_coroutine_self(),

                                  NULL);

    ret = write_sync(ioc, buffer, size, NULL);

    g_source_remove(watch);

    return ret;

}
",0,0,0,0,0,0,1,0,1,1,1,0,0,0,0
19102,qemu,0,"static void aio_read_done(void *opaque, int ret)

{

    struct aio_ctx *ctx = opaque;

    struct timeval t2;



    gettimeofday(&t2, NULL);



    if (ret < 0) {

        printf(""readv failed: %s\n"", strerror(-ret));

        goto out;

    }



    if (ctx->Pflag) {

        void *cmp_buf = malloc(ctx->qiov.size);



        memset(cmp_buf, ctx->pattern, ctx->qiov.size);

        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {

            printf(""Pattern verification failed at offset %""

                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);

        }

        free(cmp_buf);

    }



    if (ctx->qflag) {

        goto out;

    }



    if (ctx->vflag) {

        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);

    }



    /* Finally, report back -- -C gives a parsable format */

    t2 = tsub(t2, ctx->t1);

    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,

                 ctx->qiov.size, 1, ctx->Cflag);

out:

    qemu_io_free(ctx->buf);

    free(ctx);

}
",0,2,6,0,0,0,0,0,0,0,0,0,1,1,1
19108,qemu,0,"static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
",0,0,2,0,0,0,1,1,0,1,1,1,0,0,1
19115,qemu,0,"static void nvdimm_build_common_dsm(Aml *dev)

{

    Aml *method, *ifctx, *function, *dsm_mem, *unpatched, *result_size;

    uint8_t byte_list[1];



    method = aml_method(NVDIMM_COMMON_DSM, 4, AML_SERIALIZED);

    function = aml_arg(2);

    dsm_mem = aml_name(NVDIMM_ACPI_MEM_ADDR);



    /*

     * do not support any method if DSM memory address has not been

     * patched.

     */

    unpatched = aml_if(aml_equal(dsm_mem, aml_int(0x0)));



    /*

     * function 0 is called to inquire what functions are supported by

     * OSPM

     */

    ifctx = aml_if(aml_equal(function, aml_int(0)));

    byte_list[0] = 0 /* No function Supported */;

    aml_append(ifctx, aml_return(aml_buffer(1, byte_list)));

    aml_append(unpatched, ifctx);



    /* No function is supported yet. */

    byte_list[0] = 1 /* Not Supported */;

    aml_append(unpatched, aml_return(aml_buffer(1, byte_list)));

    aml_append(method, unpatched);



    /*

     * The HDLE indicates the DSM function is issued from which d",0,0,7,0,0,0,0,0,0,0,0,0,1,1,1
19116,qemu,0,"static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)

{

    gnutls_anon_server_credentials anon_cred;

    int ret;



    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {

	VNC_DEBUG(""Cannot allocate credentials %s\n"", gnutls_strerror(ret));

	return NULL;

    }



    gnutls_anon_set_server_dh_params(anon_cred, dh_params);



    return anon_cred;

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
19119,qemu,0,"static int zero_single_l2(BlockDriverState *bs, uint64_t offset,

    unsigned int nb_clusters)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t *l2_table;

    int l2_index;

    int ret;

    int i;



    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);

    if (ret < 0) {

        return ret;

    }



    /* Limit nb_clusters to one L2 table */

    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);



    for (i = 0; i < nb_clusters; i++) {

        uint64_t old_offset;



        old_offset = be64_to_cpu(l2_table[l2_index + i]);



        /* Update L2 entries */

        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);

        if (old_offset & QCOW_OFLAG_COMPRESSED) {

            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);

            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);

        } else {

            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);

        }

    }



    ret = qcow2_cache_put(bs, s->l2_table_cache, (",1,0,2,0,0,0,1,1,1,1,1,1,1,1,1
19126,qemu,0,"static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)

{

    S390pciState *s = opaque;



    return &s->pbdev[PCI_SLOT(devfn)].as;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
19128,qemu,0,"static void test_info_commands(void)

{

    char *resp, *info, *info_buf, *endp;



    info_buf = info = hmp(""help info"");



    while (*info) {

        /* Extract the info command, ignore parameters and description */

        g_assert(strncmp(info, ""info "", 5) == 0);

        endp = strchr(&info[5], ' ');

        g_assert(endp != NULL);

        *endp = '\0';

        /* Now run the info command */

        if (verbose) {

            fprintf(stderr, ""\t%s\n"", info);

        }

        resp = hmp(info);

        g_free(resp);

        /* And move forward to the next line */

        info = strchr(endp + 1, '\n');

        if (!info) {

            break;

        }

        info += 1;

    }



    g_free(info_buf);

}
",0,0,2,0,0,1,0,0,1,0,0,1,1,1,1
19129,qemu,0,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)

{

    uint8_t *old_code_ptr = s->code_ptr;

    assert(ret != arg);

#if TCG_TARGET_REG_BITS == 32

    tcg_out_op_t(s, INDEX_op_mov_i32);

#else

    tcg_out_op_t(s, INDEX_op_mov_i64);

#endif

    tcg_out_r(s, ret);

    tcg_out_r(s, arg);

    old_code_ptr[1] = s->code_ptr - old_code_ptr;

}
",0,0,2,0,0,0,0,0,0,1,1,0,0,0,0
19133,qemu,0,"static int do_token_in(USBDevice *s, USBPacket *p)

{

    int request, value, index;

    int ret = 0;



    assert(p->devep == 0);



    request = (s->setup_buf[0] << 8) | s->setup_buf[1];

    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];

    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];

 

    switch(s->setup_state) {

    case SETUP_STATE_ACK:

        if (!(s->setup_buf[0] & USB_DIR_IN)) {

            ret = usb_device_handle_control(s, p, request, value, index,

                                            s->setup_len, s->data_buf);

            if (ret == USB_RET_ASYNC) {

                return USB_RET_ASYNC;

            }

            s->setup_state = SETUP_STATE_IDLE;

            if (ret > 0)

                return 0;

            return ret;

        }



        /* return 0 byte */

        return 0;



    case SETUP_STATE_DATA:

        if (s->setup_buf[0] & USB_DIR_IN) {

            int len = s->setup_len - s->setup_index;

            if (len > p->iov.size) {

            ",0,0,5,0,1,0,0,0,0,0,0,0,1,1,1
19160,qemu,0,"static int coroutine_fn backup_do_cow(BackupBlockJob *job,

                                      int64_t offset, uint64_t bytes,

                                      bool *error_is_read,

                                      bool is_write_notifier)

{

    BlockBackend *blk = job->common.blk;

    CowRequest cow_request;

    struct iovec iov;

    QEMUIOVector bounce_qiov;

    void *bounce_buffer = NULL;

    int ret = 0;

    int64_t start, end; /* bytes */

    int n; /* bytes */



    qemu_co_rwlock_rdlock(&job->flush_rwlock);



    start = QEMU_ALIGN_DOWN(offset, job->cluster_size);

    end = QEMU_ALIGN_UP(bytes + offset, job->cluster_size);



    trace_backup_do_cow_enter(job, start, offset, bytes);



    wait_for_overlapping_requests(job, start, end);

    cow_request_begin(&cow_request, job, start, end);



    for (; start < end; start += job->cluster_size) {

        if (test_bit(start / job->cluster_size, job->done_bitmap)) {

            trace_backup_do_cow_skip(job, start);

           ",2,0,2,0,0,0,0,1,0,1,1,1,1,1,1
19184,qemu,0,"static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)

{

    BDRVBlkdebugState *s = bs->opaque;

    int error = rule->options.inject.error;

    bool immediately = rule->options.inject.immediately;



    if (rule->options.inject.once) {

        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);

        remove_rule(rule);

    }



    if (!immediately) {

        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());

        qemu_coroutine_yield();

    }



    return -error;

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
19198,qemu,0,"static void pflash_write(pflash_t *pfl, hwaddr offset,

                         uint32_t value, int width, int be)

{

    uint8_t *p;

    uint8_t cmd;



    cmd = value;



    DPRINTF(""%s: writing offset "" TARGET_FMT_plx "" value %08x width %d wcycle 0x%x\n"",

            __func__, offset, value, width, pfl->wcycle);



    if (!pfl->wcycle) {

        /* Set the device in I/O access mode */

        memory_region_rom_device_set_readable(&pfl->mem, false);

    }



    switch (pfl->wcycle) {

    case 0:

        /* read mode */

        switch (cmd) {

        case 0x00: /* ??? */

            goto reset_flash;

        case 0x10: /* Single Byte Program */

        case 0x40: /* Single Byte Program */

            DPRINTF(""%s: Single Byte Program\n"", __func__);

            break;

        case 0x20: /* Block erase */

            p = pfl->storage;

            offset &= ~(pfl->sector_len - 1);



            DPRINTF(""%s: block erase at "" TARGET_FMT_plx "" bytes %x\n"",

                    __func__, offs",0,1,1,0,2,0,1,1,1,0,0,0,0,0,1
19204,qemu,0,"int kvm_init_vcpu(CPUState *cpu)

{

    KVMState *s = kvm_state;

    long mmap_size;

    int ret;



    DPRINTF(""kvm_init_vcpu\n"");



    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));

    if (ret < 0) {

        DPRINTF(""kvm_create_vcpu failed\n"");

        goto err;

    }



    cpu->kvm_fd = ret;

    cpu->kvm_state = s;

    cpu->kvm_vcpu_dirty = true;



    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);

    if (mmap_size < 0) {

        ret = mmap_size;

        DPRINTF(""KVM_GET_VCPU_MMAP_SIZE failed\n"");

        goto err;

    }



    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,

                        cpu->kvm_fd, 0);

    if (cpu->kvm_run == MAP_FAILED) {

        ret = -errno;

        DPRINTF(""mmap'ing vcpu state failed\n"");

        goto err;

    }



    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {

        s->coalesced_mmio_ring =

            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;

    }



    ret = kvm",0,3,4,0,0,0,0,0,0,0,0,0,0,1,1
19216,qemu,1,"void arm_cpu_do_interrupt(CPUState *cs)
{
    ARMCPU *cpu = ARM_CPU(cs);
    CPUARMState *env = &cpu->env;
    unsigned int new_el = env->exception.target_el;
    assert(!arm_feature(env, ARM_FEATURE_M));
    arm_log_exception(cs->exception_index);
    qemu_log_mask(CPU_LOG_INT, ""...from EL%d to EL%d\n"", arm_current_el(env),
                  new_el);
    if (qemu_loglevel_mask(CPU_LOG_INT)
        && !excp_is_internal(cs->exception_index)) {
        qemu_log_mask(CPU_LOG_INT, ""...with ESR %x/0x%"" PRIx32 ""\n"",
                      env->exception.syndrome >> ARM_EL_EC_SHIFT,
                      env->exception.syndrome);
    }
    if (arm_is_psci_call(cpu, cs->exception_index)) {
        arm_handle_psci_call(cpu);
        qemu_log_mask(CPU_LOG_INT, ""...handled as PSCI call\n"");
        return;
    }
    /* Semihosting semantics depend on the register width of the
     * code that caused the exception, not the target exception level,
     * so must be handled here.
    if (check_for_semihosting(cs)) {
       ",1,0,3,0,0,0,0,1,1,0,1,1,0,0,0
19223,qemu,1,"static void virtio_net_flush_tx(VirtIONet *n, VirtQueue *vq)

{

    VirtQueueElement elem;



    if (!(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK))

        return;



    if (n->async_tx.elem.out_num) {

        virtio_queue_set_notification(n->tx_vq, 0);

        return;

    }



    while (virtqueue_pop(vq, &elem)) {

        ssize_t ret, len = 0;

        unsigned int out_num = elem.out_num;

        struct iovec *out_sg = &elem.out_sg[0];

        unsigned hdr_len;



        /* hdr_len refers to the header received from the guest */

        hdr_len = n->mergeable_rx_bufs ?

            sizeof(struct virtio_net_hdr_mrg_rxbuf) :

            sizeof(struct virtio_net_hdr);



        if (out_num < 1 || out_sg->iov_len != hdr_len) {

            fprintf(stderr, ""virtio-net header not in first element\n"");

            exit(1);

        }



        /* ignore the header if GSO is not supported */

        if (!n->has_vnet_hdr) {

            out_num--;

            out_sg++;

            len += hdr_len;
",0,0,5,0,0,1,1,1,1,1,1,1,0,0,0
19237,qemu,1,"static void flush_queued_data(VirtIOSerialPort *port, bool discard)

{

    assert(port || discard);



    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
19238,qemu,1,"static int hdev_open(BlockDriverState *bs, QDict *options, int flags,

                     Error **errp)

{

    BDRVRawState *s = bs->opaque;

    Error *local_err = NULL;

    int ret;



#if defined(__APPLE__) && defined(__MACH__)







    const char *filename = qdict_get_str(options, ""filename"");

    char bsd_path[MAXPATHLEN] = """";

    bool error_occurred = false;



    /* If using a real cdrom */

    if (strcmp(filename, ""/dev/cdrom"") == 0) {

        char *mediaType = NULL;

        kern_return_t ret_val;

        io_iterator_t mediaIterator = 0;



        mediaType = FindEjectableOpticalMedia(&mediaIterator);

        if (mediaType == NULL) {

            error_setg(errp, ""Please make sure your CD/DVD is in the optical""

                       "" drive"");

            error_occurred = true;

            goto hdev_open_Mac_error;

        }



        ret_val = GetBSDPath(mediaIterator, bsd_path, sizeof(bsd_path), flags);

        if (ret_val != KERN_SUCCESS) {

            error_setg(errp, ""Coul",0,1,4,0,0,0,0,0,0,0,0,1,1,1,1
19243,qemu,1,"int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)

{

    Location loc;

    DriveInfo *dinfo;

    int res = 0, unit;



    loc_push_none(&loc);

    for (unit = 0; unit < bus->info->max_target; unit++) {

        dinfo = drive_get(IF_SCSI, bus->busnr, unit);

        if (dinfo == NULL) {

            continue;

        }

        qemu_opts_loc_restore(dinfo->opts);

        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {

            res = -1;

            break;

        }

    }

    loc_pop(&loc);

    return res;

}
",1,0,2,0,0,0,0,0,0,0,0,0,1,1,1
19245,FFmpeg,1,"static int link_filter_inouts(AVFilterContext *filt_ctx,

                              AVFilterInOut **curr_inputs,

                              AVFilterInOut **open_inputs, AVClass *log_ctx)

{

    int pad = filt_ctx->input_count, ret;



    while (pad--) {

        AVFilterInOut *p = *curr_inputs;

        if (!p) {

            av_log(log_ctx, AV_LOG_ERROR,

                   ""Not enough inputs specified for the \""%s\"" filter.\n"",

                   filt_ctx->filter->name);

            return AVERROR(EINVAL);

        }



        *curr_inputs = (*curr_inputs)->next;



        if (p->filter) {

            if ((ret = link_filter(p->filter, p->pad_idx, filt_ctx, pad, log_ctx)) < 0)

                return ret;

            av_free(p->name);

            av_free(p);

        } else {

            p->filter = filt_ctx;

            p->pad_idx = pad;

            insert_inout(open_inputs, p);

        }

    }



    if (*curr_inputs) {

        av_log(log_ctx, AV_LOG_ERROR,

               ""Too many ",1,0,5,0,0,1,1,0,1,1,1,1,1,1,1
19253,qemu,0,"static void x86_cpu_common_class_init(ObjectClass *oc, void *data)

{

    X86CPUClass *xcc = X86_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(oc);

    DeviceClass *dc = DEVICE_CLASS(oc);



    xcc->parent_realize = dc->realize;

    dc->realize = x86_cpu_realizefn;

    dc->bus_type = TYPE_ICC_BUS;

    dc->props = x86_cpu_properties;



    xcc->parent_reset = cc->reset;

    cc->reset = x86_cpu_reset;

    cc->reset_dump_flags = CPU_DUMP_FPU | CPU_DUMP_CCOP;



    cc->class_by_name = x86_cpu_class_by_name;

    cc->parse_features = x86_cpu_parse_featurestr;

    cc->has_work = x86_cpu_has_work;

    cc->do_interrupt = x86_cpu_do_interrupt;

    cc->cpu_exec_interrupt = x86_cpu_exec_interrupt;

    cc->dump_state = x86_cpu_dump_state;

    cc->set_pc = x86_cpu_set_pc;

    cc->synchronize_from_tb = x86_cpu_synchronize_from_tb;

    cc->gdb_read_register = x86_cpu_gdb_read_register;

    cc->gdb_write_register = x86_cpu_gdb_write_register;

    cc->get_arch_id = x86_cpu_get_arch_id;

    cc->get_paging_en",0,0,0,0,0,0,0,1,1,0,0,0,1,0,1
19256,qemu,0,"static int qpa_init_in (HWVoiceIn *hw, audsettings_t *as)

{

    int error;

    static pa_sample_spec ss;

    audsettings_t obt_as = *as;

    PAVoiceIn *pa = (PAVoiceIn *) hw;



    ss.format = audfmt_to_pa (as->fmt, as->endianness);

    ss.channels = as->nchannels;

    ss.rate = as->freq;



    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);



    pa->s = pa_simple_new (

        conf.server,

        ""qemu"",

        PA_STREAM_RECORD,

        conf.source,

        ""pcm.capture"",

        &ss,

        NULL,                   /* channel map */

        NULL,                   /* buffering attributes */

        &error

        );

    if (!pa->s) {

        qpa_logerr (error, ""pa_simple_new for capture failed\n"");

        goto fail1;

    }



    audio_pcm_init_info (&hw->info, &obt_as);

    hw->samples = conf.samples;

    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);

    if (!pa->pcm_buf) {

        dolog (""Could not allocate buffer (%d bytes)\n"",

    ",3,1,3,0,0,0,0,0,0,0,1,0,0,0,0
19274,qemu,0,"uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf)

{

    CPU_DoubleU farg;

    int isneg;

    int ret;

    farg.ll = arg;

    isneg = float64_is_neg(farg.d);

    if (unlikely(float64_is_nan(farg.d))) {

        if (float64_is_signaling_nan(farg.d)) {

            /* Signaling NaN: flags are undefined */

            ret = 0x00;

        } else {

            /* Quiet NaN */

            ret = 0x11;

        }

    } else if (unlikely(float64_is_infinity(farg.d))) {

        /* +/- infinity */

        if (isneg)

            ret = 0x09;

        else

            ret = 0x05;

    } else {

        if (float64_is_zero(farg.d)) {

            /* +/- zero */

            if (isneg)

                ret = 0x12;

            else

                ret = 0x02;

        } else {

            if (isden(farg.d)) {

                /* Denormalized numbers */

                ret = 0x10;

            } else {

                /* Normalized numbers */

                ret = 0x00;

            }

       ",0,0,7,0,0,0,0,0,0,0,1,1,1,1,1
19290,qemu,0,"void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)

{

    VGACommonState *s = opaque;

    int index;



    /* check port range access depending on color/monochrome mode */

    if (vga_ioport_invalid(s, addr)) {

        return;

    }

#ifdef DEBUG_VGA

    printf(""VGA: write addr=0x%04x data=0x%02x\n"", addr, val);

#endif



    switch(addr) {

    case VGA_ATT_W:

        if (s->ar_flip_flop == 0) {

            val &= 0x3f;

            s->ar_index = val;

        } else {

            index = s->ar_index & 0x1f;

            switch(index) {

            case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:

                s->ar[index] = val & 0x3f;

                break;

            case VGA_ATC_MODE:

                s->ar[index] = val & ~0x10;

                break;

            case VGA_ATC_OVERSCAN:

                s->ar[index] = val;

                break;

            case VGA_ATC_PLANE_ENABLE:

                s->ar[index] = val & ~0xc0;

                break;

            case VGA_A",0,0,4,0,2,0,0,0,0,0,0,0,1,1,1
19291,qemu,0,"static int usbnet_can_receive(NetClientState *nc)

{

    USBNetState *s = qemu_get_nic_opaque(nc);



    if (!s->dev.config) {

        return 0;

    }



    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {

        return 1;

    }



    return !s->in_len;

}
",0,0,2,0,0,0,0,0,1,1,1,0,1,1,1
19301,qemu,0,"static void dhcp_decode(const uint8_t *buf, int size,

                        int *pmsg_type)

{

    const uint8_t *p, *p_end;

    int len, tag;



    *pmsg_type = 0;



    p = buf;

    p_end = buf + size;

    if (size < 5)

        return;

    if (memcmp(p, rfc1533_cookie, 4) != 0)

        return;

    p += 4;

    while (p < p_end) {

        tag = p[0];

        if (tag == RFC1533_PAD) {

            p++;

        } else if (tag == RFC1533_END) {

            break;

        } else {

            p++;

            if (p >= p_end)

                break;

            len = *p++;

            dprintf(""dhcp: tag=0x%02x len=%d\n"", tag, len);



            switch(tag) {

            case RFC2132_MSG_TYPE:

                if (len >= 1)

                    *pmsg_type = p[0];

                break;

            default:

                break;

            }

            p += len;

        }

    }

}
",0,0,6,0,1,1,0,0,0,0,0,0,1,1,1
19307,qemu,0,"static int xhci_fire_ctl_transfer(XHCIState *xhci, XHCITransfer *xfer)

{

    XHCITRB *trb_setup, *trb_status;

    uint8_t bmRequestType;



    trb_setup = &xfer->trbs[0];

    trb_status = &xfer->trbs[xfer->trb_count-1];



    trace_usb_xhci_xfer_start(xfer, xfer->epctx->slotid,

                              xfer->epctx->epid, xfer->streamid);



    /* at most one Event Data TRB allowed after STATUS */

    if (TRB_TYPE(*trb_status) == TR_EVDATA && xfer->trb_count > 2) {

        trb_status--;

    }



    /* do some sanity checks */

    if (TRB_TYPE(*trb_setup) != TR_SETUP) {

        DPRINTF(""xhci: ep0 first TD not SETUP: %d\n"",

                TRB_TYPE(*trb_setup));

        return -1;

    }

    if (TRB_TYPE(*trb_status) != TR_STATUS) {

        DPRINTF(""xhci: ep0 last TD not STATUS: %d\n"",

                TRB_TYPE(*trb_status));

        return -1;

    }

    if (!(trb_setup->control & TRB_TR_IDT)) {

        DPRINTF(""xhci: Setup TRB doesn't have IDT set\n"");

        return -1;

    }

    ",0,0,4,0,0,0,0,0,1,0,0,1,1,1,0
19322,qemu,0,"void qemu_free_timer(QEMUTimer *ts)

{

    g_free(ts);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
19353,FFmpeg,1,"static av_cold int dvdsub_close(AVCodecContext *avctx)

{

    DVDSubContext *ctx = avctx->priv_data;

    av_freep(&ctx->buf);

    ctx->buf_size = 0;

    return 0;

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,1
19373,qemu,0,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    int start_track, format, msf, toclen;

    uint64_t nb_sectors;



    msf = req->cmd.buf[1] & 2;

    format = req->cmd.buf[2] & 0xf;

    start_track = req->cmd.buf[6];

    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);

    nb_sectors /= s->qdev.blocksize / 512;

    switch (format) {

    case 0:

        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);

        break;

    case 1:

        /* multi session : only a single session defined */

        toclen = 12;

        memset(outbuf, 0, 12);

        outbuf[1] = 0x0a;

        outbuf[2] = 0x01;

        outbuf[3] = 0x01;

        break;

    case 2:

        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);

        break;

    default:

        return -1;

    }

    return toclen;

}
",5,0,0,0,1,0,0,0,0,0,0,0,0,0,1
19380,qemu,0,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int ret;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);

        return;

    }



    ret = refresh_total_sectors(bs, bs->total_sectors);

    if (ret < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        return;

    }

}
",0,0,6,0,0,0,0,0,0,0,0,0,0,1,1
19389,qemu,0,"static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)

{

    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);

    uint8_t *pci_conf = s->dev.config;



    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);

    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);



    /* USB misc control 1/2 */

    pci_set_long(pci_conf + 0x40,0x00001000);

    /* PM capability */

    pci_set_long(pci_conf + 0x80,0x00020001);

    /* USB legacy support  */

    pci_set_long(pci_conf + 0xc0,0x00002000);



    return usb_uhci_common_initfn(s);

}
",0,0,0,0,0,0,1,1,1,0,0,1,0,1,0
19403,qemu,1,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
19408,qemu,1,"static void vfio_vga_probe_nvidia_3d0_quirk(VFIOPCIDevice *vdev)

{

    VFIOQuirk *quirk;

    VFIONvidia3d0Quirk *data;



    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||

        !vdev->bars[1].region.size) {

        return;

    }



    quirk = g_malloc0(sizeof(*quirk));

    quirk->data = data = g_malloc0(sizeof(*data));

    quirk->mem = g_malloc0(sizeof(MemoryRegion) * 2);

    quirk->nr_mem = 2;

    data->vdev = vdev;



    memory_region_init_io(&quirk->mem[0], OBJECT(vdev), &vfio_nvidia_3d4_quirk,

                          data, ""vfio-nvidia-3d4-quirk"", 2);

    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,

                                0x14 /* 0x3c0 + 0x14 */, &quirk->mem[0]);



    memory_region_init_io(&quirk->mem[1], OBJECT(vdev), &vfio_nvidia_3d0_quirk,

                          data, ""vfio-nvidia-3d0-quirk"", 2);

    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,

                                0x10 /* 0x3c0 + 0x10 */, ",0,0,1,0,0,0,0,1,0,1,1,1,0,0,0
19411,FFmpeg,0,"static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}
",0,0,2,0,0,2,1,1,0,0,0,0,1,1,0
19431,qemu,1,"static int get_physical_address (CPUMIPSState *env, hwaddr *physical,

                                int *prot, target_ulong real_address,

                                int rw, int access_type)

{

    /* User mode can only access useg/xuseg */

    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;

    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;

    int kernel_mode = !user_mode && !supervisor_mode;

#if defined(TARGET_MIPS64)

    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;

    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;

    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;

#endif

    int ret = TLBRET_MATCH;

    /* effective address (modified for KVM T&E kernel segments) */

    target_ulong address = real_address;



#define USEG_LIMIT      0x7FFFFFFFUL

#define KSEG0_BASE      0x80000000UL

#define KSEG1_BASE      0xA0000000UL

#define KSEG2_BASE      0xC0000000UL

#define KSEG3_BASE      0xE0000000UL



#define KVM_KSEG0_BASE  0x4000000",0,0,2,0,0,0,0,0,0,0,1,0,0,1,1
19434,qemu,1,"static int get_htab_fd(sPAPRMachineState *spapr)

{

    if (spapr->htab_fd >= 0) {

        return spapr->htab_fd;

    }



    spapr->htab_fd = kvmppc_get_htab_fd(false);

    if (spapr->htab_fd < 0) {

        error_report(""Unable to open fd for reading hash table from KVM: %s"",

                     strerror(errno));

    }



    return spapr->htab_fd;

}
",1,0,2,0,0,0,0,1,0,1,1,0,1,1,1
19441,qemu,1,"static void qobject_input_start_list(Visitor *v, const char *name,

                                     GenericList **list, size_t size,

                                     Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    const QListEntry *entry;



    if (list) {

        *list = NULL;

    }

    if (!qobj) {

        return;

    }

    if (qobject_type(qobj) != QTYPE_QLIST) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""list"");

        return;

    }



    entry = qobject_input_push(qiv, qobj, list);

    if (entry && list) {

        *list = g_malloc0(size);

    }

}
",0,0,4,0,0,0,1,0,1,1,0,1,1,1,1
19469,qemu,0,"static void test_qga_file_write_read(gconstpointer fix)

{

    const TestFixture *fixture = fix;

    const unsigned char helloworld[] = ""Hello World!\n"";

    const char *b64;

    gchar *cmd, *enc;

    QDict *ret, *val;

    int64_t id, eof;

    gsize count;



    /* open */

    ret = qmp_fd(fixture->fd, ""{'execute': 'guest-file-open',""

                 "" 'arguments': { 'path': 'foo', 'mode': 'w+' } }"");

    g_assert_nonnull(ret);

    qmp_assert_no_error(ret);

    id = qdict_get_int(ret, ""return"");

    QDECREF(ret);



    enc = g_base64_encode(helloworld, sizeof(helloworld));

    /* write */

    cmd = g_strdup_printf(""{'execute': 'guest-file-write',""

                          "" 'arguments': { 'handle': %"" PRId64 "",""

                          "" 'buf-b64': '%s' } }"", id, enc);

    ret = qmp_fd(fixture->fd, cmd);

    g_assert_nonnull(ret);

    qmp_assert_no_error(ret);



    val = qdict_get_qdict(ret, ""return"");

    count = qdict_get_int(val, ""count"");

    eof = qdict_get_bool(val, ""eof"");",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
19473,qemu,0,"static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,

                                                const void *unused)

{

    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);

}
",0,0,0,0,0,0,0,0,0,1,0,1,1,0,1
19490,qemu,0,"static int xen_9pfs_connect(struct XenDevice *xendev)

{

    int i;

    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);

    V9fsState *s = &xen_9pdev->state;

    QemuOpts *fsdev;



    if (xenstore_read_fe_int(&xen_9pdev->xendev, ""num-rings"",

                             &xen_9pdev->num_rings) == -1 ||

        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {

        return -1;

    }



    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));

    for (i = 0; i < xen_9pdev->num_rings; i++) {

        char *str;

        int ring_order;



        xen_9pdev->rings[i].priv = xen_9pdev;

        xen_9pdev->rings[i].evtchn = -1;

        xen_9pdev->rings[i].local_port = -1;



        str = g_strdup_printf(""ring-ref%u"", i);

        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,

                                 &xen_9pdev->rings[i].ref) == -1) {

            g_free(str);

            goto out;

        }

        g_free(str);

        str = g_strdu",1,1,2,0,0,0,0,1,0,0,0,0,1,1,1
19492,qemu,0,"static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,

                            TCGArg dst, TCGArg src)

{

    if (temps_are_copies(dst, src)) {

        tcg_op_remove(s, op);

        return;

    }



    if (temp_is_const(src)) {

        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);

        return;

    }



    TCGOpcode new_op = op_to_mov(op->opc);

    tcg_target_ulong mask;



    op->opc = new_op;



    reset_temp(dst);

    mask = temps[src].mask;

    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {

        /* High bits of the destination are now garbage.  */

        mask |= ~0xffffffffull;

    }

    temps[dst].mask = mask;



    assert(!temp_is_const(src));



    if (s->temps[src].type == s->temps[dst].type) {

        temps[dst].next_copy = temps[src].next_copy;

        temps[dst].prev_copy = src;

        temps[temps[dst].next_copy].prev_copy = dst;

        temps[src].next_copy = dst;

        temps[dst].is_const = false;

    }



    args[0] = dst",0,0,4,0,0,0,1,1,1,1,1,1,0,1,1
19494,FFmpeg,0,"av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx)

{

  /* VIS-specific optimizations */

  int accel = vis_level ();

  const int high_bit_depth = avctx->bits_per_raw_sample > 8;



  if (accel & ACCEL_SPARC_VIS) {

      if (avctx->bits_per_raw_sample <= 8 &&

          avctx->idct_algo == FF_IDCT_SIMPLEVIS) {

          c->idct_put = ff_simple_idct_put_vis;

          c->idct_add = ff_simple_idct_add_vis;

          c->idct     = ff_simple_idct_vis;

          c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;

      }



      if (!high_bit_depth) {

      c->put_pixels_tab[0][0] = MC_put_o_16_vis;

      c->put_pixels_tab[0][1] = MC_put_x_16_vis;

      c->put_pixels_tab[0][2] = MC_put_y_16_vis;

      c->put_pixels_tab[0][3] = MC_put_xy_16_vis;



      c->put_pixels_tab[1][0] = MC_put_o_8_vis;

      c->put_pixels_tab[1][1] = MC_put_x_8_vis;

      c->put_pixels_tab[1][2] = MC_put_y_8_vis;

      c->put_pixels_tab[1][3] = MC_put_xy_8_vis;



      c->avg_pixels_tab[0][0] = MC_avg_o",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
19538,FFmpeg,0,"void vp8_mc(VP8Context *s, int luma,

            uint8_t *dst, uint8_t *src, const VP56mv *mv,

            int x_off, int y_off, int block_w, int block_h,

            int width, int height, int linesize,

            vp8_mc_func mc_func[3][3])

{

    if (AV_RN32A(mv)) {

        static const uint8_t idx[3][8] = {

            { 0, 1, 2, 1, 2, 1, 2, 1 }, // nr. of left extra pixels,

                                        // also function pointer index

            { 0, 3, 5, 3, 5, 3, 5, 3 }, // nr. of extra pixels required

            { 0, 2, 3, 2, 3, 2, 3, 2 }, // nr. of right extra pixels

        };

        int mx = (mv->x << luma)&7, mx_idx = idx[0][mx];

        int my = (mv->y << luma)&7, my_idx = idx[0][my];



        x_off += mv->x >> (3 - luma);

        y_off += mv->y >> (3 - luma);



        // edge emulation

        src += y_off * linesize + x_off;

        if (x_off < mx_idx || x_off >= width  - block_w - idx[2][mx] ||

            y_off < my_idx || y_off >= height - block_h - idx[2][my",0,0,2,0,0,0,1,1,1,1,0,1,1,1,1
19554,qemu,1,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,1
19557,FFmpeg,1,"DECLARE_LOOP_FILTER(mmxext)

DECLARE_LOOP_FILTER(sse2)

DECLARE_LOOP_FILTER(ssse3)

DECLARE_LOOP_FILTER(sse4)



#endif /* HAVE_YASM */



#define VP8_LUMA_MC_FUNC(IDX, SIZE, OPT) \

    c->put_vp8_epel_pixels_tab[IDX][0][2] = ff_put_vp8_epel ## SIZE ## _h6_ ## OPT; \

    c->put_vp8_epel_pixels_tab[IDX][2][0] = ff_put_vp8_epel ## SIZE ## _v6_ ## OPT; \

    c->put_vp8_epel_pixels_tab[IDX][2][2] = ff_put_vp8_epel ## SIZE ## _h6v6_ ## OPT



#define VP8_MC_FUNC(IDX, SIZE, OPT) \

    c->put_vp8_epel_pixels_tab[IDX][0][1] = ff_put_vp8_epel ## SIZE ## _h4_ ## OPT; \

    c->put_vp8_epel_pixels_tab[IDX][1][0] = ff_put_vp8_epel ## SIZE ## _v4_ ## OPT; \

    c->put_vp8_epel_pixels_tab[IDX][1][1] = ff_put_vp8_epel ## SIZE ## _h4v4_ ## OPT; \

    c->put_vp8_epel_pixels_tab[IDX][1][2] = ff_put_vp8_epel ## SIZE ## _h6v4_ ## OPT; \

    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \

    VP8_LUMA_MC_FUNC(IDX, SIZE, OPT)



#define VP8_BILINEAR_MC_FUNC(IDX, SIZE, OPT) \

    c->put_",0,0,1,0,0,0,1,1,1,1,1,0,0,0,0
19567,qemu,0,"static int get_bat (CPUState *env, mmu_ctx_t *ctx,

                    target_ulong virtual, int rw, int type)

{

    target_ulong *BATlt, *BATut, *BATu, *BATl;

    target_ulong base, BEPIl, BEPIu, bl;

    int i;

    int ret = -1;



#if defined (DEBUG_BATS)

    if (loglevel != 0) {

        fprintf(logfile, ""%s: %cBAT v 0x"" ADDRX ""\n"", __func__,

                type == ACCESS_CODE ? 'I' : 'D', virtual);

    }

#endif

    switch (type) {

    case ACCESS_CODE:

        BATlt = env->IBAT[1];

        BATut = env->IBAT[0];

        break;

    default:

        BATlt = env->DBAT[1];

        BATut = env->DBAT[0];

        break;

    }

#if defined (DEBUG_BATS)

    if (loglevel != 0) {

        fprintf(logfile, ""%s...: %cBAT v 0x"" ADDRX ""\n"", __func__,

                type == ACCESS_CODE ? 'I' : 'D', virtual);

    }

#endif

    base = virtual & 0xFFFC0000;

    for (i = 0; i < 4; i++) {

        BATu = &BATut[i];

        BATl = &BATlt[i];

        BEPIu = *BATu & 0xF0000000;

        BEPIl = *BATu",1,0,6,0,1,0,0,0,0,0,0,0,0,0,0
19574,qemu,0,"static void *migration_thread(void *opaque)

{

    MigrationState *s = opaque;

    /* Used by the bandwidth calcs, updated later */

    int64_t initial_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);

    int64_t setup_start = qemu_clock_get_ms(QEMU_CLOCK_HOST);

    int64_t initial_bytes = 0;

    int64_t max_size = 0;

    int64_t start_time = initial_time;

    int64_t end_time;

    bool old_vm_running = false;

    bool entered_postcopy = false;

    /* The active state we expect to be in; ACTIVE or POSTCOPY_ACTIVE */

    enum MigrationStatus current_active_state = MIGRATION_STATUS_ACTIVE;



    rcu_register_thread();



    qemu_savevm_state_header(s->to_dst_file);



    if (migrate_postcopy_ram()) {

        /* Now tell the dest that it should open its end so it can reply */

        qemu_savevm_send_open_return_path(s->to_dst_file);



        /* And do a ping that will make stuff easier to debug */

        qemu_savevm_send_ping(s->to_dst_file, 1);



        /*

         * Tell the destination ",0,0,1,0,0,0,1,1,1,1,0,1,0,1,0
19576,qemu,0,"void replay_input_event(QemuConsole *src, InputEvent *evt)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
19593,FFmpeg,1,"static inline unsigned int get_uint(ShortenContext *s, int k)

{

    if (s->version != 0)

        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);

    return get_ur_golomb_shorten(&s->gb, k);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
19595,FFmpeg,1,"static void scale_coefs (

    int32_t *dst,

    const int32_t *src,

    int dynrng,

    int len)

{

    int i, shift, round;

    int16_t mul;

    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;



    mul = (dynrng & 0x1f) + 0x20;

    shift = 4 - ((dynrng << 23) >> 28);

    if (shift > 0 ) {

      round = 1 << (shift-1);

      for (i=0; i<len; i+=8) {



          temp = src[i] * mul;

          temp1 = src[i+1] * mul;

          temp = temp + round;

          temp2 = src[i+2] * mul;



          temp1 = temp1 + round;

          dst[i] = temp >> shift;

          temp3 = src[i+3] * mul;

          temp2 = temp2 + round;



          dst[i+1] = temp1 >> shift;

          temp4 = src[i + 4] * mul;

          temp3 = temp3 + round;

          dst[i+2] = temp2 >> shift;



          temp5 = src[i+5] * mul;

          temp4 = temp4 + round;

          dst[i+3] = temp3 >> shift;

          temp6 = src[i+6] * mul;



          dst[i+4] = temp4 >> shift;

          temp5 = temp5 + round;

    ",1,0,10,0,0,0,1,0,0,0,0,1,1,1,1
19612,qemu,1,"static int handle_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)
{
    const char *sec_model = qemu_opt_get(opts, ""security_model"");
    const char *path = qemu_opt_get(opts, ""path"");
    if (sec_model) {
        error_report(""Invalid argument security_model specified with handle fsdriver"");
        return -1;
    }
    if (!path) {
        error_report(""fsdev: No path specified"");
        return -1;
    }
    fse->path = g_strdup(path);
    return 0;
}",0,0,4,0,0,0,1,1,1,1,1,1,0,0,0
19633,qemu,1,"void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
19643,qemu,1,"static int integratorcm_init(SysBusDevice *dev)

{

    IntegratorCMState *s = INTEGRATOR_CM(dev);



    s->cm_osc = 0x01000048;

    /* ??? What should the high bits of this value be?  */

    s->cm_auxosc = 0x0007feff;

    s->cm_sdram = 0x00011122;

    if (s->memsz >= 256) {

        integrator_spd[31] = 64;

        s->cm_sdram |= 0x10;

    } else if (s->memsz >= 128) {

        integrator_spd[31] = 32;

        s->cm_sdram |= 0x0c;

    } else if (s->memsz >= 64) {

        integrator_spd[31] = 16;

        s->cm_sdram |= 0x08;

    } else if (s->memsz >= 32) {

        integrator_spd[31] = 4;

        s->cm_sdram |= 0x04;

    } else {

        integrator_spd[31] = 2;

    }

    memcpy(integrator_spd + 73, ""QEMU-MEMORY"", 11);

    s->cm_init = 0x00000112;

    s->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,

                                   1000);

    memory_region_init_ram(&s->flash, OBJECT(s), ""integrator.flash"", 0x100000,

                           &error_abort);

  ",0,0,4,0,0,0,1,1,1,1,1,1,0,0,0
19650,qemu,1,"static void unterminated_array_comma(void)

{

    QObject *obj = qobject_from_json(""[32,"", NULL);

    g_assert(obj == NULL);

}
",0,0,0,0,0,0,0,0,0,0,0,1,1,1,1
19654,FFmpeg,0,"static int svq1_decode_frame_header(GetBitContext *bitbuf, MpegEncContext *s)

{

    int frame_size_code;



    skip_bits(bitbuf, 8); /* temporal_reference */



    /* frame type */

    s->pict_type = get_bits(bitbuf, 2) + 1;

    if (s->pict_type == 4)

        return AVERROR_INVALIDDATA;



    if (s->pict_type == AV_PICTURE_TYPE_I) {

        /* unknown fields */

        if (s->f_code == 0x50 || s->f_code == 0x60) {

            int csum = get_bits(bitbuf, 16);



            csum = ff_svq1_packet_checksum(bitbuf->buffer,

                                           bitbuf->size_in_bits >> 3,

                                           csum);



            av_dlog(s->avctx, ""%s checksum (%02x) for packet data\n"",

                    (csum == 0) ? ""correct"" : ""incorrect"", csum);

        }



        if ((s->f_code ^ 0x10) >= 0x50) {

            uint8_t msg[256];



            svq1_parse_string(bitbuf, msg);



            av_log(s->avctx, AV_LOG_ERROR,

                   ""embedded message: \""%s\""\",1,0,4,0,0,0,0,1,1,0,0,1,1,0,0
19665,FFmpeg,1,"void prepare_grab(void)

{

    fprintf(stderr, ""Must supply at least one input file\n"");

    exit(1);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,0,0
19667,FFmpeg,1,"static int compare_codec_desc(const void *a, const void *b)

{

    const AVCodecDescriptor * const *da = a;

    const AVCodecDescriptor * const *db = b;



    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :

           strcmp((*da)->name, (*db)->name);

}
",0,0,0,0,0,0,0,1,1,0,1,1,1,1,1
19684,qemu,1,"static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,

                           struct iovec *iov, int niov, int create,

                           enum AIOCBState aiocb_type)

{

    int nr_copies = s->inode.nr_copies;

    SheepdogObjReq hdr;

    unsigned int wlen;

    int ret;

    uint64_t oid = aio_req->oid;

    unsigned int datalen = aio_req->data_len;

    uint64_t offset = aio_req->offset;

    uint8_t flags = aio_req->flags;

    uint64_t old_oid = aio_req->base_oid;



    if (!nr_copies) {

        error_report(""bug"");

    }



    memset(&hdr, 0, sizeof(hdr));



    if (aiocb_type == AIOCB_READ_UDATA) {

        wlen = 0;

        hdr.opcode = SD_OP_READ_OBJ;

        hdr.flags = flags;

    } else if (create) {

        wlen = datalen;

        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;

        hdr.flags = SD_FLAG_CMD_WRITE | flags;

    } else {

        wlen = datalen;

        hdr.opcode = SD_OP_WRITE_OBJ;

        hdr.flags = SD_FLAG_CMD_WRITE | flags;

    }

",0,0,3,0,0,0,0,1,1,1,1,1,0,0,0
19685,qemu,1,"static void ehci_writeback_async_complete_packet(EHCIPacket *p)
{
    EHCIQueue *q = p->queue;
    int state;
    state = ehci_get_state(q->ehci, q->async);
    ehci_state_executing(q);
    ehci_state_writeback(q); /* Frees the packet! */
    if (!(q->qh.token & QTD_TOKEN_HALT)) {
        ehci_state_advqueue(q);
    ehci_set_state(q->ehci, q->async, state);",0,0,1,0,0,0,0,1,1,1,0,0,0,0,1
19709,qemu,1,"static void gen_ldst_pair (DisasContext *ctx, uint32_t opc, int rd,

                           int base, int16_t offset)

{

    const char *opn = ""ldst_pair"";

    TCGv t0, t1;



    if (ctx->hflags & MIPS_HFLAG_BMASK || rd == 31 || rd == base) {

        generate_exception(ctx, EXCP_RI);

        return;

    }



    t0 = tcg_temp_new();

    t1 = tcg_temp_new();



    gen_base_offset_addr(ctx, t0, base, offset);



    switch (opc) {

    case LWP:

        save_cpu_state(ctx, 0);

        op_ld_lw(t1, t0, ctx);

        gen_store_gpr(t1, rd);

        tcg_gen_movi_tl(t1, 4);

        gen_op_addr_add(ctx, t0, t0, t1);

        op_ld_lw(t1, t0, ctx);

        gen_store_gpr(t1, rd+1);

        opn = ""lwp"";

        break;

    case SWP:

        save_cpu_state(ctx, 0);

        gen_load_gpr(t1, rd);

        op_st_sw(t1, t0, ctx);

        tcg_gen_movi_tl(t1, 4);

        gen_op_addr_add(ctx, t0, t0, t1);

        gen_load_gpr(t1, rd+1);

        op_st_sw(t1, t0, ctx);

        opn = ""swp"";

        brea",0,0,1,0,1,0,1,1,1,1,1,1,1,1,1
19716,qemu,1,"static void wdt_diag288_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    DIAG288Class *diag288 = DIAG288_CLASS(klass);



    dc->realize = wdt_diag288_realize;

    dc->unrealize = wdt_diag288_unrealize;

    dc->reset = wdt_diag288_reset;


    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->vmsd = &vmstate_diag288;

    diag288->handle_timer = wdt_diag288_handle_timer;

}",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
19721,FFmpeg,0,"int ff_estimate_motion_b(MpegEncContext * s,

                       int mb_x, int mb_y, int16_t (*mv_table)[2], uint8_t *ref_picture, int f_code)

{

    int mx, my, range, dmin;

    int xmin, ymin, xmax, ymax;

    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;

    int pred_x=0, pred_y=0;

    int P[6][2];

    const int shift= 1+s->quarter_sample;

    const int mot_stride = s->mb_width + 2;

    const int mot_xy = (mb_y + 1)*mot_stride + mb_x + 1;

    

    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, f_code);



    switch(s->me_method) {

    case ME_ZERO:

    default:

	no_motion_search(s, &mx, &my);

        dmin = 0;

        break;

    case ME_FULL:

	dmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);

        break;

    case ME_LOG:

	dmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);

        break;

    case ME_PHODS:

	dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);

        brea",0,0,1,0,1,0,1,1,1,1,0,0,1,1,0
19724,FFmpeg,0,"static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){

    MpegEncContext * const s = &h->s;

    AVCodecContext * const avctx= s->avctx;

    H264Context *hx; ///< thread context

    int buf_index;

    int context_count;

    int next_avc;

    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);

    int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts

    int nal_index;



    h->nal_unit_type= 0;



    h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1;

    if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){

        h->current_slice = 0;

        if (!s->first_field)

            s->current_picture_ptr= NULL;

        ff_h264_reset_sei(h);

    }



    for(;pass <= 1;pass++){

        buf_index = 0;

        context_count = 0;

        next_avc = h->is_avc ? 0 : buf_size;

        nal_index = 0;

    for(;;){

        int consumed;

        int dst_length;

        int bit_length;

 ",2,0,2,0,0,0,1,0,1,1,0,0,0,0,0
19728,FFmpeg,1,"static int dnxhd_find_frame_end(DNXHDParserContext *dctx,

                                const uint8_t *buf, int buf_size)

{

    ParseContext *pc = &dctx->pc;

    uint64_t state = pc->state64;

    int pic_found = pc->frame_start_found;

    int i = 0;



    if (!pic_found) {

        for (i = 0; i < buf_size; i++) {

            state = (state << 8) | buf[i];

            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {

                i++;

                pic_found = 1;

                dctx->cur_byte = 0;

                dctx->remaining = 0;

                break;

            }

        }

    }



    if (pic_found && !dctx->remaining) {

        if (!buf_size) /* EOF considered as end of frame */

            return 0;

        for (; i < buf_size; i++) {

            dctx->cur_byte++;

            state = (state << 8) | buf[i];



            if (dctx->cur_byte == 24) {

                dctx->h = (state >> 32) & 0xFFFF;

            } else if (dctx->cur_byte == 26) {

      ",2,0,6,0,0,0,1,1,1,1,1,0,0,0,0
19759,FFmpeg,0,"static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx)

{

    VAAPIEncodeContext      *ctx = avctx->priv_data;

    VAAPIEncodeH264Context *priv = ctx->priv_data;

    int hrd_buffer_size;

    int hrd_initial_buffer_fullness;



    if (avctx->bit_rate > INT32_MAX) {

        av_log(avctx, AV_LOG_ERROR, ""Target bitrate of 2^31 bps or ""

               ""higher is not supported.\n"");

        return AVERROR(EINVAL);

    }



    if (avctx->rc_buffer_size)

        hrd_buffer_size = avctx->rc_buffer_size;

    else

        hrd_buffer_size = avctx->bit_rate;

    if (avctx->rc_initial_buffer_occupancy)

        hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;

    else

        hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;



    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;

    priv->rc_params.rc = (VAEncMiscParameterRateControl) {

        .bits_per_second   = avctx->bit_rate,

        .target_percentage = 66,

        .window_size      ",0,0,3,0,0,0,0,0,0,0,0,0,0,1,0
19782,FFmpeg,1,"static inline void RENAME(planar2x)(const uint8_t *src, uint8_t *dst, long srcWidth, long srcHeight, long srcStride, long dstStride)

{

	long x,y;



	dst[0]= src[0];



	// first line

	for(x=0; x<srcWidth-1; x++){

		dst[2*x+1]= (3*src[x] +   src[x+1])>>2;

		dst[2*x+2]= (  src[x] + 3*src[x+1])>>2;

	}

	dst[2*srcWidth-1]= src[srcWidth-1];



        dst+= dstStride;



	for(y=1; y<srcHeight; y++){

#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)

		const long mmxSize= srcWidth&~15;

		asm volatile(

			""mov %4, %%""REG_a""		\n\t""

			""1:				\n\t""

			""movq (%0, %%""REG_a""), %%mm0	\n\t""

			""movq (%1, %%""REG_a""), %%mm1	\n\t""

			""movq 1(%0, %%""REG_a""), %%mm2	\n\t""

			""movq 1(%1, %%""REG_a""), %%mm3	\n\t""

			""movq -1(%0, %%""REG_a""), %%mm4	\n\t""

			""movq -1(%1, %%""REG_a""), %%mm5	\n\t""

			PAVGB"" %%mm0, %%mm5		\n\t""

			PAVGB"" %%mm0, %%mm3		\n\t""

			PAVGB"" %%mm0, %%mm5		\n\t""

			PAVGB"" %%mm0, %%mm3		\n\t""

			PAVGB"" %%mm1, %%mm4		\n\t""

			PAVGB"" %%mm1, %%mm2		\n\t""

			PAVGB"" %%mm1, %%mm4		\n\t""

			PAVGB"" %",2,0,1,0,0,0,1,1,1,1,1,1,0,0,0
19808,qemu,1,"static void gen_mtmsr(DisasContext *ctx)

{

#if defined(CONFIG_USER_ONLY)

    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

#else

    if (unlikely(ctx->pr)) {

        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);

        return;

    }

    if (ctx->opcode & 0x00010000) {

        /* Special form that does not need any synchronisation */

        TCGv t0 = tcg_temp_new();

        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));

        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));

        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);

        tcg_temp_free(t0);

    } else {

        TCGv msr = tcg_temp_new();



        /* XXX: we need to update nip before the store

         *      if we enter power saving mode, we will exit the loop

         *      directly from ppc_store_msr

         */

        gen_update_nip(ctx, ctx->nip);

#if defined(TARGET_PPC64)

        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);

#els",1,0,5,0,0,0,0,1,1,1,1,1,1,1,1
19809,qemu,1,"static void flatview_ref(FlatView *view)

{

    atomic_inc(&view->ref);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
19827,FFmpeg,1,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}",2,0,0,0,0,0,0,1,1,1,1,1,0,0,1
19834,qemu,1,"static void test_task_complete(void)

{

    QIOTask *task;

    Object *obj = object_new(TYPE_DUMMY);

    Object *src;

    struct TestTaskData data = { NULL, NULL, false };



    task = qio_task_new(obj, task_callback, &data, NULL);

    src = qio_task_get_source(task);



    qio_task_complete(task);



    g_assert(obj == src);



    object_unref(obj);

    object_unref(src);



    g_assert(data.source == obj);

    g_assert(data.err == NULL);

    g_assert(data.freed == false);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
19886,FFmpeg,0,"static int nut_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    NUTContext *nut = s->priv_data;

    ByteIOContext *bc = &s->pb;

    int64_t pos;

    int inited_stream_count;



    nut->avf= s;

    

    av_set_pts_info(s, 60, 1, AV_TIME_BASE);



    /* main header */

    pos=0;

    for(;;){

        if (find_startcode(bc, MAIN_STARTCODE, pos)<0){

            av_log(s, AV_LOG_ERROR, ""no main startcode found\n"");

            return -1;

        }

        pos= url_ftell(bc);

        if(decode_main_header(nut) >= 0)

            break;

    }

    

    

    s->bit_rate = 0;



    nut->stream = av_malloc(sizeof(StreamContext)*nut->stream_count);



    /* stream headers */

    pos=0;

    for(inited_stream_count=0; inited_stream_count < nut->stream_count;){

        if (find_startcode(bc, STREAM_STARTCODE, pos)<0){

            av_log(s, AV_LOG_ERROR, ""not all stream headers found\n"");

            return -1;

        }

        pos= url_ftell(bc);

        if(decode_stream_header(nu",2,0,4,0,0,0,0,0,1,0,1,1,0,1,0
19889,FFmpeg,1,"int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)

{

    int ret;



    av_log(s->avctx, AV_LOG_DEBUG, ""reinit context\n"");



    /* 1. streamoff */

    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);

    if (ret)

        av_log(s->avctx, AV_LOG_ERROR, ""capture VIDIOC_STREAMOFF\n"");



    /* 2. unmap the capture buffers (v4l2 and ffmpeg):

     *    we must wait for all references to be released before being allowed

     *    to queue new buffers.

     */

    av_log(s->avctx, AV_LOG_DEBUG, ""waiting for user to release AVBufferRefs\n"");

    if (atomic_load(&s->refcount))

        while(sem_wait(&s->refsync) == -1 && errno == EINTR);



    ff_v4l2_context_release(&s->capture);



    /* 3. get the new capture format */

    ret = ff_v4l2_context_get_format(&s->capture);

    if (ret) {

        av_log(s->avctx, AV_LOG_ERROR, ""query the new capture format\n"");

        return ret;

    }



    /* 4. set the capture format */

    ret = ff_v4l2_context_set_format(&s->capture);

    if ",6,0,4,0,0,1,0,1,1,1,0,1,0,0,0
19892,FFmpeg,1,"static int wsvqa_read_header(AVFormatContext *s,

                             AVFormatParameters *ap)

{

    WsVqaDemuxContext *wsvqa = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st;

    unsigned char *header;

    unsigned char scratch[VQA_PREAMBLE_SIZE];

    unsigned int chunk_tag;

    unsigned int chunk_size;



    /* initialize the video decoder stream */

    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR(ENOMEM);

    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);

    wsvqa->video_stream_index = st->index;

    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

    st->codec->codec_id = CODEC_ID_WS_VQA;

    st->codec->codec_tag = 0;  /* no fourcc */



    /* skip to the start of the VQA header */

    avio_seek(pb, 20, SEEK_SET);



    /* the VQA header needs to go to the decoder */

    st->codec->extradata_size = VQA_HEADER_SIZE;

    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

    header = (unsigned char *)st->codec->extradata;
",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
19908,FFmpeg,1,"int ff_wma_init(AVCodecContext *avctx, int flags2)

{

    WMACodecContext *s = avctx->priv_data;

    int i;

    float bps1, high_freq;

    volatile float bps;

    int sample_rate1;

    int coef_vlc_table;



    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000

        || avctx->channels    <= 0 || avctx->channels    > 2

        || avctx->bit_rate    <= 0)

        return -1;



    ff_fmt_convert_init(&s->fmt_conv, avctx);

    avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);



    if (avctx->codec->id == AV_CODEC_ID_WMAV1) {

        s->version = 1;

    } else {

        s->version = 2;




    /* compute MDCT block size */

    s->frame_len_bits = ff_wma_get_frame_len_bits(avctx->sample_rate,

                                                  s->version, 0);

    s->next_block_len_bits = s->frame_len_bits;

    s->prev_block_len_bits = s->frame_len_bits;

    s->block_len_bits      = s->frame_len_bits;



    s->frame_len = 1 << s->frame_len_bits;

    if (s->use_va",0,0,3,0,0,0,1,0,1,0,0,0,0,0,1
19912,FFmpeg,1,"av_cold int ff_ivi_decode_close(AVCodecContext *avctx)
{
    IVI45DecContext *ctx = avctx->priv_data;
    ivi_free_buffers(&ctx->planes[0]);
    if (ctx->mb_vlc.cust_tab.table)
        ff_free_vlc(&ctx->mb_vlc.cust_tab);
    av_frame_free(&ctx->p_frame);
    return 0;
}",0,0,1,0,0,0,1,1,0,0,0,1,1,1,1
19916,qemu,1,"int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,

                              const char *default_model)

{

    int i, exit_status = 0;



    if (!nd->model)

        nd->model = strdup(default_model);



    if (strcmp(nd->model, ""?"") != 0) {

        for (i = 0 ; models[i]; i++)

            if (strcmp(nd->model, models[i]) == 0)

                return i;



        fprintf(stderr, ""qemu: Unsupported NIC model: %s\n"", nd->model);

        exit_status = 1;

    }



    fprintf(stderr, ""qemu: Supported NIC models: "");

    for (i = 0 ; models[i]; i++)

        fprintf(stderr, ""%s%c"", models[i], models[i+1] ? ',' : '\n');



    exit(exit_status);

}
",2,0,3,0,0,0,0,0,0,0,0,1,1,1,1
19927,qemu,0,"static void virtio_s390_notify(void *opaque, uint16_t vector)

{

    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;

    uint64_t token = s390_virtio_device_vq_token(dev, vector);



    /* XXX kvm dependency! */

    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);

}
",0,0,1,0,0,0,0,0,1,0,0,0,0,1,1
19962,qemu,0,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)

{

    if (throttle_conflicting(cfg, errp)) {

        return false;

    }



    if (!throttle_is_valid(cfg, errp)) {

        return false;

    }



    if (throttle_max_is_missing_limit(cfg, errp)) {

        return false;

    }



    return true;

}
",0,0,3,0,0,0,0,0,0,0,0,1,1,1,1
19965,FFmpeg,1,"static void decode_block(BinkAudioContext *s, short *out, int use_dct)

{

    int ch, i, j, k;

    float q, quant[25];

    int width, coeff;

    GetBitContext *gb = &s->gb;



    if (use_dct)

        skip_bits(gb, 2);



    for (ch = 0; ch < s->channels; ch++) {

        FFTSample *coeffs = s->coeffs_ptr[ch];

        if (s->version_b) {

            coeffs[0] = av_int2flt(get_bits(gb, 32)) * s->root;

            coeffs[1] = av_int2flt(get_bits(gb, 32)) * s->root;

        } else {

            coeffs[0] = get_float(gb) * s->root;

            coeffs[1] = get_float(gb) * s->root;

        }



        for (i = 0; i < s->num_bands; i++) {

            /* constant is result of 0.066399999/log10(M_E) */

            int value = get_bits(gb, 8);

            quant[i] = expf(FFMIN(value, 95) * 0.15289164787221953823f) * s->root;

        }



        k = 0;

        q = quant[0];



        // parse coefficients

        i = 2;

        while (i < s->frame_len) {

            if (s->version_b) {

         ",2,0,3,0,0,1,1,1,1,1,0,0,0,0,0
19966,qemu,1,"void qemu_main_loop_start(void)

{

}
",0,0,0,0,0,0,0,1,1,1,0,0,0,0,0
19976,FFmpeg,1,"static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,

                                 const uint8_t *buf, int size, int64_t pts)

{

    MpegMuxContext *s = ctx->priv_data;

    AVStream *st = ctx->streams[stream_index];

    StreamInfo *stream = st->priv_data;

    int64_t dts;

    int len;



    /* XXX: system clock should be computed precisely, especially for

       CBR case. The current mode gives at least something coherent */

    if (stream_index == s->scr_stream_index)

        s->last_scr = pts;

    

#if 0

    printf(""%d: pts=%0.3f scr=%0.3f\n"", 

           stream_index, pts / 90000.0, s->last_scr / 90000.0);

#endif

    

    /* XXX: currently no way to pass dts, will change soon */

    dts = AV_NOPTS_VALUE;



    /* we assume here that pts != AV_NOPTS_VALUE */

    if (stream->start_pts == AV_NOPTS_VALUE) {

        stream->start_pts = pts;

        stream->start_dts = dts;

    }

    while (size > 0) {

        len = s->packet_data_max_size - stream->buffer_ptr;

  ",1,0,4,0,0,1,0,0,1,0,0,0,1,1,1
19987,qemu,1,"static void cpu_devinit(const char *cpu_model, unsigned int id,

                        uint64_t prom_addr, qemu_irq **cpu_irqs)

{

    CPUState *cs;

    SPARCCPU *cpu;

    CPUSPARCState *env;



    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    env = &cpu->env;



    cpu_sparc_set_id(env, id);

    if (id == 0) {

        qemu_register_reset(main_cpu_reset, cpu);

    } else {

        qemu_register_reset(secondary_cpu_reset, cpu);

        cs = CPU(cpu);

        cs->halted = 1;

    }

    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);

    env->prom_addr = prom_addr;

}
",0,0,2,0,0,0,1,1,1,0,1,0,0,0,0
19998,FFmpeg,0,"av_cold void avcodec_register(AVCodec *codec)

{

    AVCodec **p;

    avcodec_init();

    p = &first_avcodec;

    while (*p != NULL)

        p = &(*p)->next;

    *p          = codec;

    codec->next = NULL;



    if (codec->init_static_data)

        codec->init_static_data(codec);

}
",0,0,1,0,0,1,0,0,0,0,0,0,1,0,0
19999,qemu,1,"static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)

{

    int i;



    if ((p[1] & 0xF) == 3) {

        /* NAA designator type */

        if (p[3] != 8) {

            return -EINVAL;

        }

        *p_wwn = ldq_be_p(p + 4);

        return 0;

    }



    if ((p[1] & 0xF) == 8) {

        /* SCSI name string designator type */

        if (p[3] < 20 || memcmp(&p[4], ""naa."", 4)) {

            return -EINVAL;

        }

        if (p[3] > 20 && p[24] != ',') {

            return -EINVAL;

        }

        *p_wwn = 0;

        for (i = 8; i < 24; i++) {

            char c = toupper(p[i]);

            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);

            *p_wwn = (*p_wwn << 4) | c;

        }

        return 0;

    }



    return -EINVAL;

}
",1,0,5,0,0,0,1,0,0,1,0,1,1,1,0
20000,FFmpeg,1,"static int decode_i_picture_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int pqindex, status = 0;



    /* Prolog common to all frametypes should be done in caller */

    //BF = Buffer Fullness

    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))

    {

        av_log(v->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");

    }



    /* Quantizer stuff */

    pqindex = get_bits(gb, 5);

    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)

        v->pq = pquant_table[0][pqindex];

    else

    {

        v->pq = pquant_table[v->quantizer_mode-1][pqindex];

    }

    if (pqindex < 9) v->halfpq = get_bits(gb, 1);

    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)

        v->pquantizer = get_bits(gb, 1);

    av_log(v->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",

           v->pq, v->halfpq);

#if HAS_ADVANCED_PROFILE

    if (v->profile <= PROFILE_MAIN)

#endif

    {

        if (v->extended_mv) v->mvrange = get_prefix(gb, 0, 3);

        if (v->multires) v->respic = get_",0,0,9,0,0,0,0,0,0,1,0,0,1,1,1
20005,FFmpeg,0,"static void show_stream(AVFormatContext *fmt_ctx, int stream_idx)

{

    AVStream *stream = fmt_ctx->streams[stream_idx];

    AVCodecContext *dec_ctx;

    AVCodec *dec;

    char val_str[128];

    AVDictionaryEntry *tag = NULL;

    AVRational display_aspect_ratio;



    printf(""[STREAM]\n"");



    printf(""index=%d\n"", stream->index);



    if ((dec_ctx = stream->codec)) {

        if ((dec = dec_ctx->codec)) {

            printf(""codec_name=%s\n"", dec->name);

            printf(""codec_long_name=%s\n"", dec->long_name);

        } else {

            printf(""codec_name=unknown\n"");

        }



        printf(""codec_type=%s\n"", media_type_string(dec_ctx->codec_type));

        printf(""codec_time_base=%d/%d\n"",

               dec_ctx->time_base.num, dec_ctx->time_base.den);



        /* print AVI/FourCC tag */

        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);

        printf(""codec_tag_string=%s\n"", val_str);

        printf(""codec_tag=0x%04x\n"", dec_ctx->codec_tag);


",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
20019,FFmpeg,0,"static void encode_block(MpegEncContext *s, int16_t *block, int n)

{

    int i, j, table_id;

    int component, dc, last_index, val, run;

    MJpegContext *m = s->mjpeg_ctx;



    /* DC coef */

    component = (n <= 3 ? 0 : (n&1) + 1);

    table_id = (n <= 3 ? 0 : 1);

    dc = block[0]; /* overflow is impossible */

    val = dc - s->last_dc[component];



    ff_mjpeg_encode_coef(m, table_id, val, 0);



    s->last_dc[component] = dc;



    /* AC coefs */



    run = 0;

    last_index = s->block_last_index[n];

    table_id |= 2;



    for(i=1;i<=last_index;i++) {

        j = s->intra_scantable.permutated[i];

        val = block[j];



        if (val == 0) {

            run++;

        } else {

            while (run >= 16) {

                ff_mjpeg_encode_code(m, table_id, 0xf0);

                run -= 16;

            }

            ff_mjpeg_encode_coef(m, table_id, val, run);

            run = 0;

        }

    }



    /* output EOB only if not already 64 values */

    if (last_in",1,0,2,0,0,1,0,0,0,0,0,0,1,1,1
20022,FFmpeg,0,"static void RENAME(swScale)(SwsContext *c, uint8_t* srcParam[], int srcStrideParam[], int srcSliceY,

             int srcSliceH, uint8_t* dstParam[], int dstStride[]){



	/* load a few things into local vars to make the code more readable? and faster */

	const int srcW= c->srcW;

	const int dstW= c->dstW;

	const int dstH= c->dstH;

	const int chrDstW= c->chrDstW;

	const int lumXInc= c->lumXInc;

	const int chrXInc= c->chrXInc;

	const int dstFormat= c->dstFormat;

	const int flags= c->flags;

	const int canMMX2BeUsed= c->canMMX2BeUsed;

	int16_t *vLumFilterPos= c->vLumFilterPos;

	int16_t *vChrFilterPos= c->vChrFilterPos;

	int16_t *hLumFilterPos= c->hLumFilterPos;

	int16_t *hChrFilterPos= c->hChrFilterPos;

	int16_t *vLumFilter= c->vLumFilter;

	int16_t *vChrFilter= c->vChrFilter;

	int16_t *hLumFilter= c->hLumFilter;

	int16_t *hChrFilter= c->hChrFilter;

	int16_t *lumMmxFilter= c->lumMmxFilter;

	int16_t *chrMmxFilter= c->chrMmxFilter;

	const int vLumFilterSize= c->vLumFilterSize;

	const int vChrFi",0,0,0,0,0,0,1,0,1,0,0,1,1,0,0
20026,qemu,1,"static int vscsi_queue_cmd(VSCSIState *s, vscsi_req *req)

{

    union srp_iu *srp = &req->iu.srp;

    SCSIDevice *sdev;

    int n, id, lun;



    vscsi_decode_id_lun(be64_to_cpu(srp->cmd.lun), &id, &lun);



    /* Qemu vs. linux issue with LUNs to be sorted out ... */

    sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL;

    if (!sdev) {

        dprintf(""VSCSI: Command for id %d with no drive\n"", id);

        if (srp->cmd.cdb[0] == INQUIRY) {

            vscsi_inquiry_no_target(s, req);

        } else {

            vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0x00);

            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);

        } return 1;

    }



    req->sdev = sdev;

    req->lun = lun;

    n = sdev->info->send_command(sdev, req->qtag, srp->cmd.cdb, lun);



    dprintf(""VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\n"",

            req->qtag, srp->cmd.cdb[0], id, lun, n);



    if (n) {

        /* Transfer direction must be set before preprocessing the

    ",2,0,3,0,0,0,0,0,0,0,0,0,1,1,1
20032,qemu,1,"static int do_sendv_recvv(int sockfd, struct iovec *iov, int len, int offset,

                          int do_sendv)

{

    int ret, diff, iovlen;

    struct iovec *last_iov;



    /* last_iov is inclusive, so count from one.  */

    iovlen = 1;

    last_iov = iov;

    len += offset;



    while (last_iov->iov_len < len) {

        len -= last_iov->iov_len;



        last_iov++;

        iovlen++;

    }



    diff = last_iov->iov_len - len;

    last_iov->iov_len -= diff;



    while (iov->iov_len <= offset) {

        offset -= iov->iov_len;



        iov++;

        iovlen--;

    }



    iov->iov_base = (char *) iov->iov_base + offset;

    iov->iov_len -= offset;



    {

#if defined CONFIG_IOVEC && defined CONFIG_POSIX

        struct msghdr msg;

        memset(&msg, 0, sizeof(msg));

        msg.msg_iov = iov;

        msg.msg_iovlen = iovlen;



        do {

            if (do_sendv) {

                ret = sendmsg(sockfd, &msg, 0);

            } else {

                ret = recvms",0,0,5,0,0,2,1,1,1,1,1,1,1,1,1
20035,FFmpeg,1,"static int vp9_decode_frame(AVCodecContext *ctx, void *frame,

                            int *got_frame, AVPacket *pkt)

{

    const uint8_t *data = pkt->data;

    int size = pkt->size;

    VP9Context *s = ctx->priv_data;

    int res, tile_row, tile_col, i, ref, row, col;

    int retain_segmap_ref = s->s.frames[REF_FRAME_SEGMAP].segmentation_map &&

                            (!s->s.h.segmentation.enabled || !s->s.h.segmentation.update_map);

    ptrdiff_t yoff, uvoff, ls_y, ls_uv;

    AVFrame *f;

    int bytesperpixel;



    if ((res = decode_frame_header(ctx, data, size, &ref)) < 0) {

        return res;

    } else if (res == 0) {

        if (!s->s.refs[ref].f->buf[0]) {

            av_log(ctx, AV_LOG_ERROR, ""Requested reference %d not available\n"", ref);

            return AVERROR_INVALIDDATA;

        }

        if ((res = av_frame_ref(frame, s->s.refs[ref].f)) < 0)

            return res;

        ((AVFrame *)frame)->pts = pkt->pts;

#if FF_API_PKT_PTS

FF_DISABLE_DEPRECATION_WARNINGS

 ",0,0,6,0,0,0,0,1,0,1,0,0,1,0,0
20054,qemu,0,"static uint64_t gt64120_readl (void *opaque,

                               target_phys_addr_t addr, unsigned size)

{

    GT64120State *s = opaque;

    PCIHostState *phb = PCI_HOST_BRIDGE(s);

    uint32_t val;

    uint32_t saddr;



    saddr = (addr & 0xfff) >> 2;

    switch (saddr) {



    /* CPU Configuration */

    case GT_MULTI:

        /* Only one GT64xxx is present on the CPU bus, return

           the initial value */

        val = s->regs[saddr];

        break;



    /* CPU Error Report */

    case GT_CPUERR_ADDRLO:

    case GT_CPUERR_ADDRHI:

    case GT_CPUERR_DATALO:

    case GT_CPUERR_DATAHI:

    case GT_CPUERR_PARITY:

        /* Emulated memory has no error, always return the initial

           values */

        val = s->regs[saddr];

        break;



    /* CPU Sync Barrier */

    case GT_PCI0SYNC:

    case GT_PCI1SYNC:

        /* Reading those register should empty all FIFO on the PCI

           bus, which are not emulated. The return value should be

           a ran",0,0,0,0,1,0,0,0,0,0,0,0,1,1,0
20070,qemu,0,"int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)

{

    QemuOpt *opt;



    opt = qemu_opt_find(opts, name);

    if (!opt) {

        QemuOptDesc *desc = opts->list->desc;

        int i;



        for (i = 0; desc[i].name != NULL; i++) {

            if (strcmp(desc[i].name, name) == 0) {

                break;

            }

        }

        if (desc[i].name == NULL) {

            if (i == 0) {

                /* empty list -> allow any */;

            } else {

                fprintf(stderr, ""option \""%s\"" is not valid for %s\n"",

                        name, opts->list->name);

                return -1;

            }

        }

        opt = qemu_mallocz(sizeof(*opt));

        opt->name = qemu_strdup(name);

        opt->opts = opts;

        TAILQ_INSERT_TAIL(&opts->head, opt, next);

        if (desc[i].name != NULL) {

            opt->desc = desc+i;

        }

    }

    qemu_free((/* !const */ char*)opt->str);

    opt->str = NULL;

    if (value) {

        opt",2,0,6,0,0,0,1,1,1,1,1,0,0,0,0
20086,qemu,0,"static int scsi_initfn(SCSIDevice *dev)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);

    Error *err = NULL;



    if (!s->qdev.conf.bs) {

        error_report(""drive property not set"");

        return -1;

    }



    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&

        !bdrv_is_inserted(s->qdev.conf.bs)) {

        error_report(""Device needs media, but drive is empty"");

        return -1;

    }



    blkconf_serial(&s->qdev.conf, &s->serial);

    if (dev->type == TYPE_DISK) {

        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);

        if (err) {

            error_report(""%s"", error_get_pretty(err));

            error_free(err);

            return -1;

        }

    }



    if (s->qdev.conf.discard_granularity == -1) {

        s->qdev.conf.discard_granularity =

            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);

    }



    if (!s->version) {

        s->version = g_strdup(qemu_get_version());

    }

    if (!s->vendor)",0,0,7,0,0,0,0,1,0,0,0,0,1,1,1
20095,qemu,0,"static void ehci_update_frindex(EHCIState *ehci, int frames)

{

    int i;



    if (!ehci_enabled(ehci)) {

        return;

    }



    for (i = 0; i < frames; i++) {

        ehci->frindex += 8;



        if (ehci->frindex == 0x00002000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

        }



        if (ehci->frindex == 0x00004000) {

            ehci_raise_irq(ehci, USBSTS_FLR);

            ehci->frindex = 0;

            if (ehci->usbsts_frindex >= 0x00004000) {

                ehci->usbsts_frindex -= 0x00004000;

            } else {

                ehci->usbsts_frindex = 0;

            }

        }

    }

}
",1,0,4,0,0,0,0,1,1,0,0,0,1,1,1
20102,FFmpeg,0,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)

{

    while (uls->id != CODEC_ID_NONE) {

        if(mxf_match_uid(uls->uid, *uid, 16))

            break;

        uls++;

    }

    return uls;

}
",0,0,1,0,0,1,0,1,1,0,1,1,0,0,0
20105,qemu,0,"static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *s = chr->opaque;



    if (!connected) {

        if (s->fd_tag) {

            g_source_remove(s->fd_tag);

            s->fd_tag = 0;

        }

        s->connected = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->connected)

            qemu_chr_be_generic_open(chr);

        s->connected = 1;

    }

}
",1,0,3,0,0,0,0,1,0,1,0,0,1,1,1
20109,FFmpeg,1,"int h263_decode_picture_header(MpegEncContext *s)

{

    int format, width, height;



    /* picture header */

    if (get_bits(&s->gb, 22) != 0x20)

        return -1;

    skip_bits(&s->gb, 8); /* picture timestamp */



    if (get_bits1(&s->gb) != 1)

        return -1;	/* marker */

    if (get_bits1(&s->gb) != 0)

        return -1;	/* h263 id */

    skip_bits1(&s->gb);	/* split screen off */

    skip_bits1(&s->gb);	/* camera  off */

    skip_bits1(&s->gb);	/* freeze picture release off */



    format = get_bits(&s->gb, 3);



    if (format != 7) {

        s->h263_plus = 0;

        /* H.263v1 */

        width = h263_format[format][0];

        height = h263_format[format][1];

        if (!width)

            return -1;



        s->pict_type = I_TYPE + get_bits1(&s->gb);



        s->unrestricted_mv = get_bits1(&s->gb); 

        s->h263_long_vectors = s->unrestricted_mv;



        if (get_bits1(&s->gb) != 0)

            return -1;	/* SAC: off */

        if (get_bits1(&s->gb) != 0)

  ",7,0,7,0,0,0,1,1,1,1,1,0,1,0,1
20110,qemu,1,"static void stellaris_init(const char *kernel_filename, const char *cpu_model,

                           DisplayState *ds, stellaris_board_info *board)

{

    static const int uart_irq[] = {5, 6, 33, 34};

    static const int timer_irq[] = {19, 21, 23, 35};

    static const uint32_t gpio_addr[7] =

      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,

        0x40024000, 0x40025000, 0x40026000};

    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};



    qemu_irq *pic;

    qemu_irq *gpio_in[5];

    qemu_irq *gpio_out[5];

    qemu_irq adc;

    int sram_size;

    int flash_size;

    i2c_bus *i2c;

    int i;



    flash_size = ((board->dc0 & 0xffff) + 1) << 1;

    sram_size = (board->dc0 >> 18) + 1;

    pic = armv7m_init(flash_size, sram_size, kernel_filename, cpu_model);



    if (board->dc1 & (1 << 16)) {

        adc = stellaris_adc_init(0x40038000, pic[14]);

    } else {

        adc = NULL;

    }

    for (i = 0; i < 4; i++) {

        if (board->dc2 & (0x10000 << i)) {

       ",1,0,2,0,0,0,1,1,1,1,1,0,1,0,0
20129,FFmpeg,1,"static void do_video_out(AVFormatContext *s,

                         OutputStream *ost,

                         InputStream *ist,

                         AVFrame *in_picture,

                         int *frame_size, float quality)

{

    int nb_frames, i, ret, av_unused resample_changed;

    AVFrame *final_picture, *formatted_picture;

    AVCodecContext *enc, *dec;

    double sync_ipts;



    enc = ost->st->codec;

    dec = ist->st->codec;



    sync_ipts = get_sync_ipts(ost) / av_q2d(enc->time_base);



    /* by default, we output a single frame */

    nb_frames = 1;



    *frame_size = 0;



    if(video_sync_method){

        double vdelta = sync_ipts - ost->sync_opts;

        //FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c

        if (vdelta < -1.1)

            nb_frames = 0;

        else if (video_sync_method == 2 || (video_sync_method<0 && (s->oformat->flags & AVFMT_VARIABLE_FPS))){

            if(vdelta<=-0.6){

                nb_frames=0;

            }else i",2,0,4,0,0,0,0,0,0,0,0,0,1,1,1
20131,qemu,1,"static void continue_after_map_failure(void *opaque)

{

    DMAAIOCB *dbs = (DMAAIOCB *)opaque;



    dbs->bh = qemu_bh_new(reschedule_dma, dbs);

    qemu_bh_schedule(dbs->bh);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,1,1
20148,qemu,0,"static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)

{

    EHCIState *s = ptr;

    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);

    uint32_t old = *mmio;

    int i;



    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);



    /* Only aligned reads are allowed on OHCI */

    if (addr & 3) {

        fprintf(stderr, ""usb-ehci: Mis-aligned write to addr 0x""

                TARGET_FMT_plx ""\n"", addr);

        return;

    }



    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {

        handle_port_status_write(s, (addr-PORTSC)/4, val);

        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);

        return;

    }



    if (addr < OPREGBASE) {

        fprintf(stderr, ""usb-ehci: write attempt to read-only register""

                TARGET_FMT_plx ""\n"", addr);

        return;

    }





    /* Do any register specific pre-write processing here.  */

    switch(addr) {

    case USBCMD:

        if (val & USBCMD_HCRESET) {

            ehci_reset(s",0,0,4,0,1,0,0,0,0,0,0,0,0,0,0
20151,qemu,0,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,1
20158,qemu,0,"uint64_t helper_fnmadd (uint64_t arg1, uint64_t arg2, uint64_t arg3)

{

    CPU_DoubleU farg1, farg2, farg3;



    farg1.ll = arg1;

    farg2.ll = arg2;

    farg3.ll = arg3;



    if (unlikely(float64_is_signaling_nan(farg1.d) ||

                 float64_is_signaling_nan(farg2.d) ||

                 float64_is_signaling_nan(farg3.d))) {

        /* sNaN operation */

        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);

    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||

                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {

        /* Multiplication of zero by infinity */

        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);

    } else {

#if USE_PRECISE_EMULATION

#ifdef FLOAT128

        /* This is the way the PowerPC specification defines it */

        float128 ft0_128, ft1_128;



        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);

        ft1_128 = float64_to_float128(farg2.d, &env->fp_sta",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
20189,qemu,0,"static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)

{

    const struct cow_header_v2 *cow_header = (const void *)buf;



    if (buf_size >= sizeof(struct cow_header_v2) &&

        be32_to_cpu(cow_header->magic) == COW_MAGIC &&

        be32_to_cpu(cow_header->version) == COW_VERSION)

        return 100;

    else

        return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
20197,qemu,0,"uint64_t ram_bytes_remaining(void)

{

    return ram_save_remaining() * TARGET_PAGE_SIZE;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
20199,FFmpeg,0,"static int decode_ics(AACContext * ac, SingleChannelElement * sce, GetBitContext * gb, int common_window, int scale_flag) {

    Pulse pulse;

    TemporalNoiseShaping * tns = &sce->tns;

    IndividualChannelStream * ics = &sce->ics;

    float * out = sce->coeffs;

    int global_gain, pulse_present = 0;



    /* This assignment is to silence a GCC warning about the variable being used

     * uninitialized when in fact it always is.

     */

    pulse.num_pulse = 0;



    global_gain = get_bits(gb, 8);



    if (!common_window && !scale_flag) {

        if (decode_ics_info(ac, ics, gb, 0) < 0)

            return -1;

    }



    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)

        return -1;

    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)

        return -1;



    pulse_present = 0;

    if (!scale_flag) {

        if ((pulse_present = get_bits1(gb))) {

            if (ics->window_sequence[0] == EIGHT_S",0,0,7,0,0,0,0,0,1,0,0,0,0,1,0
20200,qemu,0,"static ssize_t buffered_flush(QEMUFileBuffered *s)

{

    size_t offset = 0;

    ssize_t ret = 0;



    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);



    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {

        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);

        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,

                                    to_send);

        if (ret <= 0) {

            DPRINTF(""error flushing data, %zd\n"", ret);

            break;

        } else {

            DPRINTF(""flushed %zd byte(s)\n"", ret);

            offset += ret;

            s->bytes_xfer += ret;

        }

    }



    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);

    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);

    s->buffer_size -= offset;



    if (ret < 0) {

        return ret;

    }

    return offset;

}
",0,0,2,0,0,1,1,1,1,0,0,0,1,0,1
20213,qemu,0,"void pci_qdev_register(PCIDeviceInfo *info)

{

    info->qdev.init = pci_qdev_init;

    info->qdev.bus_type = BUS_TYPE_PCI;

    qdev_register(&info->qdev);

}
",0,0,0,0,0,0,1,1,1,0,0,1,0,0,0
20233,qemu,0,"static void vhost_net_stop_one(struct vhost_net *net,

                               VirtIODevice *dev)

{

    struct vhost_vring_file file = { .fd = -1 };



    if (!net->dev.started) {

        return;

    }



    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {

        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {

            const VhostOps *vhost_ops = net->dev.vhost_ops;

            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,

                                          &file);

            assert(r >= 0);

        }

    }

    if (net->nc->info->poll) {

        net->nc->info->poll(net->nc, true);

    }

    vhost_dev_stop(&net->dev, dev);

    vhost_dev_disable_notifiers(&net->dev, dev);

}
",1,0,4,0,0,0,0,0,0,0,0,0,1,1,1
20237,FFmpeg,0,"static int rtsp_read_header(AVFormatContext *s,

                            AVFormatParameters *ap)

{

    RTSPState *rt = s->priv_data;

    char host[1024], path[1024], tcpname[1024], cmd[2048];

    URLContext *rtsp_hd;

    int port, i, ret, err;

    RTSPHeader reply1, *reply = &reply1;

    unsigned char *content = NULL;

    AVStream *st;

    RTSPStream *rtsp_st;

    int protocol_mask;



    rtsp_abort_req = 0;

    

    /* extract hostname and port */

    url_split(NULL, 0,

              host, sizeof(host), &port, path, sizeof(path), s->filename);

    if (port < 0)

        port = RTSP_DEFAULT_PORT;



    /* open the tcp connexion */

    snprintf(tcpname, sizeof(tcpname), ""tcp://%s:%d"", host, port);

    if (url_open(&rtsp_hd, tcpname, URL_RDWR) < 0)

        return AVERROR_IO;

    rt->rtsp_hd = rtsp_hd;

    rt->seq = 0;

    

    /* describe the stream */

    snprintf(cmd, sizeof(cmd), 

             ""DESCRIBE %s RTSP/1.0\r\n""

             ""Accept: application/sdp\r\n"",

             ",0,0,2,0,0,0,0,0,0,1,1,1,1,1,1
20238,qemu,0,"int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,

                                int mmu_idx, int is_softmmu)

{

    target_ulong phys;

    int prot;



    /* XXX: implement mmu */



    phys = address;

    prot = PAGE_READ | PAGE_WRITE;



    return tlb_set_page(env, address & TARGET_PAGE_MASK,

                        phys & TARGET_PAGE_MASK, prot,

                        mmu_idx, is_softmmu);

}
",0,0,0,0,0,0,1,1,0,1,1,0,1,1,1
20248,qemu,0,"static int inc_refcounts(BlockDriverState *bs,

                         BdrvCheckResult *res,

                         void **refcount_table,

                         int64_t *refcount_table_size,

                         int64_t offset, int64_t size)

{

    BDRVQcow2State *s = bs->opaque;

    uint64_t start, last, cluster_offset, k, refcount;

    int ret;



    if (size <= 0) {

        return 0;

    }



    start = start_of_cluster(s, offset);

    last = start_of_cluster(s, offset + size - 1);

    for(cluster_offset = start; cluster_offset <= last;

        cluster_offset += s->cluster_size) {

        k = cluster_offset >> s->cluster_bits;

        if (k >= *refcount_table_size) {

            ret = realloc_refcount_array(s, refcount_table,

                                         refcount_table_size, k + 1);

            if (ret < 0) {

                res->check_errors++;

                return ret;

            }

        }



        refcount = s->get_refcount(*refcount_table, k);

      ",1,0,3,0,0,0,0,0,0,0,0,0,1,1,1
20257,qemu,0,"static void gic_do_cpu_write(void *opaque, target_phys_addr_t addr,

                             uint64_t value, unsigned size)

{

    GICState **backref = (GICState **)opaque;

    GICState *s = *backref;

    int id = (backref - s->backref);

    gic_cpu_write(s, id, addr, value);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
20282,qemu,0,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)

{

    val = cpu_to_be64(val);

    cpu_physical_memory_write(addr, &val, 8);

}
",0,0,0,0,0,0,1,0,1,0,1,0,1,1,1
20283,qemu,0,"static int fb_initialise(struct XenDevice *xendev)

{

    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);

    struct xenfb_page *fb_page;

    int videoram;

    int rc;



    if (xenstore_read_fe_int(xendev, ""videoram"", &videoram) == -1)

	videoram = 0;



    rc = common_bind(&fb->c);

    if (rc != 0)

	return rc;



    fb_page = fb->c.page;

    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,

			    fb_page->width, fb_page->height, fb_page->depth,

			    fb_page->mem_length, 0, fb_page->line_length);

    if (rc != 0)

	return rc;



    rc = xenfb_map_fb(fb);

    if (rc != 0)

	return rc;



#if 0  /* handled in xen_init_display() for now */

    if (!fb->have_console) {

        fb->c.ds = graphic_console_init(xenfb_update,

                                        xenfb_invalidate,

                                        NULL,

                                        NULL,

                                        fb);

        fb->have_console = 1;

    }

#endif



    if ",0,0,8,0,0,0,0,0,0,0,0,0,1,0,1
20299,qemu,0,"static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    }

}
",0,0,0,0,1,0,0,0,0,0,0,0,1,1,1
20301,qemu,0,"bool is_valid_option_list(const char *param)

{

    size_t buflen = strlen(param) + 1;

    char *buf = g_malloc(buflen);

    const char *p = param;

    bool result = true;



    while (*p) {

        p = get_opt_value(buf, buflen, p);

        if (*p && !*++p) {

            result = false;

            goto out;

        }



        if (!*buf || *buf == ',') {

            result = false;

            goto out;

        }

    }



out:

    free(buf);

    return result;

}
",0,2,2,0,0,1,1,1,1,1,1,0,0,0,0
20305,FFmpeg,1,"int ff_h264_alloc_tables(H264Context *h){

    MpegEncContext * const s = &h->s;

    const int big_mb_num= s->mb_stride * (s->mb_height+1);

    const int row_mb_num= 2*s->mb_stride*s->avctx->thread_count;

    int x,y;



    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode, row_mb_num * 8  * sizeof(uint8_t), fail)



    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->non_zero_count    , big_mb_num * 48 * sizeof(uint8_t), fail)

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(*h->slice_table_base), fail)

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->cbp_table, big_mb_num * sizeof(uint16_t), fail)



    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t), fail)

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0], 16*row_mb_num * sizeof(uint8_t), fail);

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);

    FF_ALLOCZ_OR_GOTO(h->s.avctx, h->direct_table, 4*big_mb_num * sizeof(uint8_t) , fail);

    FF_ALLOCZ_OR",0,0,0,0,0,0,0,1,1,1,1,1,1,1,1
20320,FFmpeg,0,"static inline CopyRet copy_frame(AVCodecContext *avctx,

                                 BC_DTS_PROC_OUT *output,

                                 void *data, int *data_size,

                                 uint8_t second_field)

{

    BC_STATUS ret;

    BC_DTS_STATUS decoder_status;

    uint8_t is_paff;

    uint8_t next_frame_same;

    uint8_t interlaced;



    CHDContext *priv = avctx->priv_data;



    uint8_t bottom_field = (output->PicInfo.flags & VDEC_FLAG_BOTTOMFIELD) ==

                           VDEC_FLAG_BOTTOMFIELD;

    uint8_t bottom_first = !!(output->PicInfo.flags & VDEC_FLAG_BOTTOM_FIRST);



    int width    = output->PicInfo.width;

    int height   = output->PicInfo.height;

    int bwidth;

    uint8_t *src = output->Ybuff;

    int sStride;

    uint8_t *dst;

    int dStride;



    ret = DtsGetDriverStatus(priv->dev, &decoder_status);

    if (ret != BC_STS_SUCCESS) {

        av_log(avctx, AV_LOG_ERROR,

               ""CrystalHD: GetDriverStatus failed: %u\n"", ret);

      ",0,0,1,0,0,0,1,0,1,1,0,0,0,0,0
20327,qemu,1,"static void net_l2tpv3_cleanup(NetClientState *nc)

{

    NetL2TPV3State *s = DO_UPCAST(NetL2TPV3State, nc, nc);

    qemu_purge_queued_packets(nc);

    l2tpv3_read_poll(s, false);

    l2tpv3_write_poll(s, false);

    if (s->fd > 0) {

        close(s->fd);

    }

    destroy_vector(s->msgvec, MAX_L2TPV3_MSGCNT, IOVSIZE);

    g_free(s->vec);

    g_free(s->header_buf);

    g_free(s->dgram_dst);

}
",0,0,1,0,0,0,0,0,0,0,1,1,1,1,1
20328,qemu,1,"static AioHandler *find_aio_handler(int fd)

{

    AioHandler *node;



    LIST_FOREACH(node, &aio_handlers, node) {

        if (node->fd == fd)

            return node;

    }



    return NULL;

}
",0,0,1,0,0,0,1,0,0,0,0,0,0,0,0
20338,FFmpeg,0,"static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16_t *lumSrc, const int16_t *chrSrc, const int16_t *alpSrc,

                                    uint8_t *dest, uint8_t *uDest, uint8_t *vDest, uint8_t *aDest, long dstW, long chrDstW)

{

    int i;

#if COMPILE_TEMPLATE_MMX

    if(!(c->flags & SWS_BITEXACT)) {

        long p= 4;

        const int16_t *src[4]= {alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW};

        uint8_t *dst[4]= {aDest, dest, uDest, vDest};

        x86_reg counter[4]= {dstW, dstW, chrDstW, chrDstW};



        if (c->flags & SWS_ACCURATE_RND) {

            while(p--) {

                if (dst[p]) {

                    __asm__ volatile(

                        YSCALEYUV2YV121_ACCURATE

                        :: ""r"" (src[p]), ""r"" (dst[p] + counter[p]),

                        ""g"" (-counter[p])

                        : ""%""REG_a

                    );

                }

            }

        } else {

            while(p--) {

              ",0,0,4,0,0,2,1,1,1,1,0,1,0,0,0
20345,qemu,1,"int x86_cpu_gdb_write_register(CPUState *cs, uint8_t *mem_buf, int n)

{

    X86CPU *cpu = X86_CPU(cs);

    CPUX86State *env = &cpu->env;

    uint32_t tmp;



    if (n < CPU_NB_REGS) {

        if (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK) {

            env->regs[gpr_map[n]] = ldtul_p(mem_buf);

            return sizeof(target_ulong);

        } else if (n < CPU_NB_REGS32) {

            n = gpr_map32[n];

            env->regs[n] &= ~0xffffffffUL;

            env->regs[n] |= (uint32_t)ldl_p(mem_buf);

            return 4;

        }

    } else if (n >= IDX_FP_REGS && n < IDX_FP_REGS + 8) {

#ifdef USE_X86LDOUBLE

        /* FIXME: byteswap float values - after fixing fpregs layout. */

        memcpy(&env->fpregs[n - IDX_FP_REGS], mem_buf, 10);

#endif

        return 10;

    } else if (n >= IDX_XMM_REGS && n < IDX_XMM_REGS + CPU_NB_REGS) {

        n -= IDX_XMM_REGS;

        if (n < CPU_NB_REGS32 ||

            (TARGET_LONG_BITS == 64 && env->hflags & HF_CS64_MASK)) {

            en",0,0,8,0,0,0,1,1,1,1,1,1,0,0,1
20352,FFmpeg,0,"int ff_h264_decode_seq_parameter_set(GetBitContext *gb, AVCodecContext *avctx,

                                     H264ParamSets *ps)

{

    AVBufferRef *sps_buf;

    int profile_idc, level_idc, constraint_set_flags = 0;

    unsigned int sps_id;

    int i, log2_max_frame_num_minus4;

    SPS *sps;



    profile_idc           = get_bits(gb, 8);

    constraint_set_flags |= get_bits1(gb) << 0;   // constraint_set0_flag

    constraint_set_flags |= get_bits1(gb) << 1;   // constraint_set1_flag

    constraint_set_flags |= get_bits1(gb) << 2;   // constraint_set2_flag

    constraint_set_flags |= get_bits1(gb) << 3;   // constraint_set3_flag

    constraint_set_flags |= get_bits1(gb) << 4;   // constraint_set4_flag

    constraint_set_flags |= get_bits1(gb) << 5;   // constraint_set5_flag

    skip_bits(gb, 2);                             // reserved_zero_2bits

    level_idc = get_bits(gb, 8);

    sps_id    = get_ue_golomb_31(gb);



    if (sps_id >= MAX_SPS_COUNT) {

        av_log(avctx, AV_LOG_ERROR,",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
20365,qemu,0,"static void cchip_write(void *opaque, hwaddr addr,

                        uint64_t val, unsigned size)

{

    TyphoonState *s = opaque;

    uint64_t oldval, newval;



    switch (addr) {

    case 0x0000:

        /* CSC: Cchip System Configuration Register.  */

        /* All sorts of data here; nothing relevant RW.  */

        break;



    case 0x0040:

        /* MTR: Memory Timing Register.  */

        /* All sorts of stuff related to real DRAM.  */

        break;



    case 0x0080:

        /* MISC: Miscellaneous Register.  */

        newval = oldval = s->cchip.misc;

        newval &= ~(val & 0x10000ff0);     /* W1C fields */

        if (val & 0x100000) {

            newval &= ~0xff0000ull;        /* ACL clears ABT and ABW */

        } else {

            newval |= val & 0x00f00000;    /* ABT field is W1S */

            if ((newval & 0xf0000) == 0) {

                newval |= val & 0xf0000;   /* ABW field is W1S iff zero */

            }

        }

        newval |= (val & 0xf000) >> ",0,0,2,0,1,0,0,0,0,0,0,0,1,0,0
20368,qemu,0,"static void exynos4210_combiner_write(void *opaque, target_phys_addr_t offset,

        uint64_t val, unsigned size)

{

    struct Exynos4210CombinerState *s =

            (struct Exynos4210CombinerState *)opaque;

    uint32_t req_quad_base_n;    /* Base of registers quad. Multiply it by 4 and

                                   get a start of corresponding group quad */

    uint32_t grp_quad_base_n;    /* Base of group quad */

    uint32_t reg_n;              /* Register number inside the quad */



    req_quad_base_n = offset >> 4;

    grp_quad_base_n = req_quad_base_n << 2;

    reg_n = (offset - (req_quad_base_n << 4)) >> 2;



    if (req_quad_base_n >= IIC_NGRP) {

        hw_error(""exynos4210.combiner: unallowed write access at offset 0x""

                TARGET_FMT_plx ""\n"", offset);

        return;

    }



    if (reg_n > 1) {

        hw_error(""exynos4210.combiner: unallowed write access at offset 0x""

                TARGET_FMT_plx ""\n"", offset);

        return;

    }



    if (offset ",0,0,3,0,0,0,0,0,1,0,0,0,1,1,1
20370,qemu,0,"static void bt_submit_acl(struct HCIInfo *info,

                const uint8_t *data, int length)

{

    struct bt_hci_s *hci = hci_from_info(info);

    uint16_t handle;

    int datalen, flags;

    struct bt_link_s *link;



    if (length < HCI_ACL_HDR_SIZE) {

        fprintf(stderr, ""%s: ACL packet too short (%iB)\n"",

                        __FUNCTION__, length);

        return;

    }



    handle = acl_handle((data[1] << 8) | data[0]);

    flags = acl_flags((data[1] << 8) | data[0]);

    datalen = (data[3] << 8) | data[2];

    data += HCI_ACL_HDR_SIZE;

    length -= HCI_ACL_HDR_SIZE;



    if (bt_hci_handle_bad(hci, handle)) {

        fprintf(stderr, ""%s: invalid ACL handle %03x\n"",

                        __FUNCTION__, handle);

        /* TODO: signal an error */

        return;

    }

    handle &= ~HCI_HANDLE_OFFSET;



    if (datalen > length) {

        fprintf(stderr, ""%s: ACL packet too short (%iB < %iB)\n"",

                        __FUNCTION__, length, datalen);

        retur",0,0,3,0,0,0,0,1,1,1,0,0,1,1,1
20398,qemu,0,"static int nbd_co_flush(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    return nbd_client_session_co_flush(&s->client);

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
20410,qemu,0,"static int qiov_is_aligned(QEMUIOVector *qiov)

{

    int i;



    for (i = 0; i < qiov->niov; i++) {

        if ((uintptr_t) qiov->iov[i].iov_base % BDRV_SECTOR_SIZE) {

            return 0;

        }

    }



    return 1;

}
",1,0,1,0,0,0,0,0,0,0,0,0,0,1,0
20422,FFmpeg,1,"static int seqvideo_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;



    SeqVideoContext *seq = avctx->priv_data;



    seq->frame.reference = 1;

    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &seq->frame)) {

        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");

        return -1;

    }



    seqvideo_decode(seq, buf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = seq->frame;



    return buf_size;

}
",0,0,1,0,0,0,0,0,0,0,0,1,1,1,1
20425,qemu,1,"static ssize_t imx_fec_receive(NetClientState *nc, const uint8_t *buf,

                               size_t len)

{

    IMXFECState *s = IMX_FEC(qemu_get_nic_opaque(nc));

    IMXFECBufDesc bd;

    uint32_t flags = 0;

    uint32_t addr;

    uint32_t crc;

    uint32_t buf_addr;

    uint8_t *crc_ptr;

    unsigned int buf_len;

    size_t size = len;



    FEC_PRINTF(""len %d\n"", (int)size);



    if (!s->regs[ENET_RDAR]) {

        qemu_log_mask(LOG_GUEST_ERROR, ""[%s]%s: Unexpected packet\n"",

                      TYPE_IMX_FEC, __func__);

        return 0;

    }



    /* 4 bytes for the CRC.  */

    size += 4;

    crc = cpu_to_be32(crc32(~0, buf, size));

    crc_ptr = (uint8_t *) &crc;



    /* Huge frames are truncated.  */

    if (size > ENET_MAX_FRAME_SIZE) {

        size = ENET_MAX_FRAME_SIZE;

        flags |= ENET_BD_TR | ENET_BD_LG;

    }



    /* Frames larger than the user limit just set error flags.  */

    if (size > (s->regs[ENET_RCR] >> 16)) {

        flags |= ENET_BD_LG;

 ",0,0,3,0,0,0,0,0,1,0,0,0,0,0,0
20433,qemu,0,"static void breakpoint_handler(CPUState *env)

{

    CPUBreakpoint *bp;



    if (env->watchpoint_hit) {

        if (env->watchpoint_hit->flags & BP_CPU) {

            env->watchpoint_hit = NULL;

            if (check_hw_breakpoints(env, 0))

                raise_exception(EXCP01_DB);

            else

                cpu_resume_from_signal(env, NULL);

        }

    } else {

        TAILQ_FOREACH(bp, &env->breakpoints, entry)

            if (bp->pc == env->eip) {

                if (bp->flags & BP_CPU) {

                    check_hw_breakpoints(env, 1);

                    raise_exception(EXCP01_DB);

                }

                break;

            }

    }

    if (prev_debug_excp_handler)

        prev_debug_excp_handler(env);

}
",0,0,6,0,0,0,0,1,0,1,0,1,0,0,0
20434,qemu,0,"static gboolean gd_button_event(GtkWidget *widget, GdkEventButton *button,

                                void *opaque)

{

    VirtualConsole *vc = opaque;

    GtkDisplayState *s = vc->s;

    InputButton btn;



    /* implicitly grab the input at the first click in the relative mode */

    if (button->button == 1 && button->type == GDK_BUTTON_PRESS &&

        !qemu_input_is_absolute() && !gd_is_grab_active(s)) {

        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(s->grab_item),

                                       TRUE);

        return TRUE;

    }



    if (button->button == 1) {

        btn = INPUT_BUTTON_LEFT;

    } else if (button->button == 2) {

        btn = INPUT_BUTTON_MIDDLE;

    } else if (button->button == 3) {

        btn = INPUT_BUTTON_RIGHT;

    } else {

        return TRUE;

    }



    qemu_input_queue_btn(vc->gfx.dcl.con, btn,

                         button->type == GDK_BUTTON_PRESS);

    qemu_input_event_sync();

    return TRUE;

}
",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
20457,FFmpeg,1,"static void * attribute_align_arg worker(void *v){

    AVCodecContext *avctx = v;

    ThreadContext *c = avctx->internal->frame_thread_encoder;

    AVPacket *pkt = NULL;



    while(!c->exit){

        int got_packet, ret;

        AVFrame *frame;

        Task task;



        if(!pkt) pkt= av_mallocz(sizeof(*pkt));

        if(!pkt) continue;

        av_init_packet(pkt);



        pthread_mutex_lock(&c->task_fifo_mutex);

        while (av_fifo_size(c->task_fifo) <= 0 || c->exit) {

            if(c->exit){

                pthread_mutex_unlock(&c->task_fifo_mutex);

                goto end;

            }

            pthread_cond_wait(&c->task_fifo_cond, &c->task_fifo_mutex);

        }

        av_fifo_generic_read(c->task_fifo, &task, sizeof(task), NULL);

        pthread_mutex_unlock(&c->task_fifo_mutex);

        frame = task.indata;



        ret = avcodec_encode_video2(avctx, pkt, frame, &got_packet);

        pthread_mutex_lock(&c->buffer_mutex);

        av_frame_unref(frame);

        pth",0,1,12,0,0,2,1,1,1,1,1,1,0,0,1
20467,qemu,1,"static void _decode_opc(DisasContext * ctx)

{

    /* This code tries to make movcal emulation sufficiently

       accurate for Linux purposes.  This instruction writes

       memory, and prior to that, always allocates a cache line.

       It is used in two contexts:

       - in memcpy, where data is copied in blocks, the first write

       of to a block uses movca.l for performance.

       - in arch/sh/mm/cache-sh4.c, movcal.l + ocbi combination is used

       to flush the cache. Here, the data written by movcal.l is never

       written to memory, and the data written is just bogus.



       To simulate this, we simulate movcal.l, we store the value to memory,

       but we also remember the previous content. If we see ocbi, we check

       if movcal.l for that address was done previously. If so, the write should

       not have hit the memory, so we restore the previous content.

       When we see an instruction that is neither movca.l

       nor ocbi, the previous content is discarded.



",4,0,1,0,0,0,0,1,0,1,1,1,1,1,1
20471,qemu,1,"void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
20480,qemu,1,"static void pmac_dma_write(BlockBackend *blk,

                         int64_t sector_num, int nb_sectors,

                         void (*cb)(void *opaque, int ret), void *opaque)

{

    DBDMA_io *io = opaque;

    MACIOIDEState *m = io->opaque;

    IDEState *s = idebus_active_if(&m->bus);

    dma_addr_t dma_addr, dma_len;

    void *mem;

    int nsector, remainder;

    int extra = 0;



    qemu_iovec_destroy(&io->iov);

    qemu_iovec_init(&io->iov, io->len / MACIO_PAGE_SIZE + 1);



    if (io->remainder_len > 0) {

        /* Return remainder of request */

        int transfer = MIN(io->remainder_len, io->len);



        MACIO_DPRINTF(""--- processing write remainder %x\n"", transfer);

        cpu_physical_memory_read(io->addr,

                                 &io->remainder + (0x200 - transfer),

                                 transfer);



        io->remainder_len -= transfer;

        io->len -= transfer;

        io->addr += transfer;



        s->io_buffer_index += transfer;

        s-",0,0,2,0,0,0,1,1,1,1,1,1,0,0,0
20485,qemu,0,"static void bdrv_delete(BlockDriverState *bs)

{

    assert(!bs->job);

    assert(bdrv_op_blocker_is_empty(bs));

    assert(!bs->refcnt);

    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    bdrv_close(bs);



    /* remove from list, if necessary */

    bdrv_make_anon(bs);



    g_free(bs);

}
",0,0,0,0,0,0,1,0,0,1,0,1,1,1,1
20495,qemu,0,"static void vtd_iommu_replay(IOMMUMemoryRegion *iommu_mr, IOMMUNotifier *n)

{

    VTDAddressSpace *vtd_as = container_of(iommu_mr, VTDAddressSpace, iommu);

    IntelIOMMUState *s = vtd_as->iommu_state;

    uint8_t bus_n = pci_bus_num(vtd_as->bus);

    VTDContextEntry ce;



    /*

     * The replay can be triggered by either a invalidation or a newly

     * created entry. No matter what, we release existing mappings

     * (it means flushing caches for UNMAP-only registers).

     */

    vtd_address_space_unmap(vtd_as, n);



    if (vtd_dev_to_context_entry(s, bus_n, vtd_as->devfn, &ce) == 0) {

        trace_vtd_replay_ce_valid(bus_n, PCI_SLOT(vtd_as->devfn),

                                  PCI_FUNC(vtd_as->devfn),

                                  VTD_CONTEXT_ENTRY_DID(ce.hi),

                                  ce.hi, ce.lo);

        vtd_page_walk(&ce, 0, ~0ULL, vtd_replay_hook, (void *)n, false);

    } else {

        trace_vtd_replay_ce_invalid(bus_n, PCI_SLOT(vtd_as->devfn),

            ",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
20507,qemu,0,"static inline int sd_wp_addr(SDState *sd, uint32_t addr)

{

    return sd->wp_groups[addr >>

            (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)];

}
",0,0,0,0,0,0,0,1,1,0,1,0,1,1,1
20518,qemu,0,"static void console_handle_escape(QemuConsole *s)

{

    int i;



    for (i=0; i<s->nb_esc_params; i++) {

        switch (s->esc_params[i]) {

            case 0: /* reset all console attributes to default */

                s->t_attrib = s->t_attrib_default;

                break;

            case 1:

                s->t_attrib.bold = 1;

                break;

            case 4:

                s->t_attrib.uline = 1;

                break;

            case 5:

                s->t_attrib.blink = 1;

                break;

            case 7:

                s->t_attrib.invers = 1;

                break;

            case 8:

                s->t_attrib.unvisible = 1;

                break;

            case 22:

                s->t_attrib.bold = 0;

                break;

            case 24:

                s->t_attrib.uline = 0;

                break;

            case 25:

                s->t_attrib.blink = 0;

                break;

            case 27:

                s->t_attri",1,0,0,0,1,0,0,0,0,0,0,0,0,0,0
20520,qemu,0,"static void write_vec_element(DisasContext *s, TCGv_i64 tcg_src, int destidx,

                              int element, TCGMemOp memop)

{

    int vect_off = vec_reg_offset(destidx, element, memop & MO_SIZE);

    switch (memop) {

    case MO_8:

        tcg_gen_st8_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_16:

        tcg_gen_st16_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_32:

        tcg_gen_st32_i64(tcg_src, cpu_env, vect_off);

        break;

    case MO_64:

        tcg_gen_st_i64(tcg_src, cpu_env, vect_off);

        break;

    default:

        g_assert_not_reached();

    }

}
",0,0,0,0,1,0,0,0,0,1,0,0,0,0,0
20531,qemu,0,"static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),

                                    int ra, int rb, int rc,

                                    int islit, uint8_t lit)

{

    if (unlikely(rc == 31))

        return;



    if (ra != 31) {

        if (islit) {

            if (lit != 0)

                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));

            else

                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);

        } else {

            TCGv tmp1, tmp2;

            tmp1 = tcg_temp_new(TCG_TYPE_I64);

            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);

            tcg_gen_shli_i64(tmp1, tmp1, 3);

            tmp2 = tcg_const_i64(64);

            tcg_gen_sub_i64(tmp1, tmp2, tmp1);

            tcg_temp_free(tmp2);

            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);

            tcg_temp_free(tmp1);

        }

        if (tcg_gen_ext_i64)

            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);

    } else

        tcg_gen_movi_i64(cpu",0,0,5,0,0,0,0,0,0,0,0,0,0,0,0
20534,FFmpeg,0,"void ff_h264_init_dequant_tables(H264Context *h)

{

    int i, x;

    init_dequant4_coeff_table(h);

    if (h->pps.transform_8x8_mode)

        init_dequant8_coeff_table(h);

    if (h->sps.transform_bypass) {

        for (i = 0; i < 6; i++)

            for (x = 0; x < 16; x++)

                h->dequant4_coeff[i][0][x] = 1 << 6;

        if (h->pps.transform_8x8_mode)

            for (i = 0; i < 6; i++)

                for (x = 0; x < 64; x++)

                    h->dequant8_coeff[i][0][x] = 1 << 6;

    }

}
",7,0,3,0,0,0,0,0,1,1,1,1,0,1,0
20541,FFmpeg,0,"static av_cold int g722_encode_init(AVCodecContext * avctx)

{

    G722Context *c = avctx->priv_data;

    int ret;



    if (avctx->channels != 1) {

        av_log(avctx, AV_LOG_ERROR, ""Only mono tracks are allowed.\n"");

        return AVERROR_INVALIDDATA;

    }



    c->band[0].scale_factor = 8;

    c->band[1].scale_factor = 2;

    c->prev_samples_pos = 22;



    if (avctx->trellis) {

        int frontier = 1 << avctx->trellis;

        int max_paths = frontier * FREEZE_INTERVAL;

        int i;

        for (i = 0; i < 2; i++) {

            c->paths[i] = av_mallocz(max_paths * sizeof(**c->paths));

            c->node_buf[i] = av_mallocz(2 * frontier * sizeof(**c->node_buf));

            c->nodep_buf[i] = av_mallocz(2 * frontier * sizeof(**c->nodep_buf));

            if (!c->paths[i] || !c->node_buf[i] || !c->nodep_buf[i]) {

                ret = AVERROR(ENOMEM);

                goto error;

            }

        }

    }



    if (avctx->frame_size) {

        /* validate frame size */

 ",1,1,4,0,0,0,0,0,0,0,1,0,1,1,1
20548,qemu,0,"static uint64_t lsi_mmio_read(void *opaque, target_phys_addr_t addr,

                              unsigned size)

{

    LSIState *s = opaque;



    return lsi_reg_readb(s, addr & 0xff);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
20549,qemu,0,"static int cryptodev_builtin_create_cipher_session(

                    CryptoDevBackendBuiltin *builtin,

                    CryptoDevBackendSymSessionInfo *sess_info,

                    Error **errp)

{

    int algo;

    int mode;

    QCryptoCipher *cipher;

    int index;

    CryptoDevBackendBuiltinSession *sess;



    if (sess_info->op_type != VIRTIO_CRYPTO_SYM_OP_CIPHER) {

        error_setg(errp, ""Unsupported optype :%u"", sess_info->op_type);

        return -1;

    }



    index = cryptodev_builtin_get_unused_session_index(builtin);

    if (index < 0) {

        error_setg(errp, ""Total number of sessions created exceeds %u"",

                  MAX_NUM_SESSIONS);

        return -1;

    }



    switch (sess_info->cipher_alg) {

    case VIRTIO_CRYPTO_CIPHER_AES_ECB:

        algo = cryptodev_builtin_get_aes_algo(sess_info->key_len,

                                                          errp);

        if (algo < 0)  {

            return -1;

        }

        mode = QCRYPTO_CIPHER_M",0,0,3,0,1,0,0,0,0,0,0,0,1,1,0
20553,qemu,0,"envlist_free(envlist_t *envlist)

{

	struct envlist_entry *entry;



	assert(envlist != NULL);



	while (envlist->el_entries.lh_first != NULL) {

		entry = envlist->el_entries.lh_first;

		LIST_REMOVE(entry, ev_link);



		free((char *)entry->ev_var);

		free(entry);

	}

	free(envlist);

}
",0,0,0,0,0,1,0,0,0,0,0,0,1,1,1
20562,qemu,0,"static void test_hba_enable(void)

{

    AHCIQState *ahci;



    ahci = ahci_boot();

    ahci_pci_enable(ahci);

    ahci_hba_enable(ahci);

    ahci_shutdown(ahci);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
20576,qemu,1,"static int writev_f(int argc, char **argv)

{

    struct timeval t1, t2;

    int Cflag = 0, qflag = 0;

    int c, cnt;

    char *buf;

    int64_t offset;

    /* Some compilers get confused and warn if this is not initialized.  */

    int total = 0;

    int nr_iov;

    int pattern = 0xcd;

    QEMUIOVector qiov;



    while ((c = getopt(argc, argv, ""CqP:"")) != EOF) {

        switch (c) {

        case 'C':

            Cflag = 1;

            break;

        case 'q':

            qflag = 1;

            break;

        case 'P':

            pattern = parse_pattern(optarg);

            if (pattern < 0) {

                return 0;

            }

            break;

        default:

            return command_usage(&writev_cmd);

        }

    }



    if (optind > argc - 2) {

        return command_usage(&writev_cmd);

    }



    offset = cvtnum(argv[optind]);

    if (offset < 0) {

        printf(""non-numeric length argument -- %s\n"", argv[optind]);

        return 0;

    }

    optind++;",0,0,3,0,1,1,0,0,0,0,0,0,1,1,1
20581,FFmpeg,0,"static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)

{

    int i;

    for (i = 0; i < width; i++) {

        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12; //-264

        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264

    }

}
",1,0,0,0,0,0,1,1,1,0,1,0,0,0,0
20600,FFmpeg,1,"static int decode_pce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac,

                      enum ChannelPosition new_che_pos[4][MAX_ELEM_ID],

                      GetBitContext *gb)

{

    int num_front, num_side, num_back, num_lfe, num_assoc_data, num_cc, sampling_index;

    int comment_len;



    skip_bits(gb, 2);  // object_type



    sampling_index = get_bits(gb, 4);

    if (m4ac->sampling_index != sampling_index)

        av_log(avctx, AV_LOG_WARNING, ""Sample rate index in program config element does not match the sample rate index configured by the container.\n"");



    num_front       = get_bits(gb, 4);

    num_side        = get_bits(gb, 4);

    num_back        = get_bits(gb, 4);

    num_lfe         = get_bits(gb, 2);

    num_assoc_data  = get_bits(gb, 3);

    num_cc          = get_bits(gb, 4);



    if (get_bits1(gb))

        skip_bits(gb, 4); // mono_mixdown_tag

    if (get_bits1(gb))

        skip_bits(gb, 4); // stereo_mixdown_tag



    if (get_bits1(gb))

        skip_bits(gb, 3);",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
20606,FFmpeg,1,"static int ws_snd_decode_frame(AVCodecContext *avctx, void *data,

                               int *got_frame_ptr, AVPacket *avpkt)

{

    WSSndContext *s = avctx->priv_data;

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;



    int in_size, out_size, ret;

    int sample = 128;

    uint8_t *samples;

    uint8_t *samples_end;



    if (!buf_size)

        return 0;



    if (buf_size < 4) {

        av_log(avctx, AV_LOG_ERROR, ""packet is too small\n"");

        return AVERROR(EINVAL);

    }



    out_size = AV_RL16(&buf[0]);

    in_size  = AV_RL16(&buf[2]);

    buf += 4;



    if (in_size > buf_size) {

        av_log(avctx, AV_LOG_ERROR, ""Frame data is larger than input buffer\n"");

        return -1;

    }



    /* get output buffer */

    s->frame.nb_samples = out_size;

    if ((ret = avctx->get_buffer(avctx, &s->frame)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return ret;

    }

    samples     = s->frame.data[0];

    ",0,0,4,0,0,0,0,0,0,0,1,1,0,0,0
20613,FFmpeg,1,"static av_always_inline void hyscale(SwsContext *c, int16_t *dst, int dstWidth,

                                     const uint8_t *src_in[4], int srcW, int xInc,

                                     const int16_t *hLumFilter,

                                     const int16_t *hLumFilterPos, int hLumFilterSize,

                                     uint8_t *formatConvBuffer,

                                     uint32_t *pal, int isAlpha)

{

    void (*toYV12)(uint8_t *, const uint8_t *, int, uint32_t *) = isAlpha ? c->alpToYV12 : c->lumToYV12;

    void (*convertRange)(int16_t *, int) = isAlpha ? NULL : c->lumConvertRange;

    const uint8_t *src = src_in[isAlpha ? 3 : 0];



    if (toYV12) {

        toYV12(formatConvBuffer, src, srcW, pal);

        src= formatConvBuffer;

    } else if (c->readLumPlanar && !isAlpha) {

        c->readLumPlanar(formatConvBuffer, src_in, srcW);

        src = formatConvBuffer;

    }



    if (!c->hyscale_fast) {

        c->hyScale(c, dst, dstWidth, src, hLumFilter",5,0,3,0,0,0,1,1,1,0,1,0,1,1,1
20617,FFmpeg,0,"static av_always_inline av_flatten void h264_loop_filter_chroma_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0)

{

    int i, d;

    for( i = 0; i < 4; i++ ) {

        const int tc = tc0[i];

        if( tc <= 0 ) {

            pix += 2*ystride;

            continue;

        }

        for( d = 0; d < 2; d++ ) {

            const int p0 = pix[-1*xstride];

            const int p1 = pix[-2*xstride];

            const int q0 = pix[0];

            const int q1 = pix[1*xstride];



            if( FFABS( p0 - q0 ) < alpha &&

                FFABS( p1 - p0 ) < beta &&

                FFABS( q1 - q0 ) < beta ) {



                int delta = av_clip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );



                pix[-xstride] = av_clip_uint8( p0 + delta );    /* p0' */

                pix[0]        = av_clip_uint8( q0 - delta );    /* q0' */

            }

            pix += ystride;

        }

    }

}
",2,0,2,0,0,0,0,0,0,1,1,1,1,0,0
20618,FFmpeg,0,"int ff_mpeg4_decode_picture_header(MpegEncContext * s, GetBitContext *gb)

{

    int startcode, v;



    /* search next start code */

    align_get_bits(gb);

    startcode = 0xff;

    for(;;) {

        v = get_bits(gb, 8);

        startcode = ((startcode << 8) | v) & 0xffffffff;

        

        if(get_bits_count(gb) >= gb->size*8){

            if(gb->size==1 && s->divx_version){

                printf(""frame skip %d\n"", gb->size);

                return FRAME_SKIPED; //divx bug

            }else

                return -1; //end of stream

        }



        if((startcode&0xFFFFFF00) != 0x100)

            continue; //no startcode

        

        if(s->avctx->debug&FF_DEBUG_STARTCODE){

            printf(""startcode: %3X "", startcode);

            if     (startcode<=0x11F) printf(""Video Object Start"");

            else if(startcode<=0x12F) printf(""Video Object Layer Start"");

            else if(startcode<=0x13F) printf(""Reserved"");

            else if(startcode<=0x15F) printf(""FGS bp st",1,0,8,0,0,0,0,0,0,0,0,0,1,1,1
20620,FFmpeg,0,"static void mpegvideo_extract_headers(AVCodecParserContext *s,

                                      AVCodecContext *avctx,

                                      const uint8_t *buf, int buf_size)

{

    ParseContext1 *pc = s->priv_data;

    const uint8_t *buf_end;

    const uint8_t *buf_start= buf;

    uint32_t start_code;

    int frame_rate_index, ext_type, bytes_left;

    int frame_rate_ext_n, frame_rate_ext_d;

    int picture_structure, top_field_first, repeat_first_field, progressive_frame;

    int horiz_size_ext, vert_size_ext, bit_rate_ext;

//FIXME replace the crap with get_bits()

    s->repeat_pict = 0;

    buf_end = buf + buf_size;

    while (buf < buf_end) {

        start_code= -1;

        buf= ff_find_start_code(buf, buf_end, &start_code);

        bytes_left = buf_end - buf;

        switch(start_code) {

        case PICTURE_START_CODE:

            ff_fetch_timestamp(s, buf-buf_start-4, 1);



            if (bytes_left >= 2) {

                s->pict_type = (buf[1] >> 3) & 7;

 ",0,0,1,0,1,1,0,0,0,1,0,0,0,0,0
20623,FFmpeg,1,"static int set_chroma_format(AVCodecContext *avctx)

{

    int num_formats = sizeof(schro_pixel_format_map) /

                      sizeof(schro_pixel_format_map[0]);

    int idx;



    SchroEncoderParams *p_schro_params = avctx->priv_data;



    for (idx = 0; idx < num_formats; ++idx) {

        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {

            p_schro_params->format->chroma_format =

                            schro_pixel_format_map[idx].schro_pix_fmt;

            return 0;

        }

    }



    av_log(avctx, AV_LOG_ERROR,

           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""

           "" and 4:4:4 formats.\n"");



    return -1;

}
",11,0,1,0,0,0,0,0,1,0,0,0,1,1,1
20631,qemu,1,"IEEE_ARITH2(sqrtt)

IEEE_ARITH2(cvtst)

IEEE_ARITH2(cvtts)



static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)

{

    TCGv vb, vc;



    /* No need to set flushzero, since we have an integer output.  */

    vb = gen_ieee_input(ctx, rb, fn11, 0);

    vc = dest_fpr(ctx, rc);



    /* Almost all integer conversions use cropped rounding, and most

       also do not have integer overflow enabled.  Special case that.  */

    switch (fn11) {

    case QUAL_RM_C:

        gen_helper_cvttq_c(vc, cpu_env, vb);

        break;

    case QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:

        gen_helper_cvttq_svic(vc, cpu_env, vb);

        break;

    default:

        gen_qual_roundmode(ctx, fn11);

        gen_helper_cvttq(vc, cpu_env, vb);

        break;

    }



    gen_fp_exc_raise(rc, fn11);

}
",0,0,0,0,1,0,0,0,0,1,1,1,0,0,0
20643,qemu,1,"static int virtio_serial_device_exit(DeviceState *dev)

{

    VirtIOSerial *vser = VIRTIO_SERIAL(dev);

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);



    unregister_savevm(dev, ""virtio-console"", vser);



    g_free(vser->ivqs);

    g_free(vser->ovqs);

    g_free(vser->ports_map);

    if (vser->post_load) {

        g_free(vser->post_load->connected);

        timer_del(vser->post_load->timer);

        timer_free(vser->post_load->timer);

        g_free(vser->post_load);

    }

    virtio_cleanup(vdev);

    return 0;

}
",0,0,1,0,0,0,0,1,0,1,1,0,0,1,0
20644,qemu,1,"int kvm_arch_init_vcpu(CPUState *cenv)

{

    int ret = 0;

    struct kvm_sregs sregs;



    sregs.pvr = cenv->spr[SPR_PVR];

    ret = kvm_vcpu_ioctl(cenv, KVM_SET_SREGS, &sregs);



    idle_timer = qemu_new_timer_ns(vm_clock, kvm_kick_env, cenv);



    return ret;

}
",0,0,0,0,0,0,1,1,1,1,1,0,1,1,0
20647,qemu,1,"static void virtio_queue_notify_vq(VirtQueue *vq)
{
    if (vq->vring.desc && vq->handle_output) {
        VirtIODevice *vdev = vq->vdev;
        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);
        vq->handle_output(vdev, vq);",0,0,3,0,0,0,1,0,1,1,0,0,1,1,1
20659,FFmpeg,1,"static av_cold int mp_decode_init(AVCodecContext *avctx)

{

    MotionPixelsContext *mp = avctx->priv_data;

    int w4 = (avctx->width  + 3) & ~3;

    int h4 = (avctx->height + 3) & ~3;



    if(avctx->extradata_size < 2){

        av_log(avctx, AV_LOG_ERROR, ""extradata too small\n"");

        return AVERROR_INVALIDDATA;

    }



    motionpixels_tableinit();

    mp->avctx = avctx;

    ff_dsputil_init(&mp->dsp, avctx);

    mp->changes_map = av_mallocz(avctx->width * h4);

    mp->offset_bits_len = av_log2(avctx->width * avctx->height) + 1;

    mp->vpt = av_mallocz(avctx->height * sizeof(YuvPixel));

    mp->hpt = av_mallocz(h4 * w4 / 16 * sizeof(YuvPixel));



    avctx->pix_fmt = AV_PIX_FMT_RGB555;

    avcodec_get_frame_defaults(&mp->frame);

    return 0;

}",0,0,1,0,0,0,1,1,1,1,0,1,1,1,1
20662,FFmpeg,0,"static void put_payload_header(

                                AVFormatContext *s,

                                ASFStream       *stream,

                                int             presentation_time,

                                int             m_obj_size,

                                int             m_obj_offset,

                                int             payload_len

            )

{

    ASFContext *asf = s->priv_data;

    ByteIOContext *pb = &asf->pb;

    int val;

    

    val = stream->num;

    if (s->streams[val - 1]->codec.coded_frame->key_frame)

        val |= ASF_PL_FLAG_KEY_FRAME;

    put_byte(pb, val);

        

    put_byte(pb, stream->seq);  //Media object number

    put_le32(pb, m_obj_offset); //Offset Into Media Object

         

    // Replicated Data shall be at least 8 bytes long.

    // The first 4 bytes of data shall contain the 

    // Size of the Media Object that the payload belongs to.

    // The next 4 bytes of data shall contain the 

    // Pres",0,0,1,0,0,0,0,1,1,1,0,1,0,0,0
20697,FFmpeg,1,"static int pcm_encode_frame(AVCodecContext *avctx,

			    unsigned char *frame, int buf_size, void *data)

{

    int n, sample_size, v;

    short *samples;

    unsigned char *dst;



    switch(avctx->codec->id) {

    case CODEC_ID_PCM_S16LE:

    case CODEC_ID_PCM_S16BE:

    case CODEC_ID_PCM_U16LE:

    case CODEC_ID_PCM_U16BE:

        sample_size = 2;

        break;

    default:

        sample_size = 1;

        break;

    }

    n = buf_size / sample_size;

    samples = data;

    dst = frame;



    switch(avctx->codec->id) {

    case CODEC_ID_PCM_S16LE:

        for(;n>0;n--) {

            v = *samples++;

            dst[0] = v & 0xff;

            dst[1] = v >> 8;

            dst += 2;

        }

        break;

    case CODEC_ID_PCM_S16BE:

        for(;n>0;n--) {

            v = *samples++;

            dst[0] = v >> 8;

            dst[1] = v;

            dst += 2;

        }

        break;

    case CODEC_ID_PCM_U16LE:

        for(;n>0;n--) {

            v = *samples++;

     ",3,0,0,0,2,0,0,0,0,1,1,1,0,0,0
20698,FFmpeg,1,"static inline void hScale_altivec_real(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc, int16_t *filter, int16_t *filterPos, int filterSize) {

  register int i;

  int __attribute__ ((aligned (16))) tempo[4];



  if (filterSize % 4) {

    for(i=0; i<dstW; i++) {

      register int j;

      register int srcPos = filterPos[i];

      register int val = 0;

      for(j=0; j<filterSize; j++) {

	val += ((int)src[srcPos + j])*filter[filterSize*i + j];

      }

      dst[i] = av_clip(val>>7, 0, (1<<15)-1);

    }

  }

  else

  switch (filterSize) {

  case 4:

    {

      for(i=0; i<dstW; i++) {

	register int srcPos = filterPos[i];



	vector unsigned char src_v0 = vec_ld(srcPos, src);

	vector unsigned char src_v1, src_vF;

	vector signed short src_v, filter_v;

	vector signed int val_vEven, val_s;

	if ((((int)src + srcPos)% 16) > 12) {

	  src_v1 = vec_ld(srcPos + 16, src);

	}

	src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));



	src_v = // vec_unpackh sign-extends...

	  (vector si",3,0,2,0,1,0,0,0,0,0,0,0,1,1,1
20716,qemu,1,"void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
",0,0,0,0,0,0,0,0,0,0,1,0,1,0,1
20722,qemu,1,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,0,0
20728,qemu,0,"static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
20738,qemu,0,"static int mch_init(PCIDevice *d)

{

    int i;

    MCHPCIState *mch = MCH_PCI_DEVICE(d);



    /* setup pci memory regions */

    memory_region_init_alias(&mch->pci_hole, OBJECT(mch), ""pci-hole"",

                             mch->pci_address_space,

                             mch->below_4g_mem_size,

                             0x100000000ULL - mch->below_4g_mem_size);

    memory_region_add_subregion(mch->system_memory, mch->below_4g_mem_size,

                                &mch->pci_hole);



    pc_init_pci64_hole(&mch->pci_info, 0x100000000ULL + mch->above_4g_mem_size,

                       mch->pci_hole64_size);

    memory_region_init_alias(&mch->pci_hole_64bit, OBJECT(mch), ""pci-hole64"",

                             mch->pci_address_space,

                             mch->pci_info.w64.begin,

                             mch->pci_hole64_size);

    if (mch->pci_hole64_size) {

        memory_region_add_subregion(mch->system_memory,

                                    mch->pci_info.w64.",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
20741,FFmpeg,0,"static int h261_find_frame_end(ParseContext *pc, AVCodecContext* avctx, const uint8_t *buf, int buf_size){

    int vop_found, i, j, bits_left, last_bits;

    uint32_t state;



    H261Context *h = avctx->priv_data;



    if(h){

        bits_left = h->bits_left;

        last_bits = h->last_bits;

    }

    else{

        bits_left = 0;

        last_bits = 0;

    }



    vop_found= pc->frame_start_found;

    state= pc->state;

    if(bits_left!=0 && !vop_found)

        state = state << (8-bits_left) | last_bits;

    i=0;

    if(!vop_found){

        for(i=0; i<buf_size; i++){

            state= (state<<8) | buf[i];

            for(j=0; j<8; j++){

                if(( (  (state<<j)  |  (buf[i]>>(8-j))  )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){

                    i++;

                    vop_found=1;

                    break;

                }

            }

            if(vop_found)

                    break;    

        }

    }

    if(vop_found){

        for(; i<",3,0,6,0,0,0,0,0,0,0,0,0,1,1,1
20743,qemu,0,"void address_space_write(AddressSpace *as, target_phys_addr_t addr,

                         const uint8_t *buf, int len)

{

    address_space_rw(as, addr, (uint8_t *)buf, len, true);

}
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0
20751,qemu,0,"static void audio_run_capture (AudioState *s)

{

    CaptureVoiceOut *cap;



    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {

        int live, rpos, captured;

        HWVoiceOut *hw = &cap->hw;

        SWVoiceOut *sw;



        captured = live = audio_pcm_hw_get_live_out (hw);

        rpos = hw->rpos;

        while (live) {

            int left = hw->samples - rpos;

            int to_capture = audio_MIN (live, left);

            st_sample_t *src;

            struct capture_callback *cb;



            src = hw->mix_buf + rpos;

            hw->clip (cap->buf, src, to_capture);

            mixeng_clear (src, to_capture);



            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {

                cb->ops.capture (cb->opaque, cap->buf,

                                 to_capture << hw->info.shift);

            }

            rpos = (rpos + to_capture) % hw->samples;

            live -= to_capture;

        }

        hw->rpos = rpos;



        for (s",3,0,1,0,0,1,0,0,1,0,0,0,1,1,1
20761,qemu,1,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));


    return chr;

}",0,0,0,0,0,0,0,0,0,0,0,0,1,0,1
20766,qemu,1,"static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""eccmemctl"");

    qdev_prop_set_uint32(dev, ""version"", version);

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, base);

    if (version == 0) { // SS-600MP only

        sysbus_mmio_map(s, 1, base + 0x1000);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,0,1
20797,qemu,0,"int pcistb_service_call(S390CPU *cpu, uint8_t r1, uint8_t r3, uint64_t gaddr,

                        uint8_t ar)

{

    CPUS390XState *env = &cpu->env;

    S390PCIBusDevice *pbdev;

    MemoryRegion *mr;

    int i;

    uint32_t fh;

    uint8_t pcias;

    uint8_t len;

    uint8_t buffer[128];



    if (env->psw.mask & PSW_MASK_PSTATE) {

        program_interrupt(env, PGM_PRIVILEGED, 6);

        return 0;

    }



    fh = env->regs[r1] >> 32;

    pcias = (env->regs[r1] >> 16) & 0xf;

    len = env->regs[r1] & 0xff;



    if (pcias > 5) {

        DPRINTF(""pcistb invalid space\n"");

        setcc(cpu, ZPCI_PCI_LS_ERR);

        s390_set_status_code(env, r1, ZPCI_PCI_ST_INVAL_AS);

        return 0;

    }



    switch (len) {

    case 16:

    case 32:

    case 64:

    case 128:

        break;

    default:

        program_interrupt(env, PGM_SPECIFICATION, 6);

        return 0;

    }



    pbdev = s390_pci_find_dev_by_fh(fh);

    if (!pbdev || !(pbdev->fh & FH_MASK_ENABLE)) {

        D",0,0,3,0,1,0,1,1,1,0,1,0,1,1,1
20802,qemu,0,"static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,

                                  void *opaque)

{

    monitor_flush(opaque);

    return FALSE;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1
20803,qemu,0,"static always_inline void gen_store_spr(int reg, TCGv t)

{

    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
20811,qemu,0,"int bdrv_is_read_only(BlockDriverState *bs)

{

    return bs->read_only;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
20812,qemu,0,"static void bw_conf1_write(void *opaque, target_phys_addr_t addr,

                           uint64_t val, unsigned size)

{

    PCIBus *b = opaque;

    pci_data_write(b, addr, val, size);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,1
20831,qemu,0,"void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)

{

    TranslationBlock *tb;

    int ret;

    unsigned long pc;

    CPUX86State *saved_env;



    /* XXX: hack to restore env in all cases, even if not called from

       generated code */

    saved_env = env;

    env = cpu_single_env;



    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);

    if (ret) {

        if (retaddr) {

            /* now we have a real cpu fault */

            pc = (unsigned long)retaddr;

            tb = tb_find_pc(pc);

            if (tb) {

                /* the PC is inside the translated code. It means that we have

                   a virtual CPU fault */

                cpu_restore_state(tb, env, pc, NULL);

            }

        }

        if (retaddr)

            raise_exception_err(EXCP0E_PAGE, env->error_code);

        else

            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);

    }

    env = saved_env;

}
",0,0,5,0,0,0,0,0,0,0,0,0,0,0,0
20835,qemu,1,"static void test_tco1_status_bits(void)

{

    TestData d;

    uint16_t ticks = 8;

    uint16_t val;

    int ret;



    d.args = NULL;

    d.noreboot = true;

    test_init(&d);



    stop_tco(&d);

    clear_tco_status(&d);

    reset_on_second_timeout(false);

    set_tco_timeout(&d, ticks);

    load_tco(&d);

    start_tco(&d);

    clock_step(ticks * TCO_TICK_NSEC);



    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);

    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);

    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);

    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;

    g_assert(ret == 1);

    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);

    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);

    qtest_end();

}
",0,0,0,0,0,0,0,0,0,0,0,1,0,0,0
20840,qemu,1,"block_crypto_create_opts_init(QCryptoBlockFormat format,

                              QemuOpts *opts,

                              Error **errp)

{

    OptsVisitor *ov;

    QCryptoBlockCreateOptions *ret = NULL;

    Error *local_err = NULL;



    ret = g_new0(QCryptoBlockCreateOptions, 1);

    ret->format = format;



    ov = opts_visitor_new(opts);



    visit_start_struct(opts_get_visitor(ov),

                       NULL, NULL, 0, &local_err);

    if (local_err) {

        goto out;

    }



    switch (format) {

    case Q_CRYPTO_BLOCK_FORMAT_LUKS:

        visit_type_QCryptoBlockCreateOptionsLUKS_members(

            opts_get_visitor(ov), &ret->u.luks, &local_err);

        break;



    default:

        error_setg(&local_err, ""Unsupported block format %d"", format);

        break;

    }

    error_propagate(errp, local_err);

    local_err = NULL;



    visit_end_struct(opts_get_visitor(ov), &local_err);



 out:

    if (local_err) {

        error_propagate(errp, local_err);

       ",6,1,2,0,1,0,0,0,0,0,1,1,1,1,0
20856,FFmpeg,0,"static void RENAME(yuv2yuvX)(SwsContext *c, const int16_t *lumFilter,

                             const int16_t **lumSrc, int lumFilterSize,

                             const int16_t *chrFilter, const int16_t **chrUSrc,

                             const int16_t **chrVSrc,

                             int chrFilterSize, const int16_t **alpSrc,

                             uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                             uint8_t *aDest, int dstW, int chrDstW)

{

    if (uDest) {

        x86_reg uv_off = c->uv_off;

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X(CHR_MMX_FILTER_OFFSET, vDest - uv_off, chrDstW + uv_off, uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)

    }



    YSCALEYUV2YV12X(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,0
20902,qemu,0,"static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
",0,0,1,0,0,0,1,1,0,1,1,1,0,0,0
20903,FFmpeg,0,"static int xan_huffman_decode(unsigned char *dest, unsigned char *src)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = src + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = src[byte + val - 0x17];

        else

            val = src[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    }



    return 0;

}
",0,0,3,0,0,1,0,0,0,0,0,0,1,1,1
20908,qemu,0,"static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)

{

    return t && t->rearm;

}
",0,0,0,0,0,0,0,1,1,0,0,0,0,0,0
20917,FFmpeg,1,"static int iff_read_header(AVFormatContext *s)

{

    IffDemuxContext *iff = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st;

    uint8_t *buf;

    uint32_t chunk_id, data_size;

    uint32_t screenmode = 0, num, den;

    unsigned transparency = 0;

    unsigned masking = 0; // no mask

    uint8_t fmt[16];

    int fmt_size;



    st = avformat_new_stream(s, NULL);

    if (!st)

        return AVERROR(ENOMEM);



    st->codec->channels = 1;

    st->codec->channel_layout = AV_CH_LAYOUT_MONO;

    avio_skip(pb, 8);

    // codec_tag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content

    st->codec->codec_tag = avio_rl32(pb);

    iff->bitmap_compression = -1;

    iff->svx8_compression = -1;

    iff->maud_bits = -1;

    iff->maud_compression = -1;



    while(!url_feof(pb)) {

        uint64_t orig_pos;

        int res;

        const char *metadata_tag = NULL;

        chunk_id = avio_rl32(pb);

        data_size = avio_rb32(pb);

        orig_pos",1,0,7,0,0,1,1,1,1,1,1,1,0,0,0
20918,FFmpeg,1,"static int ftp_status(FTPContext *s, char **line, const int response_codes[])

{

    int err, i, dash = 0, result = 0, code_found = 0;

    char buf[CONTROL_BUFFER_SIZE];

    AVBPrint line_buffer;



    if (line)

        av_bprint_init(&line_buffer, 0, AV_BPRINT_SIZE_AUTOMATIC);



    while (!code_found || dash) {

        if ((err = ftp_get_line(s, buf, sizeof(buf))) < 0) {

            av_bprint_finalize(&line_buffer, NULL);

            return err;

        }



        av_log(s, AV_LOG_DEBUG, ""%s\n"", buf);



        if (strlen(buf) < 4)

            continue;



        err = 0;

        for (i = 0; i < 3; ++i) {

            if (buf[i] < '0' || buf[i] > '9')

                continue;

            err *= 10;

            err += buf[i] - '0';

        }

        dash = !!(buf[3] == '-');



        for (i = 0; response_codes[i]; ++i) {

            if (err == response_codes[i]) {

                if (line)

                    av_bprintf(&line_buffer, ""%s"", buf);

                code_found = 1;

  ",2,0,6,0,0,1,1,1,0,1,1,1,0,0,0
20938,qemu,0,"static uint32_t arm_sysctl_read(void *opaque, target_phys_addr_t offset)

{

    arm_sysctl_state *s = (arm_sysctl_state *)opaque;



    switch (offset) {

    case 0x00: /* ID */

        return s->sys_id;

    case 0x04: /* SW */

        /* General purpose hardware switches.

           We don't have a useful way of exposing these to the user.  */

        return 0;

    case 0x08: /* LED */

        return s->leds;

    case 0x20: /* LOCK */

        return s->lockval;

    case 0x0c: /* OSC0 */

    case 0x10: /* OSC1 */

    case 0x14: /* OSC2 */

    case 0x18: /* OSC3 */

    case 0x1c: /* OSC4 */

    case 0x24: /* 100HZ */

        /* ??? Implement these.  */

        return 0;

    case 0x28: /* CFGDATA1 */

        return s->cfgdata1;

    case 0x2c: /* CFGDATA2 */

        return s->cfgdata2;

    case 0x30: /* FLAGS */

        return s->flags;

    case 0x38: /* NVFLAGS */

        return s->nvflags;

    case 0x40: /* RESETCTL */

        return s->resetlevel;

    case 0x44: /* PCICTL */

  ",0,0,0,0,2,0,0,0,0,0,0,0,0,0,1
20945,qemu,0,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)

{

    struct qemu_work_item wi;



    if (qemu_cpu_is_self(cpu)) {

        func(data);

        return;

    }



    wi.func = func;

    wi.data = data;

    wi.free = false;

    if (cpu->queued_work_first == NULL) {

        cpu->queued_work_first = &wi;

    } else {

        cpu->queued_work_last->next = &wi;

    }

    cpu->queued_work_last = &wi;

    wi.next = NULL;

    wi.done = false;



    qemu_cpu_kick(cpu);

    while (!wi.done) {

        CPUState *self_cpu = current_cpu;



        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);

        current_cpu = self_cpu;

    }

}
",0,0,2,0,0,1,0,0,0,0,0,0,1,1,1
20958,FFmpeg,0,"double avpriv_strtod(char *restrict nptr, char **restrict endptr)

{

    char *end;

    double res;



    /* Skip leading spaces */

    while (isspace(*nptr))

        nptr++;



    if (!av_strncasecmp(nptr, ""infinity"", 8)) {

        end = nptr + 8;

        res = INFINITY;

    } else if (!av_strncasecmp(nptr, ""inf"", 3)) {

        end = nptr + 3;

        res = INFINITY;

    } else if (!av_strncasecmp(nptr, ""+infinity"", 9)) {

        end = nptr + 9;

        res = INFINITY;

    } else if (!av_strncasecmp(nptr, ""+inf"", 4)) {

        end = nptr + 4;

        res = INFINITY;

    } else if (!av_strncasecmp(nptr, ""-infinity"", 9)) {

        end = nptr + 9;

        res = -INFINITY;

    } else if (!av_strncasecmp(nptr, ""-inf"", 4)) {

        end = nptr + 4;

        res = -INFINITY;

    } else if (!av_strncasecmp(nptr, ""nan"", 3)) {

        end = check_nan_suffix(nptr + 3);

        res = NAN;

    } else if (!av_strncasecmp(nptr, ""+nan"", 4) ||

               !av_strncasecmp(nptr, ""-nan"", 4)) {

   ",0,0,8,0,0,1,0,0,0,0,0,0,0,0,0
20961,FFmpeg,0,"static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {

    double time = av_gettime() / 1000000.0;

    /* update current video pts */

    is->video_current_pts = pts;

    is->video_current_pts_drift = is->video_current_pts - time;

    is->video_current_pos = pos;

    is->frame_last_pts = pts;

    check_external_clock_sync(is, is->video_current_pts);

}
",0,0,1,0,0,0,0,1,0,1,1,0,0,0,0
20970,qemu,0,"open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;



	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}
",0,0,2,0,1,1,1,1,1,1,1,0,0,0,0
20975,qemu,0,"static unsigned int event_status_media(IDEState *s,

                                       uint8_t *buf)

{

    uint8_t event_code, media_status;



    media_status = 0;

    if (s->tray_open) {

        media_status = MS_TRAY_OPEN;

    } else if (bdrv_is_inserted(s->bs)) {

        media_status = MS_MEDIA_PRESENT;

    }



    /* Event notification descriptor */

    event_code = MEC_NO_CHANGE;

    if (media_status != MS_TRAY_OPEN) {

        if (s->events.new_media) {

            event_code = MEC_NEW_MEDIA;

            s->events.new_media = false;

        } else if (s->events.eject_request) {

            event_code = MEC_EJECT_REQUESTED;

            s->events.eject_request = false;

        }

    }



    buf[4] = event_code;

    buf[5] = media_status;



    /* These fields are reserved, just clear them. */

    buf[6] = 0;

    buf[7] = 0;



    return 8; /* We wrote to 4 extra bytes from the header */

}
",0,0,5,0,0,0,0,0,0,0,0,0,1,0,0
20994,qemu,0,"static void virtio_scsi_hotunplug(HotplugHandler *hotplug_dev, DeviceState *dev,

                                  Error **errp)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(hotplug_dev);

    VirtIOSCSI *s = VIRTIO_SCSI(vdev);

    SCSIDevice *sd = SCSI_DEVICE(dev);



    if ((vdev->guest_features >> VIRTIO_SCSI_F_HOTPLUG) & 1) {

        virtio_scsi_push_event(s, sd,

                               VIRTIO_SCSI_T_TRANSPORT_RESET,

                               VIRTIO_SCSI_EVT_RESET_REMOVED);

    }



    if (s->ctx) {

        blk_op_unblock_all(sd->conf.blk, s->blocker);

    }

    qdev_simple_device_unplug_cb(hotplug_dev, dev, errp);

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
20996,qemu,0,"int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,

                                    SocketAddress *addr,

                                    Error **errp)

{

    int fd;



    trace_qio_channel_socket_connect_sync(ioc, addr);

    fd = socket_connect(addr, NULL, NULL, errp);

    if (fd < 0) {

        trace_qio_channel_socket_connect_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_connect_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
21007,FFmpeg,1,"static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,
                      int append)
{
    int buflen;
    /** when the frame data does not need to be concatenated, the input buffer
        is resetted and additional bits from the previous frame are copyed
        and skipped later so that a fast byte copy is possible */
    if (!append) {
        s->frame_offset = get_bits_count(gb) & 7;
        s->num_saved_bits = s->frame_offset;
        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);
    buflen = (s->num_saved_bits + len + 8) >> 3;
    if (len <= 0 || buflen > MAX_FRAMESIZE) {
        avpriv_request_sample(s->avctx, ""Too small input buffer"");
    s->num_saved_bits += len;
    if (!append) {
        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),
                     s->num_saved_bits);
    } else {
        int align = 8 - (get_bits_count(gb) & 7);
        align = FFMIN(align, len);
        put_bits(&s->pb, align, get_bits(gb, align));
        len -= align;
        ",0,0,3,0,0,0,1,1,1,1,0,1,1,1,1
21012,FFmpeg,1,"static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx,

                                 const ReadInterval *interval, int64_t *cur_ts)

{

    AVPacket pkt, pkt1;

    AVFrame *frame = NULL;

    int ret = 0, i = 0, frame_count = 0;

    int64_t start = -INT64_MAX, end = interval->end;

    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;



    av_init_packet(&pkt);



    av_log(NULL, AV_LOG_VERBOSE, ""Processing read interval "");

    log_read_interval(interval, NULL, AV_LOG_VERBOSE);



    if (interval->has_start) {

        int64_t target;

        if (interval->start_is_offset) {

            if (*cur_ts == AV_NOPTS_VALUE) {

                av_log(NULL, AV_LOG_ERROR,

                       ""Could not seek to relative position since current ""

                       ""timestamp is not defined\n"");

                ret = AVERROR(EINVAL);



            target = *cur_ts + interval->start;

        } else {

            target = interval->start;




       ",0,0,3,0,0,0,1,1,1,1,1,1,1,0,0
21030,FFmpeg,1,"int attribute_align_arg avcodec_encode_audio(AVCodecContext *avctx,
                                             uint8_t *buf, int buf_size,
                                             const short *samples)
{
    AVPacket pkt;
    AVFrame *frame;
    int ret, samples_size, got_packet;
    av_init_packet(&pkt);
    pkt.data = buf;
    pkt.size = buf_size;
    if (samples) {
        frame = av_frame_alloc();
        if (!frame)
            return AVERROR(ENOMEM);
        if (avctx->frame_size) {
            frame->nb_samples = avctx->frame_size;
        } else {
            /* if frame_size is not set, the number of samples must be
             * calculated from the buffer size */
            int64_t nb_samples;
            if (!av_get_bits_per_sample(avctx->codec_id)) {
                av_log(avctx, AV_LOG_ERROR, ""avcodec_encode_audio() does not ""
                                            ""support this codec\n"");
                av_frame_free(&frame);
                return AVERROR(EINVAL);
            }
  ",0,0,5,0,0,0,1,1,1,1,1,1,0,0,1
21034,qemu,1,"static void host_cpuid(uint32_t function, uint32_t count,

                       uint32_t *eax, uint32_t *ebx,

                       uint32_t *ecx, uint32_t *edx)

{

#if defined(CONFIG_KVM)

    uint32_t vec[4];



#ifdef __x86_64__

    asm volatile(""cpuid""

                 : ""=a""(vec[0]), ""=b""(vec[1]),

                   ""=c""(vec[2]), ""=d""(vec[3])

                 : ""0""(function), ""c""(count) : ""cc"");

#else

    asm volatile(""pusha \n\t""

                 ""cpuid \n\t""

                 ""mov %%eax, 0(%1) \n\t""

                 ""mov %%ebx, 4(%1) \n\t""

                 ""mov %%ecx, 8(%1) \n\t""

                 ""mov %%edx, 12(%1) \n\t""

                 ""popa""

                 : : ""a""(function), ""c""(count), ""S""(vec)

                 : ""memory"", ""cc"");

#endif



    if (eax)

	*eax = vec[0];

    if (ebx)

	*ebx = vec[1];

    if (ecx)

	*ecx = vec[2];

    if (edx)

	*edx = vec[3];

#endif

}
",0,0,8,0,0,0,1,0,0,1,1,0,0,1,0
21037,FFmpeg,1,"static int dxva2_map_frame(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src,

                           int flags)

{

    IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];

    DXVA2Mapping      *map;

    D3DSURFACE_DESC    surfaceDesc;

    D3DLOCKED_RECT     LockedRect;

    HRESULT            hr;

    int i, err, nb_planes;

    int lock_flags = 0;



    nb_planes = av_pix_fmt_count_planes(dst->format);



    hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);

    if (FAILED(hr)) {

        av_log(ctx, AV_LOG_ERROR, ""Error getting a surface description\n"");

        return AVERROR_UNKNOWN;

    }



    if (!(flags & AV_HWFRAME_MAP_WRITE))

        lock_flags |= D3DLOCK_READONLY;

    if (flags & AV_HWFRAME_MAP_OVERWRITE)

        lock_flags |= D3DLOCK_DISCARD;



    hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);

    if (FAILED(hr)) {

        av_log(ctx, AV_LOG_ERROR, ""Unable to lock DXVA2 surface\n"");

        return AVERROR_UNKNOWN;

    }



   ",1,0,4,0,0,0,1,1,1,0,1,1,1,1,0
21050,FFmpeg,1,"void show_help(void)

{

    const char *prog;

    const OptionDef *po;

    int i, expert;

    

    prog = do_play ? ""ffplay"" : ""ffmpeg"";



    printf(""%s version "" FFMPEG_VERSION "", Copyright (c) 2000, 2001, 2002 Gerard Lantau\n"", 

           prog);

    

    if (!do_play) {

        printf(""usage: ffmpeg [[options] -i input_file]... {[options] outfile}...\n""

               ""Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\n"");

    } else {

        printf(""usage: ffplay [options] input_file...\n""

               ""Simple audio player\n"");

    }

           

    printf(""\n""

           ""Main options are:\n"");

    for(i=0;i<2;i++) {

        if (i == 1)

            printf(""\nAdvanced options are:\n"");

        for(po = options; po->name != NULL; po++) {

            char buf[64];

            expert = (po->flags & OPT_EXPERT) != 0;

            if (expert == i) {

                strcpy(buf, po->name);

                if (po->flags & HAS_ARG) {

                    strcat(buf, "" "");

   ",2,0,4,0,0,0,0,0,0,1,1,0,0,0,0
21061,FFmpeg,1,"av_cold int ffv1_common_init(AVCodecContext *avctx)

{

    FFV1Context *s = avctx->priv_data;



    if (!avctx->width || !avctx->height)

        return AVERROR_INVALIDDATA;



    s->avctx = avctx;

    s->flags = avctx->flags;



    s->picture.f = avcodec_alloc_frame();

    s->last_picture.f = av_frame_alloc();



    ff_dsputil_init(&s->dsp, avctx);



    s->width  = avctx->width;

    s->height = avctx->height;



    // defaults

    s->num_h_slices = 1;

    s->num_v_slices = 1;



    return 0;

}",0,0,1,0,0,0,1,0,1,0,0,0,1,1,1
21070,FFmpeg,0,"static int vqa_decode_chunk(VqaContext *s)

{

    unsigned int chunk_type;

    unsigned int chunk_size;

    int byte_skip;

    unsigned int index = 0;

    int i;

    unsigned char r, g, b;

    int index_shift;

    int res;



    int cbf0_chunk = -1;

    int cbfz_chunk = -1;

    int cbp0_chunk = -1;

    int cbpz_chunk = -1;

    int cpl0_chunk = -1;

    int cplz_chunk = -1;

    int vptz_chunk = -1;



    int x, y;

    int lines = 0;

    int pixel_ptr;

    int vector_index = 0;

    int lobyte = 0;

    int hibyte = 0;

    int lobytes = 0;

    int hibytes = s->decode_buffer_size / 2;



    /* first, traverse through the frame and find the subchunks */

    while (bytestream2_get_bytes_left(&s->gb) >= 8) {



        chunk_type = bytestream2_get_be32u(&s->gb);

        index      = bytestream2_tell(&s->gb);

        chunk_size = bytestream2_get_be32u(&s->gb);



        switch (chunk_type) {



        case CBF0_TAG:

            cbf0_chunk = index;

            break;



        case CBFZ_T",0,0,1,0,1,1,1,0,1,0,0,1,1,0,0
21092,qemu,0,"static void platform_mmio_map(PCIDevice *d, int region_num,

                              pcibus_t addr, pcibus_t size, int type)

{

    int mmio_io_addr;



    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,

                                                 DEVICE_NATIVE_ENDIAN);



    cpu_register_physical_memory(addr, size, mmio_io_addr);

}
",2,0,0,0,0,0,1,1,1,1,1,1,1,0,1
21100,qemu,0,"static void bt_submit_hci(struct HCIInfo *info,

                const uint8_t *data, int length)

{

    struct bt_hci_s *hci = hci_from_info(info);

    uint16_t cmd;

    int paramlen, i;



    if (length < HCI_COMMAND_HDR_SIZE)

        goto short_hci;



    memcpy(&hci->last_cmd, data, 2);



    cmd = (data[1] << 8) | data[0];

    paramlen = data[2];

    if (cmd_opcode_ogf(cmd) == 0 || cmd_opcode_ocf(cmd) == 0)	/* NOP */

        return;



    data += HCI_COMMAND_HDR_SIZE;

    length -= HCI_COMMAND_HDR_SIZE;



    if (paramlen > length)

        return;



#define PARAM(cmd, param)	(((cmd##_cp *) data)->param)

#define PARAM16(cmd, param)	le16_to_cpup(&PARAM(cmd, param))

#define PARAMHANDLE(cmd)	HNDL(PARAM(cmd, handle))

#define LENGTH_CHECK(cmd)	if (length < sizeof(cmd##_cp)) goto short_hci

    /* Note: the supported commands bitmask in bt_hci_read_local_commands_rp

     * needs to be updated every time a command is implemented here!  */

    switch (cmd) {

    case cmd_opcode_pack(OGF_LINK_",0,2,4,0,1,0,1,1,1,1,1,1,1,0,1
21102,qemu,0,"static int kvm_s390_register_io_adapter(S390FLICState *fs, uint32_t id,

                                        uint8_t isc, bool swap,

                                        bool is_maskable)

{

    struct kvm_s390_io_adapter adapter = {

        .id = id,

        .isc = isc,

        .maskable = is_maskable,

        .swap = swap,

    };

    KVMS390FLICState *flic = KVM_S390_FLIC(fs);

    int r, ret;

    struct kvm_device_attr attr = {

        .group = KVM_DEV_FLIC_ADAPTER_REGISTER,

        .addr = (uint64_t)&adapter,

    };



    if (!kvm_check_extension(kvm_state, KVM_CAP_IRQ_ROUTING)) {

        /* nothing to do */

        return 0;

    }



    r = ioctl(flic->fd, KVM_SET_DEVICE_ATTR, &attr);



    ret = r ? -errno : 0;

    return ret;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
21106,qemu,0,"static void dec_calc(DisasContext *dc, uint32_t insn)

{

    uint32_t op0, op1, op2;

    uint32_t ra, rb, rd;

    op0 = extract32(insn, 0, 4);

    op1 = extract32(insn, 8, 2);

    op2 = extract32(insn, 6, 2);

    ra = extract32(insn, 16, 5);

    rb = extract32(insn, 11, 5);

    rd = extract32(insn, 21, 5);



    switch (op0) {

    case 0x0000:

        switch (op1) {

        case 0x00:    /* l.add */

            LOG_DIS(""l.add r%d, r%d, r%d\n"", rd, ra, rb);

            {

                int lab = gen_new_label();

                TCGv_i64 ta = tcg_temp_new_i64();

                TCGv_i64 tb = tcg_temp_new_i64();

                TCGv_i64 td = tcg_temp_local_new_i64();

                TCGv_i32 res = tcg_temp_local_new_i32();

                TCGv_i32 sr_ove = tcg_temp_local_new_i32();

                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);

                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);

                tcg_gen_add_i64(td, ta, tb);

                tcg_gen_trunc_i64_i32(res, td);

         ",0,0,0,0,2,0,1,1,0,0,0,0,0,0,0
21110,qemu,0,"QEMUClockType timerlist_get_clock(QEMUTimerList *timer_list)

{

    return timer_list->clock->type;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
21118,FFmpeg,1,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
",1,0,0,0,0,0,0,1,1,0,1,0,0,0,0
21135,qemu,1,"static void qio_channel_command_finalize(Object *obj)

{

    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);

    if (ioc->readfd != -1) {

        close(ioc->readfd);

        ioc->readfd = -1;

    }

    if (ioc->writefd != -1) {

        close(ioc->writefd);

        ioc->writefd = -1;

    }

    if (ioc->pid > 0) {

#ifndef WIN32

        qio_channel_command_abort(ioc, NULL);

#endif

    }

}
",0,0,5,0,0,0,1,0,0,0,0,0,0,0,0
21155,FFmpeg,1,"static int read_gab2_sub(AVStream *st, AVPacket *pkt) {

    if (!strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data+5) == 2) {

        uint8_t desc[256];

        int score = AVPROBE_SCORE_MAX / 2, ret;

        AVIStream *ast = st->priv_data;

        AVInputFormat *sub_demuxer;

        AVRational time_base;

        AVIOContext *pb = avio_alloc_context( pkt->data + 7,

                                              pkt->size - 7,

                                              0, NULL, NULL, NULL, NULL);

        AVProbeData pd;

        unsigned int desc_len = avio_rl32(pb);



        if (desc_len > pb->buf_end - pb->buf_ptr)

            goto error;



        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));

        avio_skip(pb, desc_len - ret);

        if (*desc)

            av_dict_set(&st->metadata, ""title"", desc, 0);



        avio_rl16(pb);   /* flags? */

        avio_rl32(pb);   /* data size */



        pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr };
",0,1,3,0,0,0,0,1,1,0,0,1,0,0,0
21166,FFmpeg,0,"int av_set_string3(void *obj, const char *name, const char *val, int alloc, const AVOption **o_out)

{

    int ret;

    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);

    if (o_out)

        *o_out = o;

    if (!o)

        return AVERROR_OPTION_NOT_FOUND;

    if (!val || o->offset<=0)

        return AVERROR(EINVAL);



    if (o->type == FF_OPT_TYPE_BINARY) {

        uint8_t **dst = (uint8_t **)(((uint8_t*)obj) + o->offset);

        int *lendst = (int *)(dst + 1);

        uint8_t *bin, *ptr;

        int len = strlen(val);

        av_freep(dst);

        *lendst = 0;

        if (len & 1) return AVERROR(EINVAL);

        len /= 2;

        ptr = bin = av_malloc(len);

        while (*val) {

            int a = hexchar2int(*val++);

            int b = hexchar2int(*val++);

            if (a < 0 || b < 0) {

                av_free(bin);

                return AVERROR(EINVAL);

            }

            *ptr++ = (a << 4) | b;

        }

        *dst = bin;

        *lendst = len;

     ",0,0,6,0,0,1,0,0,0,0,0,1,1,1,1
21168,FFmpeg,0,"void ff_h264_h_lpf_chroma_inter_msa(uint8_t *data, int img_width,

                                    int alpha, int beta, int8_t *tc)

{

    uint8_t bs0 = 1;

    uint8_t bs1 = 1;

    uint8_t bs2 = 1;

    uint8_t bs3 = 1;



    if (tc[0] < 0)

        bs0 = 0;

    if (tc[1] < 0)

        bs1 = 0;

    if (tc[2] < 0)

        bs2 = 0;

    if (tc[3] < 0)

        bs3 = 0;



    avc_loopfilter_cb_or_cr_inter_edge_ver_msa(data,

                                               bs0, bs1, bs2, bs3,

                                               tc[0], tc[1], tc[2], tc[3],

                                               alpha, beta,

                                               img_width);

}
",0,0,4,0,0,0,1,0,0,0,1,0,1,1,1
21202,qemu,0,"void slirp_select_poll(fd_set *readfds, fd_set *writefds, fd_set *xfds,

                       int select_error)

{

    Slirp *slirp;

    struct socket *so, *so_next;

    int ret;



    if (QTAILQ_EMPTY(&slirp_instances)) {

        return;

    }



    global_readfds = readfds;

    global_writefds = writefds;

    global_xfds = xfds;



    curtime = qemu_get_clock_ms(rt_clock);



    QTAILQ_FOREACH(slirp, &slirp_instances, entry) {

	/*

	 * See if anything has timed out

	 */

		if (time_fasttimo && ((curtime - time_fasttimo) >= 2)) {

			tcp_fasttimo(slirp);

			time_fasttimo = 0;

		}

		if (do_slowtimo && ((curtime - last_slowtimo) >= 499)) {

			ip_slowtimo(slirp);

			tcp_slowtimo(slirp);

			last_slowtimo = curtime;

		}



	/*

	 * Check sockets

	 */

	if (!select_error) {

		/*

		 * Check TCP sockets

		 */

		for (so = slirp->tcb.so_next; so != &slirp->tcb;

		     so = so_next) {

			so_next = so->so_next;



			/*

			 * FD_ISSET is meaningless on these sockets

			 * (and they can cra",1,0,5,0,0,0,0,0,0,0,0,0,1,1,1
21218,qemu,0,"uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)

{

    uint8_t opa, opb, res;

    int i;



    res = 0;

    for (i = 0; i < 7; i++) {

        opa = op1 >> (i * 8);

        opb = op2 >> (i * 8);

        if (opa >= opb)

            res |= 1 << i;

    }

    return res;

}
",1,0,1,0,0,0,0,0,0,0,1,0,0,0,0
21219,qemu,0,"static int s390_ipl_init(SysBusDevice *dev)

{

    S390IPLState *ipl = S390_IPL(dev);

    uint64_t pentry = KERN_IMAGE_START;

    int kernel_size;



    int bios_size;

    char *bios_filename;



    /*

     * Always load the bios if it was enforced,

     * even if an external kernel has been defined.

     */

    if (!ipl->kernel || ipl->enforce_bios) {

        uint64_t fwbase = (MIN(ram_size, 0x80000000U) - 0x200000) & ~0xffffUL;



        if (bios_name == NULL) {

            bios_name = ipl->firmware;

        }



        bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);

        if (bios_filename == NULL) {

            hw_error(""could not find stage1 bootloader\n"");

        }



        bios_size = load_elf(bios_filename, bios_translate_addr, &fwbase,

                             &ipl->bios_start_addr, NULL, NULL, 1,

                             ELF_MACHINE, 0);

        if (bios_size > 0) {

            /* Adjust ELF start address to final location */

            ipl->bios_",2,0,6,0,0,0,0,1,1,1,0,0,0,1,0
21250,qemu,1,"static int virtcon_parse(const char *devname)

{

    QemuOptsList *device = qemu_find_opts(""device"");

    static int index = 0;

    char label[32];

    QemuOpts *bus_opts, *dev_opts;



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_VIRTIO_CONSOLES) {

        fprintf(stderr, ""qemu: too many virtio consoles\n"");

        exit(1);

    }



    bus_opts = qemu_opts_create(device, NULL, 0);

    if (arch_type == QEMU_ARCH_S390X) {

        qemu_opt_set(bus_opts, ""driver"", ""virtio-serial-s390"");

    } else {

        qemu_opt_set(bus_opts, ""driver"", ""virtio-serial-pci"");

    } 



    dev_opts = qemu_opts_create(device, NULL, 0);

    qemu_opt_set(dev_opts, ""driver"", ""virtconsole"");



    snprintf(label, sizeof(label), ""virtcon%d"", index);

    virtcon_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!virtcon_hds[index]) {

        fprintf(stderr, ""qemu: could not open virtio console '%s': %s\n"",

                devname, strerror(errno));

        return -1;

    ",0,0,4,0,0,0,0,0,0,0,0,0,0,1,1
21256,qemu,0,"static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    }

}
",1,0,3,0,0,0,1,1,1,1,0,0,0,0,0
21261,qemu,0,"static void gen_movl_seg_T0(DisasContext *s, int seg_reg)

{

    if (s->pe && !s->vm86) {

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);

        /* abort translation because the addseg value may change or

           because ss32 may change. For R_SS, translation must always

           stop as a special handling must be done to disable hardware

           interrupts for the next instruction */

        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))

            s->is_jmp = DISAS_TB_JUMP;

    } else {

        gen_op_movl_seg_T0_vm(seg_reg);

        if (seg_reg == R_SS)

            s->is_jmp = DISAS_TB_JUMP;

    }

}
",1,0,3,0,0,0,0,0,0,0,0,0,0,0,1
21267,qemu,0,"void gen_intermediate_code_a64(ARMCPU *cpu, TranslationBlock *tb)

{

    CPUState *cs = CPU(cpu);

    CPUARMState *env = &cpu->env;

    DisasContext dc1, *dc = &dc1;

    target_ulong pc_start;

    target_ulong next_page_start;

    int num_insns;

    int max_insns;



    pc_start = tb->pc;



    dc->tb = tb;



    dc->is_jmp = DISAS_NEXT;

    dc->pc = pc_start;

    dc->singlestep_enabled = cs->singlestep_enabled;

    dc->condjmp = 0;



    dc->aarch64 = 1;

    /* If we are coming from secure EL0 in a system with a 32-bit EL3, then

     * there is no secure EL1, so we route exceptions to EL3.

     */

    dc->secure_routed_to_el3 = arm_feature(env, ARM_FEATURE_EL3) &&

                               !arm_el_is_aa64(env, 3);

    dc->thumb = 0;

    dc->bswap_code = 0;

    dc->condexec_mask = 0;

    dc->condexec_cond = 0;

    dc->mmu_idx = ARM_TBFLAG_MMUIDX(tb->flags);

    dc->current_el = arm_mmu_idx_to_el(dc->mmu_idx);

#if !defined(CONFIG_USER_ONLY)

    dc->user = (dc->current_el == 0);
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,1
21281,FFmpeg,0,"static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVStream *st;

    MOVStreamContext *sc;

    unsigned int i, entries;



    if (c->fc->nb_streams < 1)

        return 0;

    st = c->fc->streams[c->fc->nb_streams-1];

    sc = st->priv_data;



    avio_r8(pb); /* version */

    avio_rb24(pb); /* flags */



    entries = avio_rb32(pb);



    av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i\n"", c->fc->nb_streams-1, entries);



    if (!entries)

        return 0;

    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))

        return AVERROR_INVALIDDATA;

    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));

    if (!sc->stsc_data)

        return AVERROR(ENOMEM);



    for (i = 0; i < entries && !pb->eof_reached; i++) {

        sc->stsc_data[i].first = avio_rb32(pb);

        sc->stsc_data[i].count = avio_rb32(pb);

        sc->stsc_data[i].id = avio_rb32(pb);

        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {

            ",1,0,5,0,0,0,0,0,0,0,0,0,0,0,0
21284,FFmpeg,1,"static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = width * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
21296,qemu,1,"static uint16_t nvme_io_cmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req)

{

    NvmeNamespace *ns;

    uint32_t nsid = le32_to_cpu(cmd->nsid);



    if (nsid == 0 || nsid > n->num_namespaces) {

        return NVME_INVALID_NSID | NVME_DNR;

    }



    ns = &n->namespaces[nsid - 1];

    switch (cmd->opcode) {

    case NVME_CMD_FLUSH:

        return nvme_flush(n, ns, cmd, req);

    case NVME_CMD_WRITE_ZEROS:

        return nvme_write_zeros(n, ns, cmd, req);

    case NVME_CMD_WRITE:

    case NVME_CMD_READ:

        return nvme_rw(n, ns, cmd, req);

    default:

        return NVME_INVALID_OPCODE | NVME_DNR;

    }

}
",0,0,1,0,1,0,0,0,1,1,1,1,1,0,0
21302,FFmpeg,1,"void avfilter_link_free(AVFilterLink **link)

{

    if (!*link)

        return;



    if ((*link)->pool) {

        int i;

        for (i = 0; i < POOL_SIZE; i++) {

            if ((*link)->pool->pic[i]) {

                AVFilterBufferRef *picref = (*link)->pool->pic[i];

                /* free buffer: picrefs stored in the pool are not

                 * supposed to contain a free callback */

                av_freep(&picref->buf->data[0]);

                av_freep(&picref->buf);



                av_freep(&picref->audio);

                av_freep(&picref->video);

                av_freep(&picref);

            }

        }

        av_freep(&(*link)->pool);

    }

    av_freep(link);

}
",1,0,3,0,0,0,0,1,1,0,0,0,0,0,1
21306,qemu,0,"static uint64_t pl110_read(void *opaque, hwaddr offset,

                           unsigned size)

{

    pl110_state *s = (pl110_state *)opaque;



    if (offset >= 0xfe0 && offset < 0x1000) {

        return idregs[s->version][(offset - 0xfe0) >> 2];

    }

    if (offset >= 0x200 && offset < 0x400) {

        return s->raw_palette[(offset - 0x200) >> 2];

    }

    switch (offset >> 2) {

    case 0: /* LCDTiming0 */

        return s->timing[0];

    case 1: /* LCDTiming1 */

        return s->timing[1];

    case 2: /* LCDTiming2 */

        return s->timing[2];

    case 3: /* LCDTiming3 */

        return s->timing[3];

    case 4: /* LCDUPBASE */

        return s->upbase;

    case 5: /* LCDLPBASE */

        return s->lpbase;

    case 6: /* LCDIMSC */

        if (s->version != PL110) {

            return s->cr;

        }

        return s->int_mask;

    case 7: /* LCDControl */

        if (s->version != PL110) {

            return s->int_mask;

        }

        return s->cr;

    case 8",0,0,4,0,1,0,0,0,0,0,0,0,1,1,1
21311,FFmpeg,0,"static void fill_coding_method_array (sb_int8_array tone_level_idx, sb_int8_array tone_level_idx_temp,

                sb_int8_array coding_method, int nb_channels,

                int c, int superblocktype_2_3, int cm_table_select)

{

    int ch, sb, j;

    int tmp, acc, esp_40, comp;

    int add1, add2, add3, add4;

    int64_t multres;



    // This should never happen

    if (nb_channels <= 0)

        return;



    if (!superblocktype_2_3) {

        /* This case is untested, no samples available */

        SAMPLES_NEEDED

        for (ch = 0; ch < nb_channels; ch++)

            for (sb = 0; sb < 30; sb++) {

                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer

                    add1 = tone_level_idx[ch][sb][j] - 10;

                    if (add1 < 0)

                        add1 = 0;

                    add2 = add3 = add4 = 0;

                    if (sb > 1) {

                        add2 = tone_level_idx[ch][sb - 2][j] + to",3,0,4,0,0,0,0,0,0,0,0,0,0,0,0
21324,qemu,0,"void arm_cpu_dump_state(CPUState *cs, FILE *f, fprintf_function cpu_fprintf,

                        int flags)

{

    ARMCPU *cpu = ARM_CPU(cs);

    CPUARMState *env = &cpu->env;

    int i;



    if (is_a64(env)) {

        aarch64_cpu_dump_state(cs, f, cpu_fprintf, flags);

        return;

    }



    for(i=0;i<16;i++) {

        cpu_fprintf(f, ""R%02d=%08x"", i, env->regs[i]);

        if ((i % 4) == 3)

            cpu_fprintf(f, ""\n"");

        else

            cpu_fprintf(f, "" "");

    }



    if (arm_feature(env, ARM_FEATURE_M)) {

        uint32_t xpsr = xpsr_read(env);

        const char *mode;



        if (xpsr & XPSR_EXCP) {

            mode = ""handler"";

        } else {

            if (env->v7m.control & R_V7M_CONTROL_NPRIV_MASK) {

                mode = ""unpriv-thread"";

            } else {

                mode = ""priv-thread"";

            }

        }



        cpu_fprintf(f, ""XPSR=%08x %c%c%c%c %c %s\n"",

                    xpsr,

                    xpsr & XPSR_N ? 'N' : '-'",1,0,5,0,0,0,0,0,0,0,0,0,0,0,0
21335,qemu,1,"int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,

                       void *opaque, int version_id)

{

    VMStateField *field = vmsd->fields;

    int ret = 0;



    trace_vmstate_load_state(vmsd->name, version_id);

    if (version_id > vmsd->version_id) {

        error_report(""%s: incoming version_id %d is too new ""

                     ""for local version_id %d"",

                     vmsd->name, version_id, vmsd->version_id);

        trace_vmstate_load_state_end(vmsd->name, ""too new"", -EINVAL);

        return -EINVAL;

    }

    if  (version_id < vmsd->minimum_version_id) {

        if (vmsd->load_state_old &&

            version_id >= vmsd->minimum_version_id_old) {

            ret = vmsd->load_state_old(f, opaque, version_id);

            trace_vmstate_load_state_end(vmsd->name, ""old path"", ret);

            return ret;

        }

        error_report(""%s: incoming version_id %d is too old ""

                     ""for local minimum version_id  %d"",

                    ",2,0,3,0,0,0,1,1,1,1,1,1,1,1,1
21348,qemu,0,"static void xen_log_start(MemoryListener *listener,

                          MemoryRegionSection *section)

{

    XenIOState *state = container_of(listener, XenIOState, memory_listener);



    xen_sync_dirty_bitmap(state, section->offset_within_address_space,

                          int128_get64(section->size));

}
",0,0,0,0,0,0,0,0,0,0,1,0,1,1,1
21374,FFmpeg,1,"static void mpegvideo_extract_headers(AVCodecParserContext *s,

                                      AVCodecContext *avctx,

                                      const uint8_t *buf, int buf_size)

{

    ParseContext1 *pc = s->priv_data;

    const uint8_t *buf_end;


    uint32_t start_code;

    int frame_rate_index, ext_type, bytes_left;

    int frame_rate_ext_n, frame_rate_ext_d;

    int picture_structure, top_field_first, repeat_first_field, progressive_frame;

    int horiz_size_ext, vert_size_ext, bit_rate_ext;

//FIXME replace the crap with get_bits()

    s->repeat_pict = 0;

    buf_end = buf + buf_size;

    while (buf < buf_end) {

        start_code= -1;

        buf= ff_find_start_code(buf, buf_end, &start_code);

        bytes_left = buf_end - buf;

        switch(start_code) {

        case PICTURE_START_CODE:

            ff_fetch_timestamp(s, buf-buf_start-4, 1);



            if (bytes_left >= 2) {

                s->pict_type = (buf[1] >> 3) & 7;

            }

            break;

 ",0,0,1,0,1,1,1,1,1,1,1,1,0,0,0
21383,qemu,1,"static void test_smbios_ep_address(test_data *data)

{

    uint32_t off;



    /* find smbios entry point structure */

    for (off = 0xf0000; off < 0x100000; off += 0x10) {

        uint8_t sig[] = ""_SM_"";

        int i;



        for (i = 0; i < sizeof sig - 1; ++i) {

            sig[i] = readb(off + i);

        }



        if (!memcmp(sig, ""_SM_"", sizeof sig)) {

            break;

        }

    }



    g_assert_cmphex(off, <, 0x100000);

    data->smbios_ep_addr = off;

}
",2,0,1,0,0,0,0,1,0,1,1,1,0,1,1
21385,FFmpeg,1,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

",0,0,4,0,0,0,0,0,0,1,1,1,0,0,0
21386,FFmpeg,1,"static void fft_calc_c(FFTContext *s, FFTComplex *z) {



    int nbits, i, n, num_transforms, offset, step;

    int n4, n2, n34;

    FFTSample tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;

    FFTComplex *tmpz;

    const int fft_size = (1 << s->nbits);

    int64_t accu;



    num_transforms = (0x2aab >> (16 - s->nbits)) | 1;



    for (n=0; n<num_transforms; n++){

        offset = ff_fft_offsets_lut[n] << 2;

        tmpz = z + offset;



        tmp1 = tmpz[0].re + tmpz[1].re;

        tmp5 = tmpz[2].re + tmpz[3].re;

        tmp2 = tmpz[0].im + tmpz[1].im;

        tmp6 = tmpz[2].im + tmpz[3].im;

        tmp3 = tmpz[0].re - tmpz[1].re;

        tmp8 = tmpz[2].im - tmpz[3].im;

        tmp4 = tmpz[0].im - tmpz[1].im;

        tmp7 = tmpz[2].re - tmpz[3].re;



        tmpz[0].re = tmp1 + tmp5;

        tmpz[2].re = tmp1 - tmp5;

        tmpz[0].im = tmp2 + tmp6;

        tmpz[2].im = tmp2 - tmp6;

        tmpz[1].re = tmp3 + tmp8;

        tmpz[3].re = tmp3 - tmp8;

        tmpz[1].im = tmp4 - tm",4,0,0,0,0,0,1,1,1,1,1,1,0,0,0
21387,qemu,1,"int cpu_ppc_handle_mmu_fault(CPUPPCState *env, target_ulong address, int rw,

                             int mmu_idx)

{

    mmu_ctx_t ctx;

    int access_type;

    int ret = 0;



    if (rw == 2) {

        /* code access */

        rw = 0;

        access_type = ACCESS_CODE;

    } else {

        /* data access */

        access_type = env->access_type;

    }

    ret = get_physical_address(env, &ctx, address, rw, access_type);

    if (ret == 0) {

        tlb_set_page(env, address & TARGET_PAGE_MASK,

                     ctx.raddr & TARGET_PAGE_MASK, ctx.prot,

                     mmu_idx, TARGET_PAGE_SIZE);

        ret = 0;

    } else if (ret < 0) {

        LOG_MMU_STATE(env);

        if (access_type == ACCESS_CODE) {

            switch (ret) {

            case -1:

                /* No matches in page tables or TLB */

                switch (env->mmu_model) {

                case POWERPC_MMU_SOFT_6xx:

                    env->exception_index = POWERPC_EXCP_IFTLB;

                 ",0,0,4,0,2,0,0,0,0,0,0,0,1,1,1
21392,qemu,1,"void qemu_spice_display_init(DisplayState *ds)

{

    assert(sdpy.ds == NULL);

    qemu_spice_display_init_common(&sdpy, ds);

    register_displaychangelistener(ds, &display_listener);



    sdpy.qxl.base.sif = &dpy_interface.base;

    qemu_spice_add_interface(&sdpy.qxl.base);

    assert(sdpy.worker);



    qemu_spice_create_host_memslot(&sdpy);

    qemu_spice_create_host_primary(&sdpy);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
21411,qemu,0,"static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_sectors, int *pnum)

{

    uint64_t cluster_offset;

    int ret;



    *pnum = nb_sectors;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);

    if (ret < 0) {

        *pnum = 0;

    }



    return (cluster_offset != 0);

}
",0,0,1,0,0,0,1,1,0,1,0,1,0,1,1
21413,qemu,0,"static void migrate_params_test_apply(MigrateSetParameters *params,

                                      MigrationParameters *dest)

{

    *dest = migrate_get_current()->parameters;



    /* TODO use QAPI_CLONE() instead of duplicating it inline */



    if (params->has_compress_level) {

        dest->compress_level = params->compress_level;

    }



    if (params->has_compress_threads) {

        dest->compress_threads = params->compress_threads;

    }



    if (params->has_decompress_threads) {

        dest->decompress_threads = params->decompress_threads;

    }



    if (params->has_cpu_throttle_initial) {

        dest->cpu_throttle_initial = params->cpu_throttle_initial;

    }



    if (params->has_cpu_throttle_increment) {

        dest->cpu_throttle_increment = params->cpu_throttle_increment;

    }



    if (params->has_tls_creds) {

        dest->tls_creds = g_strdup(params->tls_creds);

    }



    if (params->has_tls_hostname) {

        dest->tls_hostname = g_strdup(params->tls_ho",0,0,7,0,0,0,1,0,0,0,0,1,1,1,1
21427,qemu,0,"void cpu_state_reset(CPUMIPSState *env)

{

    if (qemu_loglevel_mask(CPU_LOG_RESET)) {

        qemu_log(""CPU Reset (CPU %d)\n"", env->cpu_index);

        log_cpu_state(env, 0);

    }



    memset(env, 0, offsetof(CPUMIPSState, breakpoints));

    tlb_flush(env, 1);



    /* Reset registers to their default values */

    env->CP0_PRid = env->cpu_model->CP0_PRid;

    env->CP0_Config0 = env->cpu_model->CP0_Config0;

#ifdef TARGET_WORDS_BIGENDIAN

    env->CP0_Config0 |= (1 << CP0C0_BE);

#endif

    env->CP0_Config1 = env->cpu_model->CP0_Config1;

    env->CP0_Config2 = env->cpu_model->CP0_Config2;

    env->CP0_Config3 = env->cpu_model->CP0_Config3;

    env->CP0_Config6 = env->cpu_model->CP0_Config6;

    env->CP0_Config7 = env->cpu_model->CP0_Config7;

    env->CP0_LLAddr_rw_bitmask = env->cpu_model->CP0_LLAddr_rw_bitmask

                                 << env->cpu_model->CP0_LLAddr_shift;

    env->CP0_LLAddr_shift = env->cpu_model->CP0_LLAddr_shift;

    env->SYNCI_Step = env->cpu_model->SYNCI_Ste",0,0,6,0,0,0,0,1,1,1,1,1,0,0,0
21430,qemu,0,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,1
21435,qemu,0,"static BlockJob *find_block_job(const char *device, AioContext **aio_context,

                                Error **errp)

{

    BlockBackend *blk;

    BlockDriverState *bs;



    *aio_context = NULL;



    blk = blk_by_name(device);

    if (!blk) {

        goto notfound;

    }



    *aio_context = blk_get_aio_context(blk);

    aio_context_acquire(*aio_context);



    if (!blk_is_available(blk)) {

        goto notfound;

    }

    bs = blk_bs(blk);



    if (!bs->job) {

        goto notfound;

    }



    return bs->job;



notfound:

    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,

              ""No active block job on device '%s'"", device);

    if (*aio_context) {

        aio_context_release(*aio_context);

        *aio_context = NULL;

    }

    return NULL;

}
",0,3,4,0,0,0,0,0,0,0,0,0,0,0,0
21450,qemu,0,"static int bt_hci_parse(const char *str)

{

    struct HCIInfo *hci;

    bdaddr_t bdaddr;



    if (nb_hcis >= MAX_NICS) {

        fprintf(stderr, ""qemu: Too many bluetooth HCIs (max %i).\n"", MAX_NICS);

        return -1;

    }



    hci = hci_init(str);

    if (!hci)

        return -1;



    bdaddr.b[0] = 0x52;

    bdaddr.b[1] = 0x54;

    bdaddr.b[2] = 0x00;

    bdaddr.b[3] = 0x12;

    bdaddr.b[4] = 0x34;

    bdaddr.b[5] = 0x56 + nb_hcis;

    hci->bdaddr_set(hci, bdaddr.b);



    hci_table[nb_hcis++] = hci;



    return 0;

}
",0,0,2,0,0,0,1,1,1,1,1,1,1,1,0
21459,qemu,0,"static int cris_mmu_translate_page(struct cris_mmu_result *res,

				   CPUState *env, uint32_t vaddr,

				   int rw, int usermode, int debug)

{

	unsigned int vpage;

	unsigned int idx;

	uint32_t pid, lo, hi;

	uint32_t tlb_vpn, tlb_pfn = 0;

	int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;

	int cfg_v, cfg_k, cfg_w, cfg_x;	

	int set, match = 0;

	uint32_t r_cause;

	uint32_t r_cfg;

	int rwcause;

	int mmu = 1; /* Data mmu is default.  */

	int vect_base;



	r_cause = env->sregs[SFR_R_MM_CAUSE];

	r_cfg = env->sregs[SFR_RW_MM_CFG];

	pid = env->pregs[PR_PID] & 0xff;



	switch (rw) {

		case 2: rwcause = CRIS_MMU_ERR_EXEC; mmu = 0; break;

		case 1: rwcause = CRIS_MMU_ERR_WRITE; break;

		default:

		case 0: rwcause = CRIS_MMU_ERR_READ; break;

	}



	/* I exception vectors 4 - 7, D 8 - 11.  */

	vect_base = (mmu + 1) * 4;



	vpage = vaddr >> 13;



	/* We know the index which to check on each set.

	   Scan both I and D.  */

#if 0

	for (set = 0; set < 4; set++) {

		for (idx = 0; idx < 16; idx++) {",2,0,1,0,1,0,1,1,1,0,0,0,0,0,0
21466,qemu,1,"static void gen_dst(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
",0,0,1,0,0,0,0,0,0,1,1,1,1,1,1
21473,qemu,0,"static void x86_cpu_enable_xsave_components(X86CPU *cpu)

{

    CPUX86State *env = &cpu->env;

    int i;



    if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {

        return;

    }



    env->xsave_components = (XSTATE_FP_MASK | XSTATE_SSE_MASK);

    for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {

        const ExtSaveArea *esa = &x86_ext_save_areas[i];

        if (env->features[esa->feature] & esa->bits) {

            env->xsave_components |= (1ULL << i);

        }

    }



    if (kvm_enabled()) {

        KVMState *s = kvm_state;

        uint64_t kvm_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);

        kvm_mask <<= 32;

        kvm_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);

        env->xsave_components &= kvm_mask;

    }

}
",1,0,3,0,0,0,1,1,1,0,1,1,0,1,0
21487,qemu,0,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, raddr);



    /* TODO: storage key handling */

    return 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
21492,qemu,0,"static void nic_selective_reset(EEPRO100State * s)

{

    size_t i;

    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);

    //~ eeprom93xx_reset(s->eeprom);

    memcpy(eeprom_contents, s->conf.macaddr.a, 6);

    eeprom_contents[0xa] = 0x4000;

    if (s->device == i82557B || s->device == i82557C)

        eeprom_contents[5] = 0x0100;

    uint16_t sum = 0;

    for (i = 0; i < EEPROM_SIZE - 1; i++) {

        sum += eeprom_contents[i];

    }

    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;

    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));



    memset(s->mem, 0, sizeof(s->mem));

    uint32_t val = BIT(21);

    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));



    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));

    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));

}
",1,0,1,0,0,0,0,0,0,0,0,0,1,1,1
21508,qemu,1,"void pci_bridge_reset_reg(PCIDevice *dev)

{

    uint8_t *conf = dev->config;



    conf[PCI_PRIMARY_BUS] = 0;

    conf[PCI_SECONDARY_BUS] = 0;

    conf[PCI_SUBORDINATE_BUS] = 0;

    conf[PCI_SEC_LATENCY_TIMER] = 0;



    conf[PCI_IO_BASE] = 0;

    conf[PCI_IO_LIMIT] = 0;

    pci_set_word(conf + PCI_MEMORY_BASE, 0);

    pci_set_word(conf + PCI_MEMORY_LIMIT, 0);

    pci_set_word(conf + PCI_PREF_MEMORY_BASE, 0);

    pci_set_word(conf + PCI_PREF_MEMORY_LIMIT, 0);

    pci_set_word(conf + PCI_PREF_BASE_UPPER32, 0);

    pci_set_word(conf + PCI_PREF_LIMIT_UPPER32, 0);



    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);

}
",0,0,0,0,0,0,1,1,0,1,0,1,0,0,0
21511,qemu,1,"static int kvm_client_sync_dirty_bitmap(struct CPUPhysMemoryClient *client,

                                        target_phys_addr_t start_addr,

                                        target_phys_addr_t end_addr)

{

    return kvm_physical_sync_dirty_bitmap(start_addr, end_addr);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
21513,qemu,0,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)

{

    PCIBonitoState *s = opaque;

    uint32_t saddr;



    saddr = (addr - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);

    switch (saddr) {

    case BONITO_INTISR:

        return s->regs[saddr];

    default:

        return s->regs[saddr];

    }

}
",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
21538,qemu,0,"struct omap_mpu_state_s *omap310_mpu_init(MemoryRegion *system_memory,

                unsigned long sdram_size,

                const char *core)

{

    int i;

    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)

            g_malloc0(sizeof(struct omap_mpu_state_s));

    qemu_irq dma_irqs[6];

    DriveInfo *dinfo;

    SysBusDevice *busdev;



    if (!core)

        core = ""ti925t"";



    /* Core */

    s->mpu_model = omap310;

    s->cpu = cpu_arm_init(core);

    if (s->cpu == NULL) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }

    s->sdram_size = sdram_size;

    s->sram_size = OMAP15XX_SRAM_SIZE;



    s->wakeup = qemu_allocate_irq(omap_mpu_wakeup, s, 0);



    /* Clocks */

    omap_clk_init(s);



    /* Memory-mapped stuff */

    memory_region_init_ram(&s->emiff_ram, NULL, ""omap1.dram"", s->sdram_size,

                           &error_abort);

    vmstate_register_ram_global(&s->emiff_ram);

    memory_region_add_subregion(system_memory",0,0,4,0,0,0,0,0,0,0,0,0,0,1,0
21549,qemu,0,"void nbd_client_close(NBDClient *client)

{

    if (client->closing) {

        return;

    }



    client->closing = true;



    /* Force requests to finish.  They will drop their own references,

     * then we'll close the socket and free the NBDClient.

     */

    shutdown(client->sock, 2);



    /* Also tell the client, so that they release their reference.  */

    if (client->close) {

        client->close(client);

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
21567,qemu,1,"static bool find_dirty_block(RAMState *rs, PageSearchStatus *pss,

                             bool *again, ram_addr_t *ram_addr_abs)

{

    pss->offset = migration_bitmap_find_dirty(rs, pss->block, pss->offset,

                                              ram_addr_abs);

    if (pss->complete_round && pss->block == rs->last_seen_block &&

        pss->offset >= rs->last_offset) {

        /*

         * We've been once around the RAM and haven't found anything.

         * Give up.

         */

        *again = false;

        return false;

    }

    if (pss->offset >= pss->block->used_length) {

        /* Didn't find anything in this RAM Block */

        pss->offset = 0;

        pss->block = QLIST_NEXT_RCU(pss->block, next);

        if (!pss->block) {

            /* Hit the end of the list */

            pss->block = QLIST_FIRST_RCU(&ram_list.blocks);

            /* Flag that we've looped */

            pss->complete_round = true;

            rs->ram_bulk_stage = false;

            if (migr",0,0,4,0,0,0,0,0,0,0,0,1,0,0,0
21569,qemu,1,"void OPPROTO op_POWER_doz (void)

{

    if (Ts1 > Ts0)

        T0 = T1 - T0;

    else

        T0 = 0;

    RETURN();

}
",0,0,1,0,0,0,1,1,1,1,1,1,0,1,1
21576,FFmpeg,0,"int ff_wmv2_decode_secondary_picture_header(MpegEncContext *s)

{

    Wmv2Context *const w = (Wmv2Context *) s;



    if (s->pict_type == AV_PICTURE_TYPE_I) {

        if (w->j_type_bit)

            w->j_type = get_bits1(&s->gb);

        else

            w->j_type = 0; // FIXME check



        if (!w->j_type) {

            if (w->per_mb_rl_bit)

                s->per_mb_rl_table = get_bits1(&s->gb);

            else

                s->per_mb_rl_table = 0;



            if (!s->per_mb_rl_table) {

                s->rl_chroma_table_index = decode012(&s->gb);

                s->rl_table_index        = decode012(&s->gb);

            }



            s->dc_table_index = get_bits1(&s->gb);

        }

        s->inter_intra_pred = 0;

        s->no_rounding      = 1;

        if (s->avctx->debug & FF_DEBUG_PICT_INFO) {

            av_log(s->avctx, AV_LOG_DEBUG,

                   ""qscale:%d rlc:%d rl:%d dc:%d mbrl:%d j_type:%d \n"",

                   s->qscale, s->rl_chroma_table_index, s->rl_table",0,0,6,0,0,0,0,0,1,0,0,0,1,0,0
21583,FFmpeg,1,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int inc, void *y_tab)

{

    int i;

    uint8_t *y_table = y_tab;



    y_table -= elemsize * (inc >> 9);



    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {

        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;

        table[i] = y_table + elemsize * (cb >> 16);

    }

}
",1,0,0,0,0,0,1,1,1,0,0,1,0,0,0
21584,FFmpeg,0,"static int allocate_buffers(ALACContext *alac)

{

    int ch;

    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {

        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);



        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],

                         buf_size, buf_alloc_fail);



        if (alac->sample_size == 16) {

            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],

                             buf_size, buf_alloc_fail);

        }



        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],

                         buf_size, buf_alloc_fail);

    }

    return 0;

buf_alloc_fail:

    alac_decode_close(alac->avctx);

    return AVERROR(ENOMEM);

}
",1,0,1,0,0,0,1,0,0,1,1,1,0,0,1
21585,FFmpeg,0,"static int put_cod(Jpeg2000EncoderContext *s)

{

    Jpeg2000CodingStyle *codsty = &s->codsty;



    if (s->buf_end - s->buf < 14)

        return -1;



    bytestream_put_be16(&s->buf, JPEG2000_COD);

    bytestream_put_be16(&s->buf, 12); // Lcod

    bytestream_put_byte(&s->buf, 0);  // Scod

    // SGcod

    bytestream_put_byte(&s->buf, 0); // progression level

    bytestream_put_be16(&s->buf, 1); // num of layers

    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){

        bytestream_put_byte(&s->buf, 2); // ICT

    }else{

        bytestream_put_byte(&s->buf, 0); // unspecified

    }

    // SPcod

    bytestream_put_byte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels

    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2); // cblk width

    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2); // cblk height

    bytestream_put_byte(&s->buf, 0); // cblk style

    bytestream_put_byte(&s->buf, codsty->transform); // transformation

    return 0;

}
",1,0,2,0,0,0,1,1,1,1,1,0,1,0,0
21612,qemu,0,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,

                                        hwaddr size, unsigned client)

{

    assert(mr->terminates);

    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,

                                                    size, client);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,0
21622,qemu,0,"static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    BlockDriverInfo bdi;

    int ret;



    ret = bdrv_get_info(bs, &bdi);

    if (ret < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;

    } else {

        return bdi.cluster_size;

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,0
21641,FFmpeg,0,"static int libschroedinger_encode_frame(AVCodecContext *avctx, AVPacket *pkt,

                                        const AVFrame *frame, int *got_packet)

{

    int enc_size = 0;

    SchroEncoderParams *p_schro_params = avctx->priv_data;

    SchroEncoder *encoder = p_schro_params->encoder;

    struct FFSchroEncodedFrame *p_frame_output = NULL;

    int go = 1;

    SchroBuffer *enc_buf;

    int presentation_frame;

    int parse_code;

    int last_frame_in_sequence = 0;

    int pkt_size, ret;



    if (!frame) {

        /* Push end of sequence if not already signalled. */

        if (!p_schro_params->eos_signalled) {

            schro_encoder_end_of_stream(encoder);

            p_schro_params->eos_signalled = 1;

        }

    } else {

        /* Allocate frame data to schro input buffer. */

        SchroFrame *in_frame = libschroedinger_frame_from_data(avctx, frame);

        if (!in_frame)

            return AVERROR(ENOMEM);

        /* Load next frame. */

        schro_encoder_push_fra",0,0,3,0,0,0,1,1,1,0,0,0,0,1,1
21665,FFmpeg,0,"static int fill_default_ref_list(H264Context *h){

    MpegEncContext * const s = &h->s;

    int i;

    int smallest_poc_greater_than_current = -1;

    int structure_sel;

    Picture sorted_short_ref[32];

    Picture field_entry_list[2][32];

    Picture *frame_list[2];



    if (FIELD_PICTURE) {

        structure_sel = PICT_FRAME;

        frame_list[0] = field_entry_list[0];

        frame_list[1] = field_entry_list[1];

    } else {

        structure_sel = 0;

        frame_list[0] = h->default_ref_list[0];

        frame_list[1] = h->default_ref_list[1];

    }



    if(h->slice_type_nos==FF_B_TYPE){

        int list;

        int len[2];

        int short_len[2];

        int out_i;

        int limit= INT_MIN;



        /* sort frame according to POC in B slice */

        for(out_i=0; out_i<h->short_ref_count; out_i++){

            int best_i=INT_MIN;

            int best_poc=INT_MAX;



            for(i=0; i<h->short_ref_count; i++){

                const int poc= h->short_ref[i]->poc;",2,0,2,0,0,0,0,0,0,0,0,0,1,1,1
21670,qemu,1,"void qemu_savevm_state_complete(QEMUFile *f)

{

    QJSON *vmdesc;

    int vmdesc_len;

    SaveStateEntry *se;

    int ret;



    trace_savevm_state_complete();



    cpu_synchronize_all_states();



    QTAILQ_FOREACH(se, &savevm_state.handlers, entry) {

        if (!se->ops || !se->ops->save_live_complete) {

            continue;

        }

        if (se->ops && se->ops->is_active) {

            if (!se->ops->is_active(se->opaque)) {

                continue;

            }

        }

        trace_savevm_section_start(se->idstr, se->section_id);



        save_section_header(f, se, QEMU_VM_SECTION_END);



        ret = se->ops->save_live_complete(f, se->opaque);

        trace_savevm_section_end(se->idstr, se->section_id, ret);


        if (ret < 0) {

            qemu_file_set_error(f, ret);

            return;

        }

    }



    vmdesc = qjson_new();

    json_prop_int(vmdesc, ""page_size"", TARGET_PAGE_SIZE);

    json_start_array(vmdesc, ""devices"");

    QTAILQ_FOREACH(se, &savevm_",0,0,4,0,0,0,1,1,1,1,1,1,1,1,1
21694,qemu,1,"static void mvp_init (CPUMIPSState *env, const mips_def_t *def)

{

    env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));



    /* MVPConf1 implemented, TLB sharable, no gating storage support,

       programmable cache partitioning implemented, number of allocatable

       and sharable TLB entries, MVP has allocatable TCs, 2 VPEs

       implemented, 5 TCs implemented. */

    env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |

                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |

// TODO: actually do 2 VPEs.

//                             (1 << CP0MVPC0_TCA) | (0x1 << CP0MVPC0_PVPE) |

//                             (0x04 << CP0MVPC0_PTC);

                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |

                             (0x00 << CP0MVPC0_PTC);

#if !defined(CONFIG_USER_ONLY)

    /* Usermode has no TLB support */

    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);

#endif



    /* Allocatable CP1 have media extensions, allocat",0,0,2,0,0,0,1,1,1,1,1,1,1,0,0
21708,FFmpeg,1,"static int decode_band(IVI45DecContext *ctx, int plane_num,

                       IVIBandDesc *band, AVCodecContext *avctx)

{

    int         result, i, t, idx1, idx2, pos;

    IVITile     *tile;



    band->buf     = band->bufs[ctx->dst_buf];

    if (!band->buf) {

        av_log(avctx, AV_LOG_ERROR, ""Band buffer points to no data!\n"");

        return AVERROR_INVALIDDATA;

    }

    band->ref_buf = band->bufs[ctx->ref_buf];

    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);



    result = ctx->decode_band_hdr(ctx, band, avctx);

    if (result) {

        av_log(avctx, AV_LOG_ERROR, ""Error while decoding band header: %d\n"",

               result);

        return result;

    }



    if (band->is_empty) {

        av_log(avctx, AV_LOG_ERROR, ""Empty band encountered!\n"");

        return AVERROR_INVALIDDATA;

    }



    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];



    /* apply corrections to the selected rvmap table if present */

    for (i = 0; i < band->num_corr;",1,0,3,0,0,1,1,1,1,0,1,0,1,1,1
21723,qemu,0,"static int s390_virtio_device_init(VirtIOS390Device *dev, VirtIODevice *vdev)

{

    VirtIOS390Bus *bus;

    int dev_len;



    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    dev->vdev = vdev;

    dev->dev_offs = bus->dev_offs;

    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */



    dev_len = VIRTIO_DEV_OFFS_CONFIG;

    dev_len += s390_virtio_device_num_vq(dev) * VIRTIO_VQCONFIG_LEN;

    dev_len += dev->feat_len * 2;

    dev_len += virtio_bus_get_vdev_config_len(&dev->bus);



    bus->dev_offs += dev_len;



    dev->host_features = virtio_bus_get_vdev_features(&dev->bus,

                                                      dev->host_features);

    s390_virtio_device_sync(dev);

    s390_virtio_reset_idx(dev);

    if (dev->qdev.hotplugged) {

        S390CPU *cpu = s390_cpu_addr2state(0);

        s390_virtio_irq(cpu, VIRTIO_PARAM_DEV_ADD, dev->dev_offs);

    }



    return 0;

}
",0,0,1,0,0,0,0,0,0,0,1,0,1,1,1
21731,qemu,0,"RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,

                                  void (*resized)(const char*,

                                                  uint64_t length,

                                                  void *host),

                                  void *host, bool resizeable,

                                  MemoryRegion *mr, Error **errp)

{

    RAMBlock *new_block;

    Error *local_err = NULL;



    size = HOST_PAGE_ALIGN(size);

    max_size = HOST_PAGE_ALIGN(max_size);

    new_block = g_malloc0(sizeof(*new_block));

    new_block->mr = mr;

    new_block->resized = resized;

    new_block->used_length = size;

    new_block->max_length = max_size;

    assert(max_size >= size);

    new_block->fd = -1;

    new_block->host = host;

    if (host) {

        new_block->flags |= RAM_PREALLOC;

    }

    if (resizeable) {

        new_block->flags |= RAM_RESIZEABLE;

    }

    ram_block_add(new_block, &local_err);

    if (local_err) {

        g_",0,0,3,0,0,0,0,0,0,0,0,0,1,0,1
21739,qemu,0,"static inline void tcg_out_movi(TCGContext *s, TCGType type,

                                int ret, tcg_target_long arg)

{

#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)

    if (arg != (arg & 0xffffffff))

        fprintf(stderr, ""unimplemented %s with constant %ld\n"", __func__, arg);

#endif

    if (arg == (arg & 0xfff))

        tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(TCG_REG_G0) |

                  INSN_IMM13(arg));

    else {

        tcg_out32(s, SETHI | INSN_RD(ret) | ((arg & 0xfffffc00) >> 10));

        if (arg & 0x3ff)

            tcg_out32(s, ARITH_OR | INSN_RD(ret) | INSN_RS1(ret) |

                      INSN_IMM13(arg & 0x3ff));

    }

}
",0,0,5,0,0,0,0,0,0,1,0,0,1,1,1
21740,qemu,0,"qcrypto_block_luks_create(QCryptoBlock *block,

                          QCryptoBlockCreateOptions *options,

                          QCryptoBlockInitFunc initfunc,

                          QCryptoBlockWriteFunc writefunc,

                          void *opaque,

                          Error **errp)

{

    QCryptoBlockLUKS *luks;

    QCryptoBlockCreateOptionsLUKS luks_opts;

    Error *local_err = NULL;

    uint8_t *masterkey = NULL;

    uint8_t *slotkey = NULL;

    uint8_t *splitkey = NULL;

    size_t splitkeylen = 0;

    size_t i;

    QCryptoCipher *cipher = NULL;

    QCryptoIVGen *ivgen = NULL;

    char *password;

    const char *cipher_alg;

    const char *cipher_mode;

    const char *ivgen_alg;

    const char *ivgen_hash_alg = NULL;

    const char *hash_alg;

    char *cipher_mode_spec = NULL;

    QCryptoCipherAlgorithm ivcipheralg = 0;

    uint64_t iters;



    memcpy(&luks_opts, &options->u.luks, sizeof(luks_opts));

    if (!luks_opts.has_iter_time) {

        luks_opts.iter",0,0,1,0,0,0,0,0,0,0,0,0,0,0,1
21750,FFmpeg,1,"static int swf_write_trailer(AVFormatContext *s)

{

    SWFContext *swf = s->priv_data;

    ByteIOContext *pb = &s->pb;

    AVCodecContext *enc, *video_enc;

    int file_size, i;



    video_enc = NULL;

    for(i=0;i<s->nb_streams;i++) {

        enc = &s->streams[i]->codec;

        if (enc->codec_type == CODEC_TYPE_VIDEO)

            video_enc = enc;

    }



    put_swf_tag(s, TAG_END);

    put_swf_end_tag(s);

    

    put_flush_packet(&s->pb);



    /* patch file size and number of frames if not streamed */

    if (!url_is_streamed(&s->pb) && video_enc) {

        file_size = url_ftell(pb);

        url_fseek(pb, 4, SEEK_SET);

        put_le32(pb, file_size);

        url_fseek(pb, swf->duration_pos, SEEK_SET);

        put_le16(pb, video_enc->frame_number);

    }

    av_free(swf);

    return 0;

}
",1,0,2,0,0,0,0,0,0,1,1,1,1,1,0
21762,FFmpeg,1,"static int xpm_decode_frame(AVCodecContext *avctx, void *data,

                            int *got_frame, AVPacket *avpkt)

{

    XPMDecContext *x = avctx->priv_data;

    AVFrame *p=data;

    const uint8_t *end, *ptr = avpkt->data;

    int ncolors, cpp, ret, i, j;

    int64_t size;

    uint32_t *dst;



    avctx->pix_fmt = AV_PIX_FMT_BGRA;



    end = avpkt->data + avpkt->size;

    while (memcmp(ptr, ""/* XPM */\n"", 10) && ptr < end - 10)

        ptr++;



    if (ptr >= end) {

        av_log(avctx, AV_LOG_ERROR, ""missing signature\n"");

        return AVERROR_INVALIDDATA;

    }



    ptr += mod_strcspn(ptr, ""\"""");

    if (sscanf(ptr, ""\""%u %u %u %u\"","",

               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {

        av_log(avctx, AV_LOG_ERROR, ""missing image parameters\n"");

        return AVERROR_INVALIDDATA;

    }



    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)

        return ret;



    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)

        retu",0,0,4,0,0,1,1,1,1,1,1,1,1,1,1
21766,FFmpeg,0,"static void ripemd160_transform(uint32_t *state, const uint8_t buffer[64], int ext)

{

    uint32_t a, b, c, d, e, f, g, h, i, j;

    uint32_t block[16];

    int n;



    if (ext) {

        a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4];

        f = state[5]; g = state[6]; h = state[7]; i = state[8]; j = state[9];

    } else {

        a = f = state[0];

        b = g = state[1];

        c = h = state[2];

        d = i = state[3];

        e = j = state[4];

    }



    for (n = 0; n < 16; n++)

        block[n] = AV_RL32(buffer + 4 * n);



    for (n = 0; n < 16 - 1;) {

        ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j);

        ROUND160_0_TO_15(e,a,b,c,d,j,f,g,h,i);

        ROUND160_0_TO_15(d,e,a,b,c,i,j,f,g,h);

        ROUND160_0_TO_15(c,d,e,a,b,h,i,j,f,g);

        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);

    }

    ROUND160_0_TO_15(a,b,c,d,e,f,g,h,i,j);

    SWAP(a,f)



    for (; n < 32 - 1;) {

        ROUND160_16_TO_31(e,a,b,c,d,j,f,g,h,i);

        ROUND160_16_TO_31(d,",4,0,1,0,0,0,0,0,0,0,0,0,1,1,1
21767,FFmpeg,0,"static void opt_frame_size(const char *arg)

{

    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {

        fprintf(stderr, ""Incorrect frame size\n"");

        av_exit(1);

    }

    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {

        fprintf(stderr, ""Frame size must be a multiple of 2\n"");

        av_exit(1);

    }

}
",0,0,2,0,0,0,0,1,1,0,0,0,1,0,1
21776,FFmpeg,1,"static int sdl_write_trailer(AVFormatContext *s)

{

    SDLContext *sdl = s->priv_data;



    sdl->quit = 1;



    if (sdl->overlay)

        SDL_FreeYUVOverlay(sdl->overlay);


    if (sdl->event_thread)

        SDL_WaitThread(sdl->event_thread, NULL);


    if (sdl->mutex)

        SDL_DestroyMutex(sdl->mutex);


    if (sdl->init_cond)

        SDL_DestroyCond(sdl->init_cond);




    if (!sdl->sdl_was_already_inited)

        SDL_Quit();



    return 0;

}",0,0,5,0,0,0,1,1,1,1,1,0,1,1,1
21779,FFmpeg,0,"void MPV_decode_mb(MpegEncContext *s, DCTELEM block[6][64])

{

    int mb_x, mb_y;

    int dct_linesize, dct_offset;

    op_pixels_func *op_pix;

    qpel_mc_func *op_qpix;



    mb_x = s->mb_x;

    mb_y = s->mb_y;



#ifdef FF_POSTPROCESS

    quant_store[mb_y][mb_x]=s->qscale;

    //printf(""[%02d][%02d] %d\n"",mb_x,mb_y,s->qscale);

#endif



    /* update DC predictors for P macroblocks */

    if (!s->mb_intra) {

        if (s->h263_pred || s->h263_aic) {

          if(s->mbintra_table[mb_x + mb_y*s->mb_width])

          {

            int wrap, xy, v;

            s->mbintra_table[mb_x + mb_y*s->mb_width]=0;

            wrap = 2 * s->mb_width + 2;

            xy = 2 * mb_x + 1 +  (2 * mb_y + 1) * wrap;

            v = 1024;

            

            s->dc_val[0][xy] = v;

            s->dc_val[0][xy + 1] = v;

            s->dc_val[0][xy + wrap] = v;

            s->dc_val[0][xy + 1 + wrap] = v;

            /* ac pred */

            memset(s->ac_val[0][xy], 0, 16 * sizeof(INT16));

         ",0,0,5,0,0,0,0,0,0,1,1,0,1,1,1
21794,qemu,1,"static void kvm_hwpoison_page_add(ram_addr_t ram_addr)

{

    HWPoisonPage *page;



    QLIST_FOREACH(page, &hwpoison_page_list, list) {

        if (page->ram_addr == ram_addr) {

            return;

        }

    }

    page = g_malloc(sizeof(HWPoisonPage));

    page->ram_addr = ram_addr;

    QLIST_INSERT_HEAD(&hwpoison_page_list, page, list);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
21796,FFmpeg,1,"static int decode_i_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int pqindex;



    /* Prolog common to all frametypes should be done in caller */

    //BF = Buffer Fullness

    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))

    {

        av_log(v->s.avctx, AV_LOG_DEBUG, ""I BufferFullness not 0\n"");

    }



    /* Quantizer stuff */

    pqindex = get_bits(gb, 5);

    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)

        v->pq = pquant_table[0][pqindex];

    else

    {

        v->pq = pquant_table[v->quantizer_mode-1][pqindex];

    }

    if (pqindex < 9) v->halfpq = get_bits(gb, 1);

    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)

        v->pquantizer = get_bits(gb, 1);

    av_log(v->s.avctx, AV_LOG_DEBUG, ""I frame: QP=%i (+%i/2)\n"",

           v->pq, v->halfpq);

    return 0;

}
",0,0,4,0,0,0,0,0,0,1,0,0,1,1,1
21820,qemu,1,"static void pcie_mmcfg_data_write(PCIBus *s,

                                  uint32_t mmcfg_addr, uint32_t val, int len)

{

    PCIDevice *pci_dev = pcie_dev_find_by_mmcfg_addr(s, mmcfg_addr);



    if (!pci_dev) {

        return;

    }

    pci_host_config_write_common(pci_dev, PCIE_MMCFG_CONFOFFSET(mmcfg_addr),

                                 pci_config_size(pci_dev), val, len);

}
",0,0,1,0,0,0,0,0,0,1,0,0,1,1,1
21822,FFmpeg,1,"static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
",0,0,2,0,0,1,1,1,1,1,1,1,0,1,1
21828,FFmpeg,0,"static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom)

{

    char *str = NULL;

    int size;

    uint16_t str_size;



    if (c->itunes_metadata) {

        int data_size = get_be32(pb);

        int tag = get_le32(pb);

        if (tag == MKTAG('d','a','t','a')) {

            get_be32(pb); // type

            get_be32(pb); // unknown

            str_size = data_size - 16;

        } else return 0;

    } else {

        str_size = get_be16(pb); // string length

        get_be16(pb); // language

    }

    switch (atom.type) {

    case MKTAG(0xa9,'n','a','m'):

        str = c->fc->title; size = sizeof(c->fc->title); break;

    case MKTAG(0xa9,'A','R','T'):

    case MKTAG(0xa9,'w','r','t'):

        str = c->fc->author; size = sizeof(c->fc->author); break;

    case MKTAG(0xa9,'c','p','y'):

        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;

    case MKTAG(0xa9,'c','m','t'):

    case MKTAG(0xa9,'i','n','f'):

        str = c->fc->comment; size = siz",0,0,2,0,1,0,0,0,0,1,0,0,0,0,0
21836,qemu,1,"void aio_context_setup(AioContext *ctx, Error **errp)

{

#ifdef CONFIG_EPOLL

    assert(!ctx->epollfd);

    ctx->epollfd = epoll_create1(EPOLL_CLOEXEC);

    if (ctx->epollfd == -1) {

        ctx->epoll_available = false;

    } else {

        ctx->epoll_available = true;

    }

#endif

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,1,0
21841,FFmpeg,0,"static int dvbsub_display_end_segment(AVCodecContext *avctx, const uint8_t *buf,

                                        int buf_size, AVSubtitle *sub)

{

    DVBSubContext *ctx = avctx->priv_data;

    DVBSubDisplayDefinition *display_def = ctx->display_definition;



    DVBSubRegion *region;

    DVBSubRegionDisplay *display;

    AVSubtitleRect *rect;

    DVBSubCLUT *clut;

    uint32_t *clut_table;

    int i;

    int offset_x=0, offset_y=0;



    sub->rects = NULL;

    sub->start_display_time = 0;

    sub->end_display_time = ctx->time_out * 1000;

    sub->format = 0;



    if (display_def) {

        offset_x = display_def->x;

        offset_y = display_def->y;

    }



    sub->num_rects = ctx->display_list_size;

    if (sub->num_rects <= 0)

        return AVERROR_INVALIDDATA;



    sub->rects = av_mallocz_array(sub->num_rects * sub->num_rects,

                                  sizeof(*sub->rects));

    if (!sub->rects)

        return AVERROR(ENOMEM);



    i = 0;



    for (display ",2,0,3,0,0,0,0,0,1,0,0,0,1,1,1
21851,FFmpeg,0,"static QUANT_FN(pvq_encode_band)

{

    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,

                               lowband_out, level, gain, lowband_scratch, fill, 1);

}
",0,0,0,0,0,0,1,0,1,0,0,1,1,0,0
21863,qemu,0,"static void kvm_set_phys_mem(target_phys_addr_t start_addr,

			     ram_addr_t size,

			     ram_addr_t phys_offset)

{

    KVMState *s = kvm_state;

    ram_addr_t flags = phys_offset & ~TARGET_PAGE_MASK;

    KVMSlot *mem, old;

    int err;



    /* kvm works in page size chunks, but the function may be called

       with sub-page size and unaligned start address. */

    size = TARGET_PAGE_ALIGN(size);

    start_addr = TARGET_PAGE_ALIGN(start_addr);



    /* KVM does not support read-only slots */

    phys_offset &= ~IO_MEM_ROM;



    while (1) {

        mem = kvm_lookup_overlapping_slot(s, start_addr, start_addr + size);

        if (!mem) {

            break;

        }



        if (flags < IO_MEM_UNASSIGNED && start_addr >= mem->start_addr &&

            (start_addr + size <= mem->start_addr + mem->memory_size) &&

            (phys_offset - start_addr == mem->phys_offset - mem->start_addr)) {

            /* The new slot fits into the existing one and comes with

             * identical",0,0,2,0,0,1,0,0,0,1,1,1,0,0,0
21889,qemu,1,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,

                                   unsigned size)

{

}
",0,0,0,0,0,0,0,1,1,1,1,1,0,0,0
21899,FFmpeg,1,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height){

    int w_align= 1;

    int h_align= 1;



    switch(s->pix_fmt){

    case PIX_FMT_YUV420P:

    case PIX_FMT_YUYV422:

    case PIX_FMT_UYVY422:

    case PIX_FMT_YUV422P:

    case PIX_FMT_YUV444P:

    case PIX_FMT_GRAY8:

    case PIX_FMT_GRAY16BE:

    case PIX_FMT_GRAY16LE:

    case PIX_FMT_YUVJ420P:

    case PIX_FMT_YUVJ422P:

    case PIX_FMT_YUVJ444P:

    case PIX_FMT_YUVA420P:

        w_align= 16; //FIXME check for non mpeg style codecs and use less alignment

        h_align= 16;



        break;

    case PIX_FMT_YUV411P:

    case PIX_FMT_UYYVYY411:

        w_align=32;

        h_align=8;

        break;

    case PIX_FMT_YUV410P:

        if(s->codec_id == CODEC_ID_SVQ1){

            w_align=64;

            h_align=64;

        }

    case PIX_FMT_RGB555:

        if(s->codec_id == CODEC_ID_RPZA){

            w_align=4;

            h_align=4;

        }

    case PIX_FMT_PAL8:

    case PIX_FMT_BGR8:

    ca",0,0,2,0,1,0,0,0,0,0,0,0,1,0,0
21919,FFmpeg,1,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){

    c->bytestream_start=

    c->bytestream= buf;

    c->bytestream_end= buf + buf_size;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
",0,0,2,0,0,0,1,1,1,1,1,1,1,0,1
21925,FFmpeg,1,"static int hls_read_header(AVFormatContext *s)

{

    void *u = (s->flags & AVFMT_FLAG_CUSTOM_IO) ? NULL : s->pb;

    HLSContext *c = s->priv_data;

    int ret = 0, i;

    int highest_cur_seq_no = 0;



    c->ctx                = s;

    c->interrupt_callback = &s->interrupt_callback;

    c->strict_std_compliance = s->strict_std_compliance;



    c->first_packet = 1;

    c->first_timestamp = AV_NOPTS_VALUE;

    c->cur_timestamp = AV_NOPTS_VALUE;



    if (u) {

        // get the previous user agent & set back to null if string size is zero

        update_options(&c->user_agent, ""user-agent"", u);



        // get the previous cookies & set back to null if string size is zero

        update_options(&c->cookies, ""cookies"", u);



        // get the previous headers & set back to null if string size is zero

        update_options(&c->headers, ""headers"", u);



        // get the previous http proxt & set back to null if string size is zero

        update_options(&c->http_proxy, ""http_proxy"", u);

",0,0,1,0,0,0,1,1,1,1,1,1,0,1,1
21938,FFmpeg,0,"AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)

{

    AVBitStreamFilter *bsf = first_bitstream_filter;



    while (bsf) {

        if (!strcmp(name, bsf->name)) {

            AVBitStreamFilterContext *bsfc =

                av_mallocz(sizeof(AVBitStreamFilterContext));

            bsfc->filter    = bsf;

            bsfc->priv_data =

                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;

            return bsfc;

        }

        bsf = bsf->next;

    }

    return NULL;

}
",0,0,1,0,0,1,0,0,0,0,0,0,0,0,0
21957,qemu,1,"PPC_OP(divw)

{

    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {

        T0 = (int32_t)((-1) * (T0 >> 31));

    } else {

        T0 = (Ts0 / Ts1);

    }

    RETURN();

}
",0,0,1,0,0,0,0,0,0,1,1,0,0,0,0
21958,qemu,1,"BlockInterfaceErrorAction drive_get_onerror(BlockDriverState *bdrv)

{

    int index;



    for (index = 0; index < nb_drives; index++)

        if (drives_table[index].bdrv == bdrv)

            return drives_table[index].onerror;



    return BLOCK_ERR_REPORT;

}
",1,0,1,0,0,0,1,1,1,1,1,1,0,0,1
21962,qemu,1,"static void netfilter_finalize(Object *obj)

{

    NetFilterState *nf = NETFILTER(obj);

    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);



    if (nfc->cleanup) {

        nfc->cleanup(nf);

    }



    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {

        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);

    }


}",0,0,2,0,0,0,1,0,1,1,1,1,0,1,0
21967,qemu,1,"static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    pc_compat_1_5(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
21969,qemu,1,"static void amdvi_realize(DeviceState *dev, Error **err)

{

    int ret = 0;

    AMDVIState *s = AMD_IOMMU_DEVICE(dev);

    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);

    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;

    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,

                                     amdvi_uint64_equal, g_free, g_free);



    /* This device should take care of IOMMU PCI properties */

    x86_iommu->type = TYPE_AMD;

    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);

    object_property_set_bool(OBJECT(&s->pci), true, ""realized"", err);

    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,

                                         AMDVI_CAPAB_SIZE);

    assert(s->capab_offset > 0);

    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);

    assert(ret > 0);

    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);

    assert(ret > 0);



    /* set up MMIO */

    memory_region_init",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
21971,FFmpeg,1,"int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)

{

    DynBuffer *d = s->opaque;

    int size;

    static const char padbuf[FF_INPUT_BUFFER_PADDING_SIZE] = {0};

    int padding = 0;



    if (!s) {

        *pbuffer = NULL;

        return 0;

    }



    /* don't attempt to pad fixed-size packet buffers */

    if (!s->max_packet_size) {

        avio_write(s, padbuf, sizeof(padbuf));

        padding = FF_INPUT_BUFFER_PADDING_SIZE;

    }



    avio_flush(s);



    *pbuffer = d->buffer;

    size = d->size;

    av_free(d);

    av_free(s);

    return size - padding;

}
",0,0,2,0,0,0,1,0,0,0,0,0,1,1,1
21995,qemu,1,"static void qemu_net_queue_append(NetQueue *queue,

                                  NetClientState *sender,

                                  unsigned flags,

                                  const uint8_t *buf,

                                  size_t size,

                                  NetPacketSent *sent_cb)

{

    NetPacket *packet;



    if (queue->nq_count >= queue->nq_maxlen && !sent_cb) {

        return; /* drop if queue full and no callback */

    }

    packet = g_malloc(sizeof(NetPacket) + size);

    packet->sender = sender;

    packet->flags = flags;

    packet->size = size;

    packet->sent_cb = sent_cb;

    memcpy(packet->data, buf, size);




    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);

}",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
22003,FFmpeg,1,"static void decode_subframe_lpc(ShortenContext *s, int channel, int residual_size, int pred_order)

{

    int sum, i, j;

    int coeffs[pred_order];



    for (i=0; i<pred_order; i++)

        coeffs[i] = get_sr_golomb_shorten(&s->gb, LPCQUANT);



    for (i=0; i < s->blocksize; i++) {

        sum = s->lpcqoffset;

        for (j=0; j<pred_order; j++)

            sum += coeffs[j] * s->decoded[channel][i-j-1];

        s->decoded[channel][i] = get_sr_golomb_shorten(&s->gb, residual_size) + (sum >> LPCQUANT);

    }

}
",3,0,0,0,0,0,1,1,1,0,1,0,1,1,1
22006,qemu,1,"bool timerlist_expired(QEMUTimerList *timer_list)

{

    int64_t expire_time;



    if (!atomic_read(&timer_list->active_timers)) {

        return false;

    }



    qemu_mutex_lock(&timer_list->active_timers_lock);

    if (!timer_list->active_timers) {

        qemu_mutex_unlock(&timer_list->active_timers_lock);

        return false;

    }

    expire_time = timer_list->active_timers->expire_time;

    qemu_mutex_unlock(&timer_list->active_timers_lock);



    return expire_time < qemu_clock_get_ns(timer_list->clock->type);

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
22009,FFmpeg,1,"static int pxr24_uncompress(EXRContext *s, const uint8_t *src,

                            int compressed_size, int uncompressed_size,

                            EXRThreadData *td)

{

    unsigned long dest_len, expected_len = 0;

    const uint8_t *in = td->tmp;

    uint8_t *out;

    int c, i, j;



    for (i = 0; i < s->nb_channels; i++) {

        if (s->channels[i].pixel_type == EXR_FLOAT) {

            expected_len += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */

        } else if (s->channels[i].pixel_type == EXR_HALF) {

            expected_len += (td->xsize * td->ysize * 2);

        } else {//UINT 32

            expected_len += (td->xsize * td->ysize * 4);

        }

    }



    dest_len = expected_len;



    if (uncompress(td->tmp, &dest_len, src, compressed_size) != Z_OK) {

        return AVERROR_INVALIDDATA;

    } else if (dest_len != expected_len) {

        return AVERROR_INVALIDDATA;

    }



    out = td->uncompressed_data;

    for (i = 0; i < t",2,0,4,0,0,0,1,1,1,1,1,1,0,0,0
22013,FFmpeg,1,"static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    int64_t total_size = 0;

    MOVAtom a;

    int i;



    if (atom.size < 0)

        atom.size = INT64_MAX;

    while (total_size + 8 <= atom.size && !avio_feof(pb)) {

        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;

        a.size = atom.size;

        a.type=0;

        if (atom.size >= 8) {

            a.size = avio_rb32(pb);

            a.type = avio_rl32(pb);

            if (a.type == MKTAG('f','r','e','e') &&

                a.size >= 8 &&

                c->moov_retry) {

                uint8_t buf[8];

                uint32_t *type = (uint32_t *)buf + 1;

                avio_read(pb, buf, 8);

                avio_seek(pb, -8, SEEK_CUR);

                if (*type == MKTAG('m','v','h','d') ||

                    *type == MKTAG('c','m','o','v')) {

                    av_log(c->fc, AV_LOG_ERROR, ""Detected moov in a free atom.\n"");

                    a.type = MKTAG('m','o','o','v');

       ",0,0,4,0,0,1,0,0,0,1,1,1,0,1,0
22016,qemu,1,"static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist,

                                AHCICmdHdr *cmd, int64_t limit, int32_t offset)

{

    uint16_t opts = le16_to_cpu(cmd->opts);

    uint16_t prdtl = le16_to_cpu(cmd->prdtl);

    uint64_t cfis_addr = le64_to_cpu(cmd->tbl_addr);

    uint64_t prdt_addr = cfis_addr + 0x80;

    dma_addr_t prdt_len = (prdtl * sizeof(AHCI_SG));

    dma_addr_t real_prdt_len = prdt_len;

    uint8_t *prdt;

    int i;

    int r = 0;

    uint64_t sum = 0;

    int off_idx = -1;

    int64_t off_pos = -1;

    int tbl_entry_size;

    IDEBus *bus = &ad->port;

    BusState *qbus = BUS(bus);



    /*

     * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support

     * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a

     * 512 byte sector size. We limit the PRDT in this implementation to

     * a reasonably large 2GiB, which can accommodate the maximum transfer

     * request for sector sizes up to 32K.

     */



    if (!prdtl) {
",1,0,1,0,0,0,0,0,0,0,0,0,0,0,0
22034,FFmpeg,1,"static void dwt_encode97_int(DWTContext *s, int *t)

{

    int lev,

        w = s->linelen[s->ndeclevels-1][0];

    int *line = s->i_linebuf;

    line += 5;



    for (lev = s->ndeclevels-1; lev >= 0; lev--){

        int lh = s->linelen[lev][0],

            lv = s->linelen[lev][1],

            mh = s->mod[lev][0],

            mv = s->mod[lev][1],

            lp;

        int *l;



        // VER_SD

        l = line + mv;

        for (lp = 0; lp < lh; lp++) {

            int i, j = 0;



            for (i = 0; i < lv; i++)

                l[i] = t[w*i + lp];



            sd_1d97_int(line, mv, mv + lv);



            // copy back and deinterleave

            for (i =   mv; i < lv; i+=2, j++)

                t[w*j + lp] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;

            for (i = 1-mv; i < lv; i+=2, j++)

                t[w*j + lp] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;

        }



        // HOR_SD

        l = line + mh;

        for (lp = 0; lp < lv; lp++){

            int i, j = ",6,0,0,0,0,0,0,0,0,0,0,0,0,0,0
22037,FFmpeg,1,"static void decode_postinit(H264Context *h){

    MpegEncContext * const s = &h->s;

    Picture *out = s->current_picture_ptr;

    Picture *cur = s->current_picture_ptr;

    int i, pics, out_of_order, out_idx;



    s->current_picture_ptr->qscale_type= FF_QSCALE_TYPE_H264;

    s->current_picture_ptr->pict_type= s->pict_type;



    if (h->next_output_pic) return;



    if (cur->field_poc[0]==INT_MAX || cur->field_poc[1]==INT_MAX) {

        //FIXME this allows the next thread to start once we encounter the first field of a PAFF packet

        //This works if the next packet contains the second field. It does not work if both fields are

        //in the same packet.

        //ff_thread_finish_setup(s->avctx);

        return;

    }



    cur->interlaced_frame = 0;

    cur->repeat_pict = 0;



    /* Signal interlacing information externally. */

    /* Prioritize picture timing SEI information over used decoding process if it exists. */



    if(h->sps.pic_struct_present_flag){

        switch (h-",0,0,3,0,1,0,0,0,0,0,1,0,1,1,1
22047,qemu,1,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
",0,0,3,0,0,0,0,0,0,0,1,0,1,1,1
22058,qemu,1,"gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,

             uint32_t up_shift, CPUTriCoreState *env)

{

    TCGv temp = tcg_temp_new();

    TCGv temp2 = tcg_temp_new();

    TCGv temp3 = tcg_temp_new();

    TCGv_i64 t1 = tcg_temp_new_i64();

    TCGv_i64 t2 = tcg_temp_new_i64();

    TCGv_i64 t3 = tcg_temp_new_i64();

    TCGv_i64 t4 = tcg_temp_new_i64();



    tcg_gen_ext_i32_i64(t2, arg2);

    tcg_gen_ext_i32_i64(t3, arg3);



    tcg_gen_mul_i64(t2, t2, t3);



    tcg_gen_ext_i32_i64(t1, arg1);

    /* if we shift part of the fraction out, we need to round up */

    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);

    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);

    tcg_gen_sari_i64(t2, t2, up_shift - n);

    tcg_gen_add_i64(t2, t2, t4);



    tcg_gen_sub_i64(t3, t1, t2);

    tcg_gen_trunc_i64_i32(temp3, t3);

    /* calc v bit */

    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);

    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);

    tcg_gen",0,0,3,0,0,0,1,1,1,1,1,0,0,0,0
22065,qemu,1,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    ",0,1,11,0,0,0,1,1,1,1,1,0,0,1,1
22082,qemu,0,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *bs_entry;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));

    }



    bs_entry = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);



    bs_entry->state.bs = bs;

    bs_entry->state.flags = flags;



    return bs_queue;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,0
22086,FFmpeg,0,"static void format_line(void *ptr, int level, const char *fmt, va_list vl,

                        AVBPrint part[3], int *print_prefix, int type[2])

{

    AVClass* avc = ptr ? *(AVClass **) ptr : NULL;

    av_bprint_init(part+0, 0, 1);

    av_bprint_init(part+1, 0, 1);

    av_bprint_init(part+2, 0, 65536);



    if(type) type[0] = type[1] = AV_CLASS_CATEGORY_NA + 16;

    if (*print_prefix && avc) {

        if (avc->parent_log_context_offset) {

            AVClass** parent = *(AVClass ***) (((uint8_t *) ptr) +

                                   avc->parent_log_context_offset);

            if (parent && *parent) {

                av_bprintf(part+0, ""[%s @ %p] "",

                         (*parent)->item_name(parent), parent);

                if(type) type[0] = get_category(parent);

            }

        }

        av_bprintf(part+1, ""[%s @ %p] "",

                 avc->item_name(ptr), ptr);

        if(type) type[1] = get_category(ptr);

    }



    av_vbprintf(part+2, fmt, vl);



    if(*part",1,0,7,0,0,0,0,0,0,0,0,0,0,0,1
22089,FFmpeg,0,"static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid)

{

    if (cid != ctx->cid) {

        int index;



        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {

            av_log(ctx->avctx, AV_LOG_ERROR, ""unsupported cid %d\n"", cid);

            return AVERROR(ENOSYS);

        }

        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {

            av_log(ctx->avctx, AV_LOG_ERROR, ""bit depth mismatches %d %d\n"", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);

            return AVERROR_INVALIDDATA;

        }

        ctx->cid_table = &ff_dnxhd_cid_table[index];

        av_log(ctx->avctx, AV_LOG_VERBOSE, ""Profile cid %d.\n"", cid);



        ff_free_vlc(&ctx->ac_vlc);

        ff_free_vlc(&ctx->dc_vlc);

        ff_free_vlc(&ctx->run_vlc);



        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,

                 ctx->cid_table->ac_bits, 1, 1,

                 ctx->cid_table->ac_codes, 2, 2, 0);

        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,

          ",0,0,3,0,0,0,0,0,0,0,0,0,0,0,1
22093,FFmpeg,0,"static void check_default_settings(AVCodecContext *avctx)

{

    X264Context *x4 = avctx->priv_data;



    int score = 0;

    score += x4->params.analyse.i_me_range == 0;

    score += x4->params.rc.i_qp_step == 3;

    score += x4->params.i_keyint_max == 12;

    score += x4->params.rc.i_qp_min == 2;

    score += x4->params.rc.i_qp_max == 31;

    score += x4->params.rc.f_qcompress == 0.5;

    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;

    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;

    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)

            avctx->crf = 23;

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
22094,qemu,0,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,0
22132,qemu,1,"static int unix_close(void *opaque)

{

    QEMUFileSocket *s = opaque;

    close(s->fd);

    g_free(s);

    return 0;

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
22137,FFmpeg,0,"static int mpeg_decode_frame(AVCodecContext *avctx,

                             void *data, int *data_size,

                             AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    Mpeg1Context *s = avctx->priv_data;

    AVFrame *picture = data;

    MpegEncContext *s2 = &s->mpeg_enc_ctx;

    av_dlog(avctx, ""fill_buffer\n"");



    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == SEQ_END_CODE)) {

        /* special case for last picture */

        if (s2->low_delay == 0 && s2->next_picture_ptr) {

            *picture = s2->next_picture_ptr->f;

            s2->next_picture_ptr = NULL;



            *data_size = sizeof(AVFrame);

        }

        return buf_size;

    }



    if (s2->flags & CODEC_FLAG_TRUNCATED) {

        int next = ff_mpeg1_find_frame_end(&s2->parse_context, buf, buf_size, NULL);



        if (ff_combine_frame(&s2->parse_context, next, (const uint8_t **)&buf, &buf_size) < 0)

            return buf_size;

    }



    s",0,0,4,0,0,0,0,0,0,0,0,0,0,1,1
22140,qemu,0,"static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *s = chr->opaque;

    int size, len;

    uint8_t buf[1024];



    len = sizeof(buf);

    if (len > s->max_size)

        len = s->max_size;

    if (len == 0)

        return;

    size = read(s->fd_in, buf, len);

    if (size == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (size > 0) {

        qemu_chr_read(chr, buf, size);

    }

}
",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
22151,qemu,0,"static void smbios_build_type_1_fields(QemuOpts *opts)

{

    const char *val;



    val = qemu_opt_get(opts, ""manufacturer"");

    if (val) {

        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),

                         val, strlen(val) + 1);

    }

    val = qemu_opt_get(opts, ""product"");

    if (val) {

        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),

                         val, strlen(val) + 1);

    }

    val = qemu_opt_get(opts, ""version"");

    if (val) {

        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),

                         val, strlen(val) + 1);

    }

    val = qemu_opt_get(opts, ""serial"");

    if (val) {

        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),

                         val, strlen(val) + 1);

    }

    val = qemu_opt_get(opts, ""uuid"");

    if (val) {

        if (qemu_uuid_parse(val, qemu_uuid) != 0) {

            error_report(""Invalid UUID"");

            exit(1",0,0,6,0,0,0,0,1,0,1,0,1,1,1,1
22155,qemu,0,"static void vmsvga_fifo_run(struct vmsvga_state_s *s)

{

    uint32_t cmd, colour;

    int args, len;

    int x, y, dx, dy, width, height;

    struct vmsvga_cursor_definition_s cursor;

    uint32_t cmd_start;



    len = vmsvga_fifo_length(s);

    while (len > 0) {

        /* May need to go back to the start of the command if incomplete */

        cmd_start = s->cmd->stop;



        switch (cmd = vmsvga_fifo_read(s)) {

        case SVGA_CMD_UPDATE:

        case SVGA_CMD_UPDATE_VERBOSE:

            len -= 5;

            if (len < 0) {

                goto rewind;

            }



            x = vmsvga_fifo_read(s);

            y = vmsvga_fifo_read(s);

            width = vmsvga_fifo_read(s);

            height = vmsvga_fifo_read(s);

            vmsvga_update_rect_delayed(s, x, y, width, height);

            break;



        case SVGA_CMD_RECT_FILL:

            len -= 6;

            if (len < 0) {

                goto rewind;

            }



            colour = vmsvga_fifo_read(s);
",0,2,10,0,1,1,0,0,0,0,0,0,1,1,1
22167,qemu,1,"static int hdev_get_max_segments(const struct stat *st)

{

#ifdef CONFIG_LINUX

    char buf[32];

    const char *end;

    char *sysfspath;

    int ret;

    int fd = -1;

    long max_segments;



    sysfspath = g_strdup_printf(""/sys/dev/block/%u:%u/queue/max_segments"",

                                major(st->st_rdev), minor(st->st_rdev));

    fd = open(sysfspath, O_RDONLY);

    if (fd == -1) {

        ret = -errno;

        goto out;

    }

    do {

        ret = read(fd, buf, sizeof(buf));

    } while (ret == -1 && errno == EINTR);

    if (ret < 0) {

        ret = -errno;

        goto out;

    } else if (ret == 0) {

        ret = -EIO;

        goto out;

    }

    buf[ret] = 0;

    /* The file is ended with '\n', pass 'end' to accept that. */

    ret = qemu_strtol(buf, &end, 10, &max_segments);

    if (ret == 0 && end && *end == '\n') {

        ret = max_segments;

    }



out:

    g_free(sysfspath);

    return ret;

#else

    return -ENOTSUP;

#endif

}
",0,3,6,0,0,1,1,1,1,0,1,1,1,1,0
22201,qemu,0,"static void apic_update_irq(APICCommonState *s)

{

    if (!(s->spurious_vec & APIC_SV_ENABLE)) {

        return;

    }

    if (apic_irq_pending(s) > 0) {

        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);

    } else if (apic_accept_pic_intr(&s->busdev.qdev) &&

               pic_get_output(isa_pic)) {

        apic_deliver_pic_intr(&s->busdev.qdev, 1);

    }

}
",0,0,3,0,0,0,0,0,0,0,1,0,1,0,0
22250,qemu,1,"PPC_OP(extsh)

{

    T0 = (int32_t)((int16_t)(Ts0));

    RETURN();

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
22265,qemu,1,"static int nfs_file_open(BlockDriverState *bs, QDict *options, int flags,

                         Error **errp) {

    NFSClient *client = bs->opaque;

    int64_t ret;



    client->aio_context = bdrv_get_aio_context(bs);



    ret = nfs_client_open(client, options,

                          (flags & BDRV_O_RDWR) ? O_RDWR : O_RDONLY,

                          bs->open_flags, errp);

    if (ret < 0) {

        return ret;

    }

    qemu_mutex_init(&client->mutex);

    bs->total_sectors = ret;

    ret = 0;

    return ret;

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
22270,qemu,0,"static uint32_t pmac_ide_readb (void *opaque,target_phys_addr_t addr)

{

    uint8_t retval;

    MACIOIDEState *d = opaque;



    addr = (addr & 0xFFF) >> 4;

    switch (addr) {

    case 1 ... 7:

        retval = ide_ioport_read(&d->bus, addr);

        break;

    case 8:

    case 22:

        retval = ide_status_read(&d->bus, 0);

        break;

    default:

        retval = 0xFF;

        break;

    }

    return retval;

}
",0,0,0,0,1,0,1,0,1,1,0,0,1,1,0
22276,qemu,0,"target_phys_addr_t booke206_tlb_to_page_size(CPUState *env, ppcmas_tlb_t *tlb)

{

    uint32_t tlbncfg;

    int tlbn = booke206_tlbm_to_tlbn(env, tlb);

    int tlbm_size;



    tlbncfg = env->spr[SPR_BOOKE_TLB0CFG + tlbn];



    if (tlbncfg & TLBnCFG_AVAIL) {

        tlbm_size = (tlb->mas1 & MAS1_TSIZE_MASK) >> MAS1_TSIZE_SHIFT;

    } else {

        tlbm_size = (tlbncfg & TLBnCFG_MINSIZE) >> TLBnCFG_MINSIZE_SHIFT;

        tlbm_size <<= 1;

    }



    return 1024ULL << tlbm_size;

}
",0,0,1,0,0,0,0,1,0,1,0,0,1,1,1
22279,qemu,0,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
",0,0,0,0,0,0,1,0,0,1,0,1,0,0,0
22280,qemu,0,"static void thread_pool_cancel(BlockAIOCB *acb)

{

    ThreadPoolElement *elem = (ThreadPoolElement *)acb;

    ThreadPool *pool = elem->pool;



    trace_thread_pool_cancel(elem, elem->common.opaque);



    qemu_mutex_lock(&pool->lock);

    if (elem->state == THREAD_QUEUED &&

        /* No thread has yet started working on elem. we can try to ""steal""

         * the item from the worker if we can get a signal from the

         * semaphore.  Because this is non-blocking, we can do it with

         * the lock taken and ensure that elem will remain THREAD_QUEUED.

         */

        qemu_sem_timedwait(&pool->sem, 0) == 0) {

        QTAILQ_REMOVE(&pool->request_list, elem, reqs);

        qemu_bh_schedule(pool->completion_bh);



        elem->state = THREAD_DONE;

        elem->ret = -ECANCELED;

    }



    qemu_mutex_unlock(&pool->lock);

}
",0,0,2,0,0,0,1,1,0,1,0,0,1,0,0
22300,qemu,1,"static void monitor_protocol_event_init(void)

{

    qemu_mutex_init(&monitor_event_state_lock);

    /* Limit RTC & BALLOON events to 1 per second */

    monitor_protocol_event_throttle(QEVENT_RTC_CHANGE, 1000);

    monitor_protocol_event_throttle(QEVENT_BALLOON_CHANGE, 1000);

    monitor_protocol_event_throttle(QEVENT_WATCHDOG, 1000);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
22316,FFmpeg,1,"static int seek_test(const char *input_filename, const char *start, const char *end)

{

    AVCodec *codec = NULL;

    AVCodecContext *ctx= NULL;

    AVCodecParameters *origin_par = NULL;

    AVFrame *fr = NULL;

    AVFormatContext *fmt_ctx = NULL;

    int video_stream;

    int result;

    int i, j;

    long int start_ts, end_ts;



    size_of_array = 0;

    number_of_elements = 0;

    crc_array = pts_array = NULL;



    result = avformat_open_input(&fmt_ctx, input_filename, NULL, NULL);

    if (result < 0) {

        av_log(NULL, AV_LOG_ERROR, ""Can't open file\n"");

        return result;

    }



    result = avformat_find_stream_info(fmt_ctx, NULL);

    if (result < 0) {

        av_log(NULL, AV_LOG_ERROR, ""Can't get stream info\n"");

        return result;

    }



    start_ts = read_seek_range(start);

    end_ts = read_seek_range(end);

    if ((start_ts < 0) || (end_ts < 0))

        return -1;



    //TODO: add ability to work with audio format

    video_stream = av_find_best_strea",2,0,3,0,0,0,1,0,1,1,1,1,1,1,1
22330,qemu,0,"AUXReply aux_request(AUXBus *bus, AUXCommand cmd, uint32_t address,

                      uint8_t len, uint8_t *data)

{

    AUXReply ret = AUX_NACK;

    I2CBus *i2c_bus = aux_get_i2c_bus(bus);

    size_t i;

    bool is_write = false;



    DPRINTF(""request at address 0x%"" PRIX32 "", command %u, len %u\n"", address,

            cmd, len);



    switch (cmd) {

    /*

     * Forward the request on the AUX bus..

     */

    case WRITE_AUX:

    case READ_AUX:

        is_write = cmd == READ_AUX ? false : true;

        for (i = 0; i < len; i++) {

            if (!address_space_rw(&bus->aux_addr_space, address++,

                                  MEMTXATTRS_UNSPECIFIED, data++, 1,

                                  is_write)) {

                ret = AUX_I2C_ACK;

            } else {

                ret = AUX_NACK;

                break;

            }

        }

        break;

    /*

     * Classic I2C transactions..

     */

    case READ_I2C:

    case WRITE_I2C:

        is_write = cmd == R",1,0,1,0,1,0,0,1,1,1,1,1,1,0,0
22361,FFmpeg,1,"static inline void RENAME(yuv2yuvX_ar)(SwsContext *c, const int16_t *lumFilter,

                                       const int16_t **lumSrc, int lumFilterSize,

                                       const int16_t *chrFilter, const int16_t **chrUSrc,

                                       const int16_t **chrVSrc,

                                       int chrFilterSize, const int16_t **alpSrc,

                                       uint8_t *dest, uint8_t *uDest, uint8_t *vDest,

                                       uint8_t *aDest, long dstW, long chrDstW)

{

    if (uDest) {

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, uDest, chrDstW, 0)

        YSCALEYUV2YV12X_ACCURATE(CHR_MMX_FILTER_OFFSET, vDest, chrDstW + c->uv_off, c->uv_off)

    }

    if (CONFIG_SWSCALE_ALPHA && aDest) {

        YSCALEYUV2YV12X_ACCURATE(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)

    }



    YSCALEYUV2YV12X_ACCURATE(LUM_MMX_FILTER_OFFSET, dest, dstW, 0)

}
",0,0,2,0,0,0,0,1,1,1,0,1,0,0,0
22364,qemu,1,"MigrationInfo *qmp_query_migrate(Error **errp)

{

    MigrationInfo *info = g_malloc0(sizeof(*info));

    MigrationState *s = migrate_get_current();



    switch (s->state) {

    case MIG_STATE_NONE:

        /* no migration has happened ever */

        break;

    case MIG_STATE_SETUP:

        info->has_status = true;

        info->status = g_strdup(""setup"");

        info->has_total_time = false;

        break;

    case MIG_STATE_ACTIVE:

    case MIG_STATE_CANCELLING:

        info->has_status = true;

        info->status = g_strdup(""active"");

        info->has_total_time = true;

        info->total_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME)

            - s->total_time;

        info->has_expected_downtime = true;

        info->expected_downtime = s->expected_downtime;

        info->has_setup_time = true;

        info->setup_time = s->setup_time;



        info->has_ram = true;

        info->ram = g_malloc0(sizeof(*info->ram));

        info->ram->transferred = ram_bytes_transferred();",0,0,0,0,1,0,0,0,0,0,1,0,0,0,0
22365,qemu,1,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
",0,0,2,0,0,0,0,0,0,1,0,0,1,1,0
22369,qemu,1,"PPC_OP(cmpl)

{

    if (T0 < T1) {

        T0 = 0x08;

    } else if (T0 > T1) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}
",0,0,2,0,0,0,0,0,0,0,0,1,0,0,0
22379,FFmpeg,0,"static int voc_probe(AVProbeData *p)

{

    int version, check;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))

        return 0;

    version = p->buf[22] | (p->buf[23] << 8);

    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return AVPROBE_SCORE_MAX;

}
",0,0,3,0,0,0,0,1,0,1,1,1,1,1,1
22381,qemu,1,"int ram_load(QEMUFile *f, void *opaque, int version_id)

{

    ram_addr_t addr;

    int flags;



    if (version_id < 3 || version_id > 4) {

        return -EINVAL;

    }



    do {

        addr = qemu_get_be64(f);



        flags = addr & ~TARGET_PAGE_MASK;

        addr &= TARGET_PAGE_MASK;



        if (flags & RAM_SAVE_FLAG_MEM_SIZE) {

            if (version_id == 3) {

                if (addr != ram_bytes_total()) {

                    return -EINVAL;

                }

            } else {

                /* Synchronize RAM block list */

                char id[256];

                ram_addr_t length;

                ram_addr_t total_ram_bytes = addr;



                while (total_ram_bytes) {

                    RAMBlock *block;

                    uint8_t len;



                    len = qemu_get_byte(f);

                    qemu_get_buffer(f, (uint8_t *)id, len);

                    id[len] = 0;

                    length = qemu_get_be64(f);



                    QLIST_FORE",0,0,4,0,0,1,0,0,0,1,0,0,0,0,0
22387,qemu,1,"static void drive_backup_prepare(BlkActionState *common, Error **errp)

{

    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);

    BlockDriverState *bs;

    DriveBackup *backup;

    Error *local_err = NULL;



    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);

    backup = common->action->u.drive_backup.data;



    bs = qmp_get_root_bs(backup->device, errp);

    if (!bs) {

        return;

    }



    /* AioContext is released in .clean() */

    state->aio_context = bdrv_get_aio_context(bs);

    aio_context_acquire(state->aio_context);

    bdrv_drained_begin(bs);

    state->bs = bs;



    do_drive_backup(backup, common->block_job_txn, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    state->job = state->bs->job;

}
",0,0,2,0,0,0,1,1,0,0,0,1,1,1,1
22389,qemu,1,"static inline void RET_STOP (DisasContext *ctx)

{

    gen_op_update_nip((ctx)->nip);

    ctx->exception = EXCP_MTMSR;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
22392,FFmpeg,0,"static void term_exit(void)

{

#ifndef __MINGW32__

    tcsetattr (0, TCSANOW, &oldtty);

#endif

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
22399,qemu,0,"static int get_segment64(CPUPPCState *env, struct mmu_ctx_hash64 *ctx,

                         target_ulong eaddr, int rw, int type)

{

    hwaddr hash;

    target_ulong vsid;

    int pr, target_page_bits;

    int ret, ret2;



    pr = msr_pr;

    ctx->eaddr = eaddr;

    ppc_slb_t *slb;

    target_ulong pageaddr;

    int segment_bits;



    LOG_MMU(""Check SLBs\n"");

    slb = slb_lookup(env, eaddr);

    if (!slb) {

        return -5;

    }



    if (slb->vsid & SLB_VSID_B) {

        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT_1T;

        segment_bits = 40;

    } else {

        vsid = (slb->vsid & SLB_VSID_VSID) >> SLB_VSID_SHIFT;

        segment_bits = 28;

    }



    target_page_bits = (slb->vsid & SLB_VSID_L)

        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;

    ctx->key = !!(pr ? (slb->vsid & SLB_VSID_KP)

                  : (slb->vsid & SLB_VSID_KS));

    ctx->nx = !!(slb->vsid & SLB_VSID_N);



    pageaddr = eaddr & ((1ULL << segment_bits)

                          ",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
22413,qemu,0,"static int v9fs_receivefd(int sockfd, int *status)

{

    struct iovec iov;

    struct msghdr msg;

    struct cmsghdr *cmsg;

    int retval, data, fd;

    union MsgControl msg_control;



    iov.iov_base = &data;

    iov.iov_len = sizeof(data);



    memset(&msg, 0, sizeof(msg));

    msg.msg_iov = &iov;

    msg.msg_iovlen = 1;

    msg.msg_control = &msg_control;

    msg.msg_controllen = sizeof(msg_control);



    do {

        retval = recvmsg(sockfd, &msg, 0);

    } while (retval < 0 && errno == EINTR);

    if (retval <= 0) {

        return retval;

    }

    /*

     * data is set to V9FS_FD_VALID, if ancillary data is sent.  If this

     * request doesn't need ancillary data (fd) or an error occurred,

     * data is set to negative errno value.

     */

    if (data != V9FS_FD_VALID) {

        *status = data;

        return 0;

    }

    /*

     * File descriptor (fd) is sent in the ancillary data. Check if we

     * indeed received it. One of the reasons to fail to receive it is i",0,0,4,0,0,1,1,1,0,1,0,0,0,0,0
22417,qemu,0,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}
",0,0,1,0,0,0,0,0,0,1,1,1,1,1,1
22418,qemu,0,"static AioHandler *find_aio_handler(AioContext *ctx, int fd)

{

    AioHandler *node;



    QLIST_FOREACH(node, &ctx->aio_handlers, node) {

        if (node->pfd.fd == fd)

            if (!node->deleted)

                return node;

    }



    return NULL;

}
",0,0,2,0,0,0,0,0,0,0,1,1,1,1,1
22421,qemu,0,"static void disas_xtensa_insn(CPUXtensaState *env, DisasContext *dc)

{

#define HAS_OPTION_BITS(opt) do { \

        if (!option_bits_enabled(dc, opt)) { \

            qemu_log(""Option is not enabled %s:%d\n"", \

                    __FILE__, __LINE__); \

            goto invalid_opcode; \

        } \

    } while (0)



#define HAS_OPTION(opt) HAS_OPTION_BITS(XTENSA_OPTION_BIT(opt))



#define TBD() qemu_log(""TBD(pc = %08x): %s:%d\n"", dc->pc, __FILE__, __LINE__)

#define RESERVED() do { \

        qemu_log(""RESERVED(pc = %08x, %02x%02x%02x): %s:%d\n"", \

                dc->pc, b0, b1, b2, __FILE__, __LINE__); \

        goto invalid_opcode; \

    } while (0)





#ifdef TARGET_WORDS_BIGENDIAN

#define OP0 (((b0) & 0xf0) >> 4)

#define OP1 (((b2) & 0xf0) >> 4)

#define OP2 ((b2) & 0xf)

#define RRR_R ((b1) & 0xf)

#define RRR_S (((b1) & 0xf0) >> 4)

#define RRR_T ((b0) & 0xf)

#else

#define OP0 (((b0) & 0xf))

#define OP1 (((b2) & 0xf))

#define OP2 (((b2) & 0xf0) >> 4)

#define RRR_R (((b1) & 0xf0) >>",0,2,2,0,0,2,0,0,0,0,0,0,1,0,1
22425,FFmpeg,0,"static int end_frame(AVFilterLink *inlink)

{

    AVFilterContext    *ctx = inlink->dst;

    FPSContext           *s = ctx->priv;

    AVFilterLink   *outlink = ctx->outputs[0];

    AVFilterBufferRef  *buf = inlink->cur_buf;

    int64_t delta;

    int i, ret;



    inlink->cur_buf = NULL;

    s->frames_in++;

    /* discard frames until we get the first timestamp */

    if (s->pts == AV_NOPTS_VALUE) {

        if (buf->pts != AV_NOPTS_VALUE) {

            write_to_fifo(s->fifo, buf);

            s->first_pts = s->pts = buf->pts;

        } else {

            av_log(ctx, AV_LOG_WARNING, ""Discarding initial frame(s) with no ""

                   ""timestamp.\n"");

            avfilter_unref_buffer(buf);

            s->drop++;

        }

        return 0;

    }



    /* now wait for the next timestamp */

    if (buf->pts == AV_NOPTS_VALUE) {

        return write_to_fifo(s->fifo, buf);

    }



    /* number of output frames */

    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,

    ",0,0,7,0,0,0,0,0,0,0,1,0,1,0,0
22426,FFmpeg,1,"static int roq_read_packet(AVFormatContext *s,

                           AVPacket *pkt)

{

    RoqDemuxContext *roq = s->priv_data;

    AVIOContext *pb = s->pb;

    int ret = 0;

    unsigned int chunk_size;

    unsigned int chunk_type;

    unsigned int codebook_size;

    unsigned char preamble[RoQ_CHUNK_PREAMBLE_SIZE];

    int packet_read = 0;

    int64_t codebook_offset;



    while (!packet_read) {



        if (avio_feof(s->pb))

            return AVERROR(EIO);



        /* get the next chunk preamble */

        if ((ret = avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE)) !=

            RoQ_CHUNK_PREAMBLE_SIZE)

            return AVERROR(EIO);



        chunk_type = AV_RL16(&preamble[0]);

        chunk_size = AV_RL32(&preamble[2]);

        if(chunk_size > INT_MAX)

            return AVERROR_INVALIDDATA;



        chunk_size = ffio_limit(pb, chunk_size);



        switch (chunk_type) {



        case RoQ_INFO:

            if (roq->video_stream_index == -1) {

                AVStre",0,0,4,0,1,1,1,1,1,1,1,0,0,0,0
22429,FFmpeg,1,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""",0,0,2,0,0,0,1,1,1,1,1,1,0,0,1
22431,qemu,1,"void qemu_file_set_error(QEMUFile *f, int ret)

{

    if (f->last_error == 0) {

        f->last_error = ret;

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
22436,FFmpeg,0,"static int encode_picture_lossless(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){

    MpegEncContext * const s = avctx->priv_data;

    MJpegContext * const m = s->mjpeg_ctx;

    AVFrame *pict = data;

    const int width= s->width;

    const int height= s->height;

    AVFrame * const p= (AVFrame*)&s->current_picture;

    const int predictor= avctx->prediction_method+1;



    init_put_bits(&s->pb, buf, buf_size);



    *p = *pict;

    p->pict_type= FF_I_TYPE;

    p->key_frame= 1;



    ff_mjpeg_encode_picture_header(s);



    s->header_bits= put_bits_count(&s->pb);



    if(avctx->pix_fmt == PIX_FMT_RGB32){

        int x, y, i;

        const int linesize= p->linesize[0];

        uint16_t (*buffer)[4]= (void *) s->rd_scratchpad;

        int left[3], top[3], topleft[3];



        for(i=0; i<3; i++){

            buffer[0][i]= 1 << (9 - 1);

        }



        for(y = 0; y < height; y++) {

            const int modified_predictor= y ? predictor : 1;

            uint8_t",2,0,2,0,0,0,0,0,0,0,1,0,1,0,0
22459,FFmpeg,0,"static int opt_input_file(OptionsContext *o, const char *opt, const char *filename)

{

    AVFormatContext *ic;

    AVInputFormat *file_iformat = NULL;

    int err, i, ret;

    int64_t timestamp;

    uint8_t buf[128];

    AVDictionary **opts;

    int orig_nb_streams;                     // number of streams before avformat_find_stream_info



    if (o->format) {

        if (!(file_iformat = av_find_input_format(o->format))) {

            av_log(NULL, AV_LOG_FATAL, ""Unknown input format: '%s'\n"", o->format);

            exit_program(1);

        }

    }



    if (!strcmp(filename, ""-""))

        filename = ""pipe:"";



    using_stdin |= !strncmp(filename, ""pipe:"", 5) ||

                    !strcmp(filename, ""/dev/stdin"");



    /* get default parameters from command line */

    ic = avformat_alloc_context();

    if (!ic) {

        print_error(filename, AVERROR(ENOMEM));

        exit_program(1);

    }

    if (o->nb_audio_sample_rate) {

        snprintf(buf, sizeof(buf), ""%d"", o->audio_samp",8,0,7,0,0,0,1,1,1,1,1,1,0,0,1
22462,qemu,0,"uint64_t helper_efdctuidz (uint64_t val)

{

    CPU_DoubleU u;



    u.ll = val;

    /* NaN are not treated the same way IEEE 754 does */

    if (unlikely(float64_is_nan(u.d)))

        return 0;



    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);

}
",0,0,1,0,0,0,0,0,0,0,1,0,0,0,0
22465,qemu,0,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= file->blob->len);

    assert(start_offset + size <= file->blob->len);

    assert(*checksum == 0x0);



    memset(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    g_array_append",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
22503,FFmpeg,1,"void ff_thread_release_buffer(AVCodecContext *avctx, ThreadFrame *f)

{

    PerThreadContext *p = avctx->internal->thread_ctx;

    FrameThreadContext *fctx;

    AVFrame *dst, *tmp;

FF_DISABLE_DEPRECATION_WARNINGS

    int can_direct_free = !(avctx->active_thread_type & FF_THREAD_FRAME) ||

                          avctx->thread_safe_callbacks                   ||

                          (

#if FF_API_GET_BUFFER

                           !avctx->get_buffer &&

#endif

                           avctx->get_buffer2 == avcodec_default_get_buffer2);

FF_ENABLE_DEPRECATION_WARNINGS



    if (!f->f->buf[0])

        return;



    if (avctx->debug & FF_DEBUG_BUFFERS)

        av_log(avctx, AV_LOG_DEBUG, ""thread_release_buffer called on pic %p\n"", f);



    av_buffer_unref(&f->progress);

    f->owner    = NULL;



    if (can_direct_free) {

        av_frame_unref(f->f);

        return;

    }



    fctx = p->parent;

    pthread_mutex_lock(&fctx->buffer_mutex);



    if (p->num_released_buffers + 1 >",0,0,6,0,0,0,0,1,0,1,1,1,0,0,0
22531,FFmpeg,1,"void ff_schro_queue_free(FFSchroQueue *queue, void (*free_func)(void *))

{

    while (queue->p_head)

        free_func(ff_schro_queue_pop(queue));

}
",0,0,0,0,0,1,1,1,1,1,1,1,1,1,1
22534,qemu,1,"void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
",0,0,2,0,0,0,0,0,0,1,0,0,1,1,1
22545,qemu,0,"static inline void gen_op_addl_ESP_im(int32_t val)

{

    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);

#ifdef TARGET_X86_64

    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);

#endif

    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

}
",0,0,2,0,0,0,1,0,1,0,0,0,0,1,1
22552,qemu,0,"static unsigned int dec_movu_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZ);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);

	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}
",0,0,0,0,0,0,1,1,0,0,1,1,1,1,1
22559,FFmpeg,0,"AVInputFormat *av_find_input_format(const char *short_name)

{

    AVInputFormat *fmt = NULL;

    while ((fmt = av_iformat_next(fmt)))

        if (match_format(short_name, fmt->name))

            return fmt;

    return NULL;

}
",3,0,2,0,0,1,0,1,0,0,0,0,1,1,1
22597,FFmpeg,1,"static av_cold void dsputil_init_sse2(DSPContext *c, AVCodecContext *avctx,

                                      int mm_flags)

{

#if HAVE_SSE2_INLINE

    const int high_bit_depth = avctx->bits_per_raw_sample > 8;



    if (!high_bit_depth && avctx->idct_algo == FF_IDCT_XVIDMMX) {

        c->idct_put              = ff_idct_xvid_sse2_put;

        c->idct_add              = ff_idct_xvid_sse2_add;

        c->idct                  = ff_idct_xvid_sse2;

        c->idct_permutation_type = FF_SSE2_IDCT_PERM;

    }

#endif /* HAVE_SSE2_INLINE */



#if HAVE_SSE2_EXTERNAL

    c->scalarproduct_int16          = ff_scalarproduct_int16_sse2;

    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_sse2;

    if (mm_flags & AV_CPU_FLAG_ATOM) {

        c->vector_clip_int32 = ff_vector_clip_int32_int_sse2;

    } else {

        c->vector_clip_int32 = ff_vector_clip_int32_sse2;

    }

    if (avctx->flags & CODEC_FLAG_BITEXACT) {

        c->apply_window_int16 = ff_apply_window_int16_sse2;

    } el",0,0,6,0,0,0,0,0,0,1,1,1,0,0,0
22601,FFmpeg,0,"static int au_probe(AVProbeData *p)

{

    /* check file header */

    if (p->buf_size <= 24)

        return 0;

    if (p->buf[0] == '.' && p->buf[1] == 's' &&

        p->buf[2] == 'n' && p->buf[3] == 'd')

        return AVPROBE_SCORE_MAX;

    else

        return 0;

}
",0,0,2,0,0,0,0,0,0,1,0,0,1,1,0
22615,qemu,1,"static void pc_fw_add_pflash_drv(void)

{

    QemuOpts *opts;

    QEMUMachine *machine;

    char *filename;



    if (bios_name == NULL) {

        bios_name = BIOS_FILENAME;

    }

    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);



    opts = drive_add(IF_PFLASH, -1, filename, ""readonly=on"");



    g_free(filename);



    if (opts == NULL) {

      return;

    }



    machine = find_default_machine();

    if (machine == NULL) {

      return;

    }



    drive_init(opts, machine->use_scsi);

}
",0,0,3,0,0,0,0,0,0,1,0,0,1,1,0
22637,FFmpeg,0,"void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,

                        int *duration)

{

    int64_t out_pts = AV_NOPTS_VALUE;

    int removed_samples = 0;



#ifdef DEBUG

    ff_af_queue_log_state(afq);

#endif



    /* get output pts from the next frame or generated pts */

    if (afq->frame_queue) {

        if (afq->frame_queue->pts != AV_NOPTS_VALUE)

            out_pts = afq->frame_queue->pts - afq->remaining_delay;

    } else {

        if (afq->next_pts != AV_NOPTS_VALUE)

            out_pts = afq->next_pts - afq->remaining_delay;

    }

    if (pts) {

        if (out_pts != AV_NOPTS_VALUE)

            *pts = ff_samples_to_time_base(afq->avctx, out_pts);

        else

            *pts = AV_NOPTS_VALUE;

    }



    /* if the delay is larger than the packet duration, we use up delay samples

       for the output packet and leave all frames in the queue */

    if (afq->remaining_delay >= nb_samples) {

        removed_samples      += nb_samples;

        afq-",1,0,9,0,0,0,1,1,1,1,1,1,1,1,1
22652,qemu,1,"void stream_start(BlockDriverState *bs, BlockDriverState *base,

                  const char *base_id, int64_t speed,

                  BlockDriverCompletionFunc *cb,

                  void *opaque, Error **errp)

{

    StreamBlockJob *s;

    Coroutine *co;



    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    if (base_id) {

        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);

    }



    co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, co, opaque);

    qemu_coroutine_enter(co, s);

}
",0,0,2,0,0,0,1,1,1,1,0,1,1,1,0
22655,FFmpeg,1,"static double get_diff_limited_q(MpegEncContext *s, RateControlEntry *rce, double q){

    RateControlContext *rcc= &s->rc_context;

    AVCodecContext *a= s->avctx;

    const int pict_type= rce->new_pict_type;

    const double last_p_q    = rcc->last_qscale_for[P_TYPE];

    const double last_non_b_q= rcc->last_qscale_for[rcc->last_non_b_pict_type];



    if     (pict_type==I_TYPE && (a->i_quant_factor>0.0 || rcc->last_non_b_pict_type==P_TYPE))

        q= last_p_q    *FFABS(a->i_quant_factor) + a->i_quant_offset;

    else if(pict_type==B_TYPE && a->b_quant_factor>0.0)

        q= last_non_b_q*    a->b_quant_factor  + a->b_quant_offset;




    /* last qscale / qdiff stuff */

    if(rcc->last_non_b_pict_type==pict_type || pict_type!=I_TYPE){

        double last_q= rcc->last_qscale_for[pict_type];

        const int maxdiff= FF_QP2LAMBDA * a->max_qdiff;



        if     (q > last_q + maxdiff) q= last_q + maxdiff;

        else if(q < last_q - maxdiff) q= last_q - maxdiff;

    }



    rcc->last_qscale",3,0,12,0,0,0,0,0,0,0,1,0,1,0,0
22662,FFmpeg,0,"static int mov_write_hdlr_tag(AVIOContext *pb, MOVTrack *track)

{

    const char *hdlr, *descr = NULL, *hdlr_type = NULL;

    int64_t pos = avio_tell(pb);



    if (!track) { /* no media --> data handler */

        hdlr      = ""dhlr"";

        hdlr_type = ""url "";

        descr     = ""DataHandler"";

    } else {

        hdlr = (track->mode == MODE_MOV) ? ""mhlr"" : ""\0\0\0\0"";

        if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO) {

            hdlr_type = ""vide"";

            descr     = ""VideoHandler"";

        } else if (track->enc->codec_type == AVMEDIA_TYPE_AUDIO) {

            hdlr_type = ""soun"";

            descr     = ""SoundHandler"";

        } else if (track->enc->codec_type == AVMEDIA_TYPE_SUBTITLE) {

            if (track->tag == MKTAG('t','x','3','g')) hdlr_type = ""sbtl"";

            else                                      hdlr_type = ""text"";

            descr = ""SubtitleHandler"";

        } else if (track->enc->codec_tag == MKTAG('r','t','p',' ')) {

            hdlr_type = ""hint""",0,0,6,0,0,0,0,0,0,0,0,0,1,0,0
22683,qemu,1,"PPC_OP(srawi)

{

    T1 = T0;

    T0 = (Ts0 >> PARAM(1));

    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {

        xer_ca = 1;

    } else {

        xer_ca = 0;

    }

    RETURN();

}
",0,0,1,0,0,0,1,1,1,0,1,0,1,1,0
22693,qemu,1,"void trace_init_file(const char *file)

{

#ifdef CONFIG_TRACE_SIMPLE

    st_set_trace_file(file);

#elif defined CONFIG_TRACE_LOG

    /* If both the simple and the log backends are enabled, ""-trace file""

     * only applies to the simple backend; use ""-D"" for the log backend.

     */

    if (file) {

        qemu_set_log_filename(file);

    }

#else

    if (file) {

        fprintf(stderr, ""error: -trace file=...: ""

                ""option not supported by the selected tracing backends\n"");

        exit(1);

    }

#endif

}
",1,0,5,0,0,0,1,1,1,1,1,1,1,0,1
22702,FFmpeg,1,"static int srt_probe(AVProbeData *p)

{

    const unsigned char *ptr = p->buf;

    int i, v, num = 0;



    if (AV_RB24(ptr) == 0xEFBBBF)

        ptr += 3;  /* skip UTF-8 BOM */



    while (*ptr == '\r' || *ptr == '\n')

        ptr++;

    for (i=0; i<2; i++) {

        if ((num == i || num + 1 == i)

            && sscanf(ptr, ""%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d"", &v) == 1)

            return AVPROBE_SCORE_MAX;

        num = atoi(ptr);

        ptr += strcspn(ptr, ""\n"") + 1;

    }

    return 0;

}
",1,0,2,0,0,1,1,1,1,1,1,1,0,0,0
22705,qemu,1,"static void piix4_update_hotplug(PIIX4PMState *s)

{

    PCIDevice *dev = &s->dev;

    BusState *bus = qdev_get_parent_bus(&dev->qdev);

    DeviceState *qdev, *next;



    s->pci0_hotplug_enable = ~0;



    QTAILQ_FOREACH_SAFE(qdev, &bus->children, sibling, next) {

        PCIDevice *pdev = PCI_DEVICE(qdev);

        PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pdev);

        int slot = PCI_SLOT(pdev->devfn);



        if (pc->no_hotplug) {

            s->pci0_hotplug_enable &= ~(1 << slot);

        }

    }

}
",0,0,1,0,0,0,0,0,0,0,1,1,1,1,1
22709,qemu,1,"static void stream_set_speed(BlockJob *job, int64_t speed, Error **errp)

{

    StreamBlockJob *s = container_of(job, StreamBlockJob, common);



    if (speed < 0) {

        error_setg(errp, QERR_INVALID_PARAMETER, ""speed"");

        return;

    }

    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);

}
",0,0,1,0,0,0,1,1,1,1,1,1,0,0,0
22718,FFmpeg,1,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
",0,0,0,0,0,0,0,0,1,0,1,0,1,1,1
22741,qemu,1,"int unix_start_incoming_migration(const char *path)

{

    struct sockaddr_un un;

    int sock;



    dprintf(""Attempting to start an incoming migration\n"");



    sock = socket(PF_UNIX, SOCK_STREAM, 0);

    if (sock < 0) {

        fprintf(stderr, ""Could not open unix socket: %s\n"", strerror(errno));

        return -EINVAL;

    }



    memset(&un, 0, sizeof(un));

    un.sun_family = AF_UNIX;

    snprintf(un.sun_path, sizeof(un.sun_path), ""%s"", path);



    unlink(un.sun_path);

    if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) {

        fprintf(stderr, ""bind(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }

    if (listen(sock, 1) < 0) {

        fprintf(stderr, ""listen(unix:%s): %s\n"", un.sun_path, strerror(errno));

        goto err;

    }



    qemu_set_fd_handler2(sock, NULL, unix_accept_incoming_migration, NULL,

			 (void *)(unsigned long)sock);



    return 0;



err:

    close(sock);



    return -EINVAL;

}
",0,2,3,0,0,0,0,0,0,0,0,0,1,1,1
22752,qemu,0,"void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)

{

    BlockDriver *drv = bs->drv;

    Error *local_err = NULL;



    memset(&bs->bl, 0, sizeof(bs->bl));



    if (!drv) {

        return;

    }



    /* Default alignment based on whether driver has byte interface */

    bs->request_alignment = drv->bdrv_co_preadv ? 1 : 512;



    /* Take some limits from the children as a default */

    if (bs->file) {

        bdrv_refresh_limits(bs->file->bs, &local_err);

        if (local_err) {

            error_propagate(errp, local_err);

            return;

        }

        bs->bl.opt_transfer = bs->file->bs->bl.opt_transfer;

        bs->bl.max_transfer = bs->file->bs->bl.max_transfer;

        bs->bl.min_mem_alignment = bs->file->bs->bl.min_mem_alignment;

        bs->bl.opt_mem_alignment = bs->file->bs->bl.opt_mem_alignment;

        bs->bl.max_iov = bs->file->bs->bl.max_iov;

    } else {

        bs->bl.min_mem_alignment = 512;

        bs->bl.opt_mem_alignment = getpagesize();



     ",0,0,3,0,0,0,1,1,0,1,0,0,1,1,1
22759,qemu,0,"static int check_refblocks(BlockDriverState *bs, BdrvCheckResult *res,

                           BdrvCheckMode fix, bool *rebuild,

                           void **refcount_table, int64_t *nb_clusters)

{

    BDRVQcow2State *s = bs->opaque;

    int64_t i, size;

    int ret;



    for(i = 0; i < s->refcount_table_size; i++) {

        uint64_t offset, cluster;

        offset = s->refcount_table[i];

        cluster = offset >> s->cluster_bits;



        /* Refcount blocks are cluster aligned */

        if (offset_into_cluster(s, offset)) {

            fprintf(stderr, ""ERROR refcount block %"" PRId64 "" is not ""

                ""cluster aligned; refcount table entry corrupted\n"", i);

            res->corruptions++;

            *rebuild = true;

            continue;

        }



        if (cluster >= *nb_clusters) {

            fprintf(stderr, ""%s refcount block %"" PRId64 "" is outside image\n"",

                    fix & BDRV_FIX_ERRORS ? ""Repairing"" : ""ERROR"", i);



            if (fix & BDRV_",1,0,3,0,0,0,0,0,0,0,0,0,1,1,1
22801,qemu,1,"DriveInfo *drive_init(QemuOpts *opts, BlockInterfaceType block_default_type)

{

    const char *buf;

    const char *file = NULL;

    const char *serial;

    const char *mediastr = """";

    BlockInterfaceType type;

    enum { MEDIA_DISK, MEDIA_CDROM } media;

    int bus_id, unit_id;

    int cyls, heads, secs, translation;

    BlockDriver *drv = NULL;

    int max_devs;

    int index;

    int ro = 0;

    int bdrv_flags = 0;

    int on_read_error, on_write_error;

    const char *devaddr;

    DriveInfo *dinfo;

    BlockIOLimit io_limits;

    int snapshot = 0;

    bool copy_on_read;

    int ret;

    Error *error = NULL;



    translation = BIOS_ATA_TRANSLATION_AUTO;

    media = MEDIA_DISK;



    /* extract parameters */

    bus_id  = qemu_opt_get_number(opts, ""bus"", 0);

    unit_id = qemu_opt_get_number(opts, ""unit"", -1);

    index   = qemu_opt_get_number(opts, ""index"", -1);



    cyls  = qemu_opt_get_number(opts, ""cyls"", 0);

    heads = qemu_opt_get_number(opts, ""heads"", 0);

    secs ",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
22815,qemu,1,"static const char *keyval_parse_one(QDict *qdict, const char *params,

                                    const char *implied_key,

                                    Error **errp)

{

    const char *key, *key_end, *s;

    size_t len;

    char key_in_cur[128];

    QDict *cur;

    int ret;

    QObject *next;

    QString *val;



    key = params;

    len = strcspn(params, ""=,"");

    if (implied_key && len && key[len] != '=') {

        /* Desugar implied key */

        key = implied_key;

        len = strlen(implied_key);

    }

    key_end = key + len;



    /*

     * Loop over key fragments: @s points to current fragment, it

     * applies to @cur.  @key_in_cur[] holds the previous fragment.

     */

    cur = qdict;

    s = key;

    for (;;) {

        ret = parse_qapi_name(s, false);

        len = ret < 0 ? 0 : ret;

        assert(s + len <= key_end);

        if (!len || (s + len < key_end && s[len] != '.')) {

            assert(key != implied_key);

            error_setg(errp, ""In",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
22826,FFmpeg,0,"static void mdct_test(AC3MDCTContext *mdct, AVLFG *lfg)

{

    int16_t input[MDCT_SAMPLES];

    int32_t output[AC3_MAX_COEFS];

    float input1[MDCT_SAMPLES];

    float output1[AC3_MAX_COEFS];

    float s, a, err, e, emax;

    int i, k, n;



    for (i = 0; i < MDCT_SAMPLES; i++) {

        input[i]  = (av_lfg_get(lfg) % 65535 - 32767) * 9 / 10;

        input1[i] = input[i];

    }



    mdct512(mdct, output, input);



    /* do it by hand */

    for (k = 0; k < AC3_MAX_COEFS; k++) {

        s = 0;

        for (n = 0; n < MDCT_SAMPLES; n++) {

            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));

            s += input1[n] * cos(a);

        }

        output1[k] = -2 * s / MDCT_SAMPLES;

    }



    err  = 0;

    emax = 0;

    for (i = 0; i < AC3_MAX_COEFS; i++) {

        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);

        e = output[i] - output1[i];

        if (e > emax)

            emax = e;

        err += e * e;

    }

    av_log",4,0,1,0,0,0,0,0,0,0,0,0,1,1,0
22833,FFmpeg,1,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};



    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});

    return sar;

}
",0,0,1,0,0,0,1,0,0,1,1,1,1,1,1
22834,qemu,1,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    return inl(0xcfc);

}
",0,0,0,0,0,0,0,0,0,1,1,1,0,0,0
22844,FFmpeg,1,"static int decode_block(BinkAudioContext *s, float **out, int use_dct)

{

    int ch, i, j, k;

    float q, quant[25];

    int width, coeff;

    GetBitContext *gb = &s->gb;



    if (use_dct)

        skip_bits(gb, 2);



    for (ch = 0; ch < s->channels; ch++) {

        FFTSample *coeffs = out[ch];



        if (s->version_b) {

            if (get_bits_left(gb) < 64)

                return AVERROR_INVALIDDATA;

            coeffs[0] = av_int2float(get_bits_long(gb, 32)) * s->root;

            coeffs[1] = av_int2float(get_bits_long(gb, 32)) * s->root;

        } else {

            if (get_bits_left(gb) < 58)

                return AVERROR_INVALIDDATA;

            coeffs[0] = get_float(gb) * s->root;

            coeffs[1] = get_float(gb) * s->root;

        }



        if (get_bits_left(gb) < s->num_bands * 8)

            return AVERROR_INVALIDDATA;

        for (i = 0; i < s->num_bands; i++) {

            int value = get_bits(gb, 8);

            quant[i]  = quant_table[FFMIN(value, 95)];

 ",2,0,5,0,0,0,0,0,0,0,0,1,0,0,0
22875,qemu,1,"static int load_normal_reset(S390CPU *cpu)

{

    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);



    pause_all_vcpus();

    cpu_synchronize_all_states();

    cpu_reset_all();


    io_subsystem_reset();

    scc->initial_cpu_reset(CPU(cpu));

    scc->load_normal(CPU(cpu));

    cpu_synchronize_all_post_reset();

    resume_all_vcpus();

    return 0;

}",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
22876,qemu,1,"static void v9fs_post_lcreate(V9fsState *s, V9fsLcreateState *vs, int err)

{

    if (err == 0) {

        v9fs_string_copy(&vs->fidp->path, &vs->fullname);

        stat_to_qid(&vs->stbuf, &vs->qid);

        vs->offset += pdu_marshal(vs->pdu, vs->offset, ""Qd"", &vs->qid,

                &vs->iounit);

        err = vs->offset;

    } else {

        vs->fidp->fid_type = P9_FID_NONE;

        close(vs->fidp->fs.fd);

        err = -errno;

    }



    complete_pdu(s, vs->pdu, err);

    v9fs_string_free(&vs->name);

    v9fs_string_free(&vs->fullname);

    qemu_free(vs);

}
",0,0,1,0,0,0,0,0,0,0,1,1,1,1,1
22906,qemu,1,"static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
22931,qemu,1,"static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,

                                      int do_init,

                                      const char *cpu_model,

                                      uint32_t sysclk)

{

    PowerPCCPU *cpu;

    CPUPPCState *env;

    qemu_irq *irqs;



    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }

    env = &cpu->env;



    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);



    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    ppcuic_init(env, irqs, 0x0C0, 0, 1);

    return cpu;

}
",0,0,1,0,0,0,0,0,0,1,1,1,0,0,0
22944,FFmpeg,1,"static void create_default_qtables(uint8_t *qtables, uint8_t q)

{

    int factor = q;

    int i;



    factor = av_clip(q, 1, 99);



    if (q < 50)

        q = 5000 / factor;

    else

        q = 200 - factor * 2;



    for (i = 0; i < 128; i++) {

        int val = (default_quantizers[i] * q + 50) / 100;



        /* Limit the quantizers to 1 <= q <= 255. */

        val = av_clip(val, 1, 255);

        qtables[i] = val;

    }

}
",1,0,1,0,0,0,1,1,0,0,0,0,0,0,0
22949,FFmpeg,0,"void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}
",0,0,0,0,0,1,1,1,1,0,1,1,1,1,1
22955,FFmpeg,1,"static void lumRangeToJpeg16_c(int16_t *_dst, int width)

{

    int i;

    int32_t *dst = (int32_t *) _dst;

    for (i = 0; i < width; i++)

        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;

}
",1,0,0,0,0,0,1,1,0,1,1,1,0,0,0
22956,FFmpeg,1,"static void fill_coding_method_array(sb_int8_array tone_level_idx,

                                     sb_int8_array tone_level_idx_temp,

                                     sb_int8_array coding_method,

                                     int nb_channels,

                                     int c, int superblocktype_2_3,

                                     int cm_table_select)

{

    int ch, sb, j;

    int tmp, acc, esp_40, comp;

    int add1, add2, add3, add4;

    int64_t multres;



    if (!superblocktype_2_3) {

        /* This case is untested, no samples available */

        SAMPLES_NEEDED

        for (ch = 0; ch < nb_channels; ch++)

            for (sb = 0; sb < 30; sb++) {

                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer

                    add1 = tone_level_idx[ch][sb][j] - 10;

                    if (add1 < 0)

                        add1 = 0;

                    add2 = add3 = add4 = 0;

                    if (",3,0,3,0,0,0,1,1,1,0,0,1,0,0,0
22959,FFmpeg,1,"static void find_motion(DeshakeContext *deshake, uint8_t *src1, uint8_t *src2,

                        int width, int height, int stride, Transform *t)

{

    int x, y;

    IntMotionVector mv = {0, 0};

    int counts[128][128];

    int count_max_value = 0;

    int contrast;



    int pos;

    double *angles = av_malloc(sizeof(*angles) * width * height / (16 * deshake->blocksize));

    int center_x = 0, center_y = 0;

    double p_x, p_y;



    // Reset counts to zero

    for (x = 0; x < deshake->rx * 2 + 1; x++) {

        for (y = 0; y < deshake->ry * 2 + 1; y++) {

            counts[x][y] = 0;

        }

    }



    pos = 0;

    // Find motion for every block and store the motion vector in the counts

    for (y = deshake->ry; y < height - deshake->ry - (deshake->blocksize * 2); y += deshake->blocksize * 2) {

        // We use a width of 16 here to match the libavcodec sad functions

        for (x = deshake->rx; x < width - deshake->rx - 16; x += 16) {

            // If the contrast is too",5,0,0,0,0,0,0,0,0,1,0,0,1,1,0
22966,FFmpeg,1,"static int dirac_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *pkt)

{

    DiracContext *s     = avctx->priv_data;

    AVFrame *picture    = data;

    uint8_t *buf        = pkt->data;

    int buf_size        = pkt->size;

    int i, data_unit_size, buf_idx = 0;

    int ret;



    /* release unused frames */

    for (i = 0; i < MAX_FRAMES; i++)

        if (s->all_frames[i].avframe->data[0] && !s->all_frames[i].avframe->reference) {

            av_frame_unref(s->all_frames[i].avframe);

            memset(s->all_frames[i].interpolated, 0, sizeof(s->all_frames[i].interpolated));

        }



    s->current_picture = NULL;

    *got_frame = 0;



    /* end of stream, so flush delayed pics */

    if (buf_size == 0)

        return get_delayed_pic(s, (AVFrame *)data, got_frame);



    for (;;) {

        /*[DIRAC_STD] Here starts the code from parse_info() defined in 9.6

          [DIRAC_STD] PARSE_INFO_PREFIX = ""BBCD"" as defined in ISO/IEC 646

          BBCD start code se",2,0,2,0,0,0,1,1,1,1,0,1,0,0,0
22969,qemu,1,"static TCGv gen_ea(CPUM68KState *env, DisasContext *s, uint16_t insn,

                   int opsize, TCGv val, TCGv *addrp, ea_what what)

{

    TCGv reg;

    TCGv result;

    uint32_t offset;



    switch ((insn >> 3) & 7) {

    case 0: /* Data register direct.  */

        reg = DREG(insn, 0);

        if (what == EA_STORE) {

            gen_partset_reg(opsize, reg, val);

            return store_dummy;

        } else {

            return gen_extend(reg, opsize, what == EA_LOADS);

        }

    case 1: /* Address register direct.  */

        reg = AREG(insn, 0);

        if (what == EA_STORE) {

            tcg_gen_mov_i32(reg, val);

            return store_dummy;

        } else {

            return gen_extend(reg, opsize, what == EA_LOADS);

        }

    case 2: /* Indirect register */

        reg = AREG(insn, 0);

        return gen_ldst(s, opsize, reg, val, what);

    case 3: /* Indirect postincrement.  */

        reg = AREG(insn, 0);

        result = gen_ldst(s, opsize, reg, val, ",0,0,2,0,1,0,1,1,0,1,1,1,0,0,0
22970,FFmpeg,1,"static av_cold void nvenc_setup_rate_control(AVCodecContext *avctx)

{

    NvencContext *ctx = avctx->priv_data;



    if (avctx->bit_rate > 0) {

        ctx->encode_config.rcParams.averageBitRate = avctx->bit_rate;

    } else if (ctx->encode_config.rcParams.averageBitRate > 0) {

        ctx->encode_config.rcParams.maxBitRate = ctx->encode_config.rcParams.averageBitRate;

    }



    if (avctx->rc_max_rate > 0)

        ctx->encode_config.rcParams.maxBitRate = avctx->rc_max_rate;



    if (ctx->rc < 0) {

        if (ctx->flags & NVENC_ONE_PASS)

            ctx->twopass = 0;

        if (ctx->flags & NVENC_TWO_PASSES)

            ctx->twopass = 1;



        if (ctx->twopass < 0)

            ctx->twopass = (ctx->flags & NVENC_LOWLATENCY) != 0;



        if (ctx->cbr) {

            if (ctx->twopass) {

                ctx->rc = NV_ENC_PARAMS_RC_2_PASS_QUALITY;

            } else {

                ctx->rc = NV_ENC_PARAMS_RC_CBR;

            }

        } else if (avctx->global_quality > 0) {

    ",0,0,10,0,0,0,1,1,1,1,1,1,0,1,0
22976,FFmpeg,1,"static av_cold int vp3_decode_end(AVCodecContext *avctx)

{

    Vp3DecodeContext *s = avctx->priv_data;

    int i;



    if (avctx->is_copy && !s->current_frame.data[0])

        return 0;



    av_free(s->superblock_coding);

    av_free(s->all_fragments);

    av_free(s->coded_fragment_list[0]);

    av_free(s->dct_tokens_base);

    av_free(s->superblock_fragments);

    av_free(s->macroblock_coding);

    av_free(s->motion_val[0]);

    av_free(s->motion_val[1]);

    av_free(s->edge_emu_buffer);



    if (avctx->is_copy) return 0;



    for (i = 0; i < 16; i++) {

        free_vlc(&s->dc_vlc[i]);

        free_vlc(&s->ac_vlc_1[i]);

        free_vlc(&s->ac_vlc_2[i]);

        free_vlc(&s->ac_vlc_3[i]);

        free_vlc(&s->ac_vlc_4[i]);

    }



    free_vlc(&s->superblock_run_length_vlc);

    free_vlc(&s->fragment_run_length_vlc);

    free_vlc(&s->mode_code_vlc);

    free_vlc(&s->motion_vector_vlc);



    /* release all frames */

    if (s->golden_frame.data[0])

        ff_thread_release_b",1,0,3,0,0,0,1,1,1,1,1,1,1,1,1
22980,qemu,1,"static void vnc_disconnect_finish(VncState *vs)
{
    vnc_qmp_event(vs, QEVENT_VNC_DISCONNECTED);
    buffer_free(&vs->input);
    buffer_free(&vs->output);
    qobject_decref(vs->info);
#ifdef CONFIG_VNC_TLS
    vnc_tls_client_cleanup(vs);
#endif /* CONFIG_VNC_TLS */
#ifdef CONFIG_VNC_SASL
    vnc_sasl_client_cleanup(vs);
#endif /* CONFIG_VNC_SASL */
    audio_del(vs);
    QTAILQ_REMOVE(&vs->vd->clients, vs, next);
    if (QTAILQ_EMPTY(&vs->vd->clients)) {
        dcl->idle = 1;
    }
    qemu_remove_mouse_mode_change_notifier(&vs->mouse_mode_notifier);
    vnc_remove_timer(vs->vd);
    if (vs->vd->lock_key_sync)
        qemu_remove_led_event_handler(vs->led);
    qemu_free(vs);
}",0,0,8,0,0,0,0,0,0,1,1,1,0,0,0
22994,qemu,0,"void qemu_opts_print(QemuOpts *opts)

{

    QemuOpt *opt;

    QemuOptDesc *desc = opts->list->desc;



    if (desc[0].name == NULL) {

        QTAILQ_FOREACH(opt, &opts->head, next) {

            printf(""%s=\""%s\"" "", opt->name, opt->str);

        }

        return;

    }

    for (; desc && desc->name; desc++) {

        const char *value;

        QemuOpt *opt = qemu_opt_find(opts, desc->name);



        value = opt ? opt->str : desc->def_value_str;

        if (!value) {

            continue;

        }

        if (desc->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", desc->name, value);

        } else if ((desc->type == QEMU_OPT_SIZE ||

                    desc->type == QEMU_OPT_NUMBER) && opt) {

            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);

        } else {

            printf(""%s=%s "", desc->name, value);

        }

    }

}
",1,0,4,0,0,0,0,0,0,0,0,0,1,0,0
23016,qemu,0,"static uint32_t nvic_readl(nvic_state *s, uint32_t offset)

{

    ARMCPU *cpu;

    uint32_t val;

    int irq;



    switch (offset) {

    case 4: /* Interrupt Control Type.  */

        return (s->num_irq / 32) - 1;

    case 0x10: /* SysTick Control and Status.  */

        val = s->systick.control;

        s->systick.control &= ~SYSTICK_COUNTFLAG;

        return val;

    case 0x14: /* SysTick Reload Value.  */

        return s->systick.reload;

    case 0x18: /* SysTick Current Value.  */

        {

            int64_t t;

            if ((s->systick.control & SYSTICK_ENABLE) == 0)

                return 0;

            t = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL);

            if (t >= s->systick.tick)

                return 0;

            val = ((s->systick.tick - (t + 1)) / systick_scale(s)) + 1;

            /* The interrupt in triggered when the timer reaches zero.

               However the counter is not reloaded until the next clock

               tick.  This is a hack to return zero dur",0,0,2,0,1,0,0,0,0,0,0,0,1,1,1
23049,FFmpeg,0,"static int gxf_write_header(AVFormatContext *s)

{

    AVIOContext *pb = s->pb;

    GXFContext *gxf = s->priv_data;

    GXFStreamContext *vsc = NULL;

    uint8_t tracks[255] = {0};

    int i, media_info = 0;



    if (!pb->seekable) {

        av_log(s, AV_LOG_ERROR, ""gxf muxer does not support streamed output, patch welcome"");

        return -1;

    }



    gxf->flags |= 0x00080000; /* material is simple clip */

    for (i = 0; i < s->nb_streams; ++i) {

        AVStream *st = s->streams[i];

        GXFStreamContext *sc = av_mallocz(sizeof(*sc));

        if (!sc)

            return AVERROR(ENOMEM);

        st->priv_data = sc;



        sc->media_type = ff_codec_get_tag(gxf_media_types, st->codecpar->codec_id);

        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (st->codecpar->codec_id != AV_CODEC_ID_PCM_S16LE) {

                av_log(s, AV_LOG_ERROR, ""only 16 BIT PCM LE allowed for now\n"");

                return -1;

            }

            if (st->codecpar->s",2,0,5,0,0,0,0,1,1,1,0,1,0,0,0
23050,qemu,0,"static void qxl_render_update_area_unlocked(PCIQXLDevice *qxl)

{

    VGACommonState *vga = &qxl->vga;

    int i;



    if (qxl->guest_primary.resized) {

        qxl->guest_primary.resized = 0;

        qxl->guest_primary.data = memory_region_get_ram_ptr(&qxl->vga.vram);

        qxl_set_rect_to_surface(qxl, &qxl->dirty[0]);

        qxl->num_dirty_rects = 1;

        trace_qxl_render_guest_primary_resized(

               qxl->guest_primary.surface.width,

               qxl->guest_primary.surface.height,

               qxl->guest_primary.qxl_stride,

               qxl->guest_primary.bytes_pp,

               qxl->guest_primary.bits_pp);

        if (qxl->guest_primary.qxl_stride > 0) {

            qemu_free_displaysurface(vga->ds);

            qemu_create_displaysurface_from(qxl->guest_primary.surface.width,

                                            qxl->guest_primary.surface.height,

                                            qxl->guest_primary.bits_pp,

                                        ",0,0,2,0,0,0,1,1,1,0,1,1,0,0,0
23052,qemu,0,"static void page_init(void)

{

    /* NOTE: we can always suppose that qemu_host_page_size >=

       TARGET_PAGE_SIZE */

#ifdef _WIN32

    {

        SYSTEM_INFO system_info;



        GetSystemInfo(&system_info);

        qemu_real_host_page_size = system_info.dwPageSize;

    }

#else

    qemu_real_host_page_size = getpagesize();

#endif

    if (qemu_host_page_size == 0) {

        qemu_host_page_size = qemu_real_host_page_size;

    }

    if (qemu_host_page_size < TARGET_PAGE_SIZE) {

        qemu_host_page_size = TARGET_PAGE_SIZE;

    }

    qemu_host_page_mask = ~(qemu_host_page_size - 1);



#if defined(CONFIG_BSD) && defined(CONFIG_USER_ONLY)

    {

#ifdef HAVE_KINFO_GETVMMAP

        struct kinfo_vmentry *freep;

        int i, cnt;



        freep = kinfo_getvmmap(getpid(), &cnt);

        if (freep) {

            mmap_lock();

            for (i = 0; i < cnt; i++) {

                unsigned long startaddr, endaddr;



                startaddr = freep[i].kve_start;

                enda",1,0,7,0,0,0,0,1,0,0,1,0,0,0,0
23066,qemu,0,"static SocketAddress *tcp_build_address(const char *host_port, Error **errp)

{

    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);

    SocketAddress *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddress, 1);

    saddr->type = SOCKET_ADDRESS_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
",0,0,1,0,0,0,1,1,1,0,0,0,0,0,0
23074,qemu,0,"static void nbd_close(BlockDriverState *bs)

{

    BDRVNBDState *s = bs->opaque;



    qemu_opts_del(s->socket_opts);

    nbd_client_session_close(&s->client);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
23076,qemu,0,"static void reset(DeviceState *d)

{

    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);

    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);



    trace_spapr_drc_reset(spapr_drc_index(drc));



    g_free(drc->ccs);

    drc->ccs = NULL;



    /* immediately upon reset we can safely assume DRCs whose devices

     * are pending removal can be safely removed, and that they will

     * subsequently be left in an ISOLATED state. move the DRC to this

     * state in these cases (which will in turn complete any pending

     * device removals)

     */

    if (drc->awaiting_release) {

        drck->set_isolation_state(drc, SPAPR_DR_ISOLATION_STATE_ISOLATED);

        /* generally this should also finalize the removal, but if the device

         * hasn't yet been configured we normally defer removal under the

         * assumption that this transition is taking place as part of device

         * configuration. so check if we're still waiting after this, and

         * force removal if w",1,0,4,0,0,0,0,0,0,0,0,0,1,1,1
23088,qemu,0,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}
",1,0,6,0,0,0,0,0,0,0,0,0,0,0,0
23104,qemu,0,"void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)

{

    int relation;



    set_float_exception_flags(0, &env->fp_status);

    relation = float64_compare(t0, t1, &env->fp_status);

    if (unlikely(relation == float_relation_unordered)) {

        update_fpscr(env, GETPC());

    } else {

        env->sr_t = (relation == float_relation_greater);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
23105,qemu,0,"static int img_info(int argc, char **argv)

{

    int c;

    OutputFormat output_format = OFORMAT_HUMAN;

    const char *filename, *fmt, *output;

    BlockDriverState *bs;

    ImageInfo *info;



    fmt = NULL;

    output = NULL;

    for(;;) {

        int option_index = 0;

        static const struct option long_options[] = {

            {""help"", no_argument, 0, 'h'},

            {""format"", required_argument, 0, 'f'},

            {""output"", required_argument, 0, OPTION_OUTPUT},

            {0, 0, 0, 0}

        };

        c = getopt_long(argc, argv, ""f:h"",

                        long_options, &option_index);

        if (c == -1) {

            break;

        }

        switch(c) {

        case '?':

        case 'h':

            help();

            break;

        case 'f':

            fmt = optarg;

            break;

        case OPTION_OUTPUT:

            output = optarg;

            break;

        }

    }

    if (optind >= argc) {

        help();

    }

    filename = argv[o",3,0,2,0,1,0,0,0,0,0,0,0,0,0,0
23108,qemu,0,"int qio_dns_resolver_lookup_sync(QIODNSResolver *resolver,

                                 SocketAddressLegacy *addr,

                                 size_t *naddrs,

                                 SocketAddressLegacy ***addrs,

                                 Error **errp)

{

    switch (addr->type) {

    case SOCKET_ADDRESS_LEGACY_KIND_INET:

        return qio_dns_resolver_lookup_sync_inet(resolver,

                                                 addr,

                                                 naddrs,

                                                 addrs,

                                                 errp);



    case SOCKET_ADDRESS_LEGACY_KIND_UNIX:

    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:

    case SOCKET_ADDRESS_LEGACY_KIND_FD:

        return qio_dns_resolver_lookup_sync_nop(resolver,

                                                addr,

                                                naddrs,

                                                addrs,

                       ",0,0,0,0,1,0,1,1,1,1,0,0,0,0,0
23116,qemu,0,"static coroutine_fn int qcow_co_readv(BlockDriverState *bs, int64_t sector_num,

                         int nb_sectors, QEMUIOVector *qiov)

{

    BDRVQcowState *s = bs->opaque;

    int index_in_cluster;

    int ret = 0, n;

    uint64_t cluster_offset;

    struct iovec hd_iov;

    QEMUIOVector hd_qiov;

    uint8_t *buf;

    void *orig_buf;

    Error *err = NULL;



    if (qiov->niov > 1) {

        buf = orig_buf = qemu_try_blockalign(bs, qiov->size);

        if (buf == NULL) {

            return -ENOMEM;

        }

    } else {

        orig_buf = NULL;

        buf = (uint8_t *)qiov->iov->iov_base;

    }



    qemu_co_mutex_lock(&s->lock);



    while (nb_sectors != 0) {

        /* prepare next request */

        cluster_offset = get_cluster_offset(bs, sector_num << 9,

                                                 0, 0, 0, 0);

        index_in_cluster = sector_num & (s->cluster_sectors - 1);

        n = s->cluster_sectors - index_in_cluster;

        if (n > nb_sectors) {

        ",0,0,3,0,0,1,1,1,1,1,1,1,1,1,1
23123,FFmpeg,0,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}
",0,0,1,0,0,0,0,0,1,0,0,0,1,1,1
23136,FFmpeg,0,"static int ftp_restart(FTPContext *s, int64_t pos)

{

    char command[CONTROL_BUFFER_SIZE];

    const int rest_codes[] = {350, 0};



    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);

    if (!ftp_send_command(s, command, rest_codes, NULL))

        return AVERROR(EIO);



    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,1,1,0,0
23140,qemu,0,"static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child,

        int64_t offset, unsigned int bytes, QEMUIOVector *qiov)

{

    BlockDriverState *bs = child->bs;



    /* Perform I/O through a temporary buffer so that users who scribble over

     * their read buffer while the operation is in progress do not end up

     * modifying the image file.  This is critical for zero-copy guest I/O

     * where anything might happen inside guest memory.

     */

    void *bounce_buffer;



    BlockDriver *drv = bs->drv;

    struct iovec iov;

    QEMUIOVector bounce_qiov;

    int64_t cluster_offset;

    unsigned int cluster_bytes;

    size_t skip_bytes;

    int ret;



    /* FIXME We cannot require callers to have write permissions when all they

     * are doing is a read request. If we did things right, write permissions

     * would be obtained anyway, but internally by the copy-on-read code. As

     * long as it is implemented here rather than in a separate filter driver,

     * the copy-o",2,0,1,0,0,1,0,1,0,1,0,0,0,1,0
23145,qemu,0,"int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, type);

    arg = va_arg(ap, void *);

    va_end(ap);



    ret = ioctl(s->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}
",0,0,1,0,0,0,0,0,0,0,1,0,0,0,0
23155,qemu,0,"static uint64_t exynos4210_mct_read(void *opaque, target_phys_addr_t offset,

        unsigned size)

{

    Exynos4210MCTState *s = (Exynos4210MCTState *)opaque;

    int index;

    int shift;

    uint64_t count;

    uint32_t value;

    int lt_i;



    switch (offset) {



    case MCT_CFG:

        value = s->reg_mct_cfg;

        break;



    case G_CNT_L: case G_CNT_U:

        shift = 8 * (offset & 0x4);

        count = exynos4210_gfrc_get_count(&s->g_timer);

        value = UINT32_MAX & (count >> shift);

        DPRINTF(""read FRC=0x%llx\n"", count);

        break;



    case G_CNT_WSTAT:

        value = s->g_timer.reg.cnt_wstat;

        break;



    case G_COMP_L(0): case G_COMP_L(1): case G_COMP_L(2): case G_COMP_L(3):

    case G_COMP_U(0): case G_COMP_U(1): case G_COMP_U(2): case G_COMP_U(3):

    index = GET_G_COMP_IDX(offset);

    shift = 8 * (offset & 0x4);

    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);

    break;



    case G_TCON:

        value = s->g_timer.reg",0,0,5,0,1,0,1,1,1,1,1,1,0,0,0
23159,FFmpeg,0,"theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)

{

    struct ogg *ogg = ctx->priv_data;

    struct ogg_stream *os = ogg->streams + idx;

    struct theora_params *thp = os->private;

    uint64_t iframe = gp >> thp->gpshift;

    uint64_t pframe = gp & thp->gpmask;



    if (thp->version < 0x030201)

        iframe++;



    if(!pframe)

        os->pflags |= AV_PKT_FLAG_KEY;



    if (dts)

        *dts = iframe + pframe;



    return iframe + pframe;

}
",0,0,8,0,0,0,0,0,0,0,1,1,1,1,1
23161,FFmpeg,0,"static void av_build_index_raw(AVFormatContext *s)

{

    AVPacket pkt1, *pkt = &pkt1;

    int ret;

    AVStream *st;



    st = s->streams[0];

    av_read_frame_flush(s);

    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        av_free_packet(pkt);

    }

}
",1,0,2,0,0,0,1,1,1,1,1,1,0,1,0
23163,qemu,0,"static FWCfgState *bochs_bios_init(void)

{

    FWCfgState *fw_cfg;

    uint8_t *smbios_tables, *smbios_anchor;

    size_t smbios_tables_len, smbios_anchor_len;

    uint64_t *numa_fw_cfg;

    int i, j;

    unsigned int apic_id_limit = pc_apic_id_limit(max_cpus);



    fw_cfg = fw_cfg_init_io(BIOS_CFG_IOPORT);

    /* FW_CFG_MAX_CPUS is a bit confusing/problematic on x86:

     *

     * SeaBIOS needs FW_CFG_MAX_CPUS for CPU hotplug, but the CPU hotplug

     * QEMU<->SeaBIOS interface is not based on the ""CPU index"", but on the APIC

     * ID of hotplugged CPUs[1]. This means that FW_CFG_MAX_CPUS is not the

     * ""maximum number of CPUs"", but the ""limit to the APIC ID values SeaBIOS

     * may see"".

     *

     * So, this means we must not use max_cpus, here, but the maximum possible

     * APIC ID value, plus one.

     *

     * [1] The only kind of ""CPU identifier"" used between SeaBIOS and QEMU is

     *     the APIC ID, not the ""CPU index""

     */

    fw_cfg_add_i16(fw_cfg, FW_CFG_MAX_CPU",1,0,1,0,0,0,0,0,0,0,0,0,1,1,1
23174,qemu,0,"int mmu_translate(CPUS390XState *env, target_ulong vaddr, int rw, uint64_t asc,

                  target_ulong *raddr, int *flags)

{

    int r = -1;

    uint8_t *sk;



    *flags = PAGE_READ | PAGE_WRITE | PAGE_EXEC;

    vaddr &= TARGET_PAGE_MASK;



    if (!(env->psw.mask & PSW_MASK_DAT)) {

        *raddr = vaddr;

        r = 0;

        goto out;

    }



    switch (asc) {

    case PSW_ASC_PRIMARY:

    case PSW_ASC_HOME:

        r = mmu_translate_asc(env, vaddr, asc, raddr, flags, rw);

        break;

    case PSW_ASC_SECONDARY:

        /*

         * Instruction: Primary

         * Data: Secondary

         */

        if (rw == 2) {

            r = mmu_translate_asc(env, vaddr, PSW_ASC_PRIMARY, raddr, flags,

                                  rw);

            *flags &= ~(PAGE_READ | PAGE_WRITE);

        } else {

            r = mmu_translate_asc(env, vaddr, PSW_ASC_SECONDARY, raddr, flags,

                                  rw);

            *flags &= ~(PAGE_EXEC);

        }

       ",0,1,2,0,1,0,0,0,0,0,0,0,0,0,0
23184,FFmpeg,0,"static inline int decode_ac_coeffs(GetBitContext *gb, int16_t *out,

                                   int blocks_per_slice,

                                   int plane_size_factor,

                                   const uint8_t *scan)

{

    int pos, block_mask, run, level, sign, run_cb_index, lev_cb_index;

    int max_coeffs, bits_left;



    /* set initial prediction values */

    run   = 4;

    level = 2;



    max_coeffs = blocks_per_slice << 6;

    block_mask = blocks_per_slice - 1;



    for (pos = blocks_per_slice - 1; pos < max_coeffs;) {

        run_cb_index = ff_prores_run_to_cb_index[FFMIN(run, 15)];

        lev_cb_index = ff_prores_lev_to_cb_index[FFMIN(level, 9)];



        bits_left = get_bits_left(gb);

        if (bits_left <= 0 || (bits_left <= 8 && !show_bits(gb, bits_left)))

            return 0;



        run = decode_vlc_codeword(gb, ff_prores_ac_codebook[run_cb_index]);

        if (run < 0)

            return AVERROR_INVALIDDATA;



        bits_left = get_bits_left",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
23186,qemu,1,"static int local_opendir(FsContext *ctx,

                         V9fsPath *fs_path, V9fsFidOpenState *fs)

{

    int dirfd;

    DIR *stream;



    dirfd = local_opendir_nofollow(ctx, fs_path->data);

    if (dirfd == -1) {

        return -1;

    }



    stream = fdopendir(dirfd);

    if (!stream) {


        return -1;

    }

    fs->dir.stream = stream;

    return 0;

}",0,0,2,0,0,0,1,1,1,1,1,1,0,0,1
23193,FFmpeg,1,"static int mpeg_mux_init(AVFormatContext *ctx)

{

    MpegMuxContext *s = ctx->priv_data;

    int bitrate, i, mpa_id, mpv_id, ac3_id;

    AVStream *st;

    StreamInfo *stream;



    s->packet_number = 0;

    s->is_vcd = (ctx->oformat == &mpeg1vcd_mux);

    s->is_mpeg2 = (ctx->oformat == &mpeg2vob_mux);

    

    if (s->is_vcd)

        s->packet_size = 2324; /* VCD packet size */

    else

        s->packet_size = 2048;

        

    /* startcode(4) + length(2) + flags(1) */

    s->packet_data_max_size = s->packet_size - 7;

    if (s->is_mpeg2)

        s->packet_data_max_size -= 2;

    s->audio_bound = 0;

    s->video_bound = 0;

    mpa_id = AUDIO_ID;

    ac3_id = 0x80;

    mpv_id = VIDEO_ID;

    s->scr_stream_index = -1;

    for(i=0;i<ctx->nb_streams;i++) {

        st = ctx->streams[i];

        stream = av_mallocz(sizeof(StreamInfo));

        if (!stream)

            goto fail;

        st->priv_data = stream;



        switch(st->codec.codec_type) {

        case CODEC_TYPE_AUDIO:

",3,1,3,0,1,0,1,1,1,1,1,1,0,0,0
23206,FFmpeg,1,"static int mxf_read_header(AVFormatContext *s)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;

    int ret;



    mxf->last_forward_tell = INT64_MAX;

    mxf->edit_units_per_packet = 1;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!url_feof(s->pb)) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", klv.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key,",1,0,4,0,0,1,1,1,1,1,1,0,0,0,0
23213,qemu,1,"get_net_error_message(gint error)

{

    HMODULE module = NULL;

    gchar *retval = NULL;

    wchar_t *msg = NULL;

    int flags;

    size_t nchars;



    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |

        FORMAT_MESSAGE_IGNORE_INSERTS |

        FORMAT_MESSAGE_FROM_SYSTEM;



    if (error >= NERR_BASE && error <= MAX_NERR) {

        module = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);



        if (module != NULL) {

            flags |= FORMAT_MESSAGE_FROM_HMODULE;

        }

    }



    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);



    if (msg != NULL) {

        nchars = wcslen(msg);



        if (nchars > 2 &&

            msg[nchars - 1] == L'\n' &&

            msg[nchars - 2] == L'\r') {

            msg[nchars - 2] = L'\0';

        }



        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);



        LocalFree(msg);

    }



    if (module != NULL) {

        FreeLibrary(module);

    }



    return retval;

}
",0,0,5,0,0,0,0,0,0,0,0,0,0,0,0
23237,qemu,0,"static void kqemu_record_flush(void)

{

    PCRecord *r, *r_next;

    int h;



    for(h = 0; h < PC_REC_HASH_SIZE; h++) {

        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {

            r_next = r->next;

            free(r);

        }

        pc_rec_hash[h] = NULL;

    }

    nb_pc_records = 0;

}
",2,0,0,0,0,0,0,0,0,0,0,0,0,0,0
23244,qemu,0,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    cluster_num = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;

    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);

}
",0,0,1,0,0,0,0,0,1,0,0,0,0,0,0
23245,qemu,0,"int cpu_exec(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUClass *cc = CPU_GET_CLASS(cpu);

#ifdef TARGET_I386

    X86CPU *x86_cpu = X86_CPU(cpu);

#endif

    int ret, interrupt_request;

    TranslationBlock *tb;

    uint8_t *tc_ptr;

    uintptr_t next_tb;

    SyncClocks sc;



    /* This must be volatile so it is not trashed by longjmp() */

    volatile bool have_tb_lock = false;



    if (cpu->halted) {

        if (!cpu_has_work(cpu)) {

            return EXCP_HALTED;

        }



        cpu->halted = 0;

    }



    current_cpu = cpu;



    /* As long as current_cpu is null, up to the assignment just above,

     * requests by other threads to exit the execution loop are expected to

     * be issued using the exit_request global. We must make sure that our

     * evaluation of the global value is performed past the current_cpu

     * value transition point, which requires a memory barrier as well as

     * an instruction scheduling constraint on modern architecture",1,0,4,0,0,0,0,0,0,0,0,0,0,0,0
23247,qemu,0,"static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}
",0,0,0,0,0,0,1,0,0,0,0,0,1,0,0
23250,FFmpeg,0,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",0,0,0,0,0,0,1,0,0,0,0,1,0,0,0
23256,FFmpeg,1,"int ff_h263_decode_mb(MpegEncContext *s,
                      int16_t block[6][64])
{
    int cbpc, cbpy, i, cbp, pred_x, pred_y, mx, my, dquant;
    int16_t *mot_val;
    const int xy= s->mb_x + s->mb_y * s->mb_stride;
    int cbpb = 0, pb_mv_count = 0;
    av_assert2(!s->h263_pred);
    if (s->pict_type == AV_PICTURE_TYPE_P) {
        do{
            if (get_bits1(&s->gb)) {
                /* skip mb */
                s->mb_intra = 0;
                for(i=0;i<6;i++)
                    s->block_last_index[i] = -1;
                s->mv_dir = MV_DIR_FORWARD;
                s->mv_type = MV_TYPE_16X16;
                s->current_picture.mb_type[xy] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0;
                s->mv[0][0][0] = 0;
                s->mv[0][0][1] = 0;
                s->mb_skipped = !(s->obmc | s->loop_filter);
                goto end;
            cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);
            if (cbpc < 0){
                av_log(s->avctx, AV_LOG",1,1,3,0,0,0,0,0,0,1,0,1,1,1,1
23259,FFmpeg,0,"static void DEF(put, pixels16_x2)(uint8_t *block, const uint8_t *pixels, ptrdiff_t line_size, int h)

{

    MOVQ_BFE(mm6);

    __asm__ volatile(

        ""lea        (%3, %3), %%""REG_a"" \n\t""

        "".p2align 3                     \n\t""

        ""1:                             \n\t""

        ""movq   (%1), %%mm0             \n\t""

        ""movq   1(%1), %%mm1            \n\t""

        ""movq   (%1, %3), %%mm2         \n\t""

        ""movq   1(%1, %3), %%mm3        \n\t""

        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)

        ""movq   %%mm4, (%2)             \n\t""

        ""movq   %%mm5, (%2, %3)         \n\t""

        ""movq   8(%1), %%mm0            \n\t""

        ""movq   9(%1), %%mm1            \n\t""

        ""movq   8(%1, %3), %%mm2        \n\t""

        ""movq   9(%1, %3), %%mm3        \n\t""

        PAVGBP(%%mm0, %%mm1, %%mm4,   %%mm2, %%mm3, %%mm5)

        ""movq   %%mm4, 8(%2)            \n\t""

        ""movq   %%mm5, 8(%2, %3)        \n\t""

        ""add    %%""REG_a"", %1           \n\t""

    ",0,0,1,0,0,0,1,1,1,1,1,1,0,1,1
23274,qemu,1,"int register_savevm(const char *idstr,

                    int instance_id,

                    int version_id,

                    SaveStateHandler *save_state,

                    LoadStateHandler *load_state,

                    void *opaque)

{

    SaveStateEntry *se, **pse;



    se = qemu_malloc(sizeof(SaveStateEntry));

    if (!se)

        return -1;

    pstrcpy(se->idstr, sizeof(se->idstr), idstr);

    se->instance_id = (instance_id == -1) ? 0 : instance_id;

    se->version_id = version_id;

    se->save_state = save_state;

    se->load_state = load_state;

    se->opaque = opaque;

    se->next = NULL;



    /* add at the end of list */

    pse = &first_se;

    while (*pse != NULL) {

        if (instance_id == -1

                && strcmp(se->idstr, (*pse)->idstr) == 0

                && se->instance_id <= (*pse)->instance_id)

            se->instance_id = (*pse)->instance_id + 1;

        pse = &(*pse)->next;

    }

    *pse = se;

    return 0;

}
",0,0,2,0,0,1,0,0,0,0,0,0,1,1,1
23277,qemu,1,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = arm_mptimer_reset;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
23299,FFmpeg,1,"static int decode_mb_cavlc(H264Context *h){

    MpegEncContext * const s = &h->s;

    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;

    int partition_count;

    unsigned int mb_type, cbp;

    int dct8x8_allowed= h->pps.transform_8x8_mode;



    s->dsp.clear_blocks(h->mb); //FIXME avoid if already clear (move after skip handlong?



    tprintf(s->avctx, ""pic:%d mb:%d/%d\n"", h->frame_num, s->mb_x, s->mb_y);

    cbp = 0; /* avoid warning. FIXME: find a solution without slowing

                down the code */

    if(h->slice_type != I_TYPE && h->slice_type != SI_TYPE){

        if(s->mb_skip_run==-1)

            s->mb_skip_run= get_ue_golomb(&s->gb);



        if (s->mb_skip_run--) {

            if(FRAME_MBAFF && (s->mb_y&1) == 0){

                if(s->mb_skip_run==0)

                    h->mb_mbaff = h->mb_field_decoding_flag = get_bits1(&s->gb);

                else

                    predict_field_decoding_flag(h);

            }

            decode_mb_skip(h);

            return 0;

  ",1,0,5,0,0,0,1,1,1,0,0,0,1,1,1
23307,qemu,1,"void pci_default_write_config(PCIDevice *d, 

                              uint32_t address, uint32_t val, int len)

{

    int can_write, i;

    uint32_t end, addr;



    if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || 

                     (address >= 0x30 && address < 0x34))) {

        PCIIORegion *r;

        int reg;



        if ( address >= 0x30 ) {

            reg = PCI_ROM_SLOT;

        }else{

            reg = (address - 0x10) >> 2;

        }

        r = &d->io_regions[reg];

        if (r->size == 0)

            goto default_config;

        /* compute the stored value */

        if (reg == PCI_ROM_SLOT) {

            /* keep ROM enable bit */

            val &= (~(r->size - 1)) | 1;

        } else {

            val &= ~(r->size - 1);

            val |= r->type;

        }

        *(uint32_t *)(d->config + address) = cpu_to_le32(val);

        pci_update_mappings(d);

        return;

    }

 default_config:

    /* not efficient, but simple */

    addr = address",0,1,4,0,0,0,0,0,0,0,0,0,0,0,0
23309,FFmpeg,1,"static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int v, i;



    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {

        if (length > 256 || !(s->state & PNG_PLTE))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length; i++) {

            v = bytestream2_get_byte(&s->gb);

            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);

        }

    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {

        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||

            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length / 2; i++) {

            /* only use the least significant bits */

            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);



            if (s->bit_depth > 8)

                AV_WB16(&s->transparent_color_be[2 * i], v);

            else

  ",2,0,5,0,0,0,1,1,1,1,1,1,0,0,0
23323,FFmpeg,1,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
",0,0,5,0,0,0,1,1,1,1,1,1,0,0,0
23339,qemu,1,"target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,

                        target_ulong arg2, int mem_idx)

{

    uint64_t tmp;



    tmp = do_lbu(env, arg2, mem_idx);

    arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);



    if (GET_LMASK64(arg2) <= 6) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);

        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);

    }



    if (GET_LMASK64(arg2) <= 5) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);

        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);

    }



    if (GET_LMASK64(arg2) <= 4) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);

        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);

    }



    if (GET_LMASK64(arg2) <= 3) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);

        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);

    }



    if (GET_LMASK64(arg2) <= 2) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);

        arg1 = (arg1 & 0xFFFFFFF",0,0,5,0,0,0,0,0,0,0,0,0,1,0,0
23344,FFmpeg,0,"static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)

{

    int i;



    for (i = 0; i < 64; i++) {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (intra && i == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    }

    return 0;

}
",1,0,4,0,0,0,1,1,0,1,0,0,1,0,1
23354,qemu,1,"static void child_handler(int sig)

{

    int status;

    while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */;

}
",0,0,0,0,0,1,1,1,1,0,1,0,0,0,0
23361,FFmpeg,0,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)

{

    int current_offset = s->pixel_ptr - dst->data[0];

    int motion_offset = current_offset + delta_y * dst->linesize[0]

                       + delta_x * (1 + s->is_16bpp);

    if (motion_offset < 0) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);

        return AVERROR_INVALIDDATA;

    } else if (motion_offset > s->upper_motion_limit_offset) {

        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",

            motion_offset, s->upper_motion_limit_offset);

        return AVERROR_INVALIDDATA;

    }

    if (src->data[0] == NULL) {

        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");

        return AVERROR(EINVAL);

    }

    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,

                                            dst->linesize[0], 8)",0,0,3,0,0,0,1,1,1,1,1,1,0,0,1
23371,qemu,0,"static void imx_epit_reset(DeviceState *dev)

{

    IMXEPITState *s = IMX_EPIT(dev);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);

    s->sr = 0;

    s->lr = TIMER_MAX;

    s->cmp = 0;

    s->cnt = 0;

    /* stop both timers */

    ptimer_stop(s->timer_cmp);

    ptimer_stop(s->timer_reload);

    /* compute new frequency */

    imx_epit_set_freq(s);

    /* init both timers to TIMER_MAX */

    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);

    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);

    if (s->freq && (s->cr & CR_EN)) {

        /* if the timer is still enabled, restart it */

        ptimer_run(s->timer_reload, 0);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
23374,qemu,0,"static void quit_timers(void)

{

    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
23386,qemu,1,"static int coroutine_fn bdrv_aligned_pwritev(BdrvChild *child,
    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,
    int64_t align, QEMUIOVector *qiov, int flags)
{
    BlockDriverState *bs = child->bs;
    BlockDriver *drv = bs->drv;
    bool waited;
    int ret;
    int64_t end_sector = DIV_ROUND_UP(offset + bytes, BDRV_SECTOR_SIZE);
    uint64_t bytes_remaining = bytes;
    int max_transfer;
    if (bdrv_has_readonly_bitmaps(bs)) {
        return -EPERM;
    assert(is_power_of_2(align));
    assert((offset & (align - 1)) == 0);
    assert((bytes & (align - 1)) == 0);
    assert(!qiov || bytes == qiov->size);
    assert((bs->open_flags & BDRV_O_NO_IO) == 0);
    assert(!(flags & ~BDRV_REQ_MASK));
    max_transfer = QEMU_ALIGN_DOWN(MIN_NON_ZERO(bs->bl.max_transfer, INT_MAX),
                                   align);
    waited = wait_serialising_requests(req);
    assert(!waited || !req->serialising);
    assert(req->overlap_offset <= offset);
    assert(offset + bytes <= req->overlap_offset ",0,0,1,0,0,0,0,0,0,1,0,0,1,1,1
23393,qemu,0,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,

        int64_t sector_num, uint8_t *buf, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *s = bs->opaque;



    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {

        QEMUBH *bh;

        acb = qemu_aio_get(bs, cb, opaque);

        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);

        bh = qemu_bh_new(raw_aio_em_cb, acb);

        qemu_bh_schedule(bh);

        return &acb->common;

    }



    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (aio_read(&acb->aiocb) < 0) {

        qemu_aio_release(acb);

        return NULL;

    }

    return &acb->common;

}
",0,0,3,0,0,0,1,1,1,1,1,1,0,0,1
23405,qemu,0,"static int coroutine_fn bdrv_co_do_readv(BdrvChild *child,

    int64_t sector_num, int nb_sectors, QEMUIOVector *qiov,

    BdrvRequestFlags flags)

{

    if (nb_sectors < 0 || nb_sectors > BDRV_REQUEST_MAX_SECTORS) {

        return -EINVAL;

    }



    return bdrv_co_preadv(child->bs, sector_num << BDRV_SECTOR_BITS,

                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,1
23411,qemu,0,"static void sigchld_handler(int signal)

{

    qemu_bh_schedule(sigchld_bh);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
23425,FFmpeg,0,"static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)

{

    MpegTSFilter *tss;

    PESContext *pes;



    /* if no pid found, then add a pid context */

    pes = av_mallocz(sizeof(PESContext));

    if (!pes)

        return 0;

    pes->ts = ts;

    pes->stream = ts->stream;

    pes->pid = pid;

    pes->pcr_pid = pcr_pid;

    pes->stream_type = stream_type;

    pes->state = MPEGTS_SKIP;

    pes->pts = AV_NOPTS_VALUE;

    pes->dts = AV_NOPTS_VALUE;

    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);

    if (!tss) {

        av_free(pes);

        return 0;

    }

    return pes;

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,1
23429,FFmpeg,1,"void mpeg_motion_internal(MpegEncContext *s,

                 uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,

                 int field_based, int bottom_field, int field_select,

                 uint8_t **ref_picture, op_pixels_func (*pix_op)[4],

                 int motion_x, int motion_y, int h, int is_mpeg12, int mb_y)

{

    uint8_t *ptr_y, *ptr_cb, *ptr_cr;

    int dxy, uvdxy, mx, my, src_x, src_y,

        uvsrc_x, uvsrc_y, v_edge_pos;

    emuedge_linesize_type uvlinesize, linesize;



#if 0

if(s->quarter_sample)

{

    motion_x>>=1;

    motion_y>>=1;

}

#endif



    v_edge_pos = s->v_edge_pos >> field_based;

    linesize   = s->current_picture.f.linesize[0] << field_based;

    uvlinesize = s->current_picture.f.linesize[1] << field_based;



    dxy = ((motion_y & 1) << 1) | (motion_x & 1);

    src_x = s->mb_x* 16               + (motion_x >> 1);

    src_y =(   mb_y<<(4-field_based)) + (motion_y >> 1);



    if (!is_mpeg12 && s->out_format == FMT_H263) {

        if((s->workaroun",1,0,5,0,0,0,1,1,1,1,1,1,0,1,0
23455,qemu,0,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)

{

    if (kvm_enabled()) {

        kvm_s390_virtio_irq(cpu, config_change, token);

    } else {

        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
23465,FFmpeg,0,"static int vble_unpack(VBLEContext *ctx, GetBitContext *gb)

{

    int i;

    static const uint8_t LUT[256] = {

        8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

        5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,

    };



    /* Read all the lengths in first */

    for (i = 0; i < ctx->size; i++) {

        /* At most we need to read 9 bits total to get indices up to 8 */

        int val = show_bits(gb, 8);



        // read reverse unary

        if (val) {

            val = LUT[val];

            skip_bits(gb, val + 1",1,0,1,0,0,0,0,0,1,0,0,0,1,1,1
23470,FFmpeg,0,"int ffurl_alloc(URLContext **puc, const char *filename, int flags,

                const AVIOInterruptCB *int_cb)

{

    URLProtocol *up = NULL;

    char proto_str[128], proto_nested[128], *ptr;

    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);



    if (filename[proto_len] != ':' || is_dos_path(filename))

        strcpy(proto_str, ""file"");

    else

        av_strlcpy(proto_str, filename,

                   FFMIN(proto_len + 1, sizeof(proto_str)));



    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));

    if ((ptr = strchr(proto_nested, '+')))

        *ptr = '\0';



    while (up = ffurl_protocol_next(up)) {

        if (!strcmp(proto_str, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&

            !strcmp(proto_nested, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

    }

    *puc = NULL;

    return AVERROR_PROTOCOL_NOT_FOUND;

}
",2,0,4,0,0,1,1,1,1,1,1,1,0,0,0
23491,qemu,0,"BlockDriverState *bdrv_next(BlockDriverState *bs)

{

    if (!bs) {

        return QTAILQ_FIRST(&bdrv_states);

    }

    return QTAILQ_NEXT(bs, device_list);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,0,1
23495,qemu,0,"void mcf_uart_write(void *opaque, target_phys_addr_t addr,

                    uint64_t val, unsigned size)

{

    mcf_uart_state *s = (mcf_uart_state *)opaque;

    switch (addr & 0x3f) {

    case 0x00:

        s->mr[s->current_mr] = val;

        s->current_mr = 1;

        break;

    case 0x04:

        /* CSR is ignored.  */

        break;

    case 0x08: /* Command Register.  */

        mcf_do_command(s, val);

        break;

    case 0x0c: /* Transmit Buffer.  */

        s->sr &= ~MCF_UART_TxEMP;

        s->tb = val;

        mcf_uart_do_tx(s);

        break;

    case 0x10:

        /* ACR is ignored.  */

        break;

    case 0x14:

        s->imr = val;

        break;

    default:

        break;

    }

    mcf_uart_update(s);

}
",0,0,0,0,1,0,1,0,1,0,0,0,0,1,1
23504,qemu,0,"MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)

{

    ARMCPU *cpu;

    uint32_t switched_level;



    if (kvm_irqchip_in_kernel()) {

        /*

         * We only need to sync timer states with user-space interrupt

         * controllers, so return early and save cycles if we don't.

         */

        return MEMTXATTRS_UNSPECIFIED;

    }



    cpu = ARM_CPU(cs);



    /* Synchronize our shadowed in-kernel device irq lines with the kvm ones */

    if (run->s.regs.device_irq_level != cpu->device_irq_level) {

        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;



        qemu_mutex_lock_iothread();



        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {

            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],

                         !!(run->s.regs.device_irq_level &

                            KVM_ARM_DEV_EL1_VTIMER));

            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;

        }



        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {

  ",0,0,5,0,5,0,1,1,1,1,1,1,0,0,0
23508,FFmpeg,0,"static int avi_write_trailer(AVFormatContext *s)

{

    AVIContext *avi = s->priv_data;

    AVIOContext *pb = s->pb;

    int res = 0;

    int i, j, n, nb_frames;

    int64_t file_size;



    if (pb->seekable) {

        if (avi->riff_id == 1) {

            ff_end_tag(pb, avi->movi_list);

            res = avi_write_idx1(s);

            ff_end_tag(pb, avi->riff_start);

        } else {

            avi_write_ix(s);

            ff_end_tag(pb, avi->movi_list);

            ff_end_tag(pb, avi->riff_start);



            file_size = avio_tell(pb);

            avio_seek(pb, avi->odml_list - 8, SEEK_SET);

            ffio_wfourcc(pb, ""LIST""); /* Making this AVI OpenDML one */

            avio_skip(pb, 16);



            for (n = nb_frames = 0; n < s->nb_streams; n++) {

                AVCodecParameters *par = s->streams[n]->codecpar;

                AVIStream *avist       = s->streams[n]->priv_data;



                if (par->codec_type == AVMEDIA_TYPE_VIDEO) {

                    if (nb_frames <",1,0,7,0,0,0,0,0,0,0,0,0,0,0,1
23516,qemu,0,"static uint64_t omap_mpui_io_read(void *opaque, target_phys_addr_t addr,

                                  unsigned size)

{

    if (size != 2) {

        return omap_badwidth_read16(opaque, addr);

    }



    if (addr == OMAP_MPUI_BASE)	/* CMR */

        return 0xfe4d;



    OMAP_BAD_REG(addr);

    return 0;

}
",0,0,2,0,0,0,0,1,1,1,0,1,1,1,0
23540,qemu,0,"static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)

{

    PCIAC97LinkState *d = opaque;

    AC97LinkState *s = &d->ac97;

    dolog (""U nam writeb %#x <- %#x\n"", addr, val);

    s->cas = 0;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
23555,qemu,0,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)

{

    S390FLICState *fs = S390_FLIC_COMMON(dev);

    uint32_t max_batch = fs->adapter_routes_max_batch;



    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {

        error_setg(errp, ""flic property adapter_routes_max_batch too big""

                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);

    }



    fs->ais_supported = true;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
23560,FFmpeg,0,"static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)

{

    InputStream  *ist = s->opaque;

    DXVA2Context *ctx = ist->hwaccel_ctx;



    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,0
23576,FFmpeg,0,"void ff_h264_idct8_add_c(uint8_t *dst, DCTELEM *block, int stride){

    int i;

    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;



    block[0] += 32;



    for( i = 0; i < 8; i++ )

    {

        const int a0 =  block[0+i*8] + block[4+i*8];

        const int a2 =  block[0+i*8] - block[4+i*8];

        const int a4 = (block[2+i*8]>>1) - block[6+i*8];

        const int a6 = (block[6+i*8]>>1) + block[2+i*8];



        const int b0 = a0 + a6;

        const int b2 = a2 + a4;

        const int b4 = a2 - a4;

        const int b6 = a0 - a6;



        const int a1 = -block[3+i*8] + block[5+i*8] - block[7+i*8] - (block[7+i*8]>>1);

        const int a3 =  block[1+i*8] + block[7+i*8] - block[3+i*8] - (block[3+i*8]>>1);

        const int a5 = -block[1+i*8] + block[7+i*8] + block[5+i*8] + (block[5+i*8]>>1);

        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);



        const int b1 = (a7>>2) + a1;

        const int b3 =  a3 + (a5>>2);

        const int b5 = (a3>>2) - a5;

  ",1,0,0,0,0,0,0,0,0,0,0,0,0,1,0
23587,qemu,0,"void do_load_dcr (void)

{

    target_ulong val;



    if (unlikely(env->dcr_env == NULL)) {

        if (loglevel != 0) {

            fprintf(logfile, ""No DCR environment\n"");

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_INVAL_INVAL);

    } else if (unlikely(ppc_dcr_read(env->dcr_env, T0, &val) != 0)) {

        if (loglevel != 0) {

            fprintf(logfile, ""DCR read error %d %03x\n"", (int)T0, (int)T0);

        }

        do_raise_exception_err(EXCP_PROGRAM, EXCP_INVAL | EXCP_PRIV_REG);

    } else {

        T0 = val;

    }

}
",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
23622,qemu,0,"void tlb_set_page(CPUArchState *env, target_ulong vaddr,

                  target_phys_addr_t paddr, int prot,

                  int mmu_idx, target_ulong size)

{

    MemoryRegionSection *section;

    unsigned int index;

    target_ulong address;

    target_ulong code_address;

    uintptr_t addend;

    CPUTLBEntry *te;

    target_phys_addr_t iotlb;



    assert(size >= TARGET_PAGE_SIZE);

    if (size != TARGET_PAGE_SIZE) {

        tlb_add_large_page(env, vaddr, size);

    }

    section = phys_page_find(paddr >> TARGET_PAGE_BITS);

#if defined(DEBUG_TLB)

    printf(""tlb_set_page: vaddr="" TARGET_FMT_lx "" paddr=0x"" TARGET_FMT_plx

           "" prot=%x idx=%d pd=0x%08lx\n"",

           vaddr, paddr, prot, mmu_idx, pd);

#endif



    address = vaddr;

    if (!(memory_region_is_ram(section->mr) ||

          memory_region_is_romd(section->mr))) {

        /* IO memory case (romd handled later) */

        address |= TLB_MMIO;

    }

    if (memory_region_is_ram(section->mr) ||

        memory_reg",0,0,5,0,0,0,0,0,0,0,0,0,1,1,1
23626,qemu,1,"static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)

{

    RTL8139State *s = opaque;



    addr &= 0xff;



    switch (addr)

    {

        case MAC0 ... MAC0+5:

            s->phys[addr - MAC0] = val;

            break;

        case MAC0+6 ... MAC0+7:

            /* reserved */

            break;

        case MAR0 ... MAR0+7:

            s->mult[addr - MAR0] = val;

            break;

        case ChipCmd:

            rtl8139_ChipCmd_write(s, val);

            break;

        case Cfg9346:

            rtl8139_Cfg9346_write(s, val);

            break;

        case TxConfig: /* windows driver sometimes writes using byte-lenth call */

            rtl8139_TxConfig_writeb(s, val);

            break;

        case Config0:

            rtl8139_Config0_write(s, val);

            break;

        case Config1:

            rtl8139_Config1_write(s, val);

            break;

        case Config3:

            rtl8139_Config3_write(s, val);

            break;

        case Confi",0,0,0,0,1,0,0,1,1,1,0,0,0,0,0
23627,FFmpeg,1,"static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,

                                    const int filter_p1, const int filter_q1,

                                    const int alpha, const int beta,

                                    const int lim_p0q0, const int lim_q1,

                                    const int lim_p1)

{

    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,

                          alpha, beta, lim_p0q0, lim_q1, lim_p1);

}
",0,0,0,0,0,0,0,0,0,0,1,0,1,1,1
23636,FFmpeg,1,"static int decode_subframe(WmallDecodeCtx *s)

{

    int offset        = s->samples_per_frame;

    int subframe_len  = s->samples_per_frame;

    int total_samples = s->samples_per_frame * s->num_channels;

    int i, j, rawpcm_tile, padding_zeroes, res;



    s->subframe_offset = get_bits_count(&s->gb);



    /* reset channel context and find the next block offset and size

        == the next block of the channel with the smallest number of

        decoded samples */

    for (i = 0; i < s->num_channels; i++) {

        if (offset > s->channel[i].decoded_samples) {

            offset = s->channel[i].decoded_samples;

            subframe_len =

                s->channel[i].subframe_len[s->channel[i].cur_subframe];

        }

    }



    /* get a list of all channels that contain the estimated block */

    s->channels_for_cur_subframe = 0;

    for (i = 0; i < s->num_channels; i++) {

        const int cur_subframe = s->channel[i].cur_subframe;

        /* subtract already processed samples */

   ",3,0,1,0,0,0,1,1,0,1,0,0,1,1,0
23643,FFmpeg,1,"static void RENAME(yuv2rgb565_1)(SwsContext *c, const int16_t *buf0,

                                 const int16_t *ubuf[2], const int16_t *bguf[2],

                                 const int16_t *abuf0, uint8_t *dest,

                                 int dstW, int uvalpha, int y)

{

    const int16_t *ubuf0 = ubuf[0], *ubuf1 = ubuf[1];

    const int16_t *buf1= buf0; //FIXME needed for RGB1/BGR1



    if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster

        __asm__ volatile(

            ""mov %%""REG_b"", ""ESP_OFFSET""(%5)        \n\t""

            ""mov        %4, %%""REG_b""               \n\t""

            ""push %%""REG_BP""                        \n\t""

            YSCALEYUV2RGB1(%%REGBP, %5)

            ""pxor    %%mm7, %%mm7                   \n\t""

            /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */

#ifdef DITHER1XBPP

            ""paddusb ""BLUE_DITHER""(%5), %%mm2      \n\t""

            ""paddusb ""GREEN_DITHER""(%5), %%mm4      \n\t""

          ",0,0,2,0,0,0,0,0,0,0,0,0,0,0,1
23656,qemu,1,"void hmp_memchar_write(Monitor *mon, const QDict *qdict)

{

    uint32_t size;

    const char *chardev = qdict_get_str(qdict, ""device"");

    const char *data = qdict_get_str(qdict, ""data"");

    Error *errp = NULL;



    size = strlen(data);

    qmp_memchar_write(chardev, size, data, false, 0, &errp);



    hmp_handle_error(mon, &errp);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
23668,FFmpeg,0,"static int do_bit_allocation(AC3DecodeContext *ctx, int flags)

{

    ac3_audio_block *ab = &ctx->audio_block;

    int i, snroffst = 0;



    if (!flags) /* bit allocation is not required */

        return 0;



    if (ab->flags & AC3_AB_SNROFFSTE) { /* check whether snroffsts are zero */

        snroffst += ab->csnroffst;

        if (ab->flags & AC3_AB_CPLINU)

            snroffst += ab->cplfsnroffst;

        for (i = 0; i < ctx->bsi.nfchans; i++)

            snroffst += ab->fsnroffst[i];

        if (ctx->bsi.flags & AC3_BSI_LFEON)

            snroffst += ab->lfefsnroffst;

        if (!snroffst) {

            memset(ab->cplbap, 0, sizeof (ab->cplbap));

            for (i = 0; i < ctx->bsi.nfchans; i++)

                memset(ab->bap[i], 0, sizeof (ab->bap[i]));

            memset(ab->lfebap, 0, sizeof (ab->lfebap));



            return 0;

        }

    }



    /* perform bit allocation */

    if ((ab->flags & AC3_AB_CPLINU) && (flags & 64))

        if (_do_bit_allocation(ctx, 5))

   ",2,0,7,0,0,0,0,0,0,0,0,0,0,0,0
23680,qemu,0,"void qmp_drive_backup(const char *device, const char *target,

                      bool has_format, const char *format,

                      enum MirrorSyncMode sync,

                      bool has_mode, enum NewImageMode mode,

                      bool has_speed, int64_t speed,

                      bool has_on_source_error, BlockdevOnError on_source_error,

                      bool has_on_target_error, BlockdevOnError on_target_error,

                      Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *target_bs;

    BlockDriverState *source = NULL;

    BlockDriver *drv = NULL;

    Error *local_err = NULL;

    int flags;

    int64_t size;

    int ret;



    if (!has_speed) {

        speed = 0;

    }

    if (!has_on_source_error) {

        on_source_error = BLOCKDEV_ON_ERROR_REPORT;

    }

    if (!has_on_target_error) {

        on_target_error = BLOCKDEV_ON_ERROR_REPORT;

    }

    if (!has_mode) {

        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;

    }



    bs =",2,0,4,0,0,0,1,1,1,1,0,1,0,1,1
23688,qemu,0,"static void malta_fpga_write(void *opaque, hwaddr addr,

                             uint64_t val, unsigned size)

{

    MaltaFPGAState *s = opaque;

    uint32_t saddr;



    saddr = (addr & 0xfffff);



    switch (saddr) {



    /* SWITCH Register */

    case 0x00200:

        break;



    /* JMPRS Register */

    case 0x00210:

        break;



    /* LEDBAR Register */

    case 0x00408:

        s->leds = val & 0xff;

        malta_fpga_update_display(s);

        break;



    /* ASCIIWORD Register */

    case 0x00410:

        snprintf(s->display_text, 9, ""%08X"", (uint32_t)val);

        malta_fpga_update_display(s);

        break;



    /* ASCIIPOS0 to ASCIIPOS7 Registers */

    case 0x00418:

    case 0x00420:

    case 0x00428:

    case 0x00430:

    case 0x00438:

    case 0x00440:

    case 0x00448:

    case 0x00450:

        s->display_text[(saddr - 0x00418) >> 3] = (char) val;

        malta_fpga_update_display(s);

        break;



    /* SOFTRES Register */

    case 0x00500:

",0,0,0,0,1,0,0,0,0,0,0,0,0,0,0
23692,FFmpeg,0,"static int revert_channel_correlation(ALSDecContext *ctx, ALSBlockData *bd,

                                       ALSChannelData **cd, int *reverted,

                                       unsigned int offset, int c)

{

    ALSChannelData *ch = cd[c];

    unsigned int   dep = 0;

    unsigned int channels = ctx->avctx->channels;



    if (reverted[c])

        return 0;



    reverted[c] = 1;



    while (dep < channels && !ch[dep].stop_flag) {

        revert_channel_correlation(ctx, bd, cd, reverted, offset,

                                   ch[dep].master_channel);



        dep++;

    }



    if (dep == channels) {

        av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel correlation!\n"");

        return AVERROR_INVALIDDATA;

    }



    bd->const_block = ctx->const_block + c;

    bd->shift_lsbs  = ctx->shift_lsbs + c;

    bd->opt_order   = ctx->opt_order + c;

    bd->store_prev_samples = ctx->store_prev_samples + c;

    bd->use_ltp     = ctx->use_ltp + c;

    bd->ltp_lag     = ctx-",0,0,4,0,0,1,1,1,0,0,0,1,0,0,0
23696,qemu,0,"build_hpet(GArray *table_data, GArray *linker)

{

    Acpi20Hpet *hpet;



    hpet = acpi_data_push(table_data, sizeof(*hpet));

    /* Note timer_block_id value must be kept in sync with value advertised by

     * emulated hpet

     */

    hpet->timer_block_id = cpu_to_le32(0x8086a201);

    hpet->addr.address = cpu_to_le64(HPET_BASE);

    build_header(linker, table_data,

                 (void *)hpet, ""HPET"", sizeof(*hpet), 1, NULL);

}
",0,0,0,0,0,0,1,1,0,1,1,1,0,0,0
23704,FFmpeg,0,"static inline void downmix_3f_1r_to_mono(float *samples)

{

    int i;



    for (i = 0; i < 256; i++) {

        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);

        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;

    }

}
",1,0,0,0,0,0,0,0,0,0,0,0,0,0,0
23714,FFmpeg,0,"static int qsv_decode_init(AVCodecContext *avctx, QSVContext *q)

{

    const AVPixFmtDescriptor *desc;

    mfxSession session = NULL;

    int iopattern = 0;

    mfxVideoParam param = { { 0 } };

    int frame_width  = avctx->coded_width;

    int frame_height = avctx->coded_height;

    int ret;



    desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);

    if (!desc)

        return AVERROR_BUG;



    if (!q->async_fifo) {

        q->async_fifo = av_fifo_alloc((1 + q->async_depth) *

                                      (sizeof(mfxSyncPoint*) + sizeof(QSVFrame*)));

        if (!q->async_fifo)

            return AVERROR(ENOMEM);

    }



    if (avctx->pix_fmt == AV_PIX_FMT_QSV && avctx->hwaccel_context) {

        AVQSVContext *user_ctx = avctx->hwaccel_context;

        session           = user_ctx->session;

        iopattern         = user_ctx->iopattern;

        q->ext_buffers    = user_ctx->ext_buffers;

        q->nb_ext_buffers = user_ctx->nb_ext_buffers;

    }



    if (avctx->hw_frames_ctx",0,0,9,0,0,0,0,1,0,1,0,0,1,1,0
23744,qemu,0,"static void virtio_pci_modern_region_map(VirtIOPCIProxy *proxy,

                                         VirtIOPCIRegion *region,

                                         struct virtio_pci_cap *cap)

{

    memory_region_add_subregion(&proxy->modern_bar,

                                region->offset,

                                &region->mr);



    cap->cfg_type = region->type;

    cap->offset = cpu_to_le32(region->offset);

    cap->length = cpu_to_le32(memory_region_size(&region->mr));

    virtio_pci_add_mem_cap(proxy, cap);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
23747,qemu,0,"static void mixer_reset (AC97LinkState *s)

{

    uint8_t active[LAST_INDEX];



    dolog (""mixer_reset\n"");

    memset (s->mixer_data, 0, sizeof (s->mixer_data));

    memset (active, 0, sizeof (active));

    mixer_store (s, AC97_Reset                   , 0x0000); /* 6940 */

    mixer_store (s, AC97_Master_Volume_Mono_Mute , 0x8000);

    mixer_store (s, AC97_PC_BEEP_Volume_Mute     , 0x0000);



    mixer_store (s, AC97_Phone_Volume_Mute       , 0x8008);

    mixer_store (s, AC97_Mic_Volume_Mute         , 0x8008);

    mixer_store (s, AC97_CD_Volume_Mute          , 0x8808);

    mixer_store (s, AC97_Aux_Volume_Mute         , 0x8808);

    mixer_store (s, AC97_Record_Gain_Mic_Mute    , 0x8000);

    mixer_store (s, AC97_General_Purpose         , 0x0000);

    mixer_store (s, AC97_3D_Control              , 0x0000);

    mixer_store (s, AC97_Powerdown_Ctrl_Stat     , 0x000f);



    /*

     * Sigmatel 9700 (STAC9700)

     */

    mixer_store (s, AC97_Vendor_ID1              , 0x8384);

    mixer_store (",0,0,0,0,0,0,0,1,1,0,0,0,0,0,0
23751,qemu,0,"int bdrv_pdiscard(BlockDriverState *bs, int64_t offset, int count)

{

    Coroutine *co;

    DiscardCo rwco = {

        .bs = bs,

        .offset = offset,

        .count = count,

        .ret = NOT_DONE,

    };



    if (qemu_in_coroutine()) {

        /* Fast-path if already in coroutine context */

        bdrv_pdiscard_co_entry(&rwco);

    } else {

        AioContext *aio_context = bdrv_get_aio_context(bs);



        co = qemu_coroutine_create(bdrv_pdiscard_co_entry, &rwco);

        qemu_coroutine_enter(co);

        while (rwco.ret == NOT_DONE) {

            aio_poll(aio_context, true);

        }

    }



    return rwco.ret;

}
",0,0,1,0,0,1,0,0,0,0,0,0,0,0,0
23758,qemu,0,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)

{

    uintptr_t ra = GETPC();



    switch (addr & 3) {

    case 3:

        cpu_stb_data_ra(env, addr, val, ra);

        break;

    case 2:

        cpu_stw_data_ra(env, addr, val, ra);

        break;

    case 1:

        /* The 3 byte store must appear atomic.  */

        if (parallel_cpus) {

            atomic_store_3(env, addr, val, 0x00ffffffu, ra);

        } else {

            cpu_stb_data_ra(env, addr, val >> 16, ra);

            cpu_stw_data_ra(env, addr + 1, val, ra);

        }

        break;

    default:

        cpu_stl_data_ra(env, addr, val, ra);

        break;

    }

}
",0,0,1,0,1,0,1,1,1,1,0,0,1,1,1
23762,FFmpeg,1,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
",0,0,4,0,0,0,1,1,1,1,0,0,0,1,1
23769,FFmpeg,1,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;

    OPEN_READER(re, &s->gb);

    count /= 2;



    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for (i = 0; i < count; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

    CLOSE_READER(re, &s->gb);

}
",2,0,1,0,0,0,0,1,1,0,0,0,1,1,1
23771,qemu,1,"static void memory_region_destructor_alias(MemoryRegion *mr)

{

    memory_region_unref(mr->alias);

}
",0,0,0,0,0,0,1,0,1,0,0,0,1,1,1
23779,qemu,1,"int ppc_hash64_handle_mmu_fault(PowerPCCPU *cpu, target_ulong eaddr,

                                int rwx, int mmu_idx)

{

    CPUState *cs = CPU(cpu);

    CPUPPCState *env = &cpu->env;

    ppc_slb_t *slb;

    hwaddr pte_offset;

    ppc_hash_pte64_t pte;

    int pp_prot, amr_prot, prot;

    uint64_t new_pte1;

    const int need_prot[] = {PAGE_READ, PAGE_WRITE, PAGE_EXEC};

    hwaddr raddr;



    assert((rwx == 0) || (rwx == 1) || (rwx == 2));



    /* 1. Handle real mode accesses */

    if (((rwx == 2) && (msr_ir == 0)) || ((rwx != 2) && (msr_dr == 0))) {

        /* Translation is off */

        /* In real mode the top 4 effective address bits are ignored */

        raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL;

        tlb_set_page(cs, eaddr & TARGET_PAGE_MASK, raddr & TARGET_PAGE_MASK,

                     PAGE_READ | PAGE_WRITE | PAGE_EXEC, mmu_idx,

                     TARGET_PAGE_SIZE);

        return 0;

    }



    /* 2. Translation is on, so look up the SLB */

    slb = slb_lookup(cpu",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
23786,FFmpeg,1,"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    PCXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    int compressed, xmin, ymin, xmax, ymax;

    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,

                 bytes_per_scanline;

    uint8_t *ptr;

    uint8_t const *bufstart = buf;

    uint8_t *scanline;

    int ret = -1;



    if (buf[0] != 0x0a || buf[1] > 5) {

        av_log(avctx, AV_LOG_ERROR, ""this is not PCX encoded data\n"");

        return AVERROR_INVALIDDATA;

    }



    compressed = buf[2];

    xmin = AV_RL16(buf+ 4);

    ymin = AV_RL16(buf+ 6);

    xmax = AV_RL16(buf+ 8);

    ymax = AV_RL16(buf+10);



    if (xmax < xmin || ymax < ymin) {

        av_log(avctx, AV_LOG_ERROR, ""invalid image dimensions\n"");

        return AVERROR_INVALIDDATA;

 ",0,0,2,0,0,0,0,1,0,0,1,0,0,0,0
23809,qemu,1,"QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict)

{

    QemuOpts *opts;



    opts = qemu_opts_create(list, qdict_get_try_str(qdict, ""id""), 1);

    if (opts == NULL)

        return NULL;



    qdict_iter(qdict, qemu_opts_from_qdict_1, opts);

    return opts;

}
",0,0,1,0,0,0,0,1,1,1,1,1,1,0,1
23816,qemu,0,"static void conditional_branch(DBDMA_channel *ch)

{

    dbdma_cmd *current = &ch->current;

    uint16_t br;

    uint16_t sel_mask, sel_value;

    uint32_t status;

    int cond;



    DBDMA_DPRINTF(""conditional_branch\n"");



    /* check if we must branch */



    br = le16_to_cpu(current->command) & BR_MASK;



    switch(br) {

    case BR_NEVER:  /* don't branch */

        next(ch);

        return;

    case BR_ALWAYS: /* always branch */

        branch(ch);

        return;

    }



    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;



    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;

    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;



    cond = (status & sel_mask) == (sel_value & sel_mask);



    switch(br) {

    case BR_IFSET:  /* branch if condition bit is 1 */

        if (cond)

            branch(ch);

        else

            next(ch);

        return;

    case BR_IFCLR:  /* branch if condition bit is 0 */

        if (!cond)

         ",0,0,2,0,2,0,0,0,0,0,0,0,0,0,0
23854,FFmpeg,0,"static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j;

    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {

        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        int *src = t1->data[j];

        if (band->i_stepsize == 16384) {

            for (i = 0; i < w; ++i)

                datap[i] = src[i] / 2;

        } else {

            // This should be VERY uncommon

            for (i = 0; i < w; ++i)

                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}
",3,0,1,0,0,0,0,0,0,0,0,0,1,1,1
23855,qemu,0,"static void gdb_accept(void)

{

    GDBState *s;

    struct sockaddr_in sockaddr;

    socklen_t len;

    int fd;



    for(;;) {

        len = sizeof(sockaddr);

        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);

        if (fd < 0 && errno != EINTR) {

            perror(""accept"");

            return;

        } else if (fd >= 0) {

#ifndef _WIN32

            fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif

            break;

        }

    }



    /* set short latency */

    socket_set_nodelay(fd);



    s = g_malloc0(sizeof(GDBState));

    s->c_cpu = first_cpu;

    s->g_cpu = first_cpu;

    s->fd = fd;

    gdb_has_xml = false;



    gdbserver_state = s;



    fcntl(fd, F_SETFL, O_NONBLOCK);

}
",1,0,4,0,0,0,0,0,0,1,0,1,1,1,1
23870,FFmpeg,0,"static int vaapi_encode_h265_init_sequence_params(AVCodecContext *avctx)

{

    VAAPIEncodeContext                 *ctx = avctx->priv_data;

    VAEncSequenceParameterBufferHEVC  *vseq = ctx->codec_sequence_params;

    VAEncPictureParameterBufferHEVC   *vpic = ctx->codec_picture_params;

    VAAPIEncodeH265Context            *priv = ctx->priv_data;

    VAAPIEncodeH265MiscSequenceParams *mseq = &priv->misc_sequence_params;

    int i;



    {

        // general_profile_space == 0.

        vseq->general_profile_idc = 1; // Main profile (ctx->codec_profile?)

        vseq->general_tier_flag = 0;



        vseq->general_level_idc = avctx->level * 3;



        vseq->intra_period = 0;

        vseq->intra_idr_period = 0;

        vseq->ip_period = 0;



        vseq->pic_width_in_luma_samples  = ctx->aligned_width;

        vseq->pic_height_in_luma_samples = ctx->aligned_height;



        vseq->seq_fields.bits.chroma_format_idc = 1; // 4:2:0.

        vseq->seq_fields.bits.separate_colour_plane_flag = 0;

",1,0,0,0,0,0,0,0,0,0,0,0,0,1,0
23872,FFmpeg,0,"static void rdft_calc_c(RDFTContext *s, FFTSample *data)

{

    int i, i1, i2;

    FFTComplex ev, od;

    const int n = 1 << s->nbits;

    const float k1 = 0.5;

    const float k2 = 0.5 - s->inverse;

    const FFTSample *tcos = s->tcos;

    const FFTSample *tsin = s->tsin;



    if (!s->inverse) {

        s->fft.fft_permute(&s->fft, (FFTComplex*)data);

        s->fft.fft_calc(&s->fft, (FFTComplex*)data);

    }

    /* i=0 is a special case because of packing, the DC term is real, so we

       are going to throw the N/2 term (also real) in with it. */

    ev.re = data[0];

    data[0] = ev.re+data[1];

    data[1] = ev.re-data[1];

    for (i = 1; i < (n>>2); i++) {

        i1 = 2*i;

        i2 = n-i1;

        /* Separate even and odd FFTs */

        ev.re =  k1*(data[i1  ]+data[i2  ]);

        od.im = -k2*(data[i1  ]-data[i2  ]);

        ev.im =  k1*(data[i1+1]-data[i2+1]);

        od.re =  k2*(data[i1+1]+data[i2+1]);

        /* Apply twiddle factors to the odd FFT and add to the even FFT",1,0,1,0,0,0,0,0,0,0,1,1,0,1,0
23877,FFmpeg,0,"static av_cold int g726_init(AVCodecContext * avctx)

{

    AVG726Context* c = (AVG726Context*)avctx->priv_data;

    unsigned int index= (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate - 2;



    if (

        (avctx->bit_rate != 16000 && avctx->bit_rate != 24000 &&

         avctx->bit_rate != 32000 && avctx->bit_rate != 40000)) {

        av_log(avctx, AV_LOG_ERROR, ""G726: unsupported audio format\n"");

        return -1;

    }

    if (avctx->sample_rate != 8000 && avctx->strict_std_compliance>FF_COMPLIANCE_INOFFICIAL) {

        av_log(avctx, AV_LOG_ERROR, ""G726: unsupported audio format\n"");

        return -1;

    }

    if(avctx->channels != 1){

        av_log(avctx, AV_LOG_ERROR, ""Only mono is supported\n"");

        return -1;

    }

    if(index>3){

        av_log(avctx, AV_LOG_ERROR, ""Unsupported number of bits %d\n"", index+2);

        return -1;

    }

    g726_reset(&c->c, index);

    c->code_size = c->c.tbls->bits;

    c->bit_buffer = 0;

    c->bits_left = 0;



    av",2,0,4,0,0,0,0,1,0,0,0,0,0,0,0
23888,qemu,1,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,

				 unsigned long offset)

{

    const unsigned long *p = addr + BITOP_WORD(offset);

    unsigned long result = offset & ~(BITS_PER_LONG-1);

    unsigned long tmp;



    if (offset >= size) {

        return size;

    }

    size -= result;

    offset %= BITS_PER_LONG;

    if (offset) {

        tmp = *(p++);

        tmp |= ~0UL >> (BITS_PER_LONG - offset);

        if (size < BITS_PER_LONG) {

            goto found_first;

        }

        if (~tmp) {

            goto found_middle;

        }

        size -= BITS_PER_LONG;

        result += BITS_PER_LONG;

    }

    while (size & ~(BITS_PER_LONG-1)) {

        if (~(tmp = *(p++))) {

            goto found_middle;

        }

        result += BITS_PER_LONG;

        size -= BITS_PER_LONG;

    }

    if (!size) {

        return result;

    }

    tmp = *p;



found_first:

    tmp |= ~0UL << size;

    if (tmp == ~0UL) {	/* Are any bits zero? */

        retur",0,3,7,0,0,1,1,1,1,1,1,1,1,1,1
23895,qemu,1,"void visit_end_implicit_struct(Visitor *v, Error **errp)

{

    assert(!error_is_set(errp));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, errp);

    }

}
",0,0,1,0,0,0,0,0,0,1,0,0,0,0,0
23899,qemu,1,"static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)

{

    int ret;



    assert(client->optlen);

    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {

        return -EIO;

    }

    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,

                                     ""option '%s' should have zero length"",

                                     nbd_opt_lookup(client->opt));

    if (fatal && !ret) {

        error_setg(errp, ""option '%s' should have zero length"",

                   nbd_opt_lookup(client->opt));

        return -EINVAL;

    }

    return ret;

}
",0,0,2,0,0,0,0,0,1,1,1,1,0,1,0
23912,qemu,1,"static int kvmppc_read_host_property(const char *node_path, const char *prop,

                                     void *val, size_t len)

{

    char *path;

    FILE *f;

    int ret;

    int pathlen;



    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)

              + 1;

    path = qemu_malloc(pathlen);

    if (path == NULL) {

        ret = -ENOMEM;

        goto out;

    }



    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);



    f = fopen(path, ""rb"");

    if (f == NULL) {

        ret = errno;

        goto free;

    }



    len = fread(val, len, 1, f);

    if (len != 1) {

        ret = ferror(f);

        goto close;

    }



close:

    fclose(f);

free:

    free(path);

out:

    return ret;

}
",0,3,3,0,0,0,0,1,0,0,0,1,1,1,1
23916,qemu,1,"static void tcg_out_qemu_ld(TCGContext *s, TCGReg data, TCGReg addr,

                            TCGMemOpIdx oi, bool is_64)

{

    TCGMemOp memop = get_memop(oi);

#ifdef CONFIG_SOFTMMU

    unsigned memi = get_mmuidx(oi);

    TCGReg addrz, param;

    tcg_insn_unit *func;

    tcg_insn_unit *label_ptr;



    addrz = tcg_out_tlb_load(s, addr, memi, memop,

                             offsetof(CPUTLBEntry, addr_read));



    /* The fast path is exactly one insn.  Thus we can perform the

       entire TLB Hit in the (annulled) delay slot of the branch

       over the TLB Miss case.  */



    /* beq,a,pt %[xi]cc, label0 */

    label_ptr = s->code_ptr;

    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT

                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);

    /* delay slot */

    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,

                    qemu_ld_opc[memop & (MO_BSWAP | MO_SSIZE)]);



    /* TLB Miss.  */



    param = TCG_REG_O1;

    if (!SPARC64 && TARGET_LONG_BITS == 64) {

",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
23918,qemu,1,"opts_visitor_cleanup(OptsVisitor *ov)

{

    if (ov->unprocessed_opts != NULL) {

        g_hash_table_destroy(ov->unprocessed_opts);

    }

    g_free(ov->fake_id_opt);

    memset(ov, '\0', sizeof *ov);

}
",0,0,1,0,0,0,0,1,0,0,0,0,1,1,1
23922,qemu,0,"static int usb_host_open(USBHostDevice *s, libusb_device *dev)

{

    USBDevice *udev = USB_DEVICE(s);

    int bus_num = libusb_get_bus_number(dev);

    int addr    = libusb_get_device_address(dev);

    int rc;



    trace_usb_host_open_started(bus_num, addr);



    if (s->dh != NULL) {

        goto fail;

    }

    rc = libusb_open(dev, &s->dh);

    if (rc != 0) {

        goto fail;

    }



    s->dev     = dev;

    s->bus_num = bus_num;

    s->addr    = addr;



    usb_host_detach_kernel(s);



    libusb_get_device_descriptor(dev, &s->ddesc);

    usb_host_get_port(s->dev, s->port, sizeof(s->port));



    usb_ep_init(udev);

    usb_host_ep_update(s);



    udev->speed     = speed_map[libusb_get_device_speed(dev)];

    usb_host_speed_compat(s);



    if (s->ddesc.iProduct) {

        libusb_get_string_descriptor_ascii(s->dh, s->ddesc.iProduct,

                                           (unsigned char *)udev->product_desc,

                                           sizeof(udev->product_",0,2,3,0,0,0,1,1,1,1,1,0,1,1,1
23924,qemu,0,"int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)

{

    PageCache *new_cache;

    int64_t ret;



    /* Check for truncation */

    if (new_size != (size_t)new_size) {

        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                   ""exceeding address space"");

        return -1;

    }



    /* Cache should not be larger than guest ram size */

    if (new_size > ram_bytes_total()) {

        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                   ""exceeds guest ram size"");

        return -1;

    }



    XBZRLE_cache_lock();



    if (XBZRLE.cache != NULL) {

        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {

            goto out_new_size;

        }

        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);

        if (!new_cache) {

            ret = -1;

            goto out;

        }



        cache_fini(XBZRLE.cache);

        XBZRLE.cache = new_cache;

    }



out_new_size:

    ret = pow2floor(new_size);",0,2,5,0,0,0,0,0,0,0,0,0,0,0,0
23933,qemu,0,"static void setup_rt_frame(int sig, struct target_sigaction *ka,

                           target_siginfo_t *info,

                           target_sigset_t *set, CPUAlphaState *env)

{

    abi_ulong frame_addr, r26;

    struct target_rt_sigframe *frame;

    int i, err = 0;



    frame_addr = get_sigframe(ka, env, sizeof(*frame));

    if (!lock_user_struct(VERIFY_WRITE, frame, frame_addr, 0)) {

        goto give_sigsegv;

    }



    err |= copy_siginfo_to_user(&frame->info, info);



    __put_user(0, &frame->uc.tuc_flags);

    __put_user(0, &frame->uc.tuc_link);

    __put_user(set->sig[0], &frame->uc.tuc_osf_sigmask);

    __put_user(target_sigaltstack_used.ss_sp,

               &frame->uc.tuc_stack.ss_sp);

    __put_user(sas_ss_flags(env->ir[IR_SP]),

               &frame->uc.tuc_stack.ss_flags);

    __put_user(target_sigaltstack_used.ss_size,

               &frame->uc.tuc_stack.ss_size);

    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);

    for (i = 0; i < TAR",1,1,1,0,0,0,0,0,0,0,1,0,1,1,0
23938,qemu,0,"static void imx_gpt_reset(DeviceState *dev)

{

    IMXGPTState *s = IMX_GPT(dev);



    /* stop timer */

    ptimer_stop(s->timer);



    /*

     * Soft reset doesn't touch some bits; hard reset clears them

     */

    s->cr &= ~(GPT_CR_EN|GPT_CR_ENMOD|GPT_CR_STOPEN|GPT_CR_DOZEN|

               GPT_CR_WAITEN|GPT_CR_DBGEN);

    s->sr = 0;

    s->pr = 0;

    s->ir = 0;

    s->cnt = 0;

    s->ocr1 = TIMER_MAX;

    s->ocr2 = TIMER_MAX;

    s->ocr3 = TIMER_MAX;

    s->icr1 = 0;

    s->icr2 = 0;



    s->next_timeout = TIMER_MAX;

    s->next_int = 0;



    /* compute new freq */

    imx_gpt_set_freq(s);



    /* reset the limit to TIMER_MAX */

    ptimer_set_limit(s->timer, TIMER_MAX, 1);



    /* if the timer is still enabled, restart it */

    if (s->freq && (s->cr & GPT_CR_EN)) {

        ptimer_run(s->timer, 1);

    }

}
",0,0,1,0,0,0,0,1,1,1,0,0,0,0,0
23942,qemu,1,"static int dynticks_start_timer(struct qemu_alarm_timer *t)

{

    struct sigevent ev;

    timer_t host_timer;

    struct sigaction act;



    sigfillset(&act.sa_mask);

    act.sa_flags = 0;

    act.sa_handler = host_alarm_handler;



    sigaction(SIGALRM, &act, NULL);








    ev.sigev_value.sival_int = 0;

    ev.sigev_notify = SIGEV_SIGNAL;

    ev.sigev_signo = SIGALRM;



    if (timer_create(CLOCK_REALTIME, &ev, &host_timer)) {

        perror(""timer_create"");



        /* disable dynticks */

        fprintf(stderr, ""Dynamic Ticks disabled\n"");



        return -1;

    }



    t->priv = (void *)(long)host_timer;



    return 0;

}",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
23947,qemu,1,"static void s390_pci_generate_event(uint8_t cc, uint16_t pec, uint32_t fh,

                                    uint32_t fid, uint64_t faddr, uint32_t e)

{

    SeiContainer *sei_cont = g_malloc0(sizeof(SeiContainer));

    S390pciState *s = S390_PCI_HOST_BRIDGE(

        object_resolve_path(TYPE_S390_PCI_HOST_BRIDGE, NULL));



    if (!s) {

        return;

    }



    sei_cont->fh = fh;

    sei_cont->fid = fid;

    sei_cont->cc = cc;

    sei_cont->pec = pec;

    sei_cont->faddr = faddr;

    sei_cont->e = e;



    QTAILQ_INSERT_TAIL(&s->pending_sei, sei_cont, link);

    css_generate_css_crws(0);

}
",0,0,1,0,0,0,0,1,0,0,1,0,0,1,1
23956,qemu,1,"void cpsr_write(CPUARMState *env, uint32_t val, uint32_t mask,

                CPSRWriteType write_type)

{

    uint32_t changed_daif;



    if (mask & CPSR_NZCV) {

        env->ZF = (~val) & CPSR_Z;

        env->NF = val;

        env->CF = (val >> 29) & 1;

        env->VF = (val << 3) & 0x80000000;

    }

    if (mask & CPSR_Q)

        env->QF = ((val & CPSR_Q) != 0);

    if (mask & CPSR_T)

        env->thumb = ((val & CPSR_T) != 0);

    if (mask & CPSR_IT_0_1) {

        env->condexec_bits &= ~3;

        env->condexec_bits |= (val >> 25) & 3;

    }

    if (mask & CPSR_IT_2_7) {

        env->condexec_bits &= 3;

        env->condexec_bits |= (val >> 8) & 0xfc;

    }

    if (mask & CPSR_GE) {

        env->GE = (val >> 16) & 0xf;

    }



    /* In a V7 implementation that includes the security extensions but does

     * not include Virtualization Extensions the SCR.FW and SCR.AW bits control

     * whether non-secure software is allowed to change the CPSR_F and CPSR_A

     * bits respec",0,0,7,0,0,0,1,1,1,0,1,0,1,0,1
23965,qemu,1,"static void vfio_probe_nvidia_bar0_quirk(VFIOPCIDevice *vdev, int nr)

{

    VFIOQuirk *quirk;

    VFIOConfigMirrorQuirk *mirror;



    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||

        !vfio_is_vga(vdev) || nr != 0) {

        return;

    }



    quirk = g_malloc0(sizeof(*quirk));

    mirror = quirk->data = g_malloc0(sizeof(*mirror));

    mirror->mem = quirk->mem = g_malloc0(sizeof(MemoryRegion));

    quirk->nr_mem = 1;

    mirror->vdev = vdev;

    mirror->offset = 0x88000;

    mirror->bar = nr;



    memory_region_init_io(mirror->mem, OBJECT(vdev),

                          &vfio_nvidia_mirror_quirk, mirror,

                          ""vfio-nvidia-bar0-88000-mirror-quirk"",

                          PCIE_CONFIG_SPACE_SIZE);

    memory_region_add_subregion_overlap(&vdev->bars[nr].region.mem,

                                        mirror->offset, mirror->mem, 1);



    QLIST_INSERT_HEAD(&vdev->bars[nr].quirks, quirk, next);



    /* The 0x1800 offset mirror only seems to g",0,0,1,0,0,0,0,0,0,1,0,0,1,1,0
24009,qemu,1,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
",0,0,2,0,0,0,0,1,1,0,0,0,0,0,0
24018,FFmpeg,1,"static int decode_frame(AVCodecContext *avctx, 

                             void *data, int *data_size,

                             uint8_t *buf, int buf_size)

{

    H264Context *h = avctx->priv_data;

    MpegEncContext *s = &h->s;

    AVFrame *pict = data; 

    int buf_index;

    

    s->flags= avctx->flags;

    s->flags2= avctx->flags2;



   /* no supplementary picture */

    if (buf_size == 0) {

        return 0;

    }

    

    if(s->flags&CODEC_FLAG_TRUNCATED){

        int next= find_frame_end(h, buf, buf_size);

        

        if( ff_combine_frame(&s->parse_context, next, &buf, &buf_size) < 0 )

            return buf_size;

//printf(""next:%d buf_size:%d last_index:%d\n"", next, buf_size, s->parse_context.last_index);

    }



    if(h->is_avc && !h->got_avcC) {

        int i, cnt, nalsize;

        unsigned char *p = avctx->extradata;

        if(avctx->extradata_size < 7) {

            av_log(avctx, AV_LOG_ERROR, ""avcC too short\n"");

            return -1;

        }

        i",0,0,5,0,0,0,0,0,0,0,1,0,1,1,1
24044,qemu,0,"static void cpu_common_reset(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);



    if (qemu_loglevel_mask(CPU_LOG_RESET)) {

        qemu_log(""CPU Reset (CPU %d)\n"", cpu->cpu_index);

        log_cpu_state(cpu, cc->reset_dump_flags);

    }



    cpu->interrupt_request = 0;

    cpu->halted = 0;

    cpu->mem_io_pc = 0;

    cpu->mem_io_vaddr = 0;

    cpu->icount_extra = 0;

    cpu->icount_decr.u32 = 0;

    cpu->can_do_io = 1;

    cpu->exception_index = -1;

    cpu->crash_occurred = false;



    if (tcg_enabled()) {

        cpu_tb_jmp_cache_clear(cpu);



#ifdef CONFIG_SOFTMMU

        tlb_flush(cpu, 0);

#endif

    }

}
",0,0,4,0,0,0,0,1,0,1,0,1,1,0,0
24047,qemu,0,"int qemu_opts_foreach(QemuOptsList *list, qemu_opts_loopfunc func, void *opaque,

                      int abort_on_failure)

{

    QemuOpts *opts;

    int rc = 0;



    TAILQ_FOREACH(opts, &list->head, next) {

        rc = func(opts, opaque);

        if (abort_on_failure  &&  rc != 0)

            break;

    }

    return rc;

}
",1,0,1,0,0,0,0,0,0,0,0,0,0,0,1
24050,qemu,0,"static void subpage_write(void *opaque, target_phys_addr_t addr,

                          uint64_t value, unsigned len)

{

    subpage_t *mmio = opaque;

    unsigned int idx = SUBPAGE_IDX(addr);

    MemoryRegionSection *section;

#if defined(DEBUG_SUBPAGE)

    printf(""%s: subpage %p len %d addr "" TARGET_FMT_plx

           "" idx %d value %""PRIx64""\n"",

           __func__, mmio, len, addr, idx, value);

#endif



    section = &phys_sections[mmio->sub_section[idx]];

    addr += mmio->base;

    addr -= section->offset_within_address_space;

    addr += section->offset_within_region;

    io_mem_write(section->mr, addr, value, len);

}
",0,0,2,0,0,0,1,1,1,1,1,1,0,0,0
24072,FFmpeg,0,"static int nvenc_find_free_reg_resource(AVCodecContext *avctx)

{

    NvencContext *ctx = avctx->priv_data;

    NvencDynLoadFunctions *dl_fn = &ctx->nvenc_dload_funcs;

    NV_ENCODE_API_FUNCTION_LIST *p_nvenc = &dl_fn->nvenc_funcs;



    int i;



    if (ctx->nb_registered_frames == FF_ARRAY_ELEMS(ctx->registered_frames)) {

        for (i = 0; i < ctx->nb_registered_frames; i++) {

            if (!ctx->registered_frames[i].mapped) {

                if (ctx->registered_frames[i].regptr) {

                    p_nvenc->nvEncUnregisterResource(ctx->nvencoder,

                                                ctx->registered_frames[i].regptr);

                    ctx->registered_frames[i].regptr = NULL;

                }

                return i;

            }

        }

    } else {

        return ctx->nb_registered_frames++;

    }



    av_log(avctx, AV_LOG_ERROR, ""Too many registered CUDA frames\n"");

    return AVERROR(ENOMEM);

}
",1,0,3,0,0,0,1,1,1,1,1,1,0,1,0
24075,qemu,1,"void tb_flush_jmp_cache(CPUState *cpu, target_ulong addr)

{

    unsigned int i;



    /* Discard jump cache entries for any tb which might potentially

       overlap the flushed page.  */

    i = tb_jmp_cache_hash_page(addr - TARGET_PAGE_SIZE);

    memset(&cpu->tb_jmp_cache[i], 0,

           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));



    i = tb_jmp_cache_hash_page(addr);

    memset(&cpu->tb_jmp_cache[i], 0,

           TB_JMP_PAGE_SIZE * sizeof(TranslationBlock *));

}
",1,0,0,1,0,0,0,0,0,0,0,0,1,1,0
24084,qemu,0,"DeviceState *bdrv_get_attached(BlockDriverState *bs)

{

    return bs->peer;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
24085,qemu,0,"static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)

{

    StackEntry *e = g_malloc0(sizeof(*e));



    e->value = value;



    /* see if we're just pushing a list head tracker */

    if (value == NULL) {

        e->is_list_head = true;

    }

    QTAILQ_INSERT_HEAD(&qov->stack, e, node);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,1
24087,qemu,0,"void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)

{

    void *p;



    size *= items;

    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);



    p = qemu_mallocz(size);



    return (p);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
24090,qemu,0,"static int send_png_rect(VncState *vs, int x, int y, int w, int h,

                         VncPalette *palette)

{

    png_byte color_type;

    png_structp png_ptr;

    png_infop info_ptr;

    png_colorp png_palette = NULL;

    pixman_image_t *linebuf;

    int level = tight_png_conf[vs->tight.compression].png_zlib_level;

    int filters = tight_png_conf[vs->tight.compression].png_filters;

    uint8_t *buf;

    int dy;



    png_ptr = png_create_write_struct_2(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL,

                                        NULL, vnc_png_malloc, vnc_png_free);



    if (png_ptr == NULL)

        return -1;



    info_ptr = png_create_info_struct(png_ptr);



    if (info_ptr == NULL) {

        png_destroy_write_struct(&png_ptr, NULL);

        return -1;

    }



    png_set_write_fn(png_ptr, (void *) vs, png_write_data, png_flush_data);

    png_set_compression_level(png_ptr, level);

    png_set_filter(png_ptr, PNG_FILTER_TYPE_DEFAULT, filters);



    if (palette) {

       ",0,0,3,0,0,0,1,1,1,0,1,0,1,0,0
24100,qemu,0,"void nvdimm_init_acpi_state(AcpiNVDIMMState *state, MemoryRegion *io,

                            FWCfgState *fw_cfg, Object *owner)

{

    memory_region_init_io(&state->io_mr, owner, &nvdimm_dsm_ops, state,

                          ""nvdimm-acpi-io"", NVDIMM_ACPI_IO_LEN);

    memory_region_add_subregion(io, NVDIMM_ACPI_IO_BASE, &state->io_mr);



    state->dsm_mem = g_array_new(false, true /* clear */, 1);

    acpi_data_push(state->dsm_mem, TARGET_PAGE_SIZE);

    fw_cfg_add_file(fw_cfg, NVDIMM_DSM_MEM_FILE, state->dsm_mem->data,

                    state->dsm_mem->len);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
24103,qemu,0,"static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,

                               BdrvCheckMode fix, bool *rebuild,

                               void **refcount_table, int64_t *nb_clusters)

{

    BDRVQcow2State *s = bs->opaque;

    int64_t i;

    QCowSnapshot *sn;

    int ret;



    if (!*refcount_table) {

        int64_t old_size = 0;

        ret = realloc_refcount_array(s, refcount_table,

                                     &old_size, *nb_clusters);

        if (ret < 0) {

            res->check_errors++;

            return ret;

        }

    }



    /* header */

    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,

                        0, s->cluster_size);

    if (ret < 0) {

        return ret;

    }



    /* current L1 table */

    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,

                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);

    if (ret < 0) {

        return ret;

    }



    /* snapshots */

  ",0,0,4,0,0,0,1,1,1,1,1,0,0,0,0
24123,qemu,1,"static void ehci_trace_qtd(EHCIQueue *q, target_phys_addr_t addr, EHCIqtd *qtd)

{

    trace_usb_ehci_qtd(q, addr, qtd->next, qtd->altnext,

                       get_field(qtd->token, QTD_TOKEN_TBYTES),

                       get_field(qtd->token, QTD_TOKEN_CPAGE),

                       get_field(qtd->token, QTD_TOKEN_CERR),

                       get_field(qtd->token, QTD_TOKEN_PID),

                       (bool)(qtd->token & QTD_TOKEN_IOC),

                       (bool)(qtd->token & QTD_TOKEN_ACTIVE),

                       (bool)(qtd->token & QTD_TOKEN_HALT),

                       (bool)(qtd->token & QTD_TOKEN_BABBLE),

                       (bool)(qtd->token & QTD_TOKEN_XACTERR));

}
",0,0,0,0,0,0,0,1,0,1,0,1,1,1,1
24141,qemu,1,"static void megasas_scsi_uninit(PCIDevice *d)

{

    MegasasState *s = MEGASAS(d);



    if (megasas_use_msix(s)) {

        msix_uninit(d, &s->mmio_io, &s->mmio_io);

    }

    if (megasas_use_msi(s)) {

        msi_uninit(d);

    }

}
",0,0,2,0,0,0,0,0,0,0,0,1,0,0,0
24148,FFmpeg,0,"static int jpeg2000_decode_frame(AVCodecContext *avctx, void *data,

                                 int *got_frame, AVPacket *avpkt)

{

    Jpeg2000DecoderContext *s = avctx->priv_data;

    ThreadFrame frame = { .f = data };

    AVFrame *picture = data;

    int tileno, ret;



    s->avctx     = avctx;

    s->buf       = s->buf_start = avpkt->data;

    s->buf_end   = s->buf_start + avpkt->size;

    s->curtileno = 0; // TODO: only one tile in DCI JP2K. to implement for more tiles



    // reduction factor, i.e number of resolution levels to skip

    s->reduction_factor = s->lowres;



    ff_jpeg2000_init_tier1_luts();



    if (s->buf_end - s->buf < 2)

        return AVERROR(EINVAL);



    // check if the image is in jp2 format

    if ((AV_RB32(s->buf) == 12) &&

        (AV_RB32(s->buf + 4) == JP2_SIG_TYPE) &&

        (AV_RB32(s->buf + 8) == JP2_SIG_VALUE)) {

        if (!jp2_find_codestream(s)) {

            av_log(avctx, AV_LOG_ERROR,

                   ""couldn't find jpeg2k codestream a",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
24162,qemu,0,"static void vfio_platform_eoi(VFIODevice *vbasedev)

{

    VFIOINTp *intp;

    VFIOPlatformDevice *vdev =

        container_of(vbasedev, VFIOPlatformDevice, vbasedev);



    qemu_mutex_lock(&vdev->intp_mutex);

    QLIST_FOREACH(intp, &vdev->intp_list, next) {

        if (intp->state == VFIO_IRQ_ACTIVE) {

            trace_vfio_platform_eoi(intp->pin,

                                event_notifier_get_fd(&intp->interrupt));

            intp->state = VFIO_IRQ_INACTIVE;



            /* deassert the virtual IRQ */

            qemu_set_irq(intp->qemuirq, 0);



            if (intp->flags & VFIO_IRQ_INFO_AUTOMASKED) {

                /* unmasks the physical level-sensitive IRQ */

                vfio_unmask_single_irqindex(vbasedev, intp->pin);

            }



            /* a single IRQ can be active at a time */

            break;

        }

    }

    /* in case there are pending IRQs, handle the first one */

    if (!QSIMPLEQ_EMPTY(&vdev->pending_intp_queue)) {

        intp = QSIMPLEQ_FIRST",4,0,4,0,0,0,1,1,1,1,1,1,0,0,0
24164,qemu,0,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
24179,qemu,0,"static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,1
24200,qemu,0,"static int ohci_service_ed_list(OHCIState *ohci, uint32_t head, int completion)

{

    struct ohci_ed ed;

    uint32_t next_ed;

    uint32_t cur;

    int active;



    active = 0;



    if (head == 0)

        return 0;



    for (cur = head; cur; cur = next_ed) {

        if (ohci_read_ed(ohci, cur, &ed)) {

            trace_usb_ohci_ed_read_error(cur);

            ohci_die(ohci);

            return 0;

        }



        next_ed = ed.next & OHCI_DPTR_MASK;



        if ((ed.head & OHCI_ED_H) || (ed.flags & OHCI_ED_K)) {

            uint32_t addr;

            /* Cancel pending packets for ED that have been paused.  */

            addr = ed.head & OHCI_DPTR_MASK;

            if (ohci->async_td && addr == ohci->async_td) {

                usb_cancel_packet(&ohci->usb_packet);

                ohci->async_td = 0;

                usb_device_ep_stopped(ohci->usb_packet.ep->dev,

                                      ohci->usb_packet.ep);

            }

            continue;

        }



     ",1,0,4,0,0,0,0,0,1,1,1,1,1,1,1
24201,qemu,0,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)

{

    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);

    object_unparent(OBJECT(&pbdev->iommu_mr));

    pbdev->iommu_enabled = false;

}
",0,0,0,0,0,0,1,0,1,1,1,1,1,1,1
24205,FFmpeg,0,"int ffurl_connect(URLContext *uc, AVDictionary **options)

{

    int err =

        uc->prot->url_open2 ? uc->prot->url_open2(uc,

                                                  uc->filename,

                                                  uc->flags,

                                                  options) :

        uc->prot->url_open(uc, uc->filename, uc->flags);

    if (err)

        return err;

    uc->is_connected = 1;

    /* We must be careful here as ffurl_seek() could be slow,

     * for example for http */

    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))

        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)

            uc->is_streamed = 1;

    return 0;

}
",2,0,3,0,0,0,0,0,0,0,0,0,1,1,1
24206,qemu,0,"uint8_t sd_read_data(SDState *sd)

{

    /* TODO: Append CRCs */

    uint8_t ret;

    int io_len;



    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)

        return 0x00;



    if (sd->state != sd_sendingdata_state) {

        fprintf(stderr, ""sd_read_data: not in Sending-Data state\n"");

        return 0x00;

    }



    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))

        return 0x00;



    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;



    switch (sd->current_cmd) {

    case 6:	/* CMD6:   SWITCH_FUNCTION */

        ret = sd->data[sd->data_offset ++];



        if (sd->data_offset >= 64)

            sd->state = sd_transfer_state;

        break;



    case 9:	/* CMD9:   SEND_CSD */

    case 10:	/* CMD10:  SEND_CID */

        ret = sd->data[sd->data_offset ++];



        if (sd->data_offset >= 16)

            sd->state = sd_transfer_state;

        break;



    case 11:	/* CMD11:  READ_DAT_UNTIL_STOP */

        if (sd->data_offset == 0)

            BLK_REA",0,0,6,0,1,0,0,0,0,0,0,0,0,0,1
24212,qemu,0,"static void test_visitor_out_int(TestOutputVisitorData *data,

                                 const void *unused)

{

    int64_t value = -42;

    QObject *obj;



    visit_type_int(data->ov, NULL, &value, &error_abort);



    obj = visitor_get(data);

    g_assert(qobject_type(obj) == QTYPE_QINT);

    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
24213,qemu,0,"void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)

{

    struct in_addr host_addr = { .s_addr = INADDR_ANY };

    int host_port;

    char buf[256] = """";

    const char *p = src_str;

    int is_udp = 0;

    int n;



    if (!slirp_inited) {

        monitor_printf(mon, ""user mode network stack not in use\n"");

        return;

    }



    if (!src_str || !src_str[0])

        goto fail_syntax;



    get_str_sep(buf, sizeof(buf), &p, ':');



    if (!strcmp(buf, ""tcp"") || buf[0] == '\0') {

        is_udp = 0;

    } else if (!strcmp(buf, ""udp"")) {

        is_udp = 1;

    } else {

        goto fail_syntax;

    }



    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {

        goto fail_syntax;

    }

    if (buf[0] != '\0' && !inet_aton(buf, &host_addr)) {

        goto fail_syntax;

    }



    host_port = atoi(p);



    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);



    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,

                   src_str)",2,4,6,0,0,0,0,0,0,0,0,0,0,0,0
24222,qemu,1,"static int qcow2_co_readv(BlockDriverState *bs, int64_t sector_num,

                          int remaining_sectors, QEMUIOVector *qiov)

{

    BDRVQcowState *s = bs->opaque;

    int index_in_cluster, n1;

    int ret;

    int cur_nr_sectors; /* number of sectors in current iteration */

    uint64_t cluster_offset = 0;

    uint64_t bytes_done = 0;

    QEMUIOVector hd_qiov;

    uint8_t *cluster_data = NULL;



    qemu_iovec_init(&hd_qiov, qiov->niov);



    qemu_co_mutex_lock(&s->lock);



    while (remaining_sectors != 0) {



        /* prepare next request */

        cur_nr_sectors = remaining_sectors;

        if (s->crypt_method) {

            cur_nr_sectors = MIN(cur_nr_sectors,

                QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors);

        }



        ret = qcow2_get_cluster_offset(bs, sector_num << 9,

            &cur_nr_sectors, &cluster_offset);

        if (ret < 0) {

            goto fail;

        }



        index_in_cluster = sector_num & (s->cluster_sectors - 1);



 ",0,1,2,0,0,1,0,0,1,1,1,1,0,1,0
24230,FFmpeg,1,"static int read_kuki_chunk(AVFormatContext *s, int64_t size)

{

    AVIOContext *pb = s->pb;

    AVStream *st      = s->streams[0];



    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)

        return -1;



    if (st->codec->codec_id == AV_CODEC_ID_AAC) {

        /* The magic cookie format for AAC is an mp4 esds atom.

           The lavc AAC decoder requires the data from the codec specific

           description as extradata input. */

        int strt, skip;

        MOVAtom atom;



        strt = avio_tell(pb);

        ff_mov_read_esds(s, pb, atom);

        skip = size - (avio_tell(pb) - strt);

        if (skip < 0 || !st->codec->extradata ||

            st->codec->codec_id != AV_CODEC_ID_AAC) {

            av_log(s, AV_LOG_ERROR, ""invalid AAC magic cookie\n"");

            return AVERROR_INVALIDDATA;

        }

        avio_skip(pb, skip);

    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {

#define ALAC_PREAMBLE 12

#define ALAC_HEADER   36

#define ALAC_NEW_KUKI 24
",2,0,5,0,0,0,1,1,1,1,1,1,0,0,0
24231,qemu,1,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)

{

    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));



    if (qemu_file_mode_is_not_valid(mode)) {

        return NULL;

    }



    r->rdma = rdma;



    if (mode[0] == 'w') {

        r->file = qemu_fopen_ops(r, &rdma_write_ops);

    } else {

        r->file = qemu_fopen_ops(r, &rdma_read_ops);

    }



    return r->file;

}
",0,0,2,0,0,0,1,1,1,1,0,1,0,1,1
24244,FFmpeg,1,"static int decode_codestream(J2kDecoderContext *s)

{

    J2kCodingStyle *codsty = s->codsty;

    J2kQuantStyle  *qntsty = s->qntsty;

    uint8_t *properties = s->properties;



    for (;;){

        int marker, len, ret = 0;

        const uint8_t *oldbuf;

        if (s->buf_end - s->buf < 2){

            av_log(s->avctx, AV_LOG_ERROR, ""Missing EOC\n"");

            break;

        }



        marker = bytestream_get_be16(&s->buf);

        if(s->avctx->debug & FF_DEBUG_STARTCODE)

            av_log(s->avctx, AV_LOG_DEBUG, ""marker 0x%.4X at pos 0x%tx\n"", marker, s->buf - s->buf_start - 4);

        oldbuf = s->buf;



        if (marker == J2K_SOD){

            J2kTile *tile = s->tile + s->curtileno;

            if (ret = init_tile(s, s->curtileno))

                return ret;

            if (ret = decode_packets(s, tile))

                return ret;

            continue;

        }

        if (marker == J2K_EOC)

            break;



        if (s->buf_end - s->buf < 2)

            return A",1,0,7,0,0,0,1,1,1,0,0,0,0,0,0
24269,FFmpeg,0,"static av_cold int ass_decode_init(AVCodecContext *avctx)

{

    avctx->subtitle_header = av_malloc(avctx->extradata_size);

    if (!avctx->extradata)

        return AVERROR(ENOMEM);

    memcpy(avctx->subtitle_header, avctx->extradata, avctx->extradata_size);

    avctx->subtitle_header_size = avctx->extradata_size;

    return 0;

}
",0,0,1,0,0,0,0,0,1,0,0,0,1,0,1
24280,qemu,1,"int v9fs_device_realize_common(V9fsState *s, Error **errp)

{

    int i, len;

    struct stat stat;

    FsDriverEntry *fse;

    V9fsPath path;

    int rc = 1;



    /* initialize pdu allocator */

    QLIST_INIT(&s->free_list);

    QLIST_INIT(&s->active_list);

    for (i = 0; i < (MAX_REQ - 1); i++) {

        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);

        s->pdus[i].s = s;

        s->pdus[i].idx = i;

    }



    v9fs_path_init(&path);



    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);



    if (!fse) {

        /* We don't have a fsdev identified by fsdev_id */

        error_setg(errp, ""9pfs device couldn't find fsdev with the ""

                   ""id = %s"",

                   s->fsconf.fsdev_id ? s->fsconf.fsdev_id : ""NULL"");

        goto out;

    }



    if (!s->fsconf.tag) {

        /* we haven't specified a mount_tag */

        error_setg(errp, ""fsdev with id %s needs mount_tag arguments"",

                   s->fsconf.fsdev_id);

        goto out;

    }



    s->ctx",1,2,2,0,0,0,1,1,1,0,1,0,1,1,1
24283,FFmpeg,1,"static int wsd_read_header(AVFormatContext *s)

{

    AVIOContext *pb = s->pb;

    AVStream *st;

    int version;

    uint32_t text_offset, data_offset, channel_assign;

    char playback_time[AV_TIMECODE_STR_SIZE];



    st = avformat_new_stream(s, NULL);

    if (!st)

        return AVERROR(ENOMEM);



    avio_skip(pb, 8);

    version = avio_r8(pb);

    av_log(s, AV_LOG_DEBUG, ""version: %i.%i\n"", version >> 4, version & 0xF);

    avio_skip(pb, 11);



    if (version < 0x10) {

        text_offset = 0x80;

        data_offset = 0x800;

        avio_skip(pb, 8);

    } else {

        text_offset = avio_rb32(pb);

        data_offset = avio_rb32(pb);

    }



    avio_skip(pb, 4);

    av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);

    av_dict_set(&s->metadata, ""playback_time"", playback_time, 0);



    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;

    st->codecpar->codec_id    = s->iformat->raw_codec_id;

    st->codecpar->sample_rate = avio_rb32(pb) / 8;

    avio_skip(pb",2,0,3,0,0,0,0,0,0,0,1,1,0,0,0
24289,FFmpeg,0,"x11grab_read_header(AVFormatContext *s1)

{

    struct x11grab *x11grab = s1->priv_data;

    Display *dpy;

    AVStream *st = NULL;

    enum AVPixelFormat input_pixfmt;

    XImage *image;

    int x_off = 0;

    int y_off = 0;

    int screen;

    int use_shm;

    char *dpyname, *offset;

    int ret = 0;

    Colormap color_map;

    XColor color[256];

    int i;



    dpyname = av_strdup(s1->filename);

    if (!dpyname)

        goto out;



    offset = strchr(dpyname, '+');

    if (offset) {

        sscanf(offset, ""%d,%d"", &x_off, &y_off);

        if (strstr(offset, ""nomouse"")) {

            av_log(s1, AV_LOG_WARNING,

                   ""'nomouse' specification in argument is deprecated: ""

                   ""use 'draw_mouse' option with value 0 instead\n"");

            x11grab->draw_mouse = 0;

        }

        *offset= 0;

    }



    av_log(s1, AV_LOG_INFO, ""device: %s -> display: %s x: %d y: %d width: %d height: %d\n"",

           s1->filename, dpyname, x_off, y_off, x11grab->widt",0,1,4,0,0,0,1,1,1,1,0,0,0,0,0
24291,FFmpeg,0,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))

            filter_common(dst+i*stride, 1, 1);

}
",1,0,2,0,0,0,0,0,0,0,0,1,1,1,1
24292,qemu,1,"void bdrv_drain(BlockDriverState *bs)

{

    bool busy = true;



    bdrv_drain_recurse(bs);





    while (busy) {

        /* Keep iterating */

         bdrv_flush_io_queue(bs);

         busy = bdrv_requests_pending(bs);

         busy |= aio_poll(bdrv_get_aio_context(bs), busy);

",0,0,0,0,0,1,0,0,0,1,0,1,0,0,0
24294,qemu,1,"static void main_loop(void)

{

    bool nonblocking;

    int last_io __attribute__ ((unused)) = 0;

#ifdef CONFIG_PROFILER

    int64_t ti;

#endif

    int r;



    qemu_main_loop_start();



    for (;;) {

#ifdef CONFIG_IOTHREAD

        nonblocking = !kvm_enabled() && last_io > 0;

#else

        nonblocking = cpu_exec_all();

        if (vm_request_pending()) {

            nonblocking = true;

        }

#endif

#ifdef CONFIG_PROFILER

        ti = profile_getclock();

#endif

        last_io = main_loop_wait(nonblocking);

#ifdef CONFIG_PROFILER

        dev_time += profile_getclock() - ti;

#endif



        if (qemu_debug_requested()) {

            vm_stop(VMSTOP_DEBUG);

        }

        if (qemu_shutdown_requested()) {

            qemu_kill_report();

            monitor_protocol_event(QEVENT_SHUTDOWN, NULL);

            if (no_shutdown) {

                vm_stop(VMSTOP_SHUTDOWN);

            } else

                break;

        }

        if (qemu_reset_requested()) {

            pau",1,0,13,0,0,0,0,1,0,1,0,0,0,0,0
24311,qemu,0,"static void bootp_reply(const struct bootp_t *bp)

{

    BOOTPClient *bc = NULL;

    struct mbuf *m;

    struct bootp_t *rbp;

    struct sockaddr_in saddr, daddr;

    struct in_addr dns_addr;

    const struct in_addr *preq_addr;

    int dhcp_msg_type, val;

    uint8_t *q;



    /* extract exact DHCP msg type */

    dhcp_decode(bp, &dhcp_msg_type, &preq_addr);

    dprintf(""bootp packet op=%d msgtype=%d"", bp->bp_op, dhcp_msg_type);

    if (preq_addr)

        dprintf("" req_addr=%08x\n"", ntohl(preq_addr->s_addr));

    else

        dprintf(""\n"");



    if (dhcp_msg_type == 0)

        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */



    if (dhcp_msg_type != DHCPDISCOVER &&

        dhcp_msg_type != DHCPREQUEST)

        return;

    /* XXX: this is a hack to get the client mac address */

    memcpy(client_ethaddr, bp->bp_hwaddr, 6);



    if ((m = m_get()) == NULL)

        return;

    m->m_data += IF_MAXLINKHDR;

    rbp = (struct bootp_t *)m->m_data;

    m->m_data += si",0,0,4,0,0,0,0,0,0,0,0,0,1,1,1
24312,qemu,0,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
",1,0,2,0,0,0,0,0,1,1,0,0,1,0,1
24315,qemu,0,"int cpu_x86_gen_code(uint8_t *gen_code_buf, int max_code_size, 

                     int *gen_code_size_ptr, uint8_t *pc_start, 

                     int flags)

{

    DisasContext dc1, *dc = &dc1;

    uint8_t *gen_code_end, *pc_ptr;

    long ret;

#ifdef DEBUG_DISAS

    struct disassemble_info disasm_info;

#endif

    dc->code32 = (flags >> GEN_FLAG_CODE32_SHIFT) & 1;

    dc->addseg = (flags >> GEN_FLAG_ADDSEG_SHIFT) & 1;

    dc->f_st = (flags >> GEN_FLAG_ST_SHIFT) & 7;

    dc->cc_op = CC_OP_DYNAMIC;

    gen_code_ptr = gen_code_buf;

    gen_code_end = gen_code_buf + max_code_size - 4096;

    gen_start();



    dc->is_jmp = 0;

    pc_ptr = pc_start;

    do {

        ret = disas_insn(dc, pc_ptr);

        if (ret == -1) 

            error(""unknown instruction at PC=0x%x B=%02x %02x"", 

                  pc_ptr, pc_ptr[0], pc_ptr[1]);

        pc_ptr = (void *)ret;

    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);

    /* we must store the eflags state if it is not already done */

  ",0,0,3,0,0,1,1,1,1,1,0,1,1,1,1
24328,qemu,1,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
",0,0,2,0,0,0,0,1,0,0,1,0,1,1,1
24331,qemu,1,"static void qio_channel_socket_finalize(Object *obj)
{
    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);
    if (ioc->fd != -1) {
#ifdef WIN32
        WSAEventSelect(ioc->fd, NULL, 0);
#endif
        closesocket(ioc->fd);
        ioc->fd = -1;",0,0,3,0,0,0,0,0,0,0,1,0,1,1,0
24351,qemu,1,"bool ftrace_init(void)

{

    char mount_point[PATH_MAX];

    char path[PATH_MAX];

    int debugfs_found;

    int trace_fd = -1;



    debugfs_found = find_mount(mount_point, ""debugfs"");

    if (debugfs_found) {

        snprintf(path, PATH_MAX, ""%s/tracing/tracing_on"", mount_point);

        trace_fd = open(path, O_WRONLY);

        if (trace_fd < 0) {

            if (errno == EACCES) {

                trace_marker_fd = open(""/dev/null"", O_WRONLY);

                if (trace_marker_fd != -1) {

                    return true;

                }

            }

            perror(""Could not open ftrace 'tracing_on' file"");

            return false;

        } else {

            if (write(trace_fd, ""1"", 1) < 0) {

                perror(""Could not write to 'tracing_on' file"");

                close(trace_fd);

                return false;

            }

            close(trace_fd);

        }

        snprintf(path, PATH_MAX, ""%s/tracing/trace_marker"", mount_point);

        trace_marker_fd = ope",0,0,5,0,0,0,0,0,1,0,0,0,0,1,1
24356,FFmpeg,0,"yuv2rgba64_1_c_template(SwsContext *c, const int32_t *buf0,

                       const int32_t *ubuf[2], const int32_t *vbuf[2],

                       const int32_t *abuf0, uint16_t *dest, int dstW,

                       int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)

{

    const int32_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];

    int i;

    int A1 = 0xffff<<14, A2= 0xffff<<14;



    if (uvalpha < 2048) {

        for (i = 0; i < ((dstW + 1) >> 1); i++) {

            int Y1 = (buf0[i * 2]    ) >> 2;

            int Y2 = (buf0[i * 2 + 1]) >> 2;

            int U  = (ubuf0[i] + (-128 << 11)) >> 2;

            int V  = (vbuf0[i] + (-128 << 11)) >> 2;

            int R, G, B;



            Y1 -= c->yuv2rgb_y_offset;

            Y2 -= c->yuv2rgb_y_offset;

            Y1 *= c->yuv2rgb_y_coeff;

            Y2 *= c->yuv2rgb_y_coeff;

            Y1 += 1 << 13;

            Y2 += 1 << 13;



            if (hasAlpha) {

                A1 = abuf0[i * 2    ] << 11;

       ",1,0,2,0,0,0,1,1,1,1,1,1,0,0,0
24364,qemu,1,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);

    }

}
",0,0,1,0,0,0,0,1,0,1,1,1,0,0,0
24368,FFmpeg,0,"static void avc_luma_mid_8w_msa(const uint8_t *src, int32_t src_stride,

                                uint8_t *dst, int32_t dst_stride,

                                int32_t height)

{

    uint32_t loop_cnt;

    v16i8 src0, src1, src2, src3, src4;

    v16i8 mask0, mask1, mask2;

    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;

    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;

    v8i16 dst0, dst1, dst2, dst3;

    v16u8 out0, out1;



    LD_SB3(&luma_mask_arr[0], 16, mask0, mask1, mask2);



    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);

    XORI_B5_128_SB(src0, src1, src2, src3, src4);

    src += (5 * src_stride);



    hz_out0 = AVC_HORZ_FILTER_SH(src0, src0, mask0, mask1, mask2);

    hz_out1 = AVC_HORZ_FILTER_SH(src1, src1, mask0, mask1, mask2);

    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);

    hz_out3 = AVC_HORZ_FILTER_SH(src3, src3, mask0, mask1, mask2);

    hz_out4 = AVC_HORZ_FILTER_SH(src4, src4, mask0, mask1, mask2);



    for (loop_cnt = (height ",1,0,0,0,0,0,1,0,0,1,1,1,0,0,0
24371,FFmpeg,0,"static av_cold int pam_encode_close(AVCodecContext *avctx)

{

    av_frame_free(&avctx->coded_frame);

    return 0;

}
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
24375,FFmpeg,0,"static av_cold int oggvorbis_init_encoder(vorbis_info *vi, AVCodecContext *avccontext)

{

    OggVorbisContext *context = avccontext->priv_data;

    double cfreq;



    if (avccontext->flags & CODEC_FLAG_QSCALE) {

        /* variable bitrate */

        if (vorbis_encode_setup_vbr(vi, avccontext->channels,

                                    avccontext->sample_rate,

                                    avccontext->global_quality / (float)FF_QP2LAMBDA / 10.0))

            return -1;

    } else {

        int minrate = avccontext->rc_min_rate > 0 ? avccontext->rc_min_rate : -1;

        int maxrate = avccontext->rc_min_rate > 0 ? avccontext->rc_max_rate : -1;



        /* constant bitrate */

        if (vorbis_encode_setup_managed(vi, avccontext->channels,

                                        avccontext->sample_rate, minrate,

                                        avccontext->bit_rate, maxrate))

            return -1;



        /* variable bitrate by estimate, disable slow rate management */

 ",0,0,3,0,0,0,0,0,0,1,0,0,1,1,0
24400,FFmpeg,1,"static int encode_frame(AVCodecContext *avctx, AVPacket *avpkt,

                        const AVFrame *frame, int *got_packet_ptr)

{

    NellyMoserEncodeContext *s = avctx->priv_data;

    int ret;



    if (s->last_frame)

        return 0;



    memcpy(s->buf, s->buf + NELLY_SAMPLES, NELLY_BUF_LEN * sizeof(*s->buf));

    if (frame) {

        memcpy(s->buf + NELLY_BUF_LEN, frame->data[0],

               frame->nb_samples * sizeof(*s->buf));

        if (frame->nb_samples < NELLY_SAMPLES) {

            memset(s->buf + NELLY_BUF_LEN + avctx->frame_size, 0,

                   (NELLY_SAMPLES - frame->nb_samples) * sizeof(*s->buf));

            if (frame->nb_samples >= NELLY_BUF_LEN)

                s->last_frame = 1;

        }

        if ((ret = ff_af_queue_add(&s->afq, frame) < 0))

            return ret;

    } else {

        memset(s->buf + NELLY_BUF_LEN, 0, NELLY_SAMPLES * sizeof(*s->buf));

        s->last_frame = 1;

    }



    if ((ret = ff_alloc_packet(avpkt, NELLY_BLOCK_LEN))) {

     ",0,0,6,0,0,0,0,0,0,0,0,0,0,0,0
24424,FFmpeg,1,"static void imdct_and_windowing(AACContext *ac, SingleChannelElement *sce, float bias)

{

    IndividualChannelStream *ics = &sce->ics;

    float *in    = sce->coeffs;

    float *out   = sce->ret;

    float *saved = sce->saved;

    const float *swindow      = ics->use_kb_window[0] ? ff_aac_kbd_short_128 : ff_sine_128;

    const float *lwindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_long_1024 : ff_sine_1024;

    const float *swindow_prev = ics->use_kb_window[1] ? ff_aac_kbd_short_128 : ff_sine_128;

    float *buf  = ac->buf_mdct;

    float *temp = ac->temp;

    int i;



    // imdct

    if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {

        if (ics->window_sequence[1] == ONLY_LONG_SEQUENCE || ics->window_sequence[1] == LONG_STOP_SEQUENCE)

            av_log(ac->avctx, AV_LOG_WARNING,

                   ""Transition from an ONLY_LONG or LONG_STOP to an EIGHT_SHORT sequence detected. ""

                   ""If you heard an audible artifact, please submit the sample to the FFmpeg developers",0,0,3,0,0,0,1,1,1,1,1,1,0,1,0
24426,FFmpeg,0,"void ff_dsputil_init_alpha(DSPContext* c, AVCodecContext *avctx)

{

    const int high_bit_depth = avctx->bits_per_raw_sample > 8;



    if (!high_bit_depth) {

    c->put_pixels_tab[0][0] = put_pixels16_axp_asm;

    c->put_pixels_tab[0][1] = put_pixels16_x2_axp;

    c->put_pixels_tab[0][2] = put_pixels16_y2_axp;

    c->put_pixels_tab[0][3] = put_pixels16_xy2_axp;



    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_axp_asm;

    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_axp;

    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_axp;

    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_axp;



    c->avg_pixels_tab[0][0] = avg_pixels16_axp;

    c->avg_pixels_tab[0][1] = avg_pixels16_x2_axp;

    c->avg_pixels_tab[0][2] = avg_pixels16_y2_axp;

    c->avg_pixels_tab[0][3] = avg_pixels16_xy2_axp;



    c->avg_no_rnd_pixels_tab[0][0] = avg_no_rnd_pixels16_axp;

    c->avg_no_rnd_pixels_tab[0][1] = avg_no_rnd_pixels16_x2_axp;

    c->avg_no_rnd_pixels_tab[0][2] = avg_no_rnd_pix",0,0,1,0,0,0,0,1,1,0,0,1,1,0,0
24433,FFmpeg,0,"static char *check_nan_suffix(char *s)

{

    char *start = s;



    if (*s++ != '(')

        return start;



    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : start;

}
",0,0,1,0,0,1,0,0,1,1,1,1,1,1,1
24472,FFmpeg,1,"static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){

    long i;

#if !HAVE_FAST_UNALIGNED

    if((long)src2 & (sizeof(long)-1)){

        for(i=0; i+7<w; i+=8){

            dst[i+0] = src1[i+0]-src2[i+0];

            dst[i+1] = src1[i+1]-src2[i+1];

            dst[i+2] = src1[i+2]-src2[i+2];

            dst[i+3] = src1[i+3]-src2[i+3];

            dst[i+4] = src1[i+4]-src2[i+4];

            dst[i+5] = src1[i+5]-src2[i+5];

            dst[i+6] = src1[i+6]-src2[i+6];

            dst[i+7] = src1[i+7]-src2[i+7];

        }

    }else

#endif

    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){

        long a = *(long*)(src1+i);

        long b = *(long*)(src2+i);

        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);

    }

    for(; i<w; i++)

        dst[i+0] = src1[i+0]-src2[i+0];

}
",3,0,4,0,0,0,1,1,1,1,1,1,0,0,0
24478,FFmpeg,0,"static int decode_frame(AVCodecContext *avctx,

                        void *data,

                        int *got_frame,

                        AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    DPXContext *const s = avctx->priv_data;

    AVFrame *picture  = data;

    AVFrame *const p = &s->picture;

    uint8_t *ptr[AV_NUM_DATA_POINTERS];



    unsigned int offset;

    int magic_num, endian;

    int x, y, i, ret;

    int w, h, bits_per_color, descriptor, elements, packing, total_size;



    unsigned int rgbBuffer = 0;

    int n_datum = 0;



    if (avpkt->size <= 1634) {

        av_log(avctx, AV_LOG_ERROR, ""Packet too small for DPX header\n"");

        return AVERROR_INVALIDDATA;

    }



    magic_num = AV_RB32(buf);

    buf += 4;



    /* Check if the files ""magic number"" is ""SDPX"" which means it uses

     * big-endian or XPDS which is for little-endian files */

    if (magic_num == AV_RL32(""SDPX"")) {

        endian = 0;

    } else ",2,0,3,0,0,0,0,0,0,1,1,0,1,1,1
24483,qemu,1,"static void gen_pool16c_insn(DisasContext *ctx, int *is_branch)

{

    int rd = mmreg((ctx->opcode >> 3) & 0x7);

    int rs = mmreg(ctx->opcode & 0x7);

    int opc;



    switch (((ctx->opcode) >> 4) & 0x3f) {

    case NOT16 + 0:

    case NOT16 + 1:

    case NOT16 + 2:

    case NOT16 + 3:

        gen_logic(ctx, OPC_NOR, rd, rs, 0);

        break;

    case XOR16 + 0:

    case XOR16 + 1:

    case XOR16 + 2:

    case XOR16 + 3:

        gen_logic(ctx, OPC_XOR, rd, rd, rs);

        break;

    case AND16 + 0:

    case AND16 + 1:

    case AND16 + 2:

    case AND16 + 3:

        gen_logic(ctx, OPC_AND, rd, rd, rs);

        break;

    case OR16 + 0:

    case OR16 + 1:

    case OR16 + 2:

    case OR16 + 3:

        gen_logic(ctx, OPC_OR, rd, rd, rs);

        break;

    case LWM16 + 0:

    case LWM16 + 1:

    case LWM16 + 2:

    case LWM16 + 3:

        {

            static const int lwm_convert[] = { 0x11, 0x12, 0x13, 0x14 };

            int offset = ZIMM(ctx->opcode, 0, 4);



         ",0,0,0,0,1,0,0,0,0,0,1,0,0,0,0
24484,FFmpeg,1,"int ff_filter_frame(AVFilterLink *link, AVFrame *frame)

{

    int (*filter_frame)(AVFilterLink *, AVFrame *);

    AVFilterPad *dst = link->dstpad;

    AVFrame *out;



    FF_DPRINTF_START(NULL, filter_frame);

    ff_dlog_link(NULL, link, 1);



    if (!(filter_frame = dst->filter_frame))

        filter_frame = default_filter_frame;



    /* copy the frame if needed */

    if (dst->needs_writable && !av_frame_is_writable(frame)) {

        av_log(link->dst, AV_LOG_DEBUG, ""Copying data in avfilter.\n"");



        switch (link->type) {

        case AVMEDIA_TYPE_VIDEO:

            out = ff_get_video_buffer(link, link->w, link->h);

            break;

        case AVMEDIA_TYPE_AUDIO:

            out = ff_get_audio_buffer(link, frame->nb_samples);

            break;

        default: return AVERROR(EINVAL);

        }

        if (!out) {

            av_frame_free(&frame);

            return AVERROR(ENOMEM);

        }

        av_frame_copy_props(out, frame);



        switch (link->type) {

   ",0,0,3,0,2,0,0,0,0,1,0,0,0,0,0
24485,qemu,1,"static ssize_t vnc_tls_push(gnutls_transport_ptr_t transport,

                            const void *data,

                            size_t len) {

    VncState *vs = (VncState *)transport;

    int ret;



 retry:

    ret = send(vs->csock, data, len, 0);

    if (ret < 0) {

        if (errno == EINTR)

            goto retry;

        return -1;

    }

    return ret;

}
",0,1,2,0,0,0,1,0,0,0,1,0,0,1,1
24486,qemu,1,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
24488,FFmpeg,0,"void ff_h264_filter_mb_fast(const H264Context *h, H264SliceContext *sl,

                            int mb_x, int mb_y, uint8_t *img_y,

                            uint8_t *img_cb, uint8_t *img_cr,

                            unsigned int linesize, unsigned int uvlinesize)

{

    assert(!FRAME_MBAFF(h));

    if(!h->h264dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff) {

        ff_h264_filter_mb(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);

        return;

    }



#if CONFIG_SMALL

    h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, h->pixel_shift);

#else

    if(h->pixel_shift){

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 1);

    }else{

        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);

    }

#endif

}
",0,0,7,0,0,0,0,1,0,0,1,0,0,0,1
24501,qemu,0,"void qmp_eject(const char *device, bool has_force, bool force, Error **errp)

{

    Error *local_err = NULL;

    int rc;



    if (!has_force) {

        force = false;

    }



    rc = do_open_tray(device, force, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    if (rc == EINPROGRESS) {

        error_setg(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", device);

        return;

    }



    qmp_x_blockdev_remove_medium(device, errp);

}
",7,0,4,0,0,0,0,0,0,0,0,0,1,0,0
24508,qemu,0,"int check_prot(int prot, int rw, int access_type)

{

    int ret;



    if (access_type == ACCESS_CODE) {

        if (prot & PAGE_EXEC) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else if (rw) {

        if (prot & PAGE_WRITE) {

            ret = 0;

        } else {

            ret = -2;

        }

    } else {

        if (prot & PAGE_READ) {

            ret = 0;

        } else {

            ret = -2;

        }

    }



    return ret;

}
",0,0,5,0,0,0,0,0,0,0,1,0,0,0,0
24540,qemu,1,"static int vmdk_write_extent(VmdkExtent *extent, int64_t cluster_offset,

                            int64_t offset_in_cluster, QEMUIOVector *qiov,

                            uint64_t qiov_offset, uint64_t n_bytes,

                            uint64_t offset)

{

    int ret;

    VmdkGrainMarker *data = NULL;

    uLongf buf_len;

    QEMUIOVector local_qiov;

    struct iovec iov;

    int64_t write_offset;

    int64_t write_end_sector;



    if (extent->compressed) {

        void *compressed_data;



        if (!extent->has_marker) {

            ret = -EINVAL;

            goto out;

        }

        buf_len = (extent->cluster_sectors << 9) * 2;

        data = g_malloc(buf_len + sizeof(VmdkGrainMarker));



        compressed_data = g_malloc(n_bytes);

        qemu_iovec_to_buf(qiov, qiov_offset, compressed_data, n_bytes);

        ret = compress(data->data, &buf_len, compressed_data, n_bytes);

        g_free(compressed_data);



        if (ret != Z_OK || buf_len == 0) {

            ret = -E",0,1,3,0,0,0,1,1,1,1,1,1,0,0,0
24542,FFmpeg,1,"static int http_server(void)

{

    int server_fd, ret, rtsp_server_fd, delay, delay1;

    struct pollfd poll_table[HTTP_MAX_CONNECTIONS + 2], *poll_entry;

    HTTPContext *c, *c_next;



    server_fd = socket_open_listen(&my_http_addr);

    if (server_fd < 0)

        return -1;



    rtsp_server_fd = socket_open_listen(&my_rtsp_addr);

    if (rtsp_server_fd < 0)

        return -1;

    

    http_log(""ffserver started.\n"");



    start_children(first_feed);



    first_http_ctx = NULL;

    nb_connections = 0;

    first_http_ctx = NULL;



    start_multicast();



    for(;;) {

        poll_entry = poll_table;

        poll_entry->fd = server_fd;

        poll_entry->events = POLLIN;

        poll_entry++;



        poll_entry->fd = rtsp_server_fd;

        poll_entry->events = POLLIN;

        poll_entry++;



        /* wait for events on each HTTP handle */

        c = first_http_ctx;

        delay = 1000;

        while (c != NULL) {

            int fd;

            fd = c->fd;

       ",1,0,2,0,0,1,1,0,1,0,1,0,0,1,0
24555,FFmpeg,0,"static int dnxhd_decode_header(DNXHDContext *ctx, AVFrame *frame,

                               const uint8_t *buf, int buf_size,

                               int first_field)

{

    static const uint8_t header_prefix[]    = { 0x00, 0x00, 0x02, 0x80, 0x01 };

    static const uint8_t header_prefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 };

    int i, cid, ret;



    if (buf_size < 0x280)

        return AVERROR_INVALIDDATA;



    if (memcmp(buf, header_prefix, 5) && memcmp(buf, header_prefix444, 5)) {

        av_log(ctx->avctx, AV_LOG_ERROR, ""error in header\n"");

        return AVERROR_INVALIDDATA;

    }

    if (buf[5] & 2) { /* interlaced */

        ctx->cur_field = buf[5] & 1;

        frame->interlaced_frame = 1;

        frame->top_field_first  = first_field ^ ctx->cur_field;

        av_log(ctx->avctx, AV_LOG_DEBUG,

               ""interlaced %d, cur field %d\n"", buf[5] & 3, ctx->cur_field);

    }



    ctx->height = AV_RB16(buf + 0x18);

    ctx->width  = AV_RB16(buf + 0x1a);



    av_dl",0,0,3,0,0,0,0,0,0,0,0,0,1,0,1
24559,qemu,1,"static int get_monitor_def(target_long *pval, const char *name)

{

    const MonitorDef *md;

    void *ptr;



    for(md = monitor_defs; md->name != NULL; md++) {

        if (compare_cmd(name, md->name)) {

            if (md->get_value) {

                *pval = md->get_value(md, md->offset);

            } else {

                CPUState *env = mon_get_cpu();

                if (!env)

                    return -2;

                ptr = (uint8_t *)env + md->offset;

                switch(md->type) {

                case MD_I32:

                    *pval = *(int32_t *)ptr;

                    break;

                case MD_TLONG:

                    *pval = *(target_long *)ptr;

                    break;

                default:

                    *pval = 0;

                    break;

                }

            }

            return 0;

        }

    }

    return -1;

}
",1,0,3,0,1,0,0,1,1,1,0,1,1,0,0
24578,qemu,1,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",0,0,5,0,0,0,0,0,1,0,1,1,0,0,0
24588,qemu,0,"FWCfgState *pc_memory_init(MemoryRegion *system_memory,

                           const char *kernel_filename,

                           const char *kernel_cmdline,

                           const char *initrd_filename,

                           ram_addr_t below_4g_mem_size,

                           ram_addr_t above_4g_mem_size,

                           MemoryRegion *rom_memory,

                           MemoryRegion **ram_memory,

                           PcGuestInfo *guest_info)

{

    int linux_boot, i;

    MemoryRegion *ram, *option_rom_mr;

    MemoryRegion *ram_below_4g, *ram_above_4g;

    FWCfgState *fw_cfg;



    linux_boot = (kernel_filename != NULL);



    /* Allocate RAM.  We allocate it as a single memory region and use

     * aliases to address portions of it, mostly for backwards compatibility

     * with older qemus that used qemu_ram_alloc().

     */

    ram = g_malloc(sizeof(*ram));

    memory_region_init_ram(ram, NULL, ""pc.ram"",

                           below_4",1,0,0,0,0,0,0,0,0,1,0,1,0,0,0
24603,qemu,0,"static void press_key(VncState *vs, int keysym)

{

    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);

    qemu_input_event_send_key_delay(0);

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);

    qemu_input_event_send_key_delay(0);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
24606,qemu,0,"static void s390_virtio_device_sync(VirtIOS390Device *dev)

{

    VirtIOS390Bus *bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);

    ram_addr_t cur_offs;

    uint8_t num_vq;

    int i;



    virtio_reset(dev->vdev);



    /* Sync dev space */

    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_TYPE, dev->vdev->device_id);



    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, s390_virtio_device_num_vq(dev));

    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_FEATURE_LEN, dev->feat_len);



    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);



    num_vq = s390_virtio_device_num_vq(dev);

    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);



    /* Sync virtqueues */

    for (i = 0; i < num_vq; i++) {

        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +

                        (i * VIRTIO_VQCONFIG_LEN);

        ram_addr_t vring;



        vring = s390_virtio_next_ring(bus);

        virtio_queue_set_addr(dev->vdev, i, vring);

        virtio_qu",1,0,0,0,0,0,0,0,1,1,1,1,0,0,0
24621,FFmpeg,1,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
",3,0,0,0,0,0,1,1,0,1,1,1,1,0,0
24625,FFmpeg,1,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
24626,qemu,1,"void aio_set_event_notifier(AioContext *ctx,

                            EventNotifier *e,

                            EventNotifierHandler *io_notify,

                            AioFlushEventNotifierHandler *io_flush)

{

    AioHandler *node;



    QLIST_FOREACH(node, &ctx->aio_handlers, node) {

        if (node->e == e && !node->deleted) {

            break;

        }

    }



    /* Are we deleting the fd handler? */

    if (!io_notify) {

        if (node) {

            g_source_remove_poll(&ctx->source, &node->pfd);



            /* If the lock is held, just mark the node as deleted */

            if (ctx->walking_handlers) {

                node->deleted = 1;

                node->pfd.revents = 0;

            } else {

                /* Otherwise, delete it for real.  We can't just mark it as

                 * deleted because deleted nodes are only cleaned up after

                 * releasing the walking_handlers lock.

                 */

                QLIST_REMOVE(node, node);",1,0,10,0,0,0,0,0,1,1,1,1,0,0,0
24629,FFmpeg,0,"int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = a;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
24631,FFmpeg,1,"static av_cold int roq_dpcm_encode_init(AVCodecContext *avctx)

{

    ROQDPCMContext *context = avctx->priv_data;



    if (avctx->channels > 2) {

        av_log(avctx, AV_LOG_ERROR, ""Audio must be mono or stereo\n"");

        return -1;

    }

    if (avctx->sample_rate != 22050) {

        av_log(avctx, AV_LOG_ERROR, ""Audio must be 22050 Hz\n"");

        return -1;

    }

    if (avctx->sample_fmt != AV_SAMPLE_FMT_S16) {

        av_log(avctx, AV_LOG_ERROR, ""Audio must be signed 16-bit\n"");

        return -1;

    }



    avctx->frame_size = ROQ_FIRST_FRAME_SIZE;



    context->lastSample[0] = context->lastSample[1] = 0;



    avctx->coded_frame= avcodec_alloc_frame();





    return 0;

}",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
24648,qemu,1,"static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,

                                  sPAPRMachineState *spapr)

{

    PowerPCCPU *cpu = POWERPC_CPU(cs);

    CPUPPCState *env = &cpu->env;

    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);

    int index = ppc_get_vcpu_dt_id(cpu);

    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),

                       0xffffffff, 0xffffffff};

    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()

        : SPAPR_TIMEBASE_FREQ;

    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;

    uint32_t page_sizes_prop[64];

    size_t page_sizes_prop_size;

    uint32_t vcpus_per_socket = smp_threads * smp_cores;

    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};

    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));

    sPAPRDRConnector *drc;

    sPAPRDRConnectorClass *drck;

    int drc_index;

    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];

    int i;



    drc = spapr_dr_conn",0,0,1,0,0,0,0,0,0,0,0,0,0,1,1
24655,FFmpeg,1,"static void test_function(const TestStruct test_sample)

{

    int ret, i;

    void **output_data  = NULL;

    AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,

                                            test_sample.nb_samples_pch);

    if (!afifo) {

        ERROR(""ERROR: av_audio_fifo_alloc returned NULL!"");

    }

    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_write failed!"");

    }

    printf(""written: %d\n"", ret);



    ret = write_samples_to_audio_fifo(afifo, test_sample, test_sample.nb_samples_pch, 0);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_write failed!"");

    }

    printf(""written: %d\n"", ret);

    printf(""remaining samples in audio_fifo: %d\n\n"", av_audio_fifo_size(afifo));



    ret = read_samples_from_audio_fifo(afifo, &output_data, test_sample.nb_samples_pch);

    if (ret < 0){

        ERROR(""ERROR: av_audio_fifo_read failed!"");

    }
",1,0,21,0,0,0,0,1,0,1,1,1,0,0,0
24668,FFmpeg,1,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)

{

    ff_wmv2_idct_c(block);

    put_pixels_clamped_c(block, dest, line_size);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,1
24677,FFmpeg,0,"static void decode_interframe_v4(AVCodecContext *avctx, uint8_t *src, uint32_t size)

{

    Hnm4VideoContext *hnm = avctx->priv_data;

    GetByteContext gb;

    uint32_t writeoffset = 0, count, left, offset;

    uint8_t tag, previous, backline, backward, swap;



    bytestream2_init(&gb, src, size);



    while (bytestream2_tell(&gb) < size) {

        count = bytestream2_peek_byte(&gb) & 0x1F;

        if (count == 0) {

            tag = bytestream2_get_byte(&gb) & 0xE0;

            tag = tag >> 5;

            if (tag == 0) {

                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);

                hnm->current[writeoffset++] = bytestream2_get_byte(&gb);

            } else if (tag == 1) {

                writeoffset += bytestream2_get_byte(&gb) * 2;

            } else if (tag == 2) {

                count = bytestream2_get_le16(&gb);

                count *= 2;

                writeoffset += count;

            } else if (tag == 3) {

                count = bytestream2_get_by",0,0,5,0,0,1,0,0,0,0,0,0,0,0,0
24720,qemu,0,"static void setup_frame(int sig, struct emulated_sigaction *ka,

			target_sigset_t *set, CPUX86State *env)

{

	struct sigframe *frame;

	int err = 0;



	frame = get_sigframe(ka, env, sizeof(*frame));



#if 0

	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))

		goto give_sigsegv;

#endif

	err |= __put_user((/*current->exec_domain

		           && current->exec_domain->signal_invmap

		           && sig < 32

		           ? current->exec_domain->signal_invmap[sig]

		           : */ sig),

		          &frame->sig);

	if (err)

		goto give_sigsegv;



	setup_sigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]);

	if (err)

		goto give_sigsegv;



	if (TARGET_NSIG_WORDS > 1) {

		err |= __copy_to_user(frame->extramask, &set->sig[1],

				      sizeof(frame->extramask));

	}

	if (err)

		goto give_sigsegv;



	/* Set up to return from userspace.  If provided, use a stub

	   already in userspace.  */

	if (ka->sa.sa_flags & TARGET_SA_RESTORER) {

		err |= __put_user(ka->sa.sa_restorer, &frame->pret",0,4,8,0,0,0,0,1,1,1,0,0,1,1,1
24730,qemu,1,"static void write_target_close(BlockDriverState *bs) {

    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);

    bdrv_delete(s->qcow);

    free(s->qcow_filename);

}
",0,0,0,0,0,0,0,0,1,1,0,0,0,0,0
24732,FFmpeg,1,"static int aiff_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
{
    AVStream *st = s->streams[0];
    AIFFInputContext *aiff = s->priv_data;
    int64_t max_size;
    int res, size;
    /* calculate size of remaining data */
    max_size = aiff->data_end - avio_tell(s->pb);
    if (max_size <= 0)
        return AVERROR_EOF;
    /* Now for that packet */
    switch (st->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        size = st->codecpar->block_align;
        break;
    default:
        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
    size = FFMIN(max_size, size);
    res = av_get_packet(s->pb, pkt, size);
    if (res < 0)
        return res;
    if (size >= st->codecpar->block_align)
        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    /* Only one stream in an AIFF file */
    pkt->stream_index = 0;
    pkt->duration     =",0,0,6,0,1,0,1,1,1,1,1,0,1,1,1
24742,qemu,0,"uint64_t helper_fnmsub (uint64_t arg1, uint64_t arg2, uint64_t arg3)

{

    CPU_DoubleU farg1, farg2, farg3;



    farg1.ll = arg1;

    farg2.ll = arg2;

    farg3.ll = arg3;



    if (unlikely(float64_is_signaling_nan(farg1.d) ||

                 float64_is_signaling_nan(farg2.d) ||

                 float64_is_signaling_nan(farg3.d))) {

        /* sNaN operation */

        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);

    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||

                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {

        /* Multiplication of zero by infinity */

        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);

    } else {

#if USE_PRECISE_EMULATION

#ifdef FLOAT128

        /* This is the way the PowerPC specification defines it */

        float128 ft0_128, ft1_128;



        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);

        ft1_128 = float64_to_float128(farg2.d, &env->fp_sta",0,0,4,0,0,0,0,0,0,0,0,0,0,0,0
24744,qemu,0,"static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
24748,qemu,0,"static void omap_l4_io_writeb(void *opaque, target_phys_addr_t addr,

                uint32_t value)

{

    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;



    return omap_l4_io_writeb_fn[i](omap_l4_io_opaque[i], addr, value);

}
",0,0,0,0,0,0,0,0,0,0,1,1,0,0,0
24754,qemu,0,"static void v9fs_create_post_lstat(V9fsState *s, V9fsCreateState *vs, int err)

{



    if (err == 0 || errno != ENOENT) {

        err = -errno;

        goto out;

    }



    if (vs->perm & P9_STAT_MODE_DIR) {

        err = v9fs_do_mkdir(s, vs);

        v9fs_create_post_mkdir(s, vs, err);

    } else if (vs->perm & P9_STAT_MODE_SYMLINK) {

        err = v9fs_do_symlink(s, vs);

        v9fs_create_post_perms(s, vs, err);

    } else if (vs->perm & P9_STAT_MODE_LINK) {

        int32_t nfid = atoi(vs->extension.data);

        V9fsFidState *nfidp = lookup_fid(s, nfid);

        if (nfidp == NULL) {

            err = -errno;

            v9fs_post_create(s, vs, err);

        }

        err = v9fs_do_link(s, &nfidp->path, &vs->fullname);

        v9fs_create_post_perms(s, vs, err);

    } else if (vs->perm & P9_STAT_MODE_DEVICE) {

        char ctype;

        uint32_t major, minor;

        mode_t nmode = 0;



        if (sscanf(vs->extension.data, ""%c %u %u"", &ctype, &major,

                        ",0,1,7,0,0,0,0,0,0,0,1,0,0,0,0
24756,qemu,0,"void pal_init (CPUState *env)

{

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
24759,qemu,0,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rets)

{

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, token, nargs, args, nret, rets);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (token == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);

    rtas_st(rets, 0, -3);

    return H_PARAMETER;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,0,0
24761,FFmpeg,0,"static void apply_tns_filter(float *out, float *in, int order, int direction,

                             float *tns_coefs, int ltp_used, int w, int filt,

                             int start_i, int len)

{

    int i, j, inc, start = start_i;

    float tmp[TNS_MAX_ORDER+1];

    if (direction) {

        inc = -1;

        start = (start + len) - 1;

    } else {

        inc = 1;

    }

    if (!ltp_used) {    /* AR filter */

        for (i = 0; i < len; i++, start += inc)

            out[i] = in[start];

            for (j = 1; j <= FFMIN(i, order); j++)

                out[i] += tns_coefs[j]*in[start - j*inc];

    } else {            /* MA filter */

        for (i = 0; i < len; i++, start += inc) {

            tmp[0] = out[i] = in[start];

            for (j = 1; j <= FFMIN(i, order); j++)

                out[i] += tmp[j]*tns_coefs[j];

            for (j = order; j > 0; j--)

                tmp[j] = tmp[j - 1];

        }

    }

}
",5,0,2,0,0,0,0,0,0,0,0,0,0,1,1
24768,FFmpeg,0,"static int mkv_write_ass_blocks(AVFormatContext *s, AVIOContext *pb,

                                AVPacket *pkt)

{

    MatroskaMuxContext *mkv = s->priv_data;

    int i, layer = 0, max_duration = 0, size, line_size, data_size = pkt->size;

    uint8_t *start, *end, *data = pkt->data;

    ebml_master blockgroup;

    char buffer[2048];



    while (data_size) {

        int duration = ass_get_duration(data);

        max_duration = FFMAX(duration, max_duration);

        end          = memchr(data, '\n', data_size);

        size         = line_size = end ? end - data + 1 : data_size;

        size        -= end ? (end[-1] == '\r') + 1 : 0;

        start        = data;

        for (i = 0; i < 3; i++, start++)

            if (!(start = memchr(start, ',', size - (start - data))))

                return max_duration;

        size -= start - data;

        sscanf(data, ""Dialogue: %d,"", &layer);

        i = snprintf(buffer, sizeof(buffer), ""%"" PRId64 "",%d,"",

                     s->streams[pkt->stre",1,0,1,0,0,1,1,1,1,0,1,1,0,0,0
24771,qemu,1,"static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg_struct;



    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;
",0,0,2,0,0,0,0,0,0,0,0,1,0,0,0
24787,FFmpeg,0,"static void draw_bar_yuv(AVFrame *out, const float *h, const float *rcp_h,

                         const ColorFloat *c, int bar_h)

{

    int x, y, yh, w = out->width;

    float mul, ht, rcp_bar_h = 1.0f / bar_h;

    uint8_t *vy = out->data[0], *vu = out->data[1], *vv = out->data[2];

    uint8_t *lpy, *lpu, *lpv;

    int lsy = out->linesize[0], lsu = out->linesize[1], lsv = out->linesize[2];

    int fmt = out->format;



    for (y = 0; y < bar_h; y += 2) {

        yh = (fmt == AV_PIX_FMT_YUV420P) ? y / 2 : y;

        ht = (bar_h - y) * rcp_bar_h;

        lpy = vy + y * lsy;

        lpu = vu + yh * lsu;

        lpv = vv + yh * lsv;

        for (x = 0; x < w; x += 2) {

            if (h[x] <= ht) {

                *lpy++ = 16;

                *lpu++ = 128;

                *lpv++ = 128;

            } else {

                mul = (h[x] - ht) * rcp_h[x];

                *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f;

                *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f ",3,0,1,0,0,0,0,0,0,0,0,0,1,1,0
24794,qemu,1,"static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)

{

    const char *file_out = qemu_opt_get(opts, ""path"");

    HANDLE fd_out;



    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,

                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fd_out == INVALID_HANDLE_VALUE) {

        return -EIO;

    }



    return qemu_chr_open_win_file(fd_out, _chr);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
24818,FFmpeg,1,"int ff_h264_fill_default_ref_list(H264Context *h, H264SliceContext *sl)

{

    int i, len;



    if (sl->slice_type_nos == AV_PICTURE_TYPE_B) {

        H264Picture *sorted[32];

        int cur_poc, list;

        int lens[2];



        if (FIELD_PICTURE(h))

            cur_poc = h->cur_pic_ptr->field_poc[h->picture_structure == PICT_BOTTOM_FIELD];

        else

            cur_poc = h->cur_pic_ptr->poc;



        for (list = 0; list < 2; list++) {

            len  = add_sorted(sorted,       h->short_ref, h->short_ref_count, cur_poc, 1 ^ list);

            len += add_sorted(sorted + len, h->short_ref, h->short_ref_count, cur_poc, 0 ^ list);

            av_assert0(len <= 32);



            len  = build_def_list(h->default_ref_list[list], FF_ARRAY_ELEMS(h->default_ref_list[0]),

                                  sorted, len, 0, h->picture_structure);

            len += build_def_list(h->default_ref_list[list] + len,

                                  FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,

  ",1,0,2,0,0,0,0,0,0,1,0,0,0,0,0
24824,qemu,1,"static void vtd_init(IntelIOMMUState *s)

{

    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);



    memset(s->csr, 0, DMAR_REG_SIZE);

    memset(s->wmask, 0, DMAR_REG_SIZE);

    memset(s->w1cmask, 0, DMAR_REG_SIZE);

    memset(s->womask, 0, DMAR_REG_SIZE);



    s->iommu_ops.translate = vtd_iommu_translate;

    s->iommu_ops.notify_started = vtd_iommu_notify_started;

    s->root = 0;

    s->root_extended = false;

    s->dmar_enabled = false;

    s->iq_head = 0;

    s->iq_tail = 0;

    s->iq = 0;

    s->iq_size = 0;

    s->qi_enabled = false;

    s->iq_last_desc_type = VTD_INV_DESC_NONE;

    s->next_frcd_reg = 0;

    s->cap = VTD_CAP_FRO | VTD_CAP_NFR | VTD_CAP_ND | VTD_CAP_MGAW |

             VTD_CAP_SAGAW | VTD_CAP_MAMV | VTD_CAP_PSI | VTD_CAP_SLLPS;

    s->ecap = VTD_ECAP_QI | VTD_ECAP_IRO;



    if (x86_iommu->intr_supported) {

        s->ecap |= VTD_ECAP_IR | VTD_ECAP_EIM;

    }



    vtd_reset_context_cache(s);

    vtd_reset_iotlb(s);



    /* Define registers with default valu",0,0,3,0,0,0,0,1,0,1,0,1,1,1,1
24829,FFmpeg,0,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }

    }

    return end+2;

}
",1,0,3,0,0,0,1,1,1,1,1,1,1,0,0
24847,qemu,0,"void helper_ctc1(CPUMIPSState *env, target_ulong arg1, uint32_t reg)

{

    switch(reg) {

    case 25:

        if (arg1 & 0xffffff00)

            return;

        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) |

                     ((arg1 & 0x1) << 23);

        break;

    case 26:

        if (arg1 & 0x007c0000)

            return;

        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c);

        break;

    case 28:

        if (arg1 & 0x007c0000)

            return;

        env->active_fpu.fcr31 = (env->active_fpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) |

                     ((arg1 & 0x4) << 22);

        break;

    case 31:

        if (arg1 & 0x007c0000)

            return;

        env->active_fpu.fcr31 = arg1;

        break;

    default:

        return;

    }

    /* set rounding mode */

    restore_rounding_mode(env);

    /* set flush-to-zero mode */

    restore_flush_mode(env);

    set_float_exception_fl",0,0,4,0,1,0,1,1,1,1,1,0,0,0,0
24853,qemu,0,"static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    }

}
",0,0,1,0,0,0,0,1,0,1,1,0,0,0,0
24855,qemu,0,"static int get_stream_blocksize(BlockDriverState *bdrv)

{

    uint8_t cmd[6];

    uint8_t buf[12];

    uint8_t sensebuf[8];

    sg_io_hdr_t io_header;

    int ret;



    memset(cmd, 0, sizeof(cmd));

    memset(buf, 0, sizeof(buf));

    cmd[0] = MODE_SENSE;

    cmd[4] = sizeof(buf);



    memset(&io_header, 0, sizeof(io_header));

    io_header.interface_id = 'S';

    io_header.dxfer_direction = SG_DXFER_FROM_DEV;

    io_header.dxfer_len = sizeof(buf);

    io_header.dxferp = buf;

    io_header.cmdp = cmd;

    io_header.cmd_len = sizeof(cmd);

    io_header.mx_sb_len = sizeof(sensebuf);

    io_header.sbp = sensebuf;

    io_header.timeout = 6000; /* XXX */



    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);

    if (ret < 0 || io_header.driver_status || io_header.host_status) {

        return -1;

    }

    return (buf[9] << 16) | (buf[10] << 8) | buf[11];

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
24880,qemu,0,"int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,

                                  int64_t size)

{

    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,0
24881,FFmpeg,0,"int ff_MPV_frame_start(MpegEncContext *s, AVCodecContext *avctx)

{

    int i, ret;

    Picture *pic;

    s->mb_skipped = 0;



    if (!ff_thread_can_start_frame(avctx)) {

        av_log(avctx, AV_LOG_ERROR, ""Attempt to start a frame outside SETUP state\n"");

        return -1;

    }



    /* mark & release old frames */

    if (s->pict_type != AV_PICTURE_TYPE_B && s->last_picture_ptr &&

        s->last_picture_ptr != s->next_picture_ptr &&

        s->last_picture_ptr->f.buf[0]) {

        ff_mpeg_unref_picture(s, s->last_picture_ptr);

    }



    /* release forgotten pictures */

    /* if (mpeg124/h263) */

    for (i = 0; i < MAX_PICTURE_COUNT; i++) {

        if (&s->picture[i] != s->last_picture_ptr &&

            &s->picture[i] != s->next_picture_ptr &&

            s->picture[i].reference && !s->picture[i].needs_realloc) {

            if (!(avctx->active_thread_type & FF_THREAD_FRAME))

                av_log(avctx, AV_LOG_ERROR,

                       ""releasing zombie picture\n"");

   ",1,0,4,0,0,0,1,0,0,0,1,1,0,0,0
24895,qemu,1,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
",0,0,0,0,0,0,1,1,1,0,0,0,0,0,0
24896,FFmpeg,1,"static int decode_frame_ilbm(AVCodecContext *avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    IffContext *s = avctx->priv_data;

    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;

    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;

    const uint8_t *buf_end = buf+buf_size;

    int y, plane, res;



    if ((res = extract_header(avctx, avpkt)) < 0)

        return res;



    if (s->init) {

        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed\n"");

            return res;

        }

    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return res;

    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {

        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < ",0,0,6,0,0,0,0,1,0,1,1,1,1,1,1
24897,qemu,1,"udp_listen(Slirp *slirp, u_int32_t haddr, u_int hport, u_int32_t laddr,

           u_int lport, int flags)

{

	struct sockaddr_in addr;

	struct socket *so;

	socklen_t addrlen = sizeof(struct sockaddr_in), opt = 1;



	so = socreate(slirp);

	if (!so) {

	    return NULL;

	}

	so->s = socket(AF_INET,SOCK_DGRAM,0);

	so->so_expire = curtime + SO_EXPIRE;

	insque(so, &slirp->udb);



	addr.sin_family = AF_INET;

	addr.sin_addr.s_addr = haddr;

	addr.sin_port = hport;



	if (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) {

		udp_detach(so);

		return NULL;

	}

	setsockopt(so->s,SOL_SOCKET,SO_REUSEADDR,(char *)&opt,sizeof(int));



	getsockname(so->s,(struct sockaddr *)&addr,&addrlen);

	so->so_fport = addr.sin_port;

	if (addr.sin_addr.s_addr == 0 ||

	    addr.sin_addr.s_addr == loopback_addr.s_addr) {

	   so->so_faddr = slirp->vhost_addr;

	} else {

	   so->so_faddr = addr.sin_addr;

	}

	so->so_lport = lport;

	so->so_laddr.s_addr = laddr;

	if (flags != SS_FACCEPTONCE)

	   so->so_expire = 0;


",0,0,4,0,0,0,1,1,1,1,1,1,1,1,1
24899,qemu,1,"static uint32_t grlib_irqmp_readl(void *opaque, target_phys_addr_t addr)

{

    IRQMP      *irqmp = opaque;

    IRQMPState *state;



    assert(irqmp != NULL);

    state = irqmp->state;

    assert(state != NULL);



    addr &= 0xff;



    /* global registers */

    switch (addr) {

    case LEVEL_OFFSET:

        return state->level;



    case PENDING_OFFSET:

        return state->pending;



    case FORCE0_OFFSET:

        /* This register is an ""alias"" for the force register of CPU 0 */

        return state->force[0];



    case CLEAR_OFFSET:

    case MP_STATUS_OFFSET:

        /* Always read as 0 */

        return 0;



    case BROADCAST_OFFSET:

        return state->broadcast;



    default:

        break;

    }



    /* mask registers */

    if (addr >= MASK_OFFSET && addr < FORCE_OFFSET) {

        int cpu = (addr - MASK_OFFSET) / 4;

        assert(cpu >= 0 && cpu < IRQMP_MAX_CPU);



        return state->mask[cpu];

    }



    /* force registers */

    if (addr >= FORCE_OFFS",1,0,2,0,1,0,0,1,0,1,0,0,1,1,1
24902,qemu,1,"void qemu_sglist_destroy(QEMUSGList *qsg)

{

    g_free(qsg->sg);


}",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
24921,qemu,1,"static int virtio_9p_device_init(VirtIODevice *vdev)

{

    V9fsState *s = VIRTIO_9P(vdev);

    int i, len;

    struct stat stat;

    FsDriverEntry *fse;

    V9fsPath path;



    virtio_init(VIRTIO_DEVICE(s), ""virtio-9p"", VIRTIO_ID_9P,

                sizeof(struct virtio_9p_config) + MAX_TAG_LEN);



    /* initialize pdu allocator */

    QLIST_INIT(&s->free_list);

    QLIST_INIT(&s->active_list);

    for (i = 0; i < (MAX_REQ - 1); i++) {

        QLIST_INSERT_HEAD(&s->free_list, &s->pdus[i], next);

    }



    s->vq = virtio_add_queue(vdev, MAX_REQ, handle_9p_output);



    fse = get_fsdev_fsentry(s->fsconf.fsdev_id);



    if (!fse) {

        /* We don't have a fsdev identified by fsdev_id */

        fprintf(stderr, ""Virtio-9p device couldn't find fsdev with the ""

                ""id = %s\n"",

                s->fsconf.fsdev_id ? s->fsconf.fsdev_id : ""NULL"");

        goto out;

    }



    if (!s->fsconf.tag) {

        /* we haven't specified a mount_tag */

        fprintf(stderr, ""fsd",1,1,2,0,0,0,0,0,0,0,0,0,0,0,0
24933,qemu,0,"static int v9fs_request(V9fsProxy *proxy, int type,

                        void *response, const char *fmt, ...)

{

    dev_t rdev;

    va_list ap;

    int size = 0;

    int retval = 0;

    uint64_t offset;

    ProxyHeader header = { 0, 0};

    struct timespec spec[2];

    int flags, mode, uid, gid;

    V9fsString *name, *value;

    V9fsString *path, *oldpath;

    struct iovec *iovec = NULL, *reply = NULL;



    qemu_mutex_lock(&proxy->mutex);



    if (proxy->sockfd == -1) {

        retval = -EIO;

        goto err_out;

    }

    iovec = &proxy->out_iovec;

    reply = &proxy->in_iovec;

    va_start(ap, fmt);

    switch (type) {

    case T_OPEN:

        path = va_arg(ap, V9fsString *);

        flags = va_arg(ap, int);

        retval = proxy_marshal(iovec, PROXY_HDR_SZ, ""sd"", path, flags);

        if (retval > 0) {

            header.size = retval;

            header.type = T_OPEN;

        }

        break;

    case T_CREATE:

        path = va_arg(ap, V9fsString *);

        flag",0,1,2,0,1,0,0,0,0,0,0,0,1,0,0
24968,qemu,1,"static void scsi_req_set_status(SCSIDiskReq *r, int status, int sense_code)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);



    r->req.status = status;

    scsi_disk_set_sense(s, sense_code);

}
",0,0,0,0,0,0,0,0,1,0,0,0,0,0,1
25005,qemu,0,"static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)

{

    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {

        return;

    }

    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;



    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&

            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {

        if (s->stopped_state == sdhc_gap_read) {

            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;

            SDHCI_GET_CLASS(s)->read_block_from_card(s);

        } else {

            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;

            SDHCI_GET_CLASS(s)->write_block_to_card(s);

        }

        s->stopped_state = sdhc_not_stopped;

    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {

        if (s->prnsts & SDHC_DOING_READ) {

            s->stopped_state = sdhc_gap_read;

        } else if (s->prnsts & SDHC_DOING_WRITE) {

            s->stopped_state = sdhc_gap_write;

        }

    }

}
",0,0,6,0,0,0,0,0,0,0,0,0,0,1,1
25024,qemu,0,"static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,

                              Error **errp)

{

    int val;



    backend->vc = g_new0(ChardevVC, 1);



    val = qemu_opt_get_number(opts, ""width"", 0);

    if (val != 0) {

        backend->vc->has_width = true;

        backend->vc->width = val;

    }



    val = qemu_opt_get_number(opts, ""height"", 0);

    if (val != 0) {

        backend->vc->has_height = true;

        backend->vc->height = val;

    }



    val = qemu_opt_get_number(opts, ""cols"", 0);

    if (val != 0) {

        backend->vc->has_cols = true;

        backend->vc->cols = val;

    }



    val = qemu_opt_get_number(opts, ""rows"", 0);

    if (val != 0) {

        backend->vc->has_rows = true;

        backend->vc->rows = val;

    }

}
",0,0,4,0,0,0,0,0,0,0,1,0,1,1,0
25066,FFmpeg,1,"static unsigned int find_best(struct vf_instance *vf){

  int is_format_okay = vf->next->query_format(vf->next, IMGFMT_YV12);

  if ((is_format_okay & VFCAP_CSP_SUPPORTED_BY_HW) || (is_format_okay & VFCAP_CSP_SUPPORTED))

    return IMGFMT_YV12;

  else

    return 0;

}
",4,0,1,0,0,0,1,1,1,1,0,0,0,1,0
25075,qemu,1,"void helper_idivl_EAX_T0(void)

{

    int den, q, r;

    int64_t num;

    

    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);

    den = T0;

    if (den == 0) {

        raise_exception(EXCP00_DIVZ);

    }

#ifdef BUGGY_GCC_DIV64

    r = idiv32(&q, num, den);

#else

    q = (num / den);

    r = (num % den);

#endif

    EAX = (uint32_t)q;

    EDX = (uint32_t)r;

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
25081,FFmpeg,1,"static inline void idct_col(int16_t *blk, const uint8_t *quant)

{

    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;

    int t10, t11, t12, t13;

    int s0, s1, s2, s3, s4, s5, s6, s7;



    s0 = (int) blk[0 * 8] * quant[0 * 8];

    s1 = (int) blk[1 * 8] * quant[1 * 8];

    s2 = (int) blk[2 * 8] * quant[2 * 8];

    s3 = (int) blk[3 * 8] * quant[3 * 8];

    s4 = (int) blk[4 * 8] * quant[4 * 8];

    s5 = (int) blk[5 * 8] * quant[5 * 8];

    s6 = (int) blk[6 * 8] * quant[6 * 8];

    s7 = (int) blk[7 * 8] * quant[7 * 8];



    t0  =  (s3 * 19266 + s5 * 12873) >> 15;

    t1  =  (s5 * 19266 - s3 * 12873) >> 15;

    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;

    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;

    t4  = t0 * 2 + t2;

    t5  = t1 * 2 + t3;

    t6  = t2 - t3;

    t7  = t3 * 2 + t6;

    t8  = (t6 * 11585) >> 14;

    t9  = (t7 * 11585) >> 14;

    tA  = (s2 * 8867 - s6 * 21407) >> 14;

    tB  = (s6 * 8867 + s2 * 21407) >> 14;

    tC  = (s0 >> 1) - (s4 >> 1);
",0,0,0,0,0,0,0,0,1,1,1,1,1,1,0
25091,FFmpeg,0,"static int fourxm_probe(AVProbeData *p)

{

    if (p->buf_size < 12)

        return 0;



    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||

        (AV_RL32(&p->buf[8]) != _4XMV_TAG))

        return 0;



    return AVPROBE_SCORE_MAX;

}
",0,0,2,0,0,0,0,0,1,1,0,0,0,0,0
25095,FFmpeg,0,"static void jpeg_table_header(AVCodecContext *avctx, PutBitContext *p,

                              ScanTable *intra_scantable,

                              uint16_t luma_intra_matrix[64],

                              uint16_t chroma_intra_matrix[64],

                              int hsample[3])

{

    int i, j, size;

    uint8_t *ptr;

    MpegEncContext *s = avctx->priv_data;



    if (avctx->codec_id != AV_CODEC_ID_LJPEG) {

        int matrix_count = 1 + !!memcmp(luma_intra_matrix,

                                        chroma_intra_matrix,

                                        sizeof(luma_intra_matrix[0]) * 64);

    if (s->force_duplicated_matrix)

        matrix_count = 2;

    /* quant matrixes */

    put_marker(p, DQT);

    put_bits(p, 16, 2 + matrix_count * (1 + 64));

    put_bits(p, 4, 0); /* 8 bit precision */

    put_bits(p, 4, 0); /* table 0 */

    for(i=0;i<64;i++) {

        j = intra_scantable->permutated[i];

        put_bits(p, 8, luma_intra_matrix[j]);

    }



      ",2,0,2,0,0,0,0,0,0,1,0,1,1,0,0
25103,qemu,0,"static void ppc_spapr_init(MachineState *machine)

{

    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);

    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);

    const char *kernel_filename = machine->kernel_filename;

    const char *kernel_cmdline = machine->kernel_cmdline;

    const char *initrd_filename = machine->initrd_filename;

    PowerPCCPU *cpu;

    PCIHostState *phb;

    int i;

    MemoryRegion *sysmem = get_system_memory();

    MemoryRegion *ram = g_new(MemoryRegion, 1);

    MemoryRegion *rma_region;

    void *rma = NULL;

    hwaddr rma_alloc_size;

    hwaddr node0_size = spapr_node0_size();

    uint32_t initrd_base = 0;

    long kernel_size = 0, initrd_size = 0;

    long load_limit, fw_size;

    bool kernel_le = false;

    char *filename;



    msi_supported = true;



    QLIST_INIT(&spapr->phbs);



    cpu_ppc_hypercall = emulate_spapr_hypercall;



    /* Allocate RMA if necessary */

    rma_alloc_size = kvmppc_alloc_rma(&rma);



    if (rma_alloc_size == -1)",0,0,1,0,0,0,0,0,0,0,0,0,0,0,1
25113,qemu,0,"static void n8x0_nand_setup(struct n800_s *s)

{

    char *otp_region;

    DriveInfo *dinfo;



    s->nand = qdev_create(NULL, ""onenand"");

    qdev_prop_set_uint16(s->nand, ""manufacturer_id"", NAND_MFR_SAMSUNG);

    /* Either 0x40 or 0x48 are OK for the device ID */

    qdev_prop_set_uint16(s->nand, ""device_id"", 0x48);

    qdev_prop_set_uint16(s->nand, ""version_id"", 0);

    qdev_prop_set_int32(s->nand, ""shift"", 1);

    dinfo = drive_get(IF_MTD, 0, 0);

    if (dinfo) {

        qdev_prop_set_drive_nofail(s->nand, ""drive"",

                                   blk_bs(blk_by_legacy_dinfo(dinfo)));

    }

    qdev_init_nofail(s->nand);

    sysbus_connect_irq(SYS_BUS_DEVICE(s->nand), 0,

                       qdev_get_gpio_in(s->mpu->gpio, N8X0_ONENAND_GPIO));

    omap_gpmc_attach(s->mpu->gpmc, N8X0_ONENAND_CS,

                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));

    otp_region = onenand_raw_otp(s->nand);



    memcpy(otp_region + 0x000, n8x0_cal_wlan_mac, sizeof(n8x0_cal_wlan_ma",0,0,2,0,0,0,0,1,0,0,0,0,0,0,1
25119,qemu,0,"void cpu_dump_state (CPUState *env, FILE *f, 

                     int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                     int flags)

{

    uint32_t c0_status;

    int i;

    

    cpu_fprintf(f, ""pc=0x"" TARGET_FMT_lx "" HI=0x"" TARGET_FMT_lx "" LO=0x"" TARGET_FMT_lx "" ds %04x "" TARGET_FMT_lx "" %d\n"",

                env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond);

    for (i = 0; i < 32; i++) {

        if ((i & 3) == 0)

            cpu_fprintf(f, ""GPR%02d:"", i);

        cpu_fprintf(f, "" %s "" TARGET_FMT_lx, regnames[i], env->gpr[i]);

        if ((i & 3) == 3)

            cpu_fprintf(f, ""\n"");

    }



    c0_status = env->CP0_Status;



    cpu_fprintf(f, ""CP0 Status  0x%08x Cause   0x%08x EPC    0x"" TARGET_FMT_lx ""\n"",

                c0_status, env->CP0_Cause, env->CP0_EPC);

    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",

                env->CP0_Config0, env->CP0_Config1, env->CP0_LLAddr);

    if (c0_status & (1 << CP0St_C",1,0,3,0,0,0,0,0,0,0,0,0,0,0,0
25130,FFmpeg,1,"static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,

        int *need_next_header, int *new_frame_start)

{

    GetBitContext bits;

    AACADTSHeaderInfo hdr;

    int size;

    union {

        uint64_t u64;

        uint8_t  u8[8];

    } tmp;



    tmp.u64 = av_be2ne64(state);

    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);



    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)

        return 0;

    *need_next_header = 0;

    *new_frame_start  = 1;

    hdr_info->sample_rate = hdr.sample_rate;

    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];

    hdr_info->samples     = hdr.samples;

    hdr_info->bit_rate    = hdr.bit_rate;

    return size;

}
",0,0,1,0,0,0,1,0,0,1,1,1,0,0,0
25134,qemu,1,"uint64_t helper_ld_asi(CPUSPARCState *env, target_ulong addr, int asi, int size,

                       int sign)

{

    uint64_t ret = 0;

#if defined(DEBUG_ASI)

    target_ulong last_addr = addr;

#endif



    if (asi < 0x80) {

        helper_raise_exception(env, TT_PRIV_ACT);

    }



    helper_check_align(env, addr, size - 1);

    addr = asi_address_mask(env, asi, addr);



    switch (asi) {

    case 0x82: /* Primary no-fault */

    case 0x8a: /* Primary no-fault LE */

        if (page_check_range(addr, size, PAGE_READ) == -1) {

#ifdef DEBUG_ASI

            dump_asi(""read "", last_addr, asi, size, ret);

#endif

            return 0;

        }

        /* Fall through */

    case 0x80: /* Primary */

    case 0x88: /* Primary LE */

        {

            switch (size) {

            case 1:

                ret = ldub_raw(addr);

                break;

            case 2:

                ret = lduw_raw(addr);

                break;

            case 4:

                ret = ldl_raw(add",0,0,6,0,2,0,1,1,1,1,1,1,0,0,0
25135,FFmpeg,1,"static av_cold int vc2_encode_init(AVCodecContext *avctx)

{

    Plane *p;

    SubBand *b;

    int i, j, level, o, shift, ret;

    const AVPixFmtDescriptor *fmt = av_pix_fmt_desc_get(avctx->pix_fmt);

    const int depth = fmt->comp[0].depth;

    VC2EncContext *s = avctx->priv_data;



    s->picture_number = 0;



    /* Total allowed quantization range */

    s->q_ceil    = DIRAC_MAX_QUANT_INDEX;



    s->ver.major = 2;

    s->ver.minor = 0;

    s->profile   = 3;

    s->level     = 3;



    s->base_vf   = -1;

    s->strict_compliance = 1;



    s->q_avg = 0;

    s->slice_max_bytes = 0;

    s->slice_min_bytes = 0;



    /* Mark unknown as progressive */

    s->interlaced = !((avctx->field_order == AV_FIELD_UNKNOWN) ||

                      (avctx->field_order == AV_FIELD_PROGRESSIVE));



    for (i = 0; i < base_video_fmts_len; i++) {

        const VC2BaseVideoFormat *fmt = &base_video_fmts[i];

        if (avctx->pix_fmt != fmt->pix_fmt)

            continue;

        if (avctx->time_ba",1,0,3,0,0,0,0,1,0,1,0,1,0,0,0
25149,FFmpeg,1,"static av_cold int rv40_decode_init(AVCodecContext *avctx)

{

    RV34DecContext *r = avctx->priv_data;



    r->rv30 = 0;

    ff_rv34_decode_init(avctx);

    if(!aic_top_vlc.bits)

        rv40_init_tables();

    r->parse_slice_header = rv40_parse_slice_header;

    r->decode_intra_types = rv40_decode_intra_types;

    r->decode_mb_info     = rv40_decode_mb_info;

    r->loop_filter        = rv40_loop_filter;

    r->luma_dc_quant_i = rv40_luma_dc_quant[0];

    r->luma_dc_quant_p = rv40_luma_dc_quant[1];

    return 0;

}
",0,0,1,0,0,0,0,0,0,1,1,1,1,1,1
25163,qemu,0,"static void spr_write_dbatu_h (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);

    RET_STOP(ctx);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
25167,qemu,0,"sprintf_len(char *string, const char *format, ...)

#else

sprintf_len(va_alist) va_dcl

#endif

{

	va_list args;

#ifdef __STDC__

	va_start(args, format);

#else

	char *string;

	char *format;

	va_start(args);

	string = va_arg(args, char *);

	format = va_arg(args, char *);

#endif

	vsprintf(string, format, args);

	return strlen(string);

}
",5,0,3,0,0,0,0,0,0,0,0,0,1,1,1
25179,FFmpeg,1,"static int extract_extradata_h2645(AVBSFContext *ctx, AVPacket *pkt,

                                   uint8_t **data, int *size)

{

    static const int extradata_nal_types_hevc[] = {

        HEVC_NAL_VPS, HEVC_NAL_SPS, HEVC_NAL_PPS,

    };

    static const int extradata_nal_types_h264[] = {

        H264_NAL_SPS, H264_NAL_PPS,

    };



    ExtractExtradataContext *s = ctx->priv_data;



    H2645Packet h2645_pkt = { 0 };

    int extradata_size = 0;

    const int *extradata_nal_types;

    int nb_extradata_nal_types;

    int i, has_sps = 0, has_vps = 0, ret = 0;



    if (ctx->par_in->codec_id == AV_CODEC_ID_HEVC) {

        extradata_nal_types    = extradata_nal_types_hevc;

        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_hevc);

    } else {

        extradata_nal_types    = extradata_nal_types_h264;

        nb_extradata_nal_types = FF_ARRAY_ELEMS(extradata_nal_types_h264);

    }



    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,

                        ",0,0,1,0,0,0,0,0,0,0,0,0,0,1,0
25181,FFmpeg,1,"static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,

                                       int16_t *src2,

                                       int height, int denom, int wx0, int wx1,

                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)

{

    int x, y;

    pixel *src = (pixel *)_src;

    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);

    pixel *dst          = (pixel *)_dst;

    ptrdiff_t dststride = _dststride / sizeof(pixel);

    const int8_t *filter = ff_hevc_epel_filters[mx - 1];

    int shift = 14 + 1 - BIT_DEPTH;

    int log2Wd = denom + shift - 1;



    ox0     = ox0 * (1 << (BIT_DEPTH - 8));

    ox1     = ox1 * (1 << (BIT_DEPTH - 8));

    for (y = 0; y < height; y++) {

        for (x = 0; x < width; x++)

            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +

                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd ",2,0,6,0,0,0,1,1,0,1,1,1,0,0,0
25182,qemu,1,"void sdl2_gl_scanout(DisplayChangeListener *dcl,

                     uint32_t backing_id, bool backing_y_0_top,


                     uint32_t x, uint32_t y,

                     uint32_t w, uint32_t h)

{

    struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);



    assert(scon->opengl);

    scon->x = x;

    scon->y = y;

    scon->w = w;

    scon->h = h;

    scon->tex_id = backing_id;

    scon->y0_top = backing_y_0_top;



    SDL_GL_MakeCurrent(scon->real_window, scon->winctx);



    if (scon->tex_id == 0 || scon->w == 0 || scon->h == 0) {

        sdl2_set_scanout_mode(scon, false);

        return;

    }



    sdl2_set_scanout_mode(scon, true);

    if (!scon->fbo_id) {

        glGenFramebuffers(1, &scon->fbo_id);

    }



    glBindFramebuffer(GL_FRAMEBUFFER_EXT, scon->fbo_id);

    glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, GL_COLOR_ATTACHMENT0_EXT,

                              GL_TEXTURE_2D, scon->tex_id, 0);

}",0,0,2,0,0,0,1,1,1,1,1,1,0,1,1
25185,qemu,1,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,0,0
25189,qemu,1,"static void tcg_out_qemu_st(TCGContext *s, TCGReg data, TCGReg addr,

                            TCGMemOpIdx oi)

{

    TCGMemOp memop = get_memop(oi);

#ifdef CONFIG_SOFTMMU

    unsigned memi = get_mmuidx(oi);

    TCGReg addrz, param;

    tcg_insn_unit *func;

    tcg_insn_unit *label_ptr;



    addrz = tcg_out_tlb_load(s, addr, memi, memop,

                             offsetof(CPUTLBEntry, addr_write));



    /* The fast path is exactly one insn.  Thus we can perform the entire

       TLB Hit in the (annulled) delay slot of the branch over TLB Miss.  */

    /* beq,a,pt %[xi]cc, label0 */

    label_ptr = s->code_ptr;

    tcg_out_bpcc0(s, COND_E, BPCC_A | BPCC_PT

                  | (TARGET_LONG_BITS == 64 ? BPCC_XCC : BPCC_ICC), 0);

    /* delay slot */

    tcg_out_ldst_rr(s, data, addrz, TCG_REG_O1,

                    qemu_st_opc[memop & (MO_BSWAP | MO_SIZE)]);



    /* TLB Miss.  */



    param = TCG_REG_O1;

    if (!SPARC64 && TARGET_LONG_BITS == 64) {

        /* Skip the high-part; ",1,0,2,0,0,0,0,0,0,0,1,0,1,0,1
25223,qemu,0,"QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
25245,FFmpeg,1,"static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,

                                       int *mb_type)

{

    int b8_stride = 2;

    int b4_stride = h->b_stride;

    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;

    int mb_type_col[2];

    const int16_t (*l1mv0)[2], (*l1mv1)[2];

    const int8_t *l1ref0, *l1ref1;

    const int is_b8x8 = IS_8X8(*mb_type);

    unsigned int sub_mb_type = MB_TYPE_L0L1;

    int i8, i4;

    int ref[2];

    int mv[2];

    int list;



    assert(sl->ref_list[1][0].reference & 3);



    await_reference_mb_row(h, sl->ref_list[1][0].parent,

                           sl->mb_y + !!IS_INTERLACED(*mb_type));



#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \

                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)



    /* ref = min(neighbors) */

    for (list = 0; list < 2; list++) {

        int left_ref     = sl->ref_cache[list][scan8[0] - 1];

        int top_ref      = sl->ref_cache[list][scan8[0] ",1,0,0,0,0,0,1,1,1,0,0,0,0,0,0
25247,qemu,1,"static void boston_lcd_event(void *opaque, int event)

{

    BostonState *s = opaque;

    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {

        qemu_chr_fe_printf(&s->lcd_display, ""        "");

        s->lcd_inited = true;

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
25252,qemu,1,"void add_command(const cmdinfo_t *ci)

{

    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));

    cmdtab[ncmds - 1] = *ci;

    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);

}
",0,0,0,0,0,0,0,1,1,0,1,0,1,1,1
25260,qemu,1,"static void openpic_update_irq(OpenPICState *opp, int n_IRQ)

{

    IRQ_src_t *src;

    int i;



    src = &opp->src[n_IRQ];



    if (!src->pending) {

        /* no irq pending */

        DPRINTF(""%s: IRQ %d is not pending\n"", __func__, n_IRQ);

        return;

    }

    if (src->ipvp & IPVP_MASK_MASK) {

        /* Interrupt source is disabled */

        DPRINTF(""%s: IRQ %d is disabled\n"", __func__, n_IRQ);

        return;

    }

    if (IPVP_PRIORITY(src->ipvp) == 0) {

        /* Priority set to zero */

        DPRINTF(""%s: IRQ %d has 0 priority\n"", __func__, n_IRQ);

        return;

    }

    if (src->ipvp & IPVP_ACTIVITY_MASK) {

        /* IRQ already active */

        DPRINTF(""%s: IRQ %d is already active\n"", __func__, n_IRQ);

        return;

    }

    if (src->ide == 0) {

        /* No target */

        DPRINTF(""%s: IRQ %d has no target\n"", __func__, n_IRQ);

        return;

    }



    if (src->ide == (1 << src->last_cpu)) {

        /* Only one CPU is allowed to receive this I",0,0,6,0,0,0,1,1,1,1,1,1,0,0,0
25263,qemu,1,"static inline void usb_bt_fifo_out_enqueue(struct USBBtState *s,

                struct usb_hci_out_fifo_s *fifo,

                void (*send)(struct HCIInfo *, const uint8_t *, int),

                int (*complete)(const uint8_t *, int),

                const uint8_t *data, int len)

{

    if (fifo->len) {

        memcpy(fifo->data + fifo->len, data, len);

        fifo->len += len;

        if (complete(fifo->data, fifo->len)) {

            send(s->hci, fifo->data, fifo->len);

            fifo->len = 0;

        }

    } else if (complete(data, len))

        send(s->hci, data, len);

    else {

        memcpy(fifo->data, data, len);

        fifo->len = len;

    }



    /* TODO: do we need to loop? */

}
",0,0,17,0,0,0,0,1,1,1,1,0,0,0,0
25265,FFmpeg,0,"static void compute_status(HTTPContext *c)

{

    HTTPContext *c1;

    FFStream *stream;

    char *p;

    time_t ti;

    int i, len;

    AVIOContext *pb;



    if (avio_open_dyn_buf(&pb) < 0) {

        /* XXX: return an error ? */

        c->buffer_ptr = c->buffer;

        c->buffer_end = c->buffer;

        return;

    }



    avio_printf(pb, ""HTTP/1.0 200 OK\r\n"");

    avio_printf(pb, ""Content-type: %s\r\n"", ""text/html"");

    avio_printf(pb, ""Pragma: no-cache\r\n"");

    avio_printf(pb, ""\r\n"");



    avio_printf(pb, ""<html><head><title>%s Status</title>\n"", program_name);

    if (c->stream->feed_filename[0])

        avio_printf(pb, ""<link rel=\""shortcut icon\"" href=\""%s\"">\n"", c->stream->feed_filename);

    avio_printf(pb, ""</head>\n<body>"");

    avio_printf(pb, ""<h1>%s Status</h1>\n"", program_name);

    /* format status */

    avio_printf(pb, ""<h2>Available Streams</h2>\n"");

    avio_printf(pb, ""<table cellspacing=0 cellpadding=4>\n"");

    avio_printf(pb, ""<tr><th valign=top>Path<th",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
25284,qemu,0,"static int ram_save_compressed_page(QEMUFile *f, PageSearchStatus *pss,

                                    bool last_stage,

                                    uint64_t *bytes_transferred)

{

    int pages = -1;

    uint64_t bytes_xmit;

    uint8_t *p;

    int ret;

    RAMBlock *block = pss->block;

    ram_addr_t offset = pss->offset;



    p = block->host + offset;



    bytes_xmit = 0;

    ret = ram_control_save_page(f, block->offset,

                                offset, TARGET_PAGE_SIZE, &bytes_xmit);

    if (bytes_xmit) {

        *bytes_transferred += bytes_xmit;

        pages = 1;

    }

    if (block == last_sent_block) {

        offset |= RAM_SAVE_FLAG_CONTINUE;

    }

    if (ret != RAM_SAVE_CONTROL_NOT_SUPP) {

        if (ret != RAM_SAVE_CONTROL_DELAYED) {

            if (bytes_xmit > 0) {

                acct_info.norm_pages++;

            } else if (bytes_xmit == 0) {

                acct_info.dup_pages++;

            }

        }

    } else {

        /* When starting ",0,0,6,0,0,0,0,0,0,0,0,0,1,1,1
25310,qemu,0,"void qmp_block_stream(bool has_job_id, const char *job_id, const char *device,

                      bool has_base, const char *base,

                      bool has_backing_file, const char *backing_file,

                      bool has_speed, int64_t speed,

                      bool has_on_error, BlockdevOnError on_error,

                      Error **errp)

{

    BlockDriverState *bs;

    BlockDriverState *base_bs = NULL;

    AioContext *aio_context;

    Error *local_err = NULL;

    const char *base_name = NULL;



    if (!has_on_error) {

        on_error = BLOCKDEV_ON_ERROR_REPORT;

    }



    bs = qmp_get_root_bs(device, errp);

    if (!bs) {

        return;

    }



    aio_context = bdrv_get_aio_context(bs);

    aio_context_acquire(aio_context);



    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_STREAM, errp)) {

        goto out;

    }



    if (has_base) {

        base_bs = bdrv_find_backing_image(bs, base);

        if (base_bs == NULL) {

            error_setg(errp, QERR_BASE_NOT_",0,1,5,0,0,0,1,1,1,1,1,1,0,0,0
25344,FFmpeg,0,"int ff_dxva2_commit_buffer(AVCodecContext *avctx,

                           AVDXVAContext *ctx,

                           DECODER_BUFFER_DESC *dsc,

                           unsigned type, const void *data, unsigned size,

                           unsigned mb_count)

{

    void     *dxva_data;

    unsigned dxva_size;

    int      result;

    HRESULT hr;



#if CONFIG_D3D11VA

    if (avctx->pix_fmt == AV_PIX_FMT_D3D11VA_VLD)

        hr = ID3D11VideoContext_GetDecoderBuffer(D3D11VA_CONTEXT(ctx)->video_context,

                                                 D3D11VA_CONTEXT(ctx)->decoder,

                                                 type,

                                                 &dxva_size, &dxva_data);

#endif

#if CONFIG_DXVA2

    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)

        hr = IDirectXVideoDecoder_GetBuffer(DXVA2_CONTEXT(ctx)->decoder, type,

                                            &dxva_data, &dxva_size);

#endif

    if (FAILED(hr)) {

        av_log(avctx, AV_LO",0,0,7,0,0,0,0,0,0,0,0,0,0,0,0
25353,qemu,0,"static int inet_listen_saddr(InetSocketAddress *saddr,

                             int port_offset,

                             bool update_addr,

                             Error **errp)

{

    struct addrinfo ai,*res,*e;

    char port[33];

    char uaddr[INET6_ADDRSTRLEN+1];

    char uport[33];

    int slisten, rc, port_min, port_max, p;

    Error *err = NULL;



    memset(&ai,0, sizeof(ai));

    ai.ai_flags = AI_PASSIVE;

    if (saddr->has_numeric && saddr->numeric) {

        ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;

    }

    ai.ai_family = inet_ai_family_from_address(saddr, &err);

    ai.ai_socktype = SOCK_STREAM;



    if (err) {

        error_propagate(errp, err);

        return -1;

    }



    if (saddr->host == NULL) {

        error_setg(errp, ""host not specified"");

        return -1;

    }

    if (saddr->port != NULL) {

        pstrcpy(port, sizeof(port), saddr->port);

    } else {

        port[0] = '\0';

    }



    /* lookup */

    if (port_offset) {

      ",0,0,6,0,0,0,0,0,0,0,0,0,0,1,1
25357,FFmpeg,0,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
25370,qemu,0,"void vmstate_unregister(const VMStateDescription *vmsd, void *opaque)

{

    SaveStateEntry *se, *new_se;



    TAILQ_FOREACH_SAFE(se, &savevm_handlers, entry, new_se) {

        if (se->vmsd == vmsd && se->opaque == opaque) {

            TAILQ_REMOVE(&savevm_handlers, se, entry);

            qemu_free(se);

        }

    }

}
",0,0,1,0,0,0,0,1,1,1,1,0,1,0,0
25382,qemu,1,"static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,

                                 struct iovec *iov, unsigned int iov_cnt)

{

    struct virtio_net_ctrl_mac mac_data;

    size_t s;

    NetClientState *nc = qemu_get_queue(n->nic);



    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {

        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {

            return VIRTIO_NET_ERR;

        }

        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));

        assert(s == sizeof(n->mac));

        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);

        rxfilter_notify(nc);



        return VIRTIO_NET_OK;

    }



    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {

        return VIRTIO_NET_ERR;

    }



    int in_use = 0;

    int first_multi = 0;

    uint8_t uni_overflow = 0;

    uint8_t multi_overflow = 0;

    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);



    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,

                   sizeof(mac_data.entries));

    mac_data",1,0,4,0,0,0,1,1,1,1,0,1,0,1,1
25401,FFmpeg,1,"static av_cold int ffmmal_init_decoder(AVCodecContext *avctx)
{
    MMALDecodeContext *ctx = avctx->priv_data;
    MMAL_STATUS_T status;
    MMAL_ES_FORMAT_T *format_in;
    MMAL_COMPONENT_T *decoder;
    char tmp[32];
    int ret = 0;
    bcm_host_init();
    if (mmal_vc_init()) {
        av_log(avctx, AV_LOG_ERROR, ""Cannot initialize MMAL VC driver!\n"");
        return AVERROR(ENOSYS);
    if ((ret = ff_get_format(avctx, avctx->codec->pix_fmts)) < 0)
        return ret;
    avctx->pix_fmt = ret;
    if ((status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &ctx->decoder)))
        goto fail;
    decoder = ctx->decoder;
    format_in = decoder->input[0]->format;
    format_in->type = MMAL_ES_TYPE_VIDEO;
    switch (avctx->codec_id) {
        case AV_CODEC_ID_MPEG2VIDEO:
            format_in->encoding = MMAL_ENCODING_MP2V;
            break;
        case AV_CODEC_ID_MPEG4:
            format_in->encoding = MMAL_ENCODING_MP4V;
            break;
        case AV_CODEC_ID_VC1:
            format",8,1,3,0,1,0,1,1,1,1,1,1,1,1,1
25404,FFmpeg,1,"static int ogg_get_length(AVFormatContext *s)

{

    struct ogg *ogg = s->priv_data;

    int i;

    int64_t size, end;

    int streams_left=0;



    if(!s->pb->seekable)

        return 0;



// already set

    if (s->duration != AV_NOPTS_VALUE)

        return 0;



    size = avio_size(s->pb);

    if(size < 0)

        return 0;

    end = size > MAX_PAGE_SIZE? size - MAX_PAGE_SIZE: 0;



    ogg_save (s);

    avio_seek (s->pb, end, SEEK_SET);



    while (!ogg_read_page (s, &i)){

        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 &&

            ogg->streams[i].codec) {

            s->streams[i]->duration =

                ogg_gptopts (s, i, ogg->streams[i].granule, NULL);

            if (s->streams[i]->start_time != AV_NOPTS_VALUE){

                s->streams[i]->duration -= s->streams[i]->start_time;

                streams_left-= (ogg->streams[i].got_start==-1);

                ogg->streams[i].got_start= 1;

            }else if(!ogg->streams[i].got_start){

      ",0,0,6,0,0,1,0,0,0,0,1,0,0,0,0
25413,FFmpeg,1,"static int mimic_decode_frame(AVCodecContext *avctx, void *data,

                              int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    MimicContext *ctx = avctx->priv_data;

    GetByteContext gb;

    int is_pframe;

    int width, height;

    int quality, num_coeffs;

    int swap_buf_size = buf_size - MIMIC_HEADER_SIZE;



    if (buf_size <= MIMIC_HEADER_SIZE) {

        av_log(avctx, AV_LOG_ERROR, ""insufficient data\n"");

        return -1;

    }



    bytestream2_init(&gb, buf, MIMIC_HEADER_SIZE);

    bytestream2_skip(&gb, 2); /* some constant (always 256) */

    quality    = bytestream2_get_le16u(&gb);

    width      = bytestream2_get_le16u(&gb);

    height     = bytestream2_get_le16u(&gb);

    bytestream2_skip(&gb, 4); /* some constant */

    is_pframe  = bytestream2_get_le32u(&gb);

    num_coeffs = bytestream2_get_byteu(&gb);

    bytestream2_skip(&gb, 3); /* some constant */



    if(!ctx->avctx) {

        int i;

",0,0,2,0,0,0,1,1,1,0,1,1,0,1,1
25448,FFmpeg,0,"static int ipvideo_decode_block_opcode_0x8(IpvideoContext *s)

{

    int x, y;

    unsigned char P[2];

    unsigned int flags = 0;



    /* 2-color encoding for each 4x4 quadrant, or 2-color encoding on

     * either top and bottom or left and right halves */

    CHECK_STREAM_PTR(2);



    P[0] = *s->stream_ptr++;

    P[1] = *s->stream_ptr++;



    if (P[0] <= P[1]) {



        CHECK_STREAM_PTR(14);

        s->stream_ptr -= 2;



        for (y = 0; y < 16; y++) {

            // new values for each 4x4 block

            if (!(y & 3)) {

                P[0] = *s->stream_ptr++; P[1] = *s->stream_ptr++;

                flags = bytestream_get_le16(&s->stream_ptr);

            }



            for (x = 0; x < 4; x++, flags >>= 1)

                *s->pixel_ptr++ = P[flags & 1];

            s->pixel_ptr += s->stride - 4;

            // switch to right half

            if (y == 7) s->pixel_ptr -= 8 * s->stride - 4;

        }



    } else {



        /* need 10 more bytes */

        CHECK_STREA",3,0,3,0,0,0,0,1,1,1,1,1,0,0,0
25459,qemu,1,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
",0,0,5,0,0,0,0,0,0,0,0,0,1,1,1
25472,qemu,1,"static void vga_draw_text(VGACommonState *s, int full_update)

{

    DisplaySurface *surface = qemu_console_surface(s->con);

    int cx, cy, cheight, cw, ch, cattr, height, width, ch_attr;

    int cx_min, cx_max, linesize, x_incr, line, line1;

    uint32_t offset, fgcol, bgcol, v, cursor_offset;

    uint8_t *d1, *d, *src, *dest, *cursor_ptr;

    const uint8_t *font_ptr, *font_base[2];

    int dup9, line_offset;

    uint32_t *palette;

    uint32_t *ch_attr_ptr;

    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL);



    /* compute font data address (in plane 2) */

    v = s->sr[VGA_SEQ_CHARACTER_MAP];

    offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2;

    if (offset != s->font_offsets[0]) {

        s->font_offsets[0] = offset;

        full_update = 1;

    }

    font_base[0] = s->vram_ptr + offset;



    offset = (((v >> 5) & 1) | ((v >> 1) & 6)) * 8192 * 4 + 2;

    font_base[1] = s->vram_ptr + offset;

    if (offset != s->font_offsets[1]) {

        s->font_offsets[1] = offs",0,0,2,0,0,0,1,0,0,1,0,0,0,0,0
25492,qemu,1,"int64_t qemu_ftell(QEMUFile *f)

{

    qemu_fflush(f);

    return f->pos;

}
",0,0,0,0,0,0,1,1,1,1,1,1,0,0,0
25501,FFmpeg,1,"static int libquvi_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    LibQuviContext *qc = s->priv_data;

    return av_read_frame(qc->fmtctx, pkt);

}
",0,0,0,0,0,0,1,0,0,1,0,0,0,0,0
25505,qemu,1,"static PCIDevice *qemu_pci_hot_add_storage(Monitor *mon,

                                           const char *devaddr,

                                           const char *opts)

{

    PCIDevice *dev;

    DriveInfo *dinfo = NULL;

    int type = -1;

    char buf[128];

    PCIBus *bus;

    int devfn;



    if (get_param_value(buf, sizeof(buf), ""if"", opts)) {

        if (!strcmp(buf, ""scsi""))

            type = IF_SCSI;

        else if (!strcmp(buf, ""virtio"")) {

            type = IF_VIRTIO;

        } else {

            monitor_printf(mon, ""type %s not a hotpluggable PCI device.\n"", buf);

            return NULL;

        }

    } else {

        monitor_printf(mon, ""no if= specified\n"");

        return NULL;

    }



    if (get_param_value(buf, sizeof(buf), ""file"", opts)) {

        dinfo = add_init_drive(opts);

        if (!dinfo)

            return NULL;

        if (dinfo->devaddr) {

            monitor_printf(mon, ""Parameter addr not supported\n"");

            return NULL;

      ",0,0,9,0,0,0,1,1,1,1,0,0,0,0,0
25510,qemu,0,"uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    return (eeprom->eedo);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
25515,qemu,0,"static void sysctl_write(void *opaque, target_phys_addr_t addr, uint32_t value)

{

    MilkymistSysctlState *s = opaque;



    trace_milkymist_sysctl_memory_write(addr, value);



    addr >>= 2;

    switch (addr) {

    case R_GPIO_OUT:

    case R_GPIO_INTEN:

    case R_TIMER0_COUNTER:

        if (value > s->regs[R_TIMER0_COUNTER]) {

            value = s->regs[R_TIMER0_COUNTER];

            error_report(""milkymist_sysctl: timer0: trying to write a ""

                    ""value greater than the limit. Clipping."");

        }

        /* milkymist timer counts up */

        value = s->regs[R_TIMER0_COUNTER] - value;

        ptimer_set_count(s->ptimer0, value);

        break;

    case R_TIMER1_COUNTER:

        if (value > s->regs[R_TIMER1_COUNTER]) {

            value = s->regs[R_TIMER1_COUNTER];

            error_report(""milkymist_sysctl: timer1: trying to write a ""

                    ""value greater than the limit. Clipping."");

        }

        /* milkymist timer counts up */

        valu",0,0,2,0,1,0,0,0,0,0,0,0,1,1,1
25526,FFmpeg,0,"AVFrame *avcodec_alloc_frame(void)

{

    AVFrame *frame = av_mallocz(sizeof(AVFrame));



    if (frame == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    avcodec_get_frame_defaults(frame);

FF_ENABLE_DEPRECATION_WARNINGS



    return frame;

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
25530,FFmpeg,1,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= src[i];

        dst[i]= acc & mask;

        i++;

        acc+= src[i];

        dst[i]= acc & mask;

    }



    for(; i<w; i++){

        acc+= src[i];

        dst[i]= acc & mask;

    }



    return acc;

}
",2,0,0,0,0,0,0,0,0,0,1,1,0,0,0
25549,qemu,0,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)

{

    PXA2xxPICState *s;

    int iomemtype;

    qemu_irq *qi;



    s = (PXA2xxPICState *)

            qemu_mallocz(sizeof(PXA2xxPICState));

    if (!s)

        return NULL;



    s->cpu_env = env;



    s->int_pending[0] = 0;

    s->int_pending[1] = 0;

    s->int_enabled[0] = 0;

    s->int_enabled[1] = 0;

    s->is_fiq[0] = 0;

    s->is_fiq[1] = 0;



    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);



    /* Enable IC memory-mapped registers access.  */

    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,

                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);

    cpu_register_physical_memory(base, 0x00100000, iomemtype);



    /* Enable IC coprocessor access.  */

    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);



    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,

                    pxa2xx_pic_load, s);



    return qi;

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
25550,qemu,0,"int net_init_vde(QemuOpts *opts, const NetClientOptions *new_opts,

                 const char *name, VLANState *vlan)

{

    const char *sock;

    const char *group;

    int port, mode;



    sock  = qemu_opt_get(opts, ""sock"");

    group = qemu_opt_get(opts, ""group"");



    port = qemu_opt_get_number(opts, ""port"", 0);

    mode = qemu_opt_get_number(opts, ""mode"", 0700);



    if (net_vde_init(vlan, ""vde"", name, sock, port, group, mode) == -1) {

        return -1;

    }



    return 0;

}
",0,0,1,0,0,0,0,0,0,0,0,1,0,0,0
25557,FFmpeg,1,"static const ID3v2EMFunc *get_extra_meta_func(const char *tag, int isv34)

{

    int i = 0;

    while (ff_id3v2_extra_meta_funcs[i].tag3) {

        if (!memcmp(tag,

                    (isv34 ?

                        ff_id3v2_extra_meta_funcs[i].tag4 :

                        ff_id3v2_extra_meta_funcs[i].tag3),

                    (isv34 ? 4 : 3)))

            return &ff_id3v2_extra_meta_funcs[i];

        i++;

    }

    return NULL;

}
",0,0,1,0,0,1,0,0,1,1,1,1,0,0,0
25566,FFmpeg,1,"int av_buffersrc_add_ref(AVFilterContext *buffer_filter,

                         AVFilterBufferRef *picref, int flags)

{

    BufferSourceContext *c = buffer_filter->priv;

    AVFilterBufferRef *buf;

    int ret;



    if (!picref) {

        c->eof = 1;

        return 0;

    } else if (c->eof)

        return AVERROR(EINVAL);



    if (!av_fifo_space(c->fifo) &&

        (ret = av_fifo_realloc2(c->fifo, av_fifo_size(c->fifo) +

                                         sizeof(buf))) < 0)

        return ret;



    if (!(flags & AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT)) {

        ret = check_format_change(buffer_filter, picref);

        if (ret < 0)

            return ret;

    }

    if (flags & AV_BUFFERSRC_FLAG_NO_COPY)

        buf = picref;

    else

        buf = copy_buffer_ref(buffer_filter, picref);





    if ((ret = av_fifo_generic_write(c->fifo, &buf, sizeof(buf), NULL)) < 0) {

        if (buf != picref)

            avfilter_unref_buffer(buf);

        return ret;

    }

    c->nb_faile",1,0,16,0,0,0,0,0,0,0,0,0,0,1,1
25571,qemu,0,"static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    g_free(qs);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
25574,qemu,0,"bool aio_pending(AioContext *ctx)

{

    AioHandler *node;

    bool result = false;



    /*

     * We have to walk very carefully in case aio_set_fd_handler is

     * called while we're walking.

     */

    qemu_lockcnt_inc(&ctx->list_lock);

    QLIST_FOREACH_RCU(node, &ctx->aio_handlers, node) {

        if (node->pfd.revents && node->io_notify) {

            result = true;

            break;

        }



        if ((node->pfd.revents & G_IO_IN) && node->io_read) {

            result = true;

            break;

        }

        if ((node->pfd.revents & G_IO_OUT) && node->io_write) {

            result = true;

            break;

        }

    }



    qemu_lockcnt_dec(&ctx->list_lock);

    return result;

}
",0,0,4,0,0,1,0,0,0,0,0,0,1,0,0
25578,qemu,0,"static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, out;



    virtqueue_get_avail_bytes(vq, &in, &out);

    return in;

}
",0,0,0,0,0,0,0,0,0,0,1,0,0,0,0
25580,qemu,0,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
",0,0,0,0,0,0,1,1,0,0,0,0,0,0,1
25583,qemu,0,"static void pc_init1(ram_addr_t ram_size,

                     const char *boot_device,

                     const char *kernel_filename,

                     const char *kernel_cmdline,

                     const char *initrd_filename,

                     const char *cpu_model,

                     int pci_enabled,

                     int kvmclock_enabled)

{

    int i;

    ram_addr_t below_4g_mem_size, above_4g_mem_size;

    PCIBus *pci_bus;

    PCII440FXState *i440fx_state;

    int piix3_devfn = -1;

    qemu_irq *cpu_irq;

    qemu_irq *isa_irq;

    qemu_irq *i8259;

    qemu_irq *cmos_s3;

    qemu_irq *smi_irq;

    IsaIrqState *isa_irq_state;

    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];

    FDCtrl *floppy_controller;

    BusState *idebus[MAX_IDE_BUS];

    ISADevice *rtc_state;



    pc_cpus_init(cpu_model);



    if (kvmclock_enabled) {

        kvmclock_create();

    }



    /* allocate ram and load rom/bios */

    pc_memory_init(ram_size, kernel_filename, kernel_cmdline, ini",0,0,1,0,0,0,0,0,0,0,0,0,0,0,1
25593,FFmpeg,0,"static av_cold int roq_decode_init(AVCodecContext *avctx)

{

    RoqContext *s = avctx->priv_data;



    s->avctx = avctx;



    if (avctx->width % 16 || avctx->height % 16) {

        av_log(avctx, AV_LOG_ERROR,

               ""Dimensions must be a multiple of 16\n"");

        return AVERROR_PATCHWELCOME;

    }



    s->width = avctx->width;

    s->height = avctx->height;



    s->last_frame    = av_frame_alloc();

    s->current_frame = av_frame_alloc();

    if (!s->current_frame || !s->last_frame) {

        av_frame_free(&s->current_frame);

        av_frame_free(&s->last_frame);

        return AVERROR(ENOMEM);

    }



    avctx->pix_fmt = AV_PIX_FMT_YUV444P;



    return 0;

}
",0,0,2,0,0,0,0,0,1,1,0,0,1,1,1
25602,qemu,1,"static int usb_bt_handle_data(USBDevice *dev, USBPacket *p)

{

    struct USBBtState *s = (struct USBBtState *) dev->opaque;

    int ret = 0;



    if (!s->config)

        goto fail;



    switch (p->pid) {

    case USB_TOKEN_IN:

        switch (p->devep & 0xf) {

        case USB_EVT_EP:

            ret = usb_bt_fifo_dequeue(&s->evt, p);

            break;



        case USB_ACL_EP:

            ret = usb_bt_fifo_dequeue(&s->acl, p);

            break;



        case USB_SCO_EP:

            ret = usb_bt_fifo_dequeue(&s->sco, p);

            break;



        default:

            goto fail;

        }

        break;



    case USB_TOKEN_OUT:

        switch (p->devep & 0xf) {

        case USB_ACL_EP:

            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,

                            usb_bt_hci_acl_complete, p->data, p->len);

            break;



        case USB_SCO_EP:

            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,

                            usb_bt_",0,2,6,0,3,0,1,1,1,1,1,1,1,0,1
25619,qemu,0,"static void rtas_ibm_read_slot_reset_state2(PowerPCCPU *cpu,

                                            sPAPREnvironment *spapr,

                                            uint32_t token, uint32_t nargs,

                                            target_ulong args, uint32_t nret,

                                            target_ulong rets)

{

    sPAPRPHBState *sphb;

    sPAPRPHBClass *spc;

    uint64_t buid;

    int state, ret;



    if ((nargs != 3) || (nret != 4 && nret != 5)) {

        goto param_error_exit;

    }



    buid = ((uint64_t)rtas_ld(args, 1) << 32) | rtas_ld(args, 2);

    sphb = find_phb(spapr, buid);

    if (!sphb) {

        goto param_error_exit;

    }



    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);

    if (!spc->eeh_get_state) {

        goto param_error_exit;

    }



    ret = spc->eeh_get_state(sphb, &state);

    rtas_st(rets, 0, ret);

    if (ret != RTAS_OUT_SUCCESS) {

        return;

    }



    rtas_st(rets, 1, state);

    rtas_st(rets, 2, RTAS_EEH_SU",0,3,4,0,0,0,0,0,0,1,0,0,0,0,0
25636,qemu,0,"void qmp_migrate_set_cache_size(int64_t value, Error **errp)

{

    MigrationState *s = migrate_get_current();



    /* Check for truncation */

    if (value != (size_t)value) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                  ""exceeding address space"");

        return;

    }



    s->xbzrle_cache_size = xbzrle_cache_resize(value);

}
",0,0,1,0,0,0,0,0,0,1,0,0,1,1,0
25669,qemu,1,"int path_is_absolute(const char *path)

{

    const char *p;

#ifdef _WIN32

    /* specific case for names like: ""\\.\d:"" */

    if (*path == '/' || *path == '\\')

        return 1;

#endif

    p = strchr(path, ':');

    if (p)

        p++;

    else

        p = path;

#ifdef _WIN32

    return (*p == '/' || *p == '\\');

#else

    return (*p == '/');

#endif

}
",0,0,6,0,0,0,0,0,0,0,1,0,1,1,1
25670,qemu,1,"opts_end_struct(Visitor *v, Error **errp)

{

    OptsVisitor *ov = to_ov(v);

    GHashTableIter iter;

    GQueue *any;



    if (--ov->depth > 0) {

        return;

    }



    /* we should have processed all (distinct) QemuOpt instances */

    g_hash_table_iter_init(&iter, ov->unprocessed_opts);

    if (g_hash_table_iter_next(&iter, NULL, (void **)&any)) {

        const QemuOpt *first;



        first = g_queue_peek_head(any);

        error_setg(errp, QERR_INVALID_PARAMETER, first->name);

    }

    g_hash_table_destroy(ov->unprocessed_opts);

    ov->unprocessed_opts = NULL;

    if (ov->fake_id_opt) {

        g_free(ov->fake_id_opt->name);

        g_free(ov->fake_id_opt->str);

        g_free(ov->fake_id_opt);

    }

    ov->fake_id_opt = NULL;

}
",0,0,3,0,0,0,0,0,0,0,0,0,0,1,0
25672,FFmpeg,1,"static av_cold int shorten_decode_close(AVCodecContext *avctx)

{

    ShortenContext *s = avctx->priv_data;

    int i;



    for (i = 0; i < s->channels; i++) {

        s->decoded[i] -= s->nwrap;

        av_freep(&s->decoded[i]);

        av_freep(&s->offset[i]);

    }

    av_freep(&s->bitstream);

    av_freep(&s->coeffs);



    return 0;

}
",1,0,0,0,0,0,0,1,0,1,1,1,0,0,1
25693,FFmpeg,0,"void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,

                                ptrdiff_t stride)

{

    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,

                                         src - (stride * 2),

                                         stride, dst, stride);

}
",0,0,1,0,0,0,1,1,0,1,1,1,1,1,1
25704,qemu,0,"static uint32_t apic_mem_readl(void *opaque, target_phys_addr_t addr)

{

    DeviceState *d;

    APICCommonState *s;

    uint32_t val;

    int index;



    d = cpu_get_current_apic();

    if (!d) {

        return 0;

    }

    s = DO_UPCAST(APICCommonState, busdev.qdev, d);



    index = (addr >> 4) & 0xff;

    switch(index) {

    case 0x02: /* id */

        val = s->id << 24;

        break;

    case 0x03: /* version */

        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */

        break;

    case 0x08:

        apic_sync_vapic(s, SYNC_FROM_VAPIC);

        if (apic_report_tpr_access) {

            cpu_report_tpr_access(s->cpu_env, TPR_ACCESS_READ);

        }

        val = s->tpr;

        break;

    case 0x09:

        val = apic_get_arb_pri(s);

        break;

    case 0x0a:

        /* ppr */

        val = apic_get_ppr(s);

        break;

    case 0x0b:

        val = 0;

        break;

    case 0x0d:

        val = s->log_dest << 24;

        break;

    case 0x0e:

  ",0,0,2,0,1,0,0,0,0,1,0,0,0,0,0
25711,qemu,0,"static SocketAddressLegacy *tcp_build_address(const char *host_port, Error **errp)

{

    InetSocketAddress *iaddr = g_new(InetSocketAddress, 1);

    SocketAddressLegacy *saddr;



    if (inet_parse(iaddr, host_port, errp)) {

        qapi_free_InetSocketAddress(iaddr);

        return NULL;

    }



    saddr = g_new0(SocketAddressLegacy, 1);

    saddr->type = SOCKET_ADDRESS_LEGACY_KIND_INET;

    saddr->u.inet.data = iaddr;



    return saddr;

}
",0,0,1,0,0,0,0,1,1,1,0,1,0,0,0
25729,FFmpeg,1,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",0,0,2,0,0,1,0,0,1,0,0,0,1,1,0
25734,qemu,1,"static const QObject *qmp_input_get_object(QmpInputVisitor *qiv,

                                           const char *name)

{

    const QObject *qobj;



    if (qiv->nb_stack == 0) {

        qobj = qiv->obj;

    } else {

        qobj = qiv->stack[qiv->nb_stack - 1].obj;

    }



    if (name && qobject_type(qobj) == QTYPE_QDICT) {

        return qdict_get(qobject_to_qdict(qobj), name);

    } else if (qiv->nb_stack > 0 && qobject_type(qobj) == QTYPE_QLIST) {

        return qlist_entry_obj(qiv->stack[qiv->nb_stack - 1].entry);

    }



    return qobj;

}
",0,0,3,0,0,0,0,0,0,1,0,0,0,1,0
25737,FFmpeg,1,"static BufferPoolEntry *get_pool(AVBufferPool *pool)

{

    BufferPoolEntry *cur = NULL, *last = NULL;



    do {

        FFSWAP(BufferPoolEntry*, cur, last);

        cur = avpriv_atomic_ptr_cas((void * volatile *)&pool->pool, last, NULL);

        if (!cur)

            return NULL;

    } while (cur != last);



    return cur;

}
",0,0,1,0,0,1,1,1,1,1,1,1,0,0,0
25738,FFmpeg,1,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,

                          int *end_pos2)

{

    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *pos - *end_pos);

        *end_pos2 =

        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;

        *pos      = get_bits_count(&s->gb);

    }

}
",0,0,1,0,1,0,1,1,1,0,0,0,0,0,0
25741,qemu,1,"static int vpc_write(BlockDriverState *bs, int64_t sector_num,

    const uint8_t *buf, int nb_sectors)

{

    BDRVVPCState *s = bs->opaque;

    int64_t offset;

    int64_t sectors, sectors_per_block;

    int ret;

    VHDFooter *footer =  (VHDFooter *) s->footer_buf;



    if (cpu_to_be32(footer->type) == VHD_FIXED) {

        return bdrv_write(bs->file, sector_num, buf, nb_sectors);

    }

    while (nb_sectors > 0) {

        offset = get_sector_offset(bs, sector_num, 1);



        sectors_per_block = s->block_size >> BDRV_SECTOR_BITS;

        sectors = sectors_per_block - (sector_num % sectors_per_block);

        if (sectors > nb_sectors) {

            sectors = nb_sectors;

        }



        if (offset == -1) {

            offset = alloc_block(bs, sector_num);

            if (offset < 0)

                return -1;

        }



        ret = bdrv_pwrite(bs->file, offset, buf, sectors * BDRV_SECTOR_SIZE);

        if (ret != sectors * BDRV_SECTOR_SIZE) {

            return -1;

        }
",0,0,5,0,0,1,1,1,1,1,1,1,0,1,0
25748,FFmpeg,1,"static int read_old_huffman_tables(HYuvContext *s){

#if 1

    GetBitContext gb;

    int i;



    init_get_bits(&gb, classic_shift_luma, sizeof(classic_shift_luma)*8);

    if(read_len_table(s->len[0], &gb)<0)

        return -1;

    init_get_bits(&gb, classic_shift_chroma, sizeof(classic_shift_chroma)*8);

    if(read_len_table(s->len[1], &gb)<0)

        return -1;



    for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];

    for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];



    if(s->bitstream_bpp >= 24){

        memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32_t));

        memcpy(s->len[1] , s->len [0], 256*sizeof(uint8_t));

    }

    memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32_t));

    memcpy(s->len[2] , s->len [1], 256*sizeof(uint8_t));



    for(i=0; i<3; i++){

        ff_free_vlc(&s->vlc[i]);

        init_vlc(&s->vlc[i], VLC_BITS, 256, s->len[i], 1, 1, s->bits[i], 4, 4, 0);

    }



    generate_joint_tables(s);



    return 0;

#else

    av_log(s->avctx, AV_",3,0,8,0,0,0,1,1,1,0,1,1,0,0,0
25753,qemu,0,"exynos4_boards_init_common(MachineState *machine,

                           Exynos4BoardType board_type)

{

    Exynos4BoardState *s = g_new(Exynos4BoardState, 1);

    MachineClass *mc = MACHINE_GET_CLASS(machine);



    if (smp_cpus != EXYNOS4210_NCPUS && !qtest_enabled()) {

        error_report(""%s board supports only %d CPU cores, ignoring smp_cpus""

                     "" value"",

                     mc->name, EXYNOS4210_NCPUS);

    }



    exynos4_board_binfo.ram_size = exynos4_board_ram_size[board_type];

    exynos4_board_binfo.board_id = exynos4_board_id[board_type];

    exynos4_board_binfo.smp_bootreg_addr =

            exynos4_board_smp_bootreg_addr[board_type];

    exynos4_board_binfo.kernel_filename = machine->kernel_filename;

    exynos4_board_binfo.initrd_filename = machine->initrd_filename;

    exynos4_board_binfo.kernel_cmdline = machine->kernel_cmdline;

    exynos4_board_binfo.gic_cpu_if_addr =

            EXYNOS4210_SMP_PRIVATE_BASE_ADDR + 0x100;



    PRINT_DEBUG(""\n ram_si",0,0,2,0,0,0,0,0,0,0,0,0,0,0,0
25787,FFmpeg,1,"static void json_print_section_header(WriterContext *wctx)

{

    JSONContext *json = wctx->priv;

    AVBPrint buf;

    const struct section *section = wctx->section[wctx->level];

    const struct section *parent_section = wctx->level ?

        wctx->section[wctx->level-1] : NULL;



    if (wctx->level && wctx->nb_item[wctx->level-1])

        printf("",\n"");



    if (section->flags & SECTION_FLAG_IS_WRAPPER) {

        printf(""{\n"");

        json->indent_level++;

    } else {

        av_bprint_init(&buf, 1, AV_BPRINT_SIZE_UNLIMITED);

        json_escape_str(&buf, section->name, wctx);

        JSON_INDENT();



        json->indent_level++;

        if (section->flags & SECTION_FLAG_IS_ARRAY) {

            printf(""\""%s\"": [\n"", buf.str);

        } else if (!(parent_section->flags & SECTION_FLAG_IS_ARRAY)) {

            printf(""\""%s\"": {%s"", buf.str, json->item_start_end);

        } else {

            printf(""{%s"", json->item_start_end);



            /* this is required so the parser can dis",0,0,4,0,0,0,1,1,1,0,1,1,1,1,1
25810,qemu,0,"build_madt(GArray *table_data, BIOSLinker *linker, VirtGuestInfo *guest_info)

{

    int madt_start = table_data->len;

    const MemMapEntry *memmap = guest_info->memmap;

    const int *irqmap = guest_info->irqmap;

    AcpiMultipleApicTable *madt;

    AcpiMadtGenericDistributor *gicd;

    AcpiMadtGenericMsiFrame *gic_msi;

    int i;



    madt = acpi_data_push(table_data, sizeof *madt);



    gicd = acpi_data_push(table_data, sizeof *gicd);

    gicd->type = ACPI_APIC_GENERIC_DISTRIBUTOR;

    gicd->length = sizeof(*gicd);

    gicd->base_address = memmap[VIRT_GIC_DIST].base;

    gicd->version = guest_info->gic_version;



    for (i = 0; i < guest_info->smp_cpus; i++) {

        AcpiMadtGenericInterrupt *gicc = acpi_data_push(table_data,

                                                     sizeof *gicc);

        ARMCPU *armcpu = ARM_CPU(qemu_get_cpu(i));



        gicc->type = ACPI_APIC_GENERIC_INTERRUPT;

        gicc->length = sizeof(*gicc);

        if (guest_info->gic_version == 2) {

      ",1,0,1,0,0,0,1,1,1,1,1,1,0,1,0
25813,qemu,0,"int slirp_can_output(void)

{

    return !slirp_vc || qemu_can_send_packet(slirp_vc);

}
",0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
25814,qemu,0,"static void usb_tablet_class_initfn(ObjectClass *klass, void *data)

{

    USBDeviceClass *uc = USB_DEVICE_CLASS(klass);



    uc->init           = usb_tablet_initfn;

    uc->product_desc   = ""QEMU USB Tablet"";

    uc->usb_desc       = &desc_tablet;

    uc->handle_packet  = usb_generic_handle_packet;

    uc->handle_reset   = usb_hid_handle_reset;

    uc->handle_control = usb_hid_handle_control;

    uc->handle_data    = usb_hid_handle_data;

    uc->handle_destroy = usb_hid_handle_destroy;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
25828,FFmpeg,1,"static int pixlet_decode_frame(AVCodecContext *avctx, void *data,
                               int *got_frame, AVPacket *avpkt)
{
    PixletContext *ctx = avctx->priv_data;
    int i, w, h, width, height, ret, version;
    AVFrame *p = data;
    ThreadFrame frame = { .f = data };
    uint32_t pktsize;
    bytestream2_init(&ctx->gb, avpkt->data, avpkt->size);
    pktsize = bytestream2_get_be32(&ctx->gb);
    if (pktsize <= 44 || pktsize - 4 > bytestream2_get_bytes_left(&ctx->gb)) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid packet size %""PRIu32""\n"", pktsize);
    }
    version = bytestream2_get_le32(&ctx->gb);
    if (version != 1)
        avpriv_request_sample(avctx, ""Version %d"", version);
    bytestream2_skip(&ctx->gb, 4);
    if (bytestream2_get_be32(&ctx->gb) != 1)
    bytestream2_skip(&ctx->gb, 4);
    width  = bytestream2_get_be32(&ctx->gb);
    height = bytestream2_get_be32(&ctx->gb);
    w = FFALIGN(width,  1 << (NB_LEVELS + 1));
    h = FFALIGN(height, 1 << (NB_LEVELS + 1));
    ctx->levels = byt",0,0,3,0,0,0,0,1,1,0,1,0,1,0,0
25831,qemu,1,"static void ccw_machine_2_9_class_options(MachineClass *mc)

{

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->gs_allowed = false;

    ccw_machine_2_10_class_options(mc);

    SET_MACHINE_COMPAT(mc, CCW_COMPAT_2_9);

    s390mc->css_migration_enabled = false;

}
",0,0,0,0,0,0,1,1,1,0,0,1,0,0,0
25854,FFmpeg,1,"static int matroska_read_header(AVFormatContext *s)

{

    MatroskaDemuxContext *matroska = s->priv_data;

    EbmlList *attachements_list = &matroska->attachments;

    MatroskaAttachement *attachements;

    EbmlList *chapters_list = &matroska->chapters;

    MatroskaChapter *chapters;

    MatroskaTrack *tracks;

    uint64_t max_start = 0;

    int64_t pos;

    Ebml ebml = { 0 };

    AVStream *st;

    int i, j, k, res;



    matroska->ctx = s;



    /* First read the EBML header. */

    if (ebml_parse(matroska, ebml_syntax, &ebml)

        || ebml.version > EBML_VERSION       || ebml.max_size > sizeof(uint64_t)

        || ebml.id_length > sizeof(uint32_t) || ebml.doctype_version > 3) {

        av_log(matroska->ctx, AV_LOG_ERROR,

               ""EBML header using unsupported features\n""

               ""(EBML version %""PRIu64"", doctype %s, doc version %""PRIu64"")\n"",

               ebml.version, ebml.doctype, ebml.doctype_version);

        ebml_free(ebml_syntax, &ebml);

        return AVERROR_P",0,0,1,0,0,0,0,0,0,0,1,1,1,0,0
25859,FFmpeg,1,"static int filter_frame(AVFilterLink *inlink, AVFrame *picref)

{

    AVFilterContext *ctx = inlink->dst;

    SignatureContext *sic = ctx->priv;

    StreamContext *sc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);

    FineSignature* fs;



    static const uint8_t pot3[5] = { 3*3*3*3, 3*3*3, 3*3, 3, 1 };

    /* indexes of words : 210,217,219,274,334  44,175,233,270,273  57,70,103,237,269  100,285,295,337,354  101,102,111,275,296

    s2usw = sorted to unsorted wordvec: 44 is at index 5, 57 at index 10...

    */

    static const unsigned int wordvec[25] = {44,57,70,100,101,102,103,111,175,210,217,219,233,237,269,270,273,274,275,285,295,296,334,337,354};

    static const uint8_t      s2usw[25]   = { 5,10,11, 15, 20, 21, 12, 22,  6,  0,  1,  2,  7, 13, 14,  8,  9,  3, 23, 16, 17, 24,  4, 18, 19};



    uint8_t wordt2b[5] = { 0, 0, 0, 0, 0 }; /* word ternary to binary */

    uint64_t intpic[32][32];

    uint64_t rowcount;

    uint8_t *p = picref->data[0];

    int inti, intj;

    int *intjlut;



 ",0,0,0,0,0,0,1,1,1,1,1,1,1,1,1
25862,qemu,1,"static void test_dma_fragmented(void)

{

    AHCIQState *ahci;

    AHCICommand *cmd;

    uint8_t px;

    size_t bufsize = 4096;

    unsigned char *tx = g_malloc(bufsize);

    unsigned char *rx = g_malloc0(bufsize);

    uint64_t ptr;



    ahci = ahci_boot_and_enable(NULL);

    px = ahci_port_select(ahci);

    ahci_port_clear(ahci, px);



    /* create pattern */

    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);



    /* Create a DMA buffer in guest memory, and write our pattern to it. */

    ptr = guest_alloc(ahci->parent->alloc, bufsize);

    g_assert(ptr);

    bufwrite(ptr, tx, bufsize);



    cmd = ahci_command_create(CMD_WRITE_DMA);

    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);

    ahci_command_commit(ahci, cmd, px);

    ahci_command_issue(ahci, cmd);

    ahci_command_verify(ahci, cmd);

    g_free(cmd);



    cmd = ahci_command_create(CMD_READ_DMA);

    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);

    ahci_command_commit(ahci, cmd, px);

    ahci_command_issue(ahci, cmd)",0,0,1,0,0,0,0,0,0,1,1,0,1,1,1
25865,qemu,1,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    uint32_t val = 0;

    struct pci_status *g = opaque;

    switch (addr) {

        case PCI_BASE:

            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);

    return val;

}
",0,0,0,0,1,0,0,0,0,1,1,0,0,1,1
25868,FFmpeg,1,"static int w64_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    int64_t size;

    AVIOContext *pb  = s->pb;

    WAVContext    *wav = s->priv_data;

    AVStream *st;

    uint8_t guid[16];



    avio_read(pb, guid, 16);

    if (memcmp(guid, guid_riff, 16))

        return -1;



    if (avio_rl64(pb) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */

        return -1;



    avio_read(pb, guid, 16);

    if (memcmp(guid, guid_wave, 16)) {

        av_log(s, AV_LOG_ERROR, ""could not find wave guid\n"");

        return -1;

    }



    size = find_guid(pb, guid_fmt);

    if (size < 0) {

        av_log(s, AV_LOG_ERROR, ""could not find fmt guid\n"");

        return -1;

    }



    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR(ENOMEM);



    /* subtract chunk header size - normal wav file doesn't count it */

    ff_get_wav_header(pb, st->codec, size - 24);

    avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);



    st->need_parsing = AVSTREAM_PARSE_FULL;



 ",0,0,6,0,0,0,1,1,1,1,0,1,0,0,1
25869,FFmpeg,1,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",1,0,0,0,0,0,1,1,1,1,1,0,0,1,0
25872,qemu,1,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
25925,qemu,0,"static void uhci_async_complete_packet(USBPacket * packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCI_QH qh;

    UHCI_TD td;

    uint32_t link;

    uint32_t old_td_ctrl;

    uint32_t val;

    uint32_t frame_addr;

    int ret;



    /* Handle async isochronous packet completion */

    frame_addr = s->async_frame_addr;

    if (frame_addr) {

        cpu_physical_memory_read(frame_addr, (uint8_t *)&link, 4);

        le32_to_cpus(&link);



        cpu_physical_memory_read(link & ~0xf, (uint8_t *)&td, sizeof(td));

        le32_to_cpus(&td.link);

        le32_to_cpus(&td.ctrl);

        le32_to_cpus(&td.token);

        le32_to_cpus(&td.buffer);

        old_td_ctrl = td.ctrl;

        ret = uhci_handle_td(s, &td, &s->pending_int_mask, 1);



        /* update the status bits of the TD */

        if (old_td_ctrl != td.ctrl) {

            val = cpu_to_le32(td.ctrl);

            cpu_physical_memory_write((link & ~0xf) + 4,

                                      (const uint8_t *)&val,

    ",0,0,2,0,0,0,0,0,1,0,0,0,1,1,1
25932,qemu,0,"static void tracked_request_end(BdrvTrackedRequest *req)

{

    if (req->serialising) {

        req->bs->serialising_in_flight--;

    }



    QLIST_REMOVE(req, list);

    qemu_co_queue_restart_all(&req->wait_queue);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,1,1
25936,FFmpeg,0,"static int adpcm_decode_frame(AVCodecContext *avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    ADPCMDecodeContext *c = avctx->priv_data;

    ADPCMChannelStatus *cs;

    int n, m, channel, i;

    int block_predictor[2];

    short *samples;

    short *samples_end;

    const uint8_t *src;

    int st; /* stereo */



    /* DK3 ADPCM accounting variables */

    unsigned char last_byte = 0;

    unsigned char nibble;

    int decode_top_nibble_next = 0;

    int diff_channel;



    /* EA ADPCM state variables */

    uint32_t samples_in_chunk;

    int32_t previous_left_sample, previous_right_sample;

    int32_t current_left_sample, current_right_sample;

    int32_t next_left_sample, next_right_sample;

    int32_t coeff1l, coeff2l, coeff1r, coeff2r;

    uint8_t shift_left, shift_right;

    int count1, count2;

    int coeff[2][2], shift[2];//used in EA MAXIS ADP",0,0,4,0,0,0,0,0,0,0,1,0,0,1,0
25937,FFmpeg,0,"static int smacker_decode_header_tree(SmackVContext *smk, GetBitContext *gb, int **recodes, int *last, int size)

{

    int res;

    HuffContext huff;

    HuffContext tmp1, tmp2;

    VLC vlc[2] = { { 0 } };

    int escapes[3];

    DBCtx ctx;

    int err = 0;



    if(size >= UINT_MAX>>4){ // (((size + 3) >> 2) + 3) << 2 must not overflow

        av_log(smk->avctx, AV_LOG_ERROR, ""size too large\n"");

        return AVERROR_INVALIDDATA;

    }



    tmp1.length = 256;

    tmp1.maxlength = 0;

    tmp1.current = 0;

    tmp1.bits = av_mallocz(256 * 4);

    tmp1.lengths = av_mallocz(256 * sizeof(int));

    tmp1.values = av_mallocz(256 * sizeof(int));



    tmp2.length = 256;

    tmp2.maxlength = 0;

    tmp2.current = 0;

    tmp2.bits = av_mallocz(256 * 4);

    tmp2.lengths = av_mallocz(256 * sizeof(int));

    tmp2.values = av_mallocz(256 * sizeof(int));



    if(get_bits1(gb)) {

        smacker_decode_tree(gb, &tmp1, 0, 0);

        skip_bits1(gb);

        if(tmp1.current > 1) {

           ",0,0,3,0,0,0,0,1,1,1,0,0,1,0,0
25947,FFmpeg,1,"static int standard_decode_picture_primary_header(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    int status = 0;



    if (v->finterpflag) v->interpfrm = get_bits(gb, 1);

    skip_bits(gb, 2); //framecnt unused

    if (v->rangered) v->rangeredfrm = get_bits(gb, 1);

    v->s.pict_type = get_bits(gb, 1);

    if (v->s.avctx->max_b_frames)

    {

        if (!v->s.pict_type)

        {

            if (get_bits(gb, 1)) v->s.pict_type = I_TYPE;

            else v->s.pict_type = B_TYPE;

        }

        else v->s.pict_type = P_TYPE;

    }

    else v->s.pict_type++;



    switch (v->s.pict_type)

    {

    case I_TYPE: status = decode_i_picture_header(v); break;

    case P_TYPE: status = decode_p_picture_primary_header(v); break;

    case BI_TYPE:

    case B_TYPE: status = decode_b_picture_primary_header(v); break;

    }



    if (status == FRAME_SKIPED)

    {

      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");

      return status;

    }

    return 0;

}
",0,0,6,0,1,0,1,1,1,1,1,1,1,0,1
25948,FFmpeg,0,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);

    }

    fclose(f);

    return acl;

}
",1,0,4,0,0,1,0,0,0,0,0,1,0,0,0
25958,qemu,0,"static int discard_f(BlockBackend *blk, int argc, char **argv)

{

    struct timeval t1, t2;

    int Cflag = 0, qflag = 0;

    int c, ret;

    int64_t offset, count;



    while ((c = getopt(argc, argv, ""Cq"")) != -1) {

        switch (c) {

        case 'C':

            Cflag = 1;

            break;

        case 'q':

            qflag = 1;

            break;

        default:

            return qemuio_command_usage(&discard_cmd);

        }

    }



    if (optind != argc - 2) {

        return qemuio_command_usage(&discard_cmd);

    }



    offset = cvtnum(argv[optind]);

    if (offset < 0) {

        print_cvtnum_err(offset, argv[optind]);

        return 0;

    }



    optind++;

    count = cvtnum(argv[optind]);

    if (count < 0) {

        print_cvtnum_err(count, argv[optind]);

        return 0;

    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {

        printf(""length cannot exceed %""PRIu64"", given %s\n"",

               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,

               arg",0,0,4,0,1,1,0,1,1,1,0,0,0,1,1
25997,qemu,0,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,

                             hwaddr size)

{

    assert(mr->terminates);

    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,

                                        memory_region_get_dirty_log_mask(mr));

}
",0,0,0,0,0,0,0,0,0,1,1,0,0,1,0
26003,qemu,0,"static void vnc_display_print_local_addr(VncDisplay *vd)

{

    SocketAddressLegacy *addr;

    Error *err = NULL;



    if (!vd->nlsock) {

        return;

    }



    addr = qio_channel_socket_get_local_address(vd->lsock[0], &err);

    if (!addr) {

        return;

    }



    if (addr->type != SOCKET_ADDRESS_LEGACY_KIND_INET) {

        qapi_free_SocketAddressLegacy(addr);

        return;

    }

    error_printf_unless_qmp(""VNC server running on %s:%s\n"",

                            addr->u.inet.data->host,

                            addr->u.inet.data->port);

    qapi_free_SocketAddressLegacy(addr);

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
26008,qemu,0,"static int v9fs_synth_lstat(FsContext *fs_ctx,

                            V9fsPath *fs_path, struct stat *stbuf)

{

    V9fsSynthNode *node = *(V9fsSynthNode **)fs_path->data;



    v9fs_synth_fill_statbuf(node, stbuf);

    return 0;

}
",0,0,0,0,0,0,1,1,1,0,1,0,0,0,1
26030,FFmpeg,1,"static av_cold int qsv_decode_close(AVCodecContext *avctx)
{
    QSVOtherContext *s = avctx->priv_data;
    ff_qsv_decode_close(&s->qsv);
    qsv_clear_buffers(s);
    av_fifo_free(s->packet_fifo);
    return 0;
}",0,0,2,0,0,0,0,0,0,0,0,0,1,1,1
26031,FFmpeg,1,"int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,

                                const char *buf)

{

    const char *text = NULL;

    char new_line[2];

    int text_len = 0;



    while (*buf) {

        if (text && callbacks->text &&

            (sscanf(buf, ""\\%1[nN]"", new_line) == 1 ||

             !strncmp(buf, ""{\\"", 2))) {

            callbacks->text(priv, text, text_len);

            text = NULL;

        }

        if (sscanf(buf, ""\\%1[nN]"", new_line) == 1) {

            if (callbacks->new_line)

                callbacks->new_line(priv, new_line[0] == 'N');

            buf += 2;

        } else if (!strncmp(buf, ""{\\"", 2)) {

            buf++;

            while (*buf == '\\') {

                char style[2], c[2], sep[2], c_num[2] = ""0"", tmp[128] = {0};

                unsigned int color = 0xFFFFFFFF;

                int len, size = -1, an = -1, alpha = -1;

                int x1, y1, x2, y2, t1 = -1, t2 = -1;

                if (sscanf(buf, ""\\%1[bis",0,0,5,0,0,2,0,1,0,1,1,1,0,0,0
26038,FFmpeg,1,"static void compute_scale_factors(unsigned char scale_code[SBLIMIT],

                                  unsigned char scale_factors[SBLIMIT][3],

                                  int sb_samples[3][12][SBLIMIT],

                                  int sblimit)

{

    int *p, vmax, v, n, i, j, k, code;

    int index, d1, d2;

    unsigned char *sf = &scale_factors[0][0];



    for(j=0;j<sblimit;j++) {

        for(i=0;i<3;i++) {

            /* find the max absolute value */

            p = &sb_samples[i][0][j];

            vmax = abs(*p);

            for(k=1;k<12;k++) {

                p += SBLIMIT;

                v = abs(*p);

                if (v > vmax)

                    vmax = v;

            }

            /* compute the scale factor index using log 2 computations */

            if (vmax > 0) {

                n = av_log2(vmax);

                /* n is the position of the MSB of vmax. now

                   use at most 2 compares to find the index */

                index = (21 - n) * 3 ",3,0,2,0,0,0,1,1,1,1,1,1,1,1,1
26059,qemu,0,"static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    NVICState *s = (NVICState *)opaque;

    VecInfo *vec;



    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);



    vec = &s->vectors[irq];

    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);

    if (vec->pending) {

        vec->pending = 0;

        nvic_irq_update(s);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,0,0
26061,qemu,0,"static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
",1,0,0,1,0,0,0,0,0,0,0,0,0,0,0
26069,qemu,0,"static int scsi_qdev_exit(DeviceState *qdev)

{

    SCSIDevice *dev = SCSI_DEVICE(qdev);



    if (dev->vmsentry) {

        qemu_del_vm_change_state_handler(dev->vmsentry);

    }

    scsi_device_destroy(dev);

    return 0;

}
",0,0,1,0,0,0,1,0,0,0,0,0,0,0,0
26075,FFmpeg,0,"static int gen_sub_bitmap(TeletextContext *ctx, AVSubtitleRect *sub_rect, vbi_page *page, int chop_top)

{

    int resx = page->columns * BITMAP_CHAR_WIDTH;

    int resy = (page->rows - chop_top) * BITMAP_CHAR_HEIGHT;

    uint8_t ci, cmax = 0;

    int ret;

    vbi_char *vc = page->text + (chop_top * page->columns);

    vbi_char *vcend = page->text + (page->rows * page->columns);



    for (; vc < vcend; vc++) {

        if (vc->opacity != VBI_TRANSPARENT_SPACE) {

            cmax = VBI_NB_COLORS;

            break;

        }

    }



    if (cmax == 0) {

        av_log(ctx, AV_LOG_DEBUG, ""dropping empty page %3x\n"", page->pgno);

        sub_rect->type = SUBTITLE_NONE;

        return 0;

    }



    if ((ret = avpicture_alloc(&sub_rect->pict, AV_PIX_FMT_PAL8, resx, resy)) < 0)

        return ret;

    // Yes, we want to allocate the palette on our own because AVSubtitle works this way

    sub_rect->pict.data[1] = NULL;



    vbi_draw_vt_page_region(page, VBI_PIXFMT_PAL8,

                    ",1,0,3,0,0,0,0,0,0,0,0,0,1,0,1
26087,FFmpeg,1,"int opt_default(const char *opt, const char *arg)

{

    const AVOption *oc, *of, *os, *oswr;

    char opt_stripped[128];

    const char *p;

    const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class(), *sc, *swr_class;



    if (!(p = strchr(opt, ':')))

        p = opt + strlen(opt);

    av_strlcpy(opt_stripped, opt, FFMIN(sizeof(opt_stripped), p - opt + 1));



    if ((oc = av_opt_find(&cc, opt_stripped, NULL, 0,

                         AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)) ||

        ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') &&

         (oc = av_opt_find(&cc, opt + 1, NULL, 0, AV_OPT_SEARCH_FAKE_OBJ))))

        av_dict_set(&codec_opts, opt, arg, FLAGS(oc));

    if ((of = av_opt_find(&fc, opt, NULL, 0,

                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)))

        av_dict_set(&format_opts, opt, arg, FLAGS(of));

#if CONFIG_SWSCALE

    sc = sws_get_class();

    if ((os = av_opt_find(&sc, opt, NULL, 0,

                          AV_OPT_SE",2,0,5,0,0,0,1,1,1,1,1,1,1,1,1
26090,qemu,1,"static void slavio_misc_init(target_phys_addr_t base,

                             target_phys_addr_t aux1_base,

                             target_phys_addr_t aux2_base, qemu_irq irq,

                             qemu_irq fdc_tc)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""slavio_misc"");

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    if (base) {

        /* 8 bit registers */

        /* Slavio control */

        sysbus_mmio_map(s, 0, base + MISC_CFG);

        /* Diagnostics */

        sysbus_mmio_map(s, 1, base + MISC_DIAG);

        /* Modem control */

        sysbus_mmio_map(s, 2, base + MISC_MDM);

        /* 16 bit registers */

        /* ss600mp diag LEDs */

        sysbus_mmio_map(s, 3, base + MISC_LEDS);

        /* 32 bit registers */

        /* System control */

        sysbus_mmio_map(s, 4, base + MISC_SYS);

    }

    if (aux1_base) {

        /* AUX 1 (Misc System Functions) */

        sysbus_mmio_map(s, 5, aux1_base);

    }

    if (",0,0,3,0,0,0,0,0,0,1,1,1,0,1,1
26100,FFmpeg,1,"int check_tm_pred4x4_mode(int mode, int mb_x, int mb_y)

{

    if (!mb_x) {

        return mb_y ? VERT_VP8_PRED : DC_129_PRED;

    } else {

        return mb_y ? mode : HOR_VP8_PRED;

    }

}
",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
26110,FFmpeg,1,"static struct ResampleContext *create(struct ResampleContext *c, int out_rate, int in_rate, int filter_size, int phase_shift, int linear,

        double cutoff, enum AVSampleFormat format, enum SwrFilterType filter_type, double kaiser_beta, double precision, int cheby, int exact_rational){

    soxr_error_t error;



    soxr_datatype_t type =

        format == AV_SAMPLE_FMT_S16P? SOXR_INT16_S :

        format == AV_SAMPLE_FMT_S16 ? SOXR_INT16_I :

        format == AV_SAMPLE_FMT_S32P? SOXR_INT32_S :

        format == AV_SAMPLE_FMT_S32 ? SOXR_INT32_I :

        format == AV_SAMPLE_FMT_FLTP? SOXR_FLOAT32_S :

        format == AV_SAMPLE_FMT_FLT ? SOXR_FLOAT32_I :

        format == AV_SAMPLE_FMT_DBLP? SOXR_FLOAT64_S :

        format == AV_SAMPLE_FMT_DBL ? SOXR_FLOAT64_I : (soxr_datatype_t)-1;



    soxr_io_spec_t io_spec = soxr_io_spec(type, type);



    soxr_quality_spec_t q_spec = soxr_quality_spec((int)((precision-2)/4), (SOXR_HI_PREC_CLOCK|SOXR_ROLLOFF_NONE)*!!cheby);

    q_spec.precision = linear?",9,0,1,0,0,0,0,1,1,0,1,1,1,0,1
26113,qemu,0,"static void bdrv_put_buffer(void *opaque, const uint8_t *buf,

                            int64_t pos, int size)

{

    QEMUFileBdrv *s = opaque;

    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);

}
",0,0,0,0,0,0,1,1,1,1,1,1,1,1,0
26117,qemu,0,"static void qemu_clock_init(QEMUClockType type)

{

    QEMUClock *clock = qemu_clock_ptr(type);



    /* Assert that the clock of type TYPE has not been initialized yet. */

    assert(main_loop_tlg.tl[type] == NULL);



    clock->type = type;

    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);

    clock->last = INT64_MIN;

    QLIST_INIT(&clock->timerlists);

    notifier_list_init(&clock->reset_notifiers);

    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);

}
",0,0,2,0,0,0,0,0,0,0,0,0,0,1,0
26136,qemu,1,"static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)

{

    CharDriverState *chr;

    PtyCharDriver *s;

    struct termios tty;

    int master_fd, slave_fd, len;

#if defined(__OpenBSD__) || defined(__DragonFly__)

    char pty_name[PATH_MAX];

#define q_ptsname(x) pty_name

#else

    char *pty_name = NULL;

#define q_ptsname(x) ptsname(x)

#endif



    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {

        return NULL;

    }



    /* Set raw attributes on the pty. */

    tcgetattr(slave_fd, &tty);

    cfmakeraw(&tty);

    tcsetattr(slave_fd, TCSAFLUSH, &tty);

    close(slave_fd);



    chr = g_malloc0(sizeof(CharDriverState));



    len = strlen(q_ptsname(master_fd)) + 5;

    chr->filename = g_malloc(len);

    snprintf(chr->filename, len, ""pty:%s"", q_ptsname(master_fd));

    qemu_opt_set(opts, ""path"", q_ptsname(master_fd));

    fprintf(stderr, ""char device redirected to %s\n"", q_ptsname(master_fd));



    s = g_malloc0(sizeof(PtyCharDriver));

    chr->opaque = s;

 ",0,0,3,0,0,0,1,1,1,1,1,1,0,0,0
26152,qemu,0,"uint32_t HELPER(sigp)(CPUS390XState *env, uint64_t order_code, uint32_t r1,

                      uint64_t cpu_addr)

{

    int cc = SIGP_CC_ORDER_CODE_ACCEPTED;



    HELPER_LOG(""%s: %016"" PRIx64 "" %08x %016"" PRIx64 ""\n"",

               __func__, order_code, r1, cpu_addr);



    /* Remember: Use ""R1 or R1 + 1, whichever is the odd-numbered register""

       as parameter (input). Status (output) is always R1. */



    switch (order_code) {

    case SIGP_SET_ARCH:

        /* switch arch */

        break;

    case SIGP_SENSE:

        /* enumerate CPU status */

        if (cpu_addr) {

            /* XXX implement when SMP comes */

            return 3;

        }

        env->regs[r1] &= 0xffffffff00000000ULL;

        cc = 1;

        break;

#if !defined(CONFIG_USER_ONLY)

    case SIGP_RESTART:

        qemu_system_reset_request();

        cpu_loop_exit(CPU(s390_env_get_cpu(env)));

        break;

    case SIGP_STOP:

        qemu_system_shutdown_request();

        cpu_loop_exit(CPU(s390_env",0,0,2,0,1,0,0,1,0,0,0,0,1,0,1
26154,FFmpeg,0,"yuv2rgb_1_c_template(SwsContext *c, const uint16_t *buf0,

                     const uint16_t *ubuf0, const uint16_t *ubuf1,

                     const uint16_t *vbuf0, const uint16_t *vbuf1,

                     const uint16_t *abuf0, uint8_t *dest, int dstW,

                     int uvalpha, enum PixelFormat dstFormat,

                     int flags, int y, enum PixelFormat target,

                     int hasAlpha)

{

    int i;



    if (uvalpha < 2048) {

        for (i = 0; i < (dstW >> 1); i++) {

            int Y1 = buf0[i * 2]     >> 7;

            int Y2 = buf0[i * 2 + 1] >> 7;

            int U  = ubuf1[i]        >> 7;

            int V  = vbuf1[i]        >> 7;

            int A1, A2;

            const void *r =  c->table_rV[V],

                       *g = (c->table_gU[U] + c->table_gV[V]),

                       *b =  c->table_bU[U];



            if (hasAlpha) {

                A1 = abuf0[i * 2    ] >> 7;

                A2 = abuf0[i * 2 + 1] >> 7;

            }



           ",1,0,2,0,0,0,0,0,0,0,0,0,1,0,0
26158,qemu,0,"static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,

                void *src)

{

    int result = 0;



    if (secn > 0) {

        uint32_t size = (uint32_t)secn * 512;

        const uint8_t *sp = (const uint8_t *)src;

        uint8_t *dp = 0;

        if (s->bdrv_cur) {

            dp = g_malloc(size);

            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {

                result = 1;

            }

        } else {

            if (sec + secn > s->secs_cur) {

                result = 1;

            } else {

                dp = (uint8_t *)s->current + (sec << 9);

            }

        }

        if (!result) {

            uint32_t i;

            for (i = 0; i < size; i++) {

                dp[i] &= sp[i];

            }

            if (s->bdrv_cur) {

                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;

            }

        }

        if (dp && s->bdrv_cur) {

            g_free(dp);

        }

    }



    return result;

}
",1,0,7,0,0,0,0,0,0,0,1,1,1,1,0
26160,qemu,0,"static int nbd_receive_list(QIOChannel *ioc, char **name, Error **errp)

{

    uint64_t magic;

    uint32_t opt;

    uint32_t type;

    uint32_t len;

    uint32_t namelen;

    int error;



    *name = NULL;

    if (read_sync(ioc, &magic, sizeof(magic)) != sizeof(magic)) {

        error_setg(errp, ""failed to read list option magic"");

        return -1;

    }

    magic = be64_to_cpu(magic);

    if (magic != NBD_REP_MAGIC) {

        error_setg(errp, ""Unexpected option list magic"");

        return -1;

    }

    if (read_sync(ioc, &opt, sizeof(opt)) != sizeof(opt)) {

        error_setg(errp, ""failed to read list option"");

        return -1;

    }

    opt = be32_to_cpu(opt);

    if (opt != NBD_OPT_LIST) {

        error_setg(errp, ""Unexpected option type %"" PRIx32 "" expected %x"",

                   opt, NBD_OPT_LIST);

        return -1;

    }



    if (read_sync(ioc, &type, sizeof(type)) != sizeof(type)) {

        error_setg(errp, ""failed to read list option type"");

        return -1;

 ",0,0,5,0,0,0,0,0,0,0,0,0,0,0,0
26173,FFmpeg,1,"static int hwupload_query_formats(AVFilterContext *avctx)

{

    HWUploadContext *ctx = avctx->priv;

    AVHWFramesConstraints *constraints = NULL;

    const enum AVPixelFormat *input_pix_fmts, *output_pix_fmts;

    AVFilterFormats *input_formats = NULL;

    int err, i;



    if (!avctx->hw_device_ctx) {

        av_log(ctx, AV_LOG_ERROR, ""A hardware device reference is required ""

               ""to upload frames to.\n"");

        return AVERROR(EINVAL);

    }



    ctx->hwdevice_ref = av_buffer_ref(avctx->hw_device_ctx);

    if (!ctx->hwdevice_ref)

        return AVERROR(ENOMEM);

    ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdevice_ref->data;



    constraints = av_hwdevice_get_hwframe_constraints(ctx->hwdevice_ref, NULL);

    if (!constraints) {

        err = AVERROR(EINVAL);

        goto fail;

    }



    input_pix_fmts  = constraints->valid_sw_formats;

    output_pix_fmts = constraints->valid_hw_formats;



    input_formats = ff_make_format_list(output_pix_fmts);

    if (!input_forma",7,1,4,0,0,0,1,1,1,1,1,1,0,0,0
26175,qemu,1,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}
",0,0,2,0,0,0,1,1,0,1,1,0,1,0,0
26183,FFmpeg,1,"void ff_MPV_frame_end(MpegEncContext *s)

{

    int i;

    /* redraw edges for the frame if decoding didn't complete */

    // just to make sure that all data is rendered.

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {

        ff_xvmc_field_end(s);

   } else if((s->error_count || s->encoding || !(s->avctx->codec->capabilities&CODEC_CAP_DRAW_HORIZ_BAND)) &&

              !s->avctx->hwaccel &&

              !(s->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU) &&

              s->unrestricted_mv &&

              s->current_picture.f.reference &&

              !s->intra_only &&

              !(s->flags & CODEC_FLAG_EMU_EDGE)) {

        int hshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_w;

        int vshift = av_pix_fmt_descriptors[s->avctx->pix_fmt].log2_chroma_h;

        s->dsp.draw_edges(s->current_picture.f.data[0], s->current_picture.f.linesize[0],

                          s->h_edge_pos, s->v_edge_pos,

                          EDGE_WIDTH, EDGE_WIDT",0,0,4,0,0,0,0,1,1,0,0,0,0,0,1
26191,qemu,0,"int qemu_get_buffer(QEMUFile *f, uint8_t *buf, int size1)

{

    int size, l;



    if (f->is_write)

        abort();



    size = size1;

    while (size > 0) {

        l = f->buf_size - f->buf_index;

        if (l == 0) {

            qemu_fill_buffer(f);

            l = f->buf_size - f->buf_index;

            if (l == 0)

                break;

        }

        if (l > size)

            l = size;

        memcpy(buf, f->buf + f->buf_index, l);

        f->buf_index += l;

        buf += l;

        size -= l;

    }

    return size1 - size;

}
",0,0,4,0,0,1,0,0,0,0,0,0,1,1,1
26225,qemu,0,"void *rom_ptr(target_phys_addr_t addr)

{

    Rom *rom;



    rom = find_rom(addr);

    if (!rom || !rom->data)

        return NULL;

    return rom->data + (addr - rom->addr);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
26226,qemu,0,"static void *do_data_decompress(void *opaque)

{

    DecompressParam *param = opaque;

    unsigned long pagesize;



    while (!quit_decomp_thread) {

        qemu_mutex_lock(&param->mutex);

        while (!param->start && !quit_decomp_thread) {

            qemu_cond_wait(&param->cond, &param->mutex);

        }

        if (!quit_decomp_thread) {

            pagesize = TARGET_PAGE_SIZE;

            /* uncompress() will return failed in some case, especially

             * when the page is dirted when doing the compression, it's

             * not a problem because the dirty page will be retransferred

             * and uncompress() won't break the data in other pages.

             */

            uncompress((Bytef *)param->des, &pagesize,

                       (const Bytef *)param->compbuf, param->len);

        }

        param->start = false;

        qemu_mutex_unlock(&param->mutex);



        qemu_mutex_lock(&decomp_done_lock);

        param->done = true;

        qemu_cond_signal(&decomp_",0,0,1,0,0,2,1,0,1,0,0,0,1,0,1
26234,qemu,1,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",2,3,5,0,0,0,0,0,0,1,0,0,1,1,1
26242,qemu,0,"static void apic_reset_common(DeviceState *dev)

{

    APICCommonState *s = APIC_COMMON(dev);

    APICCommonClass *info = APIC_COMMON_GET_CLASS(s);

    bool bsp;



    bsp = cpu_is_bsp(s->cpu);

    s->apicbase = APIC_DEFAULT_ADDRESS |

        (bsp ? MSR_IA32_APICBASE_BSP : 0) | MSR_IA32_APICBASE_ENABLE;



    s->vapic_paddr = 0;

    info->vapic_base_update(s);



    apic_init_reset(dev);



    if (bsp) {

        /*

         * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization

         * time typically by BIOS, so PIC interrupt can be delivered to the

         * processor when local APIC is enabled.

         */

        s->lvt[APIC_LVT_LINT0] = 0x700;

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,0,1
26243,qemu,0,"static void omap_pwt_init(target_phys_addr_t base, struct omap_mpu_state_s *s,

                omap_clk clk)

{

    int iomemtype;



    s->pwt.base = base;

    s->pwt.clk = clk;

    omap_pwt_reset(s);



    iomemtype = cpu_register_io_memory(0, omap_pwt_readfn,

                    omap_pwt_writefn, s);

    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
26245,qemu,0,"int vnc_hextile_send_framebuffer_update(VncState *vs, int x,

                                        int y, int w, int h)

{

    int i, j;

    int has_fg, has_bg;

    uint8_t *last_fg, *last_bg;

    VncDisplay *vd = vs->vd;



    last_fg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);

    last_bg = (uint8_t *) qemu_malloc(vd->server->pf.bytes_per_pixel);

    has_fg = has_bg = 0;

    for (j = y; j < (y + h); j += 16) {

        for (i = x; i < (x + w); i += 16) {

            vs->send_hextile_tile(vs, i, j,

                                  MIN(16, x + w - i), MIN(16, y + h - j),

                                  last_bg, last_fg, &has_bg, &has_fg);

        }

    }

    free(last_fg);

    free(last_bg);



    return 1;

}
",2,0,0,0,0,0,0,1,0,0,0,0,0,1,0
26251,qemu,0,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
",0,1,1,0,0,1,0,0,0,0,0,0,0,0,0
26257,qemu,0,"static int kvmppc_get_books_sregs(PowerPCCPU *cpu)

{

    CPUPPCState *env = &cpu->env;

    struct kvm_sregs sregs;

    int ret;

    int i;



    ret = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_SREGS, &sregs);

    if (ret < 0) {

        return ret;

    }



    if (!env->external_htab) {

        ppc_store_sdr1(env, sregs.u.s.sdr1);

    }



    /* Sync SLB */

#ifdef TARGET_PPC64

    /*

     * The packed SLB array we get from KVM_GET_SREGS only contains

     * information about valid entries. So we flush our internal copy

     * to get rid of stale ones, then put all valid SLB entries back

     * in.

     */

    memset(env->slb, 0, sizeof(env->slb));

    for (i = 0; i < ARRAY_SIZE(env->slb); i++) {

        target_ulong rb = sregs.u.s.ppc64.slb[i].slbe;

        target_ulong rs = sregs.u.s.ppc64.slb[i].slbv;

        /*

         * Only restore valid entries

         */

        if (rb & SLB_ESID_V) {

            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);

        }

    }

#endif



    /",2,0,5,0,0,0,0,0,0,0,0,0,0,0,0
26259,qemu,0,"static void integratorcp_init(ram_addr_t ram_size, int vga_ram_size,

                     const char *boot_device, DisplayState *ds,

                     const char *kernel_filename, const char *kernel_cmdline,

                     const char *initrd_filename, const char *cpu_model)

{

    CPUState *env;

    uint32_t ram_offset;

    qemu_irq *pic;

    qemu_irq *cpu_pic;

    int sd;



    if (!cpu_model)

        cpu_model = ""arm926"";

    env = cpu_init(cpu_model);

    if (!env) {

        fprintf(stderr, ""Unable to find CPU definition\n"");

        exit(1);

    }

    ram_offset = qemu_ram_alloc(ram_size);

    /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash.  */

    /* ??? RAM should repeat to fill physical memory space.  */

    /* SDRAM at address zero*/

    cpu_register_physical_memory(0, ram_size, ram_offset | IO_MEM_RAM);

    /* And again at address 0x80000000 */

    cpu_register_physical_memory(0x80000000, ram_size, ram_offset | IO_MEM_RAM);



    integratorcm_in",0,0,2,0,0,0,0,0,0,0,1,0,0,0,0
26291,qemu,1,"void hmp_cont(Monitor *mon, const QDict *qdict)

{

    BlockInfoList *bdev_list, *bdev;

    Error *err = NULL;



    bdev_list = qmp_query_block(NULL);

    for (bdev = bdev_list; bdev; bdev = bdev->next) {

        if (key_is_missing(bdev->value)) {

            monitor_read_block_device_key(mon, bdev->value->device,

                                          hmp_cont_cb, NULL);

            goto out;

        }

    }



    qmp_cont(&err);

    hmp_handle_error(mon, &err);



out:

    qapi_free_BlockInfoList(bdev_list);

}
",1,1,1,0,0,0,1,1,1,0,1,0,0,0,0
26294,FFmpeg,1,"static int decode_5(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, dst, ctx->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    npixels = ctx->npixels;

    frm = ctx->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}
",0,0,5,0,0,1,1,1,1,1,0,0,0,1,1
26306,qemu,1,"static void aux_bridge_init(Object *obj)

{

    AUXTOI2CState *s = AUXTOI2C(obj);



    s->i2c_bus = i2c_init_bus(DEVICE(obj), ""aux-i2c"");

}
",0,0,0,0,0,0,0,1,1,0,0,0,1,1,1
26315,qemu,1,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
",0,0,0,0,0,0,0,0,0,1,0,0,0,0,1
26320,qemu,1,"static int add_graphics_client(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    const char *protocol  = qdict_get_str(qdict, ""protocol"");

    const char *fdname = qdict_get_str(qdict, ""fdname"");

    CharDriverState *s;



    if (strcmp(protocol, ""spice"") == 0) {

        int fd = monitor_get_fd(mon, fdname, NULL);

        int skipauth = qdict_get_try_bool(qdict, ""skipauth"", 0);

        int tls = qdict_get_try_bool(qdict, ""tls"", 0);

        if (!using_spice) {

            /* correct one? spice isn't a device ,,, */

            qerror_report(QERR_DEVICE_NOT_ACTIVE, ""spice"");

            return -1;

        }

        if (qemu_spice_display_add_client(fd, skipauth, tls) < 0) {

            close(fd);

        }

        return 0;

#ifdef CONFIG_VNC

    } else if (strcmp(protocol, ""vnc"") == 0) {

	int fd = monitor_get_fd(mon, fdname, NULL);

        int skipauth = qdict_get_try_bool(qdict, ""skipauth"", 0);

	vnc_display_add_client(NULL, fd, skipauth);

	return 0;

#endif

    } else if ((s =",0,0,7,0,0,0,1,1,1,1,1,1,1,1,1
26330,qemu,1,"static gboolean qio_channel_tls_handshake_io(QIOChannel *ioc,

                                             GIOCondition condition,

                                             gpointer user_data)

{

    QIOTask *task = user_data;

    QIOChannelTLS *tioc = QIO_CHANNEL_TLS(

        qio_task_get_source(task));



    qio_channel_tls_handshake_task(

       tioc, task);



    object_unref(OBJECT(tioc));



    return FALSE;

}
",0,0,0,0,0,0,0,0,0,0,1,0,1,1,1
26333,qemu,1,"static void pm_update_sci(VT686PMState *s)

{

    int sci_level, pmsts;



    pmsts = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);

    sci_level = (((pmsts & s->ar.pm1.evt.en) &

                  (ACPI_BITMASK_RT_CLOCK_ENABLE |

                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0);

    qemu_set_irq(s->dev.irq[0], sci_level);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,1,0
26360,FFmpeg,0,"static void flat_print_key_prefix(WriterContext *wctx)

{

    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);

    }

}
",0,0,1,0,0,0,0,0,0,0,1,0,1,1,1
26367,FFmpeg,1,"static int sdp_parse_fmtp_config_h264(AVStream *stream,

                                      PayloadContext *h264_data,

                                      char *attr, char *value)

{

    AVCodecContext *codec = stream->codec;

    assert(codec->codec_id == CODEC_ID_H264);

    assert(h264_data != NULL);



    if (!strcmp(attr, ""packetization-mode"")) {

        av_log(codec, AV_LOG_DEBUG, ""RTP Packetization Mode: %d\n"", atoi(value));

        h264_data->packetization_mode = atoi(value);

        /*

         * Packetization Mode:

         * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed)

         * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed.

         * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A),

         *                      and 29 (FU-B) are allowed.

         */

        if (h264_data->packetization_mode > 1)

            av_log(codec, AV_LOG_ERROR,

                   ""Interleaved RTP mode is not supported yet."");

    } els",0,0,2,0,0,0,0,1,0,0,1,0,1,1,1
26388,qemu,1,"static int qcow2_create2(const char *filename, int64_t total_size,
                         const char *backing_file, const char *backing_format,
                         int flags, size_t cluster_size, int prealloc,
                         QEMUOptionParameter *options, int version,
                         Error **errp)
{
    /* Calculate cluster_bits */
    int cluster_bits;
    cluster_bits = ffs(cluster_size) - 1;
    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||
        (1 << cluster_bits) != cluster_size)
    {
        error_setg(errp, ""Cluster size must be a power of two between %d and ""
                   ""%dk"", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));
        return -EINVAL;
    /*
     * Open the image file and write a minimal qcow2 header.
     *
     * We keep things simple and start with a zero-sized image. We also
     * do without refcount blocks or a L1 table for now. We'll fix the
     * inconsistency later.
     *
     * We do need a refcount table b",2,0,1,0,0,0,0,0,0,0,0,0,0,1,0
26390,FFmpeg,0,"static void idr(H264Context *h){

    int i;

    ff_h264_remove_all_refs(h);

    h->prev_frame_num= -1;

    h->prev_frame_num_offset= 0;

    h->prev_poc_msb= 1<<16;

    h->prev_poc_lsb= 0;

    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)

        h->last_pocs[i] = INT_MIN;

}
",1,0,0,0,0,0,0,1,1,1,1,1,0,0,0
26396,qemu,0,"static void intel_hda_mmio_writel(void *opaque, target_phys_addr_t addr, uint32_t val)

{

    IntelHDAState *d = opaque;

    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);



    intel_hda_reg_write(d, reg, val, 0xffffffff);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
26428,FFmpeg,1,"static void abort_codec_experimental(AVCodec *c, int encoder)

{

    const char *codec_string = encoder ? ""encoder"" : ""decoder"";

    AVCodec *codec;

    av_log(NULL, AV_LOG_FATAL, ""%s '%s' is experimental and might produce bad ""

            ""results.\nAdd '-strict experimental' if you want to use it.\n"",

            codec_string, c->name);

    codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);

    if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))

        av_log(NULL, AV_LOG_FATAL, ""Or use the non experimental %s '%s'.\n"",

               codec_string, codec->name);

    exit(1);

}
",0,0,2,0,0,0,0,1,1,1,1,1,0,0,0
26435,FFmpeg,1,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}",1,0,0,0,0,0,1,1,1,1,1,1,0,0,0
26437,FFmpeg,1,"static int standard_decode_i_mbs(VC9Context *v)

{

    GetBitContext *gb = &v->s.gb;

    MpegEncContext *s = &v->s;

    int current_mb = 0; /* MB/Block Position info */

    uint8_t cbpcy[4], previous_cbpcy[4], predicted_cbpcy,

        *p_cbpcy /* Pointer to skip some math */;



    /* Reset CBPCY predictors */

    memset(v->previous_line_cbpcy, 0, s->mb_stride<<2);



    /* Select ttmb table depending on pq */

    if (v->pq < 5) v->ttmb_vlc = &vc9_ttmb_vlc[0];

    else if (v->pq < 13) v->ttmb_vlc = &vc9_ttmb_vlc[1];

    else v->ttmb_vlc = &vc9_ttmb_vlc[2];



    for (s->mb_y=0; s->mb_y<s->mb_height; s->mb_y++)

    {

        /* Init CBPCY for line */

        *((uint32_t*)previous_cbpcy) = 0x00000000;

        p_cbpcy = v->previous_line_cbpcy+4;



        for (s->mb_x=0; s->mb_x<s->mb_width; s->mb_x++, p_cbpcy += 4)

        {

            /* Get CBPCY */

            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);



            s->ac_pred = get_bits(gb, 1);



            /* TODO: Decod",2,0,2,0,0,0,1,0,1,1,1,1,1,1,0
26443,qemu,1,"static int jazz_led_init(SysBusDevice *dev)

{

    LedState *s = FROM_SYSBUS(LedState, dev);



    memory_region_init_io(&s->iomem, &led_ops, s, ""led"", 1);

    sysbus_init_mmio(dev, &s->iomem);



    s->ds = graphic_console_init(jazz_led_update_display,

                                 jazz_led_invalidate_display,

                                 jazz_led_screen_dump,

                                 jazz_led_text_update, s);



    return 0;

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,1,1
26451,qemu,0,"dma_read(void *opaque, target_phys_addr_t addr, unsigned int size)

{

        struct fs_dma_ctrl *ctrl = opaque;

	int c;

	uint32_t r = 0;



	if (size != 4) {

		dma_rinvalid(opaque, addr);

	}



	/* Make addr relative to this channel and bounded to nr regs.  */

	c = fs_channel(addr);

	addr &= 0xff;

	addr >>= 2;

	switch (addr)

	{

		case RW_STAT:

			r = ctrl->channels[c].state & 7;

			r |= ctrl->channels[c].eol << 5;

			r |= ctrl->channels[c].stream_cmd_src << 8;

			break;



		default:

			r = ctrl->channels[c].regs[addr];

			D(printf (""%s c=%d addr="" TARGET_FMT_plx ""\n"",

				  __func__, c, addr));

			break;

	}

	return r;

}
",0,0,1,0,1,0,0,0,0,1,0,1,0,1,0
26458,qemu,0,"static void pxa2xx_descriptor_load(struct pxa2xx_lcdc_s *s)

{

    struct pxa_frame_descriptor_s desc;

    target_phys_addr_t descptr;

    int i;



    for (i = 0; i < PXA_LCDDMA_CHANS; i ++) {

        s->dma_ch[i].source = 0;



        if (!s->dma_ch[i].up)

            continue;



        if (s->dma_ch[i].branch & FBR_BRA) {

            descptr = s->dma_ch[i].branch & FBR_SRCADDR;

            if (s->dma_ch[i].branch & FBR_BINT)

                pxa2xx_dma_bs_set(s, i);

            s->dma_ch[i].branch &= ~FBR_BRA;

        } else

            descptr = s->dma_ch[i].descriptor;



        if (!(descptr >= PXA2XX_SDRAM_BASE && descptr +

                    sizeof(desc) <= PXA2XX_SDRAM_BASE + phys_ram_size))

            continue;



        cpu_physical_memory_read(descptr, (void *)&desc, sizeof(desc));

        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);

        s->dma_ch[i].source = tswap32(desc.fsaddr);

        s->dma_ch[i].id = tswap32(desc.fidr);

        s->dma_ch[i].command = tswap32(de",1,0,4,0,0,0,0,0,0,0,0,0,0,0,1
26468,qemu,0,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
",2,1,1,0,0,0,1,1,0,0,0,0,0,1,1
26472,qemu,1,"void ppc_tlb_invalidate_all(CPUPPCState *env)

{

    switch (env->mmu_model) {

    case POWERPC_MMU_SOFT_6xx:

    case POWERPC_MMU_SOFT_74xx:

        ppc6xx_tlb_invalidate_all(env);

        break;

    case POWERPC_MMU_SOFT_4xx:

    case POWERPC_MMU_SOFT_4xx_Z:

        ppc4xx_tlb_invalidate_all(env);

        break;

    case POWERPC_MMU_REAL:

        cpu_abort(env, ""No TLB for PowerPC 4xx in real mode\n"");

        break;

    case POWERPC_MMU_MPC8xx:

        /* XXX: TODO */

        cpu_abort(env, ""MPC8xx MMU model is not implemented\n"");

        break;

    case POWERPC_MMU_BOOKE:

        tlb_flush(env, 1);

        break;

    case POWERPC_MMU_BOOKE206:

        booke206_flush_tlb(env, -1, 0);

        break;

    case POWERPC_MMU_32B:

    case POWERPC_MMU_601:

#if defined(TARGET_PPC64)

    case POWERPC_MMU_620:

    case POWERPC_MMU_64B:

    case POWERPC_MMU_2_06:


#endif /* defined(TARGET_PPC64) */

        tlb_flush(env, 1);

        break;

    default:

        /* XXX: TODO */

      ",1,0,2,0,1,0,1,1,1,1,1,1,0,0,0
26480,qemu,0,"uint32_t HELPER(lcebr)(CPUS390XState *env, uint32_t f1, uint32_t f2)

{

    env->fregs[f1].l.upper = float32_chs(env->fregs[f2].l.upper);



    return set_cc_nz_f32(env->fregs[f1].l.upper);

}
",0,0,0,0,0,0,0,0,1,1,0,0,0,0,0
26481,FFmpeg,0,"static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,

                    AVDictionary *opts, AVDictionary *opts2, int *is_http)

{

    HLSContext *c = s->priv_data;

    AVDictionary *tmp = NULL;

    const char *proto_name = NULL;

    int ret;



    av_dict_copy(&tmp, opts, 0);

    av_dict_copy(&tmp, opts2, 0);



    if (av_strstart(url, ""crypto"", NULL)) {

        if (url[6] == '+' || url[6] == ':')

            proto_name = avio_find_protocol_name(url + 7);

    }



    if (!proto_name)

        proto_name = avio_find_protocol_name(url);



    if (!proto_name)

        return AVERROR_INVALIDDATA;



    // only http(s) & file are allowed

    if (av_strstart(proto_name, ""file"", NULL)) {

        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {

            av_log(s, AV_LOG_ERROR,

                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""

                ""If you wish to override ",1,0,6,0,0,0,0,0,0,0,0,0,0,0,0
26485,qemu,0,"static int qemu_rdma_dest_init(RDMAContext *rdma, Error **errp)

{

    int ret = -EINVAL, idx;

    struct rdma_cm_id *listen_id;

    char ip[40] = ""unknown"";

    struct rdma_addrinfo *res;

    char port_str[16];



    for (idx = 0; idx < RDMA_WRID_MAX; idx++) {

        rdma->wr_data[idx].control_len = 0;

        rdma->wr_data[idx].control_curr = NULL;

    }



    if (rdma->host == NULL) {

        ERROR(errp, ""RDMA host is not set!"");

        rdma->error_state = -EINVAL;

        return -1;

    }

    /* create CM channel */

    rdma->channel = rdma_create_event_channel();

    if (!rdma->channel) {

        ERROR(errp, ""could not create rdma event channel"");

        rdma->error_state = -EINVAL;

        return -1;

    }



    /* create CM id */

    ret = rdma_create_id(rdma->channel, &listen_id, NULL, RDMA_PS_TCP);

    if (ret) {

        ERROR(errp, ""could not create cm_id!"");

        goto err_dest_init_create_listen_id;

    }



    snprintf(port_str, 16, ""%d"", rdma->port);

    port_st",1,1,3,0,0,0,1,0,0,0,1,1,0,0,0
26489,qemu,0,"int cksum(struct mbuf *m, int len)

{

	register uint16_t *w;

	register int sum = 0;

	register int mlen = 0;

	int byte_swapped = 0;



	union {

		uint8_t  c[2];

		uint16_t s;

	} s_util;

	union {

		uint16_t s[2];

		uint32_t l;

	} l_util;



	if (m->m_len == 0)

	   goto cont;

	w = mtod(m, uint16_t *);



	mlen = m->m_len;



	if (len < mlen)

	   mlen = len;

#ifdef DEBUG

	len -= mlen;

#endif

	/*

	 * Force to even boundary.

	 */

	if ((1 & (long) w) && (mlen > 0)) {

		REDUCE;

		sum <<= 8;

		s_util.c[0] = *(uint8_t *)w;

		w = (uint16_t *)((int8_t *)w + 1);

		mlen--;

		byte_swapped = 1;

	}

	/*

	 * Unroll the loop to make overhead from

	 * branches &c small.

	 */

	while ((mlen -= 32) >= 0) {

		sum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];

		sum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];

		sum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];

		sum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];

		w += 16;

	}

	mlen += 32;

	while ((mlen -= 8) >= 0) {

		sum += w[0]",0,1,5,0,0,2,0,0,0,0,0,0,0,1,0
26496,qemu,0,"void address_space_unmap(AddressSpace *as, void *buffer, target_phys_addr_t len,

                         int is_write, target_phys_addr_t access_len)

{

    if (buffer != bounce.buffer) {

        if (is_write) {

            ram_addr_t addr1 = qemu_ram_addr_from_host_nofail(buffer);

            while (access_len) {

                unsigned l;

                l = TARGET_PAGE_SIZE;

                if (l > access_len)

                    l = access_len;

                invalidate_and_set_dirty(addr1, l);

                addr1 += l;

                access_len -= l;

            }

        }

        if (xen_enabled()) {

            xen_invalidate_map_cache_entry(buffer);

        }

        return;

    }

    if (is_write) {

        address_space_write(as, bounce.addr, bounce.buffer, access_len);

    }

    qemu_vfree(bounce.buffer);

    bounce.buffer = NULL;

    cpu_notify_map_clients();

}
",0,0,6,0,0,1,0,1,1,1,1,0,0,0,0
26512,FFmpeg,1,"static av_cold int atrac3_decode_init(AVCodecContext *avctx)

{

    int i, ret;

    int version, delay, samples_per_frame, frame_factor;

    const uint8_t *edata_ptr = avctx->extradata;

    ATRAC3Context *q = avctx->priv_data;



    if (avctx->channels <= 0 || avctx->channels > 2) {

        av_log(avctx, AV_LOG_ERROR, ""Channel configuration error!\n"");


    }



    /* Take care of the codec-specific extradata. */

    if (avctx->extradata_size == 14) {

        /* Parse the extradata, WAV format */

        av_log(avctx, AV_LOG_DEBUG, ""[0-1] %d\n"",

               bytestream_get_le16(&edata_ptr));  // Unknown value always 1

        edata_ptr += 4;                             // samples per channel

        q->coding_mode = bytestream_get_le16(&edata_ptr);

        av_log(avctx, AV_LOG_DEBUG,""[8-9] %d\n"",

               bytestream_get_le16(&edata_ptr));  //Dupe of coding mode

        frame_factor = bytestream_get_le16(&edata_ptr);  // Unknown always 1

        av_log(avctx, AV_LOG_DEBUG,""[12-13] %d\",0,0,2,0,0,0,0,0,0,1,0,1,1,1,1
26530,qemu,1,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
",0,0,4,0,0,0,0,0,0,0,0,0,1,0,0
26531,qemu,1,"static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)

{

    TCGv_i64 tmp64 = tcg_temp_new_i64();



    tcg_gen_extu_i32_i64(tmp64, b);

    dead_tmp(b);

    tcg_gen_shli_i64(tmp64, tmp64, 32);

    tcg_gen_add_i64(a, tmp64, a);



    tcg_temp_free_i64(tmp64);

    return a;

}
",0,0,0,0,0,0,0,0,1,0,0,0,1,0,1
26535,qemu,0,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}
",1,0,0,0,0,0,0,0,0,1,1,1,1,1,0
26538,qemu,0,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
",0,0,0,0,0,0,1,1,1,0,1,0,0,0,1
26540,qemu,0,"static void sclp_set_write_mask(void)

{

    WriteEventMask *sccb = (void*)_sccb;



    sccb->h.length = sizeof(WriteEventMask);

    sccb->mask_length = sizeof(unsigned int);

    sccb->receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_receive_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->send_mask = SCLP_EVENT_MASK_MSG_ASCII;

    sccb->cp_send_mask = SCLP_EVENT_MASK_MSG_ASCII;



    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
26543,qemu,0,"void json_prop_int(QJSON *json, const char *name, int64_t val)

{

    json_emit_element(json, name);

    qstring_append_int(json->str, val);

}
",0,0,0,0,0,0,0,0,0,1,0,0,1,1,1
26552,qemu,0,"static void pm_update_sci(PIIX4PMState *s)

{

    int sci_level, pmsts;



    pmsts = acpi_pm1_evt_get_sts(&s->ar);

    sci_level = (((pmsts & s->ar.pm1.evt.en) &

                  (ACPI_BITMASK_RT_CLOCK_ENABLE |

                   ACPI_BITMASK_POWER_BUTTON_ENABLE |

                   ACPI_BITMASK_GLOBAL_LOCK_ENABLE |

                   ACPI_BITMASK_TIMER_ENABLE)) != 0) ||

        (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) &

          (PIIX4_PCI_HOTPLUG_STATUS | PIIX4_CPU_HOTPLUG_STATUS)) != 0);



    qemu_set_irq(s->irq, sci_level);

    /* schedule a timer interruption if needed */

    acpi_pm_tmr_update(&s->ar, (s->ar.pm1.evt.en & ACPI_BITMASK_TIMER_ENABLE) &&

                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));

}
",0,0,0,0,0,0,0,1,0,0,0,0,0,1,0
26559,FFmpeg,1,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)

{

    int bit;



    if(s->extra_bits){

        S <<= s->extra_bits;



        if(s->got_extra_bits){

            S |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);

        }

    }

    bit = (S & s->and) | s->or;

    return (((S + bit) << s->shift) - bit) << s->post_shift;

}
",0,0,4,0,0,0,0,0,0,1,0,0,0,0,1
26568,FFmpeg,0,"static int mxf_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)

{

    AVStream *st = s->streams[stream_index];

    int64_t seconds;

    MXFContext* mxf = s->priv_data;

    int64_t seekpos;

    int ret;

    MXFIndexTable *t;



    if (mxf->nb_index_tables <= 0) {

    if (!s->bit_rate)

        return AVERROR_INVALIDDATA;

    if (sample_time < 0)

        sample_time = 0;

    seconds = av_rescale(sample_time, st->time_base.num, st->time_base.den);



    if ((ret = avio_seek(s->pb, (s->bit_rate * seconds) >> 3, SEEK_SET)) < 0)

        return ret;

    ff_update_cur_dts(s, st, sample_time);

    mxf->current_edit_unit = sample_time;

    } else {

        t = &mxf->index_tables[0];



        /* clamp above zero, else ff_index_search_timestamp() returns negative

         * this also means we allow seeking before the start */

        sample_time = FFMAX(sample_time, 0);



        if (t->fake_index) {

            /* behave as if we have a proper index */

            ",1,0,5,0,0,0,1,1,1,0,1,0,0,0,0
26587,qemu,1,"if_start(Slirp *slirp)

{

    uint64_t now = qemu_get_clock_ns(rt_clock);

    int requeued = 0;

	struct mbuf *ifm, *ifqt;



	DEBUG_CALL(""if_start"");



	if (slirp->if_queued == 0)

	   return; /* Nothing to do */



 again:

        /* check if we can really output */

        if (!slirp_can_output(slirp->opaque))

            return;



	/*

	 * See which queue to get next packet from

	 * If there's something in the fastq, select it immediately

	 */

	if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {

		ifm = slirp->if_fastq.ifq_next;

	} else {

		/* Nothing on fastq, see if next_m is valid */

		if (slirp->next_m != &slirp->if_batchq)

		   ifm = slirp->next_m;

		else

		   ifm = slirp->if_batchq.ifq_next;



		/* Set which packet to send on next iteration */

		slirp->next_m = ifm->ifq_next;

	}

	/* Remove it from the queue */

	ifqt = ifm->ifq_prev;

	remque(ifm);

	slirp->if_queued--;



	/* If there are more packets for this session, re-queue them */

	if (ifm->ifs_next != /* ifm->ifs_prev !=",0,0,32,0,0,0,0,0,0,1,1,0,0,0,0
26595,qemu,0,"static void dump_human_image_check(ImageCheck *check)

{

    if (!(check->corruptions || check->leaks || check->check_errors)) {

        printf(""No errors were found on the image.\n"");

    } else {

        if (check->corruptions) {

            printf(""\n%"" PRId64 "" errors were found on the image.\n""

                ""Data may be corrupted, or further writes to the image ""

                ""may corrupt it.\n"",

                check->corruptions);

        }



        if (check->leaks) {

            printf(""\n%"" PRId64 "" leaked clusters were found on the image.\n""

                ""This means waste of disk space, but no harm to data.\n"",

                check->leaks);

        }



        if (check->check_errors) {

            printf(""\n%"" PRId64 "" internal errors have occurred during the check.\n"",

                check->check_errors);

        }

    }



    if (check->total_clusters != 0 && check->allocated_clusters != 0) {

        printf(""%"" PRId64 ""/%"" PRId64 ""= %0.2f%% allocated, %0.2f%% fra",0,0,5,0,0,0,0,0,0,0,0,0,0,0,1
26599,qemu,0,"float32 int32_to_float32( int32 a STATUS_PARAM )

{

    flag zSign;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    zSign = ( a < 0 );

    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );



}
",0,0,2,0,0,0,0,0,1,0,1,1,0,0,0
26620,qemu,1,"static int vfio_start_eventfd_injection(VFIOINTp *intp)

{

    int ret;



    ret = vfio_set_trigger_eventfd(intp, vfio_intp_interrupt);

    if (ret) {

        error_report(""vfio: Error: Failed to pass IRQ fd to the driver: %m"");

    }

    return ret;

}
",0,0,1,0,0,0,1,1,1,1,1,1,1,1,1
26642,qemu,1,"static int bt_hid_in(struct bt_hid_device_s *s)

{

    USBPacket p;



    p.pid = USB_TOKEN_IN;

    p.devep = 1;

    p.data = s->datain.buffer;

    p.len = sizeof(s->datain.buffer);

    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);



    return s->datain.len;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
26653,qemu,0,"void qmp_inject_nmi(Error **errp)

{

#if defined(TARGET_I386)

    CPUState *cs;



    CPU_FOREACH(cs) {

        X86CPU *cpu = X86_CPU(cs);



        if (!cpu->apic_state) {

            cpu_interrupt(cs, CPU_INTERRUPT_NMI);

        } else {

            apic_deliver_nmi(cpu->apic_state);

        }

    }

#else

    nmi_monitor_handle(monitor_get_cpu_index(), errp);

#endif

}
",0,0,3,0,0,0,1,1,1,0,0,1,0,0,0
26663,qemu,0,"eth_setup_ip4_fragmentation(const void *l2hdr, size_t l2hdr_len,

                            void *l3hdr, size_t l3hdr_len,

                            size_t l3payload_len,

                            size_t frag_offset, bool more_frags)

{

    if (eth_get_l3_proto(l2hdr, l2hdr_len) == ETH_P_IP) {

        uint16_t orig_flags;

        struct ip_header *iphdr = (struct ip_header *) l3hdr;

        uint16_t frag_off_units = frag_offset / IP_FRAG_UNIT_SIZE;

        uint16_t new_ip_off;



        assert(frag_offset % IP_FRAG_UNIT_SIZE == 0);

        assert((frag_off_units & ~IP_OFFMASK) == 0);



        orig_flags = be16_to_cpu(iphdr->ip_off) & ~(IP_OFFMASK|IP_MF);

        new_ip_off = frag_off_units | orig_flags  | (more_frags ? IP_MF : 0);

        iphdr->ip_off = cpu_to_be16(new_ip_off);

        iphdr->ip_len = cpu_to_be16(l3payload_len + l3hdr_len);

    }

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
26671,qemu,0,"float32 HELPER(ucf64_subs)(float32 a, float32 b, CPUUniCore32State *env)

{

    return float32_sub(a, b, &env->ucf64.fp_status);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
26673,qemu,0,"do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, sum;



    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    sum = (bsum[0] << 8) + bsum[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}
",1,0,0,0,0,0,0,0,0,1,0,0,0,1,1
26680,qemu,0,"static void ics_simple_realize(DeviceState *dev, Error **errp)

{

    ICSState *ics = ICS_SIMPLE(dev);



    if (!ics->nr_irqs) {

        error_setg(errp, ""Number of interrupts needs to be greater 0"");

        return;

    }

    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));

    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);



    qemu_register_reset(ics_simple_reset, dev);

}
",0,0,1,0,0,0,0,0,0,0,0,0,0,0,0
26701,qemu,0,"static void vnc_flush(VncState *vs)

{

    if (vs->output.offset)

	vnc_client_write(vs);

}
",0,0,1,0,0,0,0,0,0,1,1,1,1,1,1
26711,qemu,0,"static void do_subchannel_work(SubchDev *sch, ORB *orb)

{



    SCSW *s = &sch->curr_status.scsw;



    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {

        sch_handle_clear_func(sch);

    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {

        sch_handle_halt_func(sch);

    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {

        /* Triggered by both ssch and rsch. */

        sch_handle_start_func(sch, orb);

    } else {

        /* Cannot happen. */

        return;

    }

    css_inject_io_interrupt(sch);

}
",0,0,3,0,0,0,0,0,0,0,0,0,1,1,1
26725,qemu,1,"static int sd_snapshot_delete(BlockDriverState *bs,

                              const char *snapshot_id,

                              const char *name,

                              Error **errp)

{

    unsigned long snap_id = 0;

    char snap_tag[SD_MAX_VDI_TAG_LEN];

    Error *local_err = NULL;

    int fd, ret;

    char buf[SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN];

    BDRVSheepdogState *s = bs->opaque;

    unsigned int wlen = SD_MAX_VDI_LEN + SD_MAX_VDI_TAG_LEN, rlen = 0;

    uint32_t vid;

    SheepdogVdiReq hdr = {

        .opcode = SD_OP_DEL_VDI,

        .data_length = wlen,

        .flags = SD_FLAG_CMD_WRITE,

    };

    SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr;



    if (!remove_objects(s)) {

        return -1;

    }



    memset(buf, 0, sizeof(buf));

    memset(snap_tag, 0, sizeof(snap_tag));

    pstrcpy(buf, SD_MAX_VDI_LEN, s->name);

    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);

    if (ret || snap_id > UINT32_MAX) {

        error_setg(errp, ""Invalid snapshot ID",0,0,2,0,0,0,1,1,1,0,1,0,1,1,1
26726,qemu,1,"static int block_save_iterate(QEMUFile *f, void *opaque)

{

    int ret;

    int64_t last_ftell = qemu_ftell(f);



    DPRINTF(""Enter save live iterate submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* control the rate of transfer */

    blk_mig_lock();

    while ((block_mig_state.submitted +

            block_mig_state.read_done) * BLOCK_SIZE <

           qemu_file_get_rate_limit(f)) {

        blk_mig_unlock();

        if (block_mig_state.bulk_completed == 0) {

            /* first finish the bulk phase */

            if (blk_mig_save_bulked_block(f) == 0) {

                /* finished saving bulk on all devices */

                block_mig_state.bulk_completed = 1;

            }

            ret = 0;

        } else {

            /* Always called with iothread lock taken for

             * simplicity, block_save_complete al",1,0,3,0,0,1,0,0,0,0,1,0,0,0,0
26730,FFmpeg,0,"static av_cold int fft_init(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln)

{

    int i, n, n2;

    float alpha;



    n  = 1 << ln;

    n2 = n >> 1;



    FF_ALLOC_OR_GOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fft_alloc_fail);

    FF_ALLOC_OR_GOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fft_alloc_fail);



    for (i = 0; i < n2; i++) {

        alpha     = 2.0 * M_PI * i / n;

        mdct->costab[i] = FIX15(cos(alpha));

        mdct->sintab[i] = FIX15(sin(alpha));

    }



    return 0;

fft_alloc_fail:

    mdct_end(mdct);

    return AVERROR(ENOMEM);

}
",1,0,0,0,0,0,1,0,1,1,1,0,1,1,1
26734,qemu,1,"static always_inline void gen_intermediate_code_internal (CPUState *env,

                                                          TranslationBlock *tb,

                                                          int search_pc)

{

#if defined ALPHA_DEBUG_DISAS

    static int insn_count;

#endif

    DisasContext ctx, *ctxp = &ctx;

    target_ulong pc_start;

    uint32_t insn;

    uint16_t *gen_opc_end;

    CPUBreakpoint *bp;

    int j, lj = -1;

    int ret;

    int num_insns;

    int max_insns;



    pc_start = tb->pc;

    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;

    ctx.pc = pc_start;

    ctx.amask = env->amask;

#if defined (CONFIG_USER_ONLY)

    ctx.mem_idx = 0;

#else

    ctx.mem_idx = ((env->ps >> 3) & 3);

    ctx.pal_mode = env->ipr[IPR_EXC_ADDR] & 1;

#endif

    num_insns = 0;

    max_insns = tb->cflags & CF_COUNT_MASK;

    if (max_insns == 0)

        max_insns = CF_COUNT_MASK;



    gen_icount_start();

    for (ret = 0; ret == 0;) {

        if (unlikely(!TAILQ_EMPTY(&env->brea",1,0,6,0,0,0,0,0,1,0,1,1,0,1,0
26738,qemu,1,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
",0,0,0,0,0,0,0,1,0,1,1,1,1,0,1
26745,qemu,1,"static void nbd_client_closed(NBDClient *client)

{

    nb_fds--;

    if (nb_fds == 0 && !persistent && state == RUNNING) {

        state = TERMINATE;

    }

    nbd_update_server_watch();

    nbd_client_put(client);

}
",0,0,1,0,0,0,0,0,0,0,0,0,1,1,1
26749,qemu,1,"static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)

{

    NvmeSQueue *sq;

    NvmeCreateSq *c = (NvmeCreateSq *)cmd;



    uint16_t cqid = le16_to_cpu(c->cqid);

    uint16_t sqid = le16_to_cpu(c->sqid);

    uint16_t qsize = le16_to_cpu(c->qsize);

    uint16_t qflags = le16_to_cpu(c->sq_flags);

    uint64_t prp1 = le64_to_cpu(c->prp1);



    if (!cqid || nvme_check_cqid(n, cqid)) {

        return NVME_INVALID_CQID | NVME_DNR;

    }

    if (!sqid || !nvme_check_sqid(n, sqid)) {

        return NVME_INVALID_QID | NVME_DNR;

    }

    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {

        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;

    }

    if (!prp1 || prp1 & (n->page_size - 1)) {

        return NVME_INVALID_FIELD | NVME_DNR;

    }

    if (!(NVME_SQ_FLAGS_PC(qflags))) {

        return NVME_INVALID_FIELD | NVME_DNR;

    }

    sq = g_malloc0(sizeof(*sq));

    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);

    return NVME_SUCCESS;

}
",0,0,5,0,0,0,0,0,0,0,0,0,0,1,0
26774,FFmpeg,0,"void ff_ac3_bit_alloc_calc_mask(AC3BitAllocParameters *s, int16_t *band_psd,

                                int start, int end, int fast_gain, int is_lfe,

                                int dba_mode, int dba_nsegs, uint8_t *dba_offsets,

                                uint8_t *dba_lengths, uint8_t *dba_values,

                                int16_t *mask)

{

    int16_t excite[50]; /* excitation */

    int bin, k;

    int bndstrt, bndend, begin, end1, tmp;

    int lowcomp, fastleak, slowleak;



    /* excitation function */

    bndstrt = bin_to_band_tab[start];

    bndend = bin_to_band_tab[end-1] + 1;



    if (bndstrt == 0) {

        lowcomp = 0;

        lowcomp = calc_lowcomp1(lowcomp, band_psd[0], band_psd[1], 384);

        excite[0] = band_psd[0] - fast_gain - lowcomp;

        lowcomp = calc_lowcomp1(lowcomp, band_psd[1], band_psd[2], 384);

        excite[1] = band_psd[1] - fast_gain - lowcomp;

        begin = 7;

        for (bin = 2; bin < 7; bin++) {

            if (!(is_lfe && bi",1,0,2,0,0,0,1,1,1,1,1,1,0,0,0
26776,qemu,0,"static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,

                int x, int y, int w, int h)

{

    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];

    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;

    rect->x = x;

    rect->y = y;

    rect->w = w;

    rect->h = h;

}
",0,0,3,0,0,0,0,0,1,0,0,0,0,0,1
26777,qemu,0,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)

{

	if (dc->flagx_known) {

		if (dc->flags_x) {

			TCGv c;

            

			c = tcg_temp_new(TCG_TYPE_TL);

			t_gen_mov_TN_preg(c, PR_CCS);

			/* C flag is already at bit 0.  */

			tcg_gen_andi_tl(c, c, C_FLAG);

			tcg_gen_add_tl(d, d, c);

			tcg_temp_free(c);

		}

	} else {

		TCGv x, c;



		x = tcg_temp_new(TCG_TYPE_TL);

		c = tcg_temp_new(TCG_TYPE_TL);

		t_gen_mov_TN_preg(x, PR_CCS);

		tcg_gen_mov_tl(c, x);



		/* Propagate carry into d if X is set. Branch free.  */

		tcg_gen_andi_tl(c, c, C_FLAG);

		tcg_gen_andi_tl(x, x, X_FLAG);

		tcg_gen_shri_tl(x, x, 4);



		tcg_gen_and_tl(x, x, c);

		tcg_gen_add_tl(d, d, x);        

		tcg_temp_free(x);

		tcg_temp_free(c);

	}

}
",0,0,2,0,0,0,0,1,0,0,0,0,0,1,1
26780,qemu,0,"static void rtas_start_cpu(sPAPREnvironment *spapr,

                           uint32_t token, uint32_t nargs,

                           target_ulong args,

                           uint32_t nret, target_ulong rets)

{

    target_ulong id, start, r3;

    CPUState *cs;



    if (nargs != 3 || nret != 1) {

        rtas_st(rets, 0, -3);

        return;

    }



    id = rtas_ld(args, 0);

    start = rtas_ld(args, 1);

    r3 = rtas_ld(args, 2);



    cs = qemu_get_cpu(id);

    if (cs != NULL) {

        PowerPCCPU *cpu = POWERPC_CPU(cs);

        CPUPPCState *env = &cpu->env;



        if (!cs->halted) {

            rtas_st(rets, 0, -1);

            return;

        }



        /* This will make sure qemu state is up to date with kvm, and

         * mark it dirty so our changes get flushed back before the

         * new cpu enters */

        kvm_cpu_synchronize_state(cs);



        env->msr = (1ULL << MSR_SF) | (1ULL << MSR_ME);

        env->nip = start;

        env->gpr[3] = r3;

       ",1,0,3,0,0,0,0,0,1,0,0,0,1,1,1
26792,qemu,0,"int i2c_start_transfer(i2c_bus *bus, int address, int recv)

{

    DeviceState *qdev;

    i2c_slave *slave = NULL;



    LIST_FOREACH(qdev, &bus->qbus.children, sibling) {

        slave = I2C_SLAVE_FROM_QDEV(qdev);

        if (slave->address == address)

            break;

    }



    if (!slave)

        return 1;



    /* If the bus is already busy, assume this is a repeated

       start condition.  */

    bus->current_dev = slave;

    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);

    return 0;

}
",0,0,2,0,0,0,0,0,0,0,1,1,0,0,1
26819,FFmpeg,0,"static int aasc_decode_frame(AVCodecContext *avctx,

                              void *data, int *data_size,

                              AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    AascContext *s = avctx->priv_data;

    int compr, i, stride;



    s->frame.reference = 3;

    s->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &s->frame)) {

        av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed\n"");

        return -1;

    }



    compr = AV_RL32(buf);

    buf += 4;

    buf_size -= 4;

    switch (avctx->codec_tag) {

    case MKTAG('A', 'A', 'S', '4'):

        bytestream2_init(&s->gb, buf - 4, buf_size + 4);

        ff_msrle_decode(avctx, (AVPicture*)&s->frame, 8, &s->gb);

        break;

    case MKTAG('A', 'A', 'S', 'C'):

    switch(compr){

    case 0:

        stride = (avctx->width * 3 + 3) & ~3;

        for(i = avctx->height - 1; i >= 0; i--){

 ",1,0,1,0,2,0,1,1,1,1,1,1,1,1,1
26836,FFmpeg,1,"int ff_h264_field_end(H264Context *h, int in_setup)
{
    AVCodecContext *const avctx = h->avctx;
    int err = 0;
    h->mb_y = 0;
    if (CONFIG_H264_VDPAU_DECODER &&
        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)
        ff_vdpau_h264_set_reference_frames(h);
    if (in_setup || !(avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (!h->droppable) {
            err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);
            h->prev_poc_msb = h->poc_msb;
            h->prev_poc_lsb = h->poc_lsb;
        }
        h->prev_frame_num_offset = h->frame_num_offset;
        h->prev_frame_num        = h->frame_num;
        h->outputed_poc          = h->next_outputed_poc;
    }
    if (avctx->hwaccel) {
        if (avctx->hwaccel->end_frame(avctx) < 0)
            av_log(avctx, AV_LOG_ERROR,
                   ""hardware accelerator failed to decode picture\n"");
    }
    if (CONFIG_H264_VDPAU_DECODER &&
        h->avctx->codec->capabilities & CODEC_CAP_HWACCEL_VDPAU)
        f",0,0,6,0,0,0,0,0,0,0,0,0,1,0,0
26841,qemu,1,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                sdhci_write_block_to_card(s);

            }

        }

    }

}
",1,0,4,0,0,0,1,1,1,0,1,1,0,0,0
26848,qemu,1,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)

{

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_malloc0(sizeof(WinCharState));

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
",0,0,1,0,0,0,0,0,1,0,0,0,0,0,0
26862,FFmpeg,1,"static int sbr_hf_calc_npatches(AACContext *ac, SpectralBandReplication *sbr)

{

    int i, k, sb = 0;

    int msb = sbr->k[0];

    int usb = sbr->kx[1];

    int goal_sb = ((1000 << 11) + (sbr->sample_rate >> 1)) / sbr->sample_rate;



    sbr->num_patches = 0;



    if (goal_sb < sbr->kx[1] + sbr->m[1]) {

        for (k = 0; sbr->f_master[k] < goal_sb; k++) ;

    } else

        k = sbr->n_master;



    do {

        int odd = 0;

        for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) {

            sb = sbr->f_master[i];

            odd = (sb + sbr->k[0]) & 1;

        }



        sbr->patch_num_subbands[sbr->num_patches]  = FFMAX(sb - usb, 0);

        sbr->patch_start_subband[sbr->num_patches] = sbr->k[0] - odd - sbr->patch_num_subbands[sbr->num_patches];



        if (sbr->patch_num_subbands[sbr->num_patches] > 0) {

            usb = sb;

            msb = sb;

            sbr->num_patches++;

        } else

            msb = sbr->kx[1];



        if (sbr->f_master[k] - sb < 3",2,0,3,0,0,0,0,0,1,0,0,0,0,0,0
26873,qemu,0,"static void *thread_func(void *p)

{

    struct thread_info *info = p;



    rcu_register_thread();



    atomic_inc(&n_ready_threads);

    while (!atomic_mb_read(&test_start)) {

        cpu_relax();

    }



    rcu_read_lock();

    while (!atomic_read(&test_stop)) {

        info->r = xorshift64star(info->r);

        info->func(info);

    }

    rcu_read_unlock();



    rcu_unregister_thread();

    return NULL;

}
",0,0,1,0,0,2,0,0,0,0,0,0,0,0,0
26880,FFmpeg,0,"static int http_start_receive_data(HTTPContext *c)

{

    int fd;



    if (c->stream->feed_opened)

        return -1;



    /* Don't permit writing to this one */

    if (c->stream->readonly)

        return -1;



    /* open feed */

    fd = open(c->stream->feed_filename, O_RDWR);

    if (fd < 0) {

        http_log(""Error opening feeder file: %s\n"", strerror(errno));

        return -1;

    }

    c->feed_fd = fd;



    if (c->stream->truncate) {

        /* truncate feed file */

        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);

        ftruncate(c->feed_fd, FFM_PACKET_SIZE);

        http_log(""Truncating feed file '%s'\n"", c->stream->feed_filename);

    } else {

        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {

            http_log(""Error reading write index from feed file: %s\n"", strerror(errno));

            return -1;

        }

    }



    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);

    c->stream->feed_size = ls",0,0,5,0,0,0,0,0,0,1,1,0,0,0,0
26884,qemu,0,"static int usb_host_scan_dev(void *opaque, USBScanFunc *func)

{

    FILE *f = NULL;

    char line[1024];

    char buf[1024];

    int bus_num, addr, speed, device_count, class_id, product_id, vendor_id;

    char product_name[512];

    int ret = 0;



    if (!usb_host_device_path) {

        perror(""husb: USB Host Device Path not set"");

        goto the_end;

    }

    snprintf(line, sizeof(line), ""%s/devices"", usb_host_device_path);

    f = fopen(line, ""r"");

    if (!f) {

        perror(""husb: cannot open devices file"");

        goto the_end;

    }



    device_count = 0;

    bus_num = addr = class_id = product_id = vendor_id = 0;

    speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL) {

            break;

        }

        if (strlen(line) > 0) {

            line[strlen(line) - 1] = '\0';

        }

        if (line[0] == 'T' && line[1] == ':') {

            if (device_count && (vendor_id || product_id",1,2,6,0,0,0,0,0,0,0,1,0,0,0,0
26886,qemu,0,"static void ppc_cpu_class_init(ObjectClass *oc, void *data)

{

    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);

    CPUClass *cc = CPU_CLASS(oc);

    DeviceClass *dc = DEVICE_CLASS(oc);



    pcc->parent_realize = dc->realize;

    pcc->pvr = CPU_POWERPC_DEFAULT_MASK;

    pcc->pvr_mask = CPU_POWERPC_DEFAULT_MASK;

    pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_always;

    dc->realize = ppc_cpu_realizefn;

    dc->unrealize = ppc_cpu_unrealizefn;



    pcc->parent_reset = cc->reset;

    cc->reset = ppc_cpu_reset;



    cc->class_by_name = ppc_cpu_class_by_name;

    cc->has_work = ppc_cpu_has_work;

    cc->do_interrupt = ppc_cpu_do_interrupt;

    cc->dump_state = ppc_cpu_dump_state;

    cc->dump_statistics = ppc_cpu_dump_statistics;

    cc->set_pc = ppc_cpu_set_pc;

    cc->gdb_read_register = ppc_cpu_gdb_read_register;

    cc->gdb_write_register = ppc_cpu_gdb_write_register;

#ifdef CONFIG_USER_ONLY

    cc->handle_mmu_fault = ppc_cpu_handle_mmu_fault;

#else

    cc->get_phys_p",0,0,1,0,0,0,0,1,0,0,0,0,1,1,1
26904,qemu,0,"qemu_deliver_packet(VLANClientState *sender, const uint8_t *buf, int size)

{

    VLANClientState *vc;



    for (vc = sender->vlan->first_client; vc != NULL; vc = vc->next) {

        if (vc != sender && !vc->link_down) {

            vc->receive(vc->opaque, buf, size);

        }

    }

}
",1,0,1,0,0,0,0,0,0,1,0,1,1,1,1
26935,qemu,1,"void ppc970_irq_init (CPUState *env)

{

    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}
",0,0,0,0,0,0,0,0,0,1,0,1,0,1,0
26941,qemu,0,"static void do_interrupt_protected(CPUX86State *env, int intno, int is_int,

                                   int error_code, unsigned int next_eip,

                                   int is_hw)

{

    SegmentCache *dt;

    target_ulong ptr, ssp;

    int type, dpl, selector, ss_dpl, cpl;

    int has_error_code, new_stack, shift;

    uint32_t e1, e2, offset, ss = 0, esp, ss_e1 = 0, ss_e2 = 0;

    uint32_t old_eip, sp_mask;

    int vm86 = env->eflags & VM_MASK;



    has_error_code = 0;

    if (!is_int && !is_hw) {

        has_error_code = exception_has_error_code(intno);

    }

    if (is_int) {

        old_eip = next_eip;

    } else {

        old_eip = env->eip;

    }



    dt = &env->idt;

    if (intno * 8 + 7 > dt->limit) {

        raise_exception_err(env, EXCP0D_GPF, intno * 8 + 2);

    }

    ptr = dt->base + intno * 8;

    e1 = cpu_ldl_kernel(env, ptr);

    e2 = cpu_ldl_kernel(env, ptr + 4);

    /* check gate type */

    type = (e2 >> DESC_TYPE_SHIFT) & 0x1f;

    switch (type) ",0,0,4,0,1,0,0,0,0,0,0,0,0,1,0
26945,qemu,0,"static void kvm_start_vcpu(CPUState *env)

{

    env->thread = qemu_mallocz(sizeof(QemuThread));

    env->halt_cond = qemu_mallocz(sizeof(QemuCond));

    qemu_cond_init(env->halt_cond);

    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);

    while (env->created == 0)

        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);

}
",0,0,0,0,0,1,1,0,0,1,0,0,1,1,1
26946,qemu,0,"static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,

                                     bool secondary, target_ulong ptem,

                                     ppc_hash_pte64_t *pte)

{

    CPUPPCState *env = &cpu->env;

    int i;

    uint64_t token;

    target_ulong pte0, pte1;

    target_ulong pte_index;



    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;

    token = ppc_hash64_start_access(cpu, pte_index);

    if (!token) {

        return -1;

    }

    for (i = 0; i < HPTES_PER_GROUP; i++) {

        pte0 = ppc_hash64_load_hpte0(cpu, token, i);

        pte1 = ppc_hash64_load_hpte1(cpu, token, i);



        if ((pte0 & HPTE64_V_VALID)

            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))

            && HPTE64_V_COMPARE(pte0, ptem)) {

            pte->pte0 = pte0;

            pte->pte1 = pte1;

            ppc_hash64_stop_access(token);

            return (pte_index + i) * HASH_PTE_SIZE_64;

        }

    }

    ppc_hash64_stop_access(token);

    /*

     ",1,0,2,0,0,0,0,0,0,1,1,1,1,1,1
26947,FFmpeg,0,"static av_cold int dcadec_init(AVCodecContext *avctx)

{

    DCAContext *s = avctx->priv_data;



    s->avctx = avctx;

    s->core.avctx = avctx;

    s->exss.avctx = avctx;

    s->xll.avctx = avctx;

    s->lbr.avctx = avctx;



    ff_dca_init_vlcs();



    if (ff_dca_core_init(&s->core) < 0)

        return AVERROR(ENOMEM);



    if (ff_dca_lbr_init(&s->lbr) < 0)

        return AVERROR(ENOMEM);



    ff_dcadsp_init(&s->dcadsp);

    s->core.dcadsp = &s->dcadsp;

    s->xll.dcadsp = &s->dcadsp;

    s->lbr.dcadsp = &s->dcadsp;



    s->crctab = av_crc_get_table(AV_CRC_16_CCITT);



    switch (avctx->request_channel_layout & ~AV_CH_LAYOUT_NATIVE) {

    case 0:

        s->request_channel_layout = 0;

        break;

    case AV_CH_LAYOUT_STEREO:

    case AV_CH_LAYOUT_STEREO_DOWNMIX:

        s->request_channel_layout = DCA_SPEAKER_LAYOUT_STEREO;

        break;

    case AV_CH_LAYOUT_5POINT0:

        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;

        break;

    case AV_CH_LAYOUT_5",0,0,2,0,1,0,1,1,1,0,0,0,1,1,0
26971,FFmpeg,0,"static int vorbis_parse_setup_hdr_mappings(vorbis_context *vc) {

    GetBitContext *gb=&vc->gb;

    uint_fast8_t i, j;



    vc->mapping_count=get_bits(gb, 6)+1;

    vc->mappings=(vorbis_mapping *)av_mallocz(vc->mapping_count * sizeof(vorbis_mapping));



    AV_DEBUG("" There are %d mappings. \n"", vc->mapping_count);



    for(i=0;i<vc->mapping_count;++i) {

        vorbis_mapping *mapping_setup=&vc->mappings[i];



        if (get_bits(gb, 16)) {

            av_log(vc->avccontext, AV_LOG_ERROR, ""Other mappings than type 0 are not compliant with the Vorbis I specification. \n"");

            return 1;

        }

        if (get_bits1(gb)) {

            mapping_setup->submaps=get_bits(gb, 4)+1;

        } else {

            mapping_setup->submaps=1;

        }



        if (get_bits1(gb)) {

            mapping_setup->coupling_steps=get_bits(gb, 8)+1;

            mapping_setup->magnitude=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));

            mapping_setup->ang",1,0,4,0,0,0,0,0,0,0,0,0,1,1,0
26987,qemu,1,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
26988,FFmpeg,0,"static void vp6_parse_coeff_models(VP56Context *s)

{

    VP56RangeCoder *c = &s->c;

    VP56Model *model = s->modelp;

    int def_prob[11];

    int node, cg, ctx, pos;

    int ct;    /* code type */

    int pt;    /* plane type (0 for Y, 1 for U or V) */



    memset(def_prob, 0x80, sizeof(def_prob));



    for (pt=0; pt<2; pt++)

        for (node=0; node<11; node++)

            if (vp56_rac_get_prob(c, vp6_dccv_pct[pt][node])) {

                def_prob[node] = vp56_rac_gets_nn(c, 7);

                model->coeff_dccv[pt][node] = def_prob[node];

            } else if (s->framep[VP56_FRAME_CURRENT]->key_frame) {

                model->coeff_dccv[pt][node] = def_prob[node];

            }



    if (vp56_rac_get(c)) {

        for (pos=1; pos<64; pos++)

            if (vp56_rac_get_prob(c, vp6_coeff_reorder_pct[pos]))

                model->coeff_reorder[pos] = vp56_rac_gets(c, 4);

        vp6_coeff_order_table_init(s);

    }



    for (cg=0; cg<2; cg++)

        for (node=0; node<14; node+",5,0,4,0,0,0,1,1,1,1,1,1,0,1,1
26993,qemu,1,"test_opts_dict_unvisited(void)

{

    QemuOpts *opts;

    Visitor *v;

    UserDefOptions *userdef;



    opts = qemu_opts_parse(qemu_find_opts(""userdef""), ""i64x=0,bogus=1"", false,

                           &error_abort);



    v = opts_visitor_new(opts);

    /* BUG: bogus should be diagnosed */

    visit_type_UserDefOptions(v, NULL, &userdef, &error_abort);

    visit_free(v);

    qemu_opts_del(opts);

    qapi_free_UserDefOptions(userdef);

}
",0,0,0,0,0,0,0,1,0,1,0,1,0,0,0
27000,qemu,0,"static int64_t coroutine_fn parallels_co_get_block_status(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, int *pnum)

{

    BDRVParallelsState *s = bs->opaque;

    int64_t offset;



    qemu_co_mutex_lock(&s->lock);

    offset = block_status(s, sector_num, nb_sectors, pnum);

    qemu_co_mutex_unlock(&s->lock);



    if (offset < 0) {

        return 0;

    }



    return (offset << BDRV_SECTOR_BITS) |

        BDRV_BLOCK_DATA | BDRV_BLOCK_OFFSET_VALID;

}
",0,0,1,0,0,0,0,0,0,1,1,1,0,1,0
27007,qemu,0,"void helper_4xx_tlbwe_hi (target_ulong entry, target_ulong val)

{

    ppcemb_tlb_t *tlb;

    target_ulong page, end;



    LOG_SWTLB(""%s entry %d val "" TARGET_FMT_lx ""\n"", __func__, (int)entry,

              val);

    entry &= 0x3F;

    tlb = &env->tlb[entry].tlbe;

    /* Invalidate previous TLB (if it's valid) */

    if (tlb->prot & PAGE_VALID) {

        end = tlb->EPN + tlb->size;

        LOG_SWTLB(""%s: invalidate old TLB %d start "" TARGET_FMT_lx "" end ""

                  TARGET_FMT_lx ""\n"", __func__, (int)entry, tlb->EPN, end);

        for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE)

            tlb_flush_page(env, page);

    }

    tlb->size = booke_tlb_to_page_size((val >> 7) & 0x7);

    /* We cannot handle TLB size < TARGET_PAGE_SIZE.

     * If this ever occurs, one should use the ppcemb target instead

     * of the ppc or ppc64 one

     */

    if ((val & 0x40) && tlb->size < TARGET_PAGE_SIZE) {

        cpu_abort(env, ""TLB size "" TARGET_FMT_lu "" < %u ""

                  ",1,0,2,0,0,0,0,0,0,0,0,0,0,0,0
27021,qemu,1,"static void kvm_update_msi_routes_all(void *private, bool global,

                                      uint32_t index, uint32_t mask)

{

    int cnt = 0;

    MSIRouteEntry *entry;

    MSIMessage msg;

    /* TODO: explicit route update */

    QLIST_FOREACH(entry, &msi_route_list, list) {

        cnt++;

        msg = pci_get_msi_message(entry->dev, entry->vector);

        kvm_irqchip_update_msi_route(kvm_state, entry->virq,

                                     msg, entry->dev);

    }

    kvm_irqchip_commit_routes(kvm_state);

    trace_kvm_x86_update_msi_routes(cnt);

}
",0,0,0,0,0,0,1,0,1,0,0,0,0,0,0
27045,qemu,0,"static void spr_write_601_ubatu (void *opaque, int sprn)

{

    DisasContext *ctx = opaque;



    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);

    RET_STOP(ctx);

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,0,0
27046,qemu,0,"static void ide_sector_write(IDEState *s)

{

    int64_t sector_num;

    int ret, n, n1;



    s->status = READY_STAT | SEEK_STAT;

    sector_num = ide_get_sector(s);

#if defined(DEBUG_IDE)

    printf(""write sector=%Ld\n"", sector_num);

#endif

    n = s->nsector;

    if (n > s->req_nb_sectors)

        n = s->req_nb_sectors;

    ret = bdrv_write(s->bs, sector_num, s->io_buffer, n);

    s->nsector -= n;

    if (s->nsector == 0) {

        /* no more sector to write */

        ide_transfer_stop(s);

    } else {

        n1 = s->nsector;

        if (n1 > s->req_nb_sectors)

            n1 = s->req_nb_sectors;

        ide_transfer_start(s, s->io_buffer, 512 * n1, ide_sector_write);

    }

    ide_set_sector(s, sector_num + n);

    

#ifdef TARGET_I386

    if (win2k_install_hack) {

        /* It seems there is a bug in the Windows 2000 installer HDD

           IDE driver which fills the disk with empty logs when the

           IDE write IRQ comes too early. This hack tries to correct

        ",0,0,7,0,0,0,0,0,0,0,0,0,1,1,1
27048,qemu,0,"AioContext *iohandler_get_aio_context(void)

{

    iohandler_init();

    return iohandler_ctx;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,1
27056,qemu,0,"abi_long do_syscall(void *cpu_env, int num, abi_long arg1,

                    abi_long arg2, abi_long arg3, abi_long arg4,

                    abi_long arg5, abi_long arg6)

{

    abi_long ret;

    struct stat st;

    struct statfs stfs;

    void *p;



#ifdef DEBUG

    gemu_log(""syscall %d"", num);

#endif

    if(do_strace)

        print_syscall(num, arg1, arg2, arg3, arg4, arg5, arg6);



    switch(num) {

    case TARGET_NR_exit:

#ifdef CONFIG_USE_NPTL

      /* In old applications this may be used to implement _exit(2).

         However in threaded applictions it is used for thread termination,

         and _exit_group is used for application termination.

         Do thread termination if we have more then one thread.  */

      /* FIXME: This probably breaks if a signal arrives.  We should probably

         be disabling signals.  */

      if (first_cpu->next_cpu) {

          TaskState *ts;

          CPUState **lastp;

          CPUState *p;



          cpu_list_lock();

          lastp",2,0,7,0,1,0,0,1,1,1,1,1,0,1,0
27058,qemu,0,"cpu_x86_dump_seg_cache(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

                       const char *name, struct SegmentCache *sc)

{

#ifdef TARGET_X86_64

    if (env->hflags & HF_CS64_MASK) {

        cpu_fprintf(f, ""%-3s=%04x %016"" PRIx64 "" %08x %08x"", name,

                    sc->selector, sc->base, sc->limit, sc->flags);

    } else

#endif

    {

        cpu_fprintf(f, ""%-3s=%04x %08x %08x %08x"", name, sc->selector,

                    (uint32_t)sc->base, sc->limit, sc->flags);

    }



    if (!(env->hflags & HF_PE_MASK) || !(sc->flags & DESC_P_MASK))

        goto done;



    cpu_fprintf(f, "" DPL=%d "", (sc->flags & DESC_DPL_MASK) >> DESC_DPL_SHIFT);

    if (sc->flags & DESC_S_MASK) {

        if (sc->flags & DESC_CS_MASK) {

            cpu_fprintf(f, (sc->flags & DESC_L_MASK) ? ""CS64"" :

                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));

            cpu_fprintf(f, "" [%c%c"", (sc->flags & DESC_C_MASK) ? 'C' : '-',

                        (sc->flags & DESC_",0,1,6,0,0,0,0,0,0,0,0,0,0,0,0
27081,FFmpeg,1,"void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stride)

{

    int i;

    INIT_CLIP

    pixel *dst = (pixel*)_dst;

    dctcoef *block = (dctcoef*)_block;

    stride /= sizeof(pixel);



    block[0] += 1 << 5;



    for(i=0; i<4; i++){

        const int z0=  block[i + 4*0]     +  block[i + 4*2];

        const int z1=  block[i + 4*0]     -  block[i + 4*2];

        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];

        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);



        block[i + 4*0]= z0 + z3;

        block[i + 4*1]= z1 + z2;

        block[i + 4*2]= z1 - z2;

        block[i + 4*3]= z0 - z3;

    }



    for(i=0; i<4; i++){

        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];

        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];

        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];

        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);



        dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));

        dst[i ",2,0,0,0,0,0,1,1,0,0,0,0,1,1,1
27083,qemu,0,"static void disas_fp_ccomp(DisasContext *s, uint32_t insn)

{

    unsigned int mos, type, rm, cond, rn, op, nzcv;

    TCGv_i64 tcg_flags;

    int label_continue = -1;



    mos = extract32(insn, 29, 3);

    type = extract32(insn, 22, 2); /* 0 = single, 1 = double */

    rm = extract32(insn, 16, 5);

    cond = extract32(insn, 12, 4);

    rn = extract32(insn, 5, 5);

    op = extract32(insn, 4, 1);

    nzcv = extract32(insn, 0, 4);



    if (mos || type > 1) {

        unallocated_encoding(s);

        return;

    }



    if (!fp_access_check(s)) {

        return;

    }



    if (cond < 0x0e) { /* not always */

        int label_match = gen_new_label();

        label_continue = gen_new_label();

        arm_gen_test_cc(cond, label_match);

        /* nomatch: */

        tcg_flags = tcg_const_i64(nzcv << 28);

        gen_set_nzcv(tcg_flags);

        tcg_temp_free_i64(tcg_flags);

        tcg_gen_br(label_continue);

        gen_set_label(label_match);

    }



    handle_fp_compare(s, type, ",0,0,3,0,0,0,1,1,0,1,1,1,0,0,0
27088,qemu,0,"static inline int test_bit(unsigned int bit, const unsigned long *map)

{

    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));

}
",0,0,0,0,0,0,0,0,0,0,0,1,1,0,0
27100,qemu,0,"static bool try_poll_mode(AioContext *ctx, bool blocking)

{

    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {

        /* See qemu_soonest_timeout() uint64_t hack */

        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),

                             (uint64_t)ctx->poll_ns);



        if (max_ns) {

            poll_set_started(ctx, true);



            if (run_poll_handlers(ctx, max_ns)) {

                return true;

            }

        }

    }



    poll_set_started(ctx, false);



    /* Even if we don't run busy polling, try polling once in case it can make

     * progress and the caller will be able to avoid ppoll(2)/epoll_wait(2).

     */

    return run_poll_handlers_once(ctx);

}
",0,0,4,0,0,0,1,1,0,0,0,0,0,0,0
27107,qemu,1,"static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
",0,0,0,0,0,0,0,0,0,0,0,0,1,1,0
27129,qemu,1,"static void decode_sys_interrupts(CPUTriCoreState *env, DisasContext *ctx)

{

    uint32_t op2;

    uint32_t r1;

    TCGLabel *l1;

    TCGv tmp;



    op2 = MASK_OP_SYS_OP2(ctx->opcode);

    r1  = MASK_OP_SYS_S1D(ctx->opcode);



    switch (op2) {

    case OPC2_32_SYS_DEBUG:

        /* raise EXCP_DEBUG */

        break;

    case OPC2_32_SYS_DISABLE:

        tcg_gen_andi_tl(cpu_ICR, cpu_ICR, ~MASK_ICR_IE);

        break;

    case OPC2_32_SYS_DSYNC:

        break;

    case OPC2_32_SYS_ENABLE:

        tcg_gen_ori_tl(cpu_ICR, cpu_ICR, MASK_ICR_IE);

        break;

    case OPC2_32_SYS_ISYNC:

        break;

    case OPC2_32_SYS_NOP:

        break;

    case OPC2_32_SYS_RET:

        gen_compute_branch(ctx, op2, 0, 0, 0, 0);

        break;

    case OPC2_32_SYS_FRET:

        gen_fret(ctx);

        break;

    case OPC2_32_SYS_RFE:

        gen_helper_rfe(cpu_env);

        tcg_gen_exit_tb(0);

        ctx->bstate = BS_BRANCH;

        break;

    case OPC2_32_SYS_RFM:

        if ((ctx->hfla",0,0,1,0,1,0,0,1,1,0,0,0,1,1,0
27148,qemu,1,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
",0,0,1,0,0,0,1,1,1,1,0,0,0,1,0
27151,FFmpeg,1,"static unsigned long iv_decode_frame(Indeo3DecodeContext *s, 
                                     unsigned char *buf, int buf_size) 
{
  unsigned int hdr_width, hdr_height,
    chroma_width, chroma_height;
  unsigned long fflags1, fflags2, fflags3, offs1, offs2, offs3, offs;
  unsigned char *hdr_pos, *buf_pos;
  buf_pos = buf;
  buf_pos += 18;
  fflags1 = le2me_16(*(uint16_t *)buf_pos);
  buf_pos += 2;
  fflags3 = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 4;
  fflags2 = *buf_pos++;
  buf_pos += 3;
  hdr_height = le2me_16(*(uint16_t *)buf_pos);
  buf_pos += 2;
  hdr_width = le2me_16(*(uint16_t *)buf_pos);
  buf_pos += 2;
  chroma_height = ((hdr_height >> 2) + 3) & 0x7ffc;
  chroma_width = ((hdr_width >> 2) + 3) & 0x7ffc;
  offs1 = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 4;
  offs2 = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 4;
  offs3 = le2me_32(*(uint32_t *)buf_pos);
  buf_pos += 8;
  hdr_pos = buf_pos;
  if(fflags3 == 0x80) return 4;
  if(fflags1 & 0x200) {
    s->cur_frame = s->iv_frame + 1;
   ",0,0,2,0,0,0,0,1,1,1,1,1,0,0,0
27169,qemu,1,"int gen_intermediate_code_internal (CPUState *env, TranslationBlock *tb,

                                    int search_pc)

{

    DisasContext ctx, *ctxp = &ctx;

    opc_handler_t **table, *handler;

    target_ulong pc_start;

    uint16_t *gen_opc_end;

    int j, lj = -1;



    pc_start = tb->pc;

    gen_opc_ptr = gen_opc_buf;

    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;

    gen_opparam_ptr = gen_opparam_buf;

    nb_gen_labels = 0;

    ctx.nip = pc_start;

    ctx.tb = tb;

    ctx.exception = EXCP_NONE;

    ctx.spr_cb = env->spr_cb;

#if defined(CONFIG_USER_ONLY)

    ctx.mem_idx = msr_le;

#else

    ctx.supervisor = 1 - msr_pr;

    ctx.mem_idx = ((1 - msr_pr) << 1) | msr_le;

#endif

    ctx.fpu_enabled = msr_fp;

    ctx.singlestep_enabled = env->singlestep_enabled;

#if defined (DO_SINGLE_STEP) && 0

    /* Single step trace mode */

    msr_se = 1;

#endif

    /* Set env in case of segfault during code fetch */

    while (ctx.exception == EXCP_NONE && gen_opc_ptr < gen_opc_end) {

    ",0,0,4,0,0,1,0,0,0,0,0,0,0,1,1
27171,qemu,1,"static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int argc, ide_idx;

    Backend i;



    argc = setup_common(argv, ARRAY_SIZE(argv));

    for (i = 0; i <= backend_empty; i++) {

        ide_idx = backend_empty - i;

        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}
",1,0,0,0,0,0,1,1,1,1,1,1,1,0,0
27201,FFmpeg,0,"static int decode_vol_header(MpegEncContext *s, GetBitContext *gb){

    int width, height, vo_ver_id;



    /* vol header */

    skip_bits(gb, 1); /* random access */

    s->vo_type= get_bits(gb, 8);

    if (get_bits1(gb) != 0) { /* is_ol_id */

        vo_ver_id = get_bits(gb, 4); /* vo_ver_id */

        skip_bits(gb, 3); /* vo_priority */

    } else {

        vo_ver_id = 1;

    }

//printf(""vo type:%d\n"",s->vo_type);

    s->aspect_ratio_info= get_bits(gb, 4);

    if(s->aspect_ratio_info == FF_ASPECT_EXTENDED){	    

        s->aspected_width = get_bits(gb, 8); // par_width

        s->aspected_height = get_bits(gb, 8); // par_height

    }else{

        s->aspected_width = pixel_aspect[s->aspect_ratio_info][0];

        s->aspected_height= pixel_aspect[s->aspect_ratio_info][1];

    }



    if ((s->vol_control_parameters=get_bits1(gb))) { /* vol control parameter */

        int chroma_format= get_bits(gb, 2);

        if(chroma_format!=1){

            printf(""illegal chroma format\n"");

      ",3,0,4,0,0,0,0,0,0,0,0,0,1,1,0
27203,FFmpeg,0,"void ff_init_me(MpegEncContext *s){

    MotionEstContext * const c= &s->me;

    c->avctx= s->avctx;



    ff_set_cmp(&s->dsp, s->dsp.me_pre_cmp, c->avctx->me_pre_cmp);

    ff_set_cmp(&s->dsp, s->dsp.me_cmp, c->avctx->me_cmp);

    ff_set_cmp(&s->dsp, s->dsp.me_sub_cmp, c->avctx->me_sub_cmp);

    ff_set_cmp(&s->dsp, s->dsp.mb_cmp, c->avctx->mb_cmp);

    

    c->flags    = get_flags(c, 0, c->avctx->me_cmp    &FF_CMP_CHROMA);

    c->sub_flags= get_flags(c, 0, c->avctx->me_sub_cmp&FF_CMP_CHROMA);

    c->mb_flags = get_flags(c, 0, c->avctx->mb_cmp    &FF_CMP_CHROMA);



/*FIXME s->no_rounding b_type*/

    if(s->flags&CODEC_FLAG_QPEL){

        c->sub_motion_search= qpel_motion_search;

        c->qpel_avg= s->dsp.avg_qpel_pixels_tab;

        if(s->no_rounding) c->qpel_put= s->dsp.put_no_rnd_qpel_pixels_tab;

        else               c->qpel_put= s->dsp.put_qpel_pixels_tab;

    }else{

        if(c->avctx->me_sub_cmp&FF_CMP_CHROMA)

            c->sub_motion_search= hpel_motion_search;

        else i",0,0,3,0,0,0,0,0,0,0,0,0,1,0,0
27237,FFmpeg,1,"static void filter(MpegAudioContext *s, int ch, short *samples, int incr)

{

    short *p, *q;

    int sum, offset, i, j, norm, n;

    short tmp[64];

    int tmp1[32];

    int *out;



    //    print_pow1(samples, 1152);



    offset = s->samples_offset[ch];

    out = &s->sb_samples[ch][0][0][0];

    for(j=0;j<36;j++) {

        /* 32 samples at once */

        for(i=0;i<32;i++) {

            s->samples_buf[ch][offset + (31 - i)] = samples[0];

            samples += incr;

        }



        /* filter */

        p = s->samples_buf[ch] + offset;

        q = filter_bank;

        /* maxsum = 23169 */

        for(i=0;i<64;i++) {

            sum = p[0*64] * q[0*64];

            sum += p[1*64] * q[1*64];

            sum += p[2*64] * q[2*64];

            sum += p[3*64] * q[3*64];

            sum += p[4*64] * q[4*64];

            sum += p[5*64] * q[5*64];

            sum += p[6*64] * q[6*64];

            sum += p[7*64] * q[7*64];

            tmp[i] = sum >> 14;

            p++;

          ",3,0,0,0,0,0,0,0,0,0,0,0,0,1,0
27254,qemu,0,"int kvm_arch_handle_exit(CPUState *cs, struct kvm_run *run)

{

    S390CPU *cpu = S390_CPU(cs);

    int ret = 0;



    switch (run->exit_reason) {

        case KVM_EXIT_S390_SIEIC:

            ret = handle_intercept(cpu);

            break;

        case KVM_EXIT_S390_RESET:

            qemu_system_reset_request();

            break;

        case KVM_EXIT_S390_TSCH:

            ret = handle_tsch(cpu);

            break;

        case KVM_EXIT_DEBUG:

            ret = kvm_arch_handle_debug_exit(cpu);

            break;

        default:

            fprintf(stderr, ""Unknown KVM exit: %d\n"", run->exit_reason);

            break;

    }



    if (ret == 0) {

        ret = EXCP_INTERRUPT;

    }

    return ret;

}
",0,0,1,0,1,0,1,1,0,0,0,0,0,0,0
27256,qemu,0,"AddressSpace *pci_device_iommu_address_space(PCIDevice *dev)

{

    PCIBus *bus = PCI_BUS(dev->bus);

    PCIBus *iommu_bus = bus;



    while(iommu_bus && !iommu_bus->iommu_fn && iommu_bus->parent_dev) {

        iommu_bus = PCI_BUS(iommu_bus->parent_dev->bus);

    }

    if (iommu_bus && iommu_bus->iommu_fn) {

        return iommu_bus->iommu_fn(bus, iommu_bus->iommu_opaque, dev->devfn);

    }

    return &address_space_memory;

}
",0,0,1,0,0,1,0,0,0,1,1,1,1,1,1
27257,qemu,0,"static inline void gen_op_eval_fbo(TCGv dst, TCGv src,

                                    unsigned int fcc_offset)

{

    gen_mov_reg_FCC0(dst, src, fcc_offset);

    gen_mov_reg_FCC1(cpu_tmp0, src, fcc_offset);

    tcg_gen_and_tl(dst, dst, cpu_tmp0);

    tcg_gen_xori_tl(dst, dst, 0x1);

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
27261,FFmpeg,0,"static int dvbsub_decode(AVCodecContext *avctx,

                         void *data, int *data_size,

                         AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    DVBSubContext *ctx = avctx->priv_data;

    AVSubtitle *sub = data;

    const uint8_t *p, *p_end;

    int segment_type;

    int page_id;

    int segment_length;

    int i;



    av_dlog(avctx, ""DVB sub packet:\n"");



    for (i=0; i < buf_size; i++) {

        av_dlog(avctx, ""%02x "", buf[i]);

        if (i % 16 == 15)

            av_dlog(avctx, ""\n"");

    }



    if (i % 16)

        av_dlog(avctx, ""\n"");



    if (buf_size <= 6 || *buf != 0x0f) {

        av_dlog(avctx, ""incomplete or broken packet"");

        return -1;

    }



    p = buf;

    p_end = buf + buf_size;



    while (p_end - p >= 6 && *p == 0x0f) {

        p += 1;

        segment_type = *p++;

        page_id = AV_RB16(p);

        p += 2;

        segment_length = AV_RB16(p);

        p += 2;



        ",1,0,3,0,0,1,0,0,0,0,0,0,0,0,0
27266,qemu,0,"static void *mpc8544_load_device_tree(target_phys_addr_t addr,

                                     uint32_t ramsize,

                                     target_phys_addr_t initrd_base,

                                     target_phys_addr_t initrd_size,

                                     const char *kernel_cmdline)

{

    void *fdt = NULL;

#ifdef CONFIG_FDT

    uint32_t mem_reg_property[] = {0, ramsize};

    char *filename;

    int fdt_size;

    int ret;



    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, BINARY_DEVICE_TREE_FILE);

    if (!filename) {

        goto out;

    }

    fdt = load_device_tree(filename, &fdt_size);

    qemu_free(filename);

    if (fdt == NULL) {

        goto out;

    }



    /* Manipulate device tree in memory. */

    ret = qemu_devtree_setprop(fdt, ""/memory"", ""reg"", mem_reg_property,

                               sizeof(mem_reg_property));

    if (ret < 0)

        fprintf(stderr, ""couldn't set /memory/reg\n"");



    ret = qemu_devtree_setprop_cell(fdt, ",0,2,4,0,0,0,0,1,1,1,0,0,1,1,1
27272,FFmpeg,0,"static int mov_read_trak(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)

{

    AVStream *st;

    MOVStreamContext *sc;

    int ret;



    st = av_new_stream(c->fc, c->fc->nb_streams);

    if (!st) return AVERROR(ENOMEM);

    sc = av_mallocz(sizeof(MOVStreamContext));

    if (!sc) return AVERROR(ENOMEM);



    st->priv_data = sc;

    st->codec->codec_type = CODEC_TYPE_DATA;

    st->start_time = 0; /* XXX: check */



    if ((ret = mov_read_default(c, pb, atom)) < 0)

        return ret;



    /* sanity checks */

    if(sc->chunk_count && (!sc->stts_count || !sc->sample_to_chunk_sz ||

                           (!sc->sample_size && !sc->sample_count))){

        av_log(c->fc, AV_LOG_ERROR, ""stream %d, missing mandatory atoms, broken header\n"",

               st->index);

        sc->sample_count = 0; //ignore track

        return 0;

    }

    if(!sc->time_rate)

        sc->time_rate=1;

    if(!sc->time_scale)

        sc->time_scale= c->time_scale;

    av_set_pts_info(st, 64, sc->time_r",0,0,6,0,0,0,1,1,1,0,0,0,0,0,0
27296,FFmpeg,0,"static av_cold int libschroedinger_encode_init(AVCodecContext *avctx)

{

    SchroEncoderParams *p_schro_params = avctx->priv_data;

    SchroVideoFormatEnum preset;



    /* Initialize the libraries that libschroedinger depends on. */

    schro_init();



    /* Create an encoder object. */

    p_schro_params->encoder = schro_encoder_new();



    if (!p_schro_params->encoder) {

        av_log(avctx, AV_LOG_ERROR,

               ""Unrecoverable Error: schro_encoder_new failed. "");

        return -1;

    }



    /* Initialize the format. */

    preset = ff_get_schro_video_format_preset(avctx);

    p_schro_params->format =

                    schro_encoder_get_video_format(p_schro_params->encoder);

    schro_video_format_set_std_video_format(p_schro_params->format, preset);

    p_schro_params->format->width  = avctx->width;

    p_schro_params->format->height = avctx->height;



    if (set_chroma_format(avctx) == -1)

        return -1;



    if (avctx->color_primaries == AVCOL_PRI_BT709) {

   ",9,0,3,0,0,0,0,0,0,0,1,0,1,1,1
27311,qemu,0,"static struct omap_mcbsp_s *omap_mcbsp_init(MemoryRegion *system_memory,

                                            target_phys_addr_t base,

                                            qemu_irq txirq, qemu_irq rxirq,

                                            qemu_irq *dma, omap_clk clk)

{

    struct omap_mcbsp_s *s = (struct omap_mcbsp_s *)

            g_malloc0(sizeof(struct omap_mcbsp_s));



    s->txirq = txirq;

    s->rxirq = rxirq;

    s->txdrq = dma[0];

    s->rxdrq = dma[1];

    s->sink_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_sink_tick, s);

    s->source_timer = qemu_new_timer_ns(vm_clock, omap_mcbsp_source_tick, s);

    omap_mcbsp_reset(s);



    memory_region_init_io(&s->iomem, &omap_mcbsp_ops, s, ""omap-mcbsp"", 0x800);

    memory_region_add_subregion(system_memory, base, &s->iomem);



    return s;

}
",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
27317,FFmpeg,0,"static void rv34_pred_mv(RV34DecContext *r, int block_type, int subblock_no, int dmv_no)

{

    MpegEncContext *s = &r->s;

    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride;

    int A[2] = {0}, B[2], C[2];

    int i, j;

    int mx, my;

    int avail_index = avail_indexes[subblock_no];

    int c_off = part_sizes_w[block_type];



    mv_pos += (subblock_no & 1) + (subblock_no >> 1)*s->b8_stride;

    if(subblock_no == 3)

        c_off = -1;



    if(r->avail_cache[avail_index - 1]){

        A[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][0];

        A[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-1][1];

    }

    if(r->avail_cache[avail_index - 4]){

        B[0] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][0];

        B[1] = s->current_picture_ptr->f.motion_val[0][mv_pos-s->b8_stride][1];

    }else{

        B[0] = A[0];

        B[1] = A[1];

    }

    if(!r->avail_cache[avail_index - 4 + c_off]){

        if(r->avail_cache[avail_index - 4] && (r->avai",0,0,5,0,0,0,1,1,1,1,1,0,0,0,0
